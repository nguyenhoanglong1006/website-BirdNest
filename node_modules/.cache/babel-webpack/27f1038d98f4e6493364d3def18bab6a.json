{"ast":null,"code":"\"use strict\";\n\nvar Node = require('./Node');\n\nvar LinkedList = require('./LinkedList');\n\nvar createDocumentFragmentFromArguments = function createDocumentFragmentFromArguments(document, args) {\n  var docFrag = document.createDocumentFragment();\n\n  for (var i = 0; i < args.length; i++) {\n    var argItem = args[i];\n    var isNode = argItem instanceof Node;\n    docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));\n  }\n\n  return docFrag;\n}; // The ChildNode interface contains methods that are particular to `Node`\n// objects that can have a parent.  It is implemented by `Element`,\n// `DocumentType`, and `CharacterData` objects.\n\n\nvar ChildNode = {\n  // Inserts a set of Node or String objects in the children list of this\n  // ChildNode's parent, just after this ChildNode.  String objects are\n  // inserted as the equivalent Text nodes.\n  after: {\n    value: function after() {\n      var argArr = Array.prototype.slice.call(arguments);\n      var parentNode = this.parentNode,\n          nextSibling = this.nextSibling;\n\n      if (parentNode === null) {\n        return;\n      } // Find \"viable next sibling\"; that is, next one not in argArr\n\n\n      while (nextSibling && argArr.some(function (v) {\n        return v === nextSibling;\n      })) nextSibling = nextSibling.nextSibling; // ok, parent and sibling are saved away since this node could itself\n      // appear in argArr and we're about to move argArr to a document fragment.\n\n\n      var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);\n      parentNode.insertBefore(docFrag, nextSibling);\n    }\n  },\n  // Inserts a set of Node or String objects in the children list of this\n  // ChildNode's parent, just before this ChildNode.  String objects are\n  // inserted as the equivalent Text nodes.\n  before: {\n    value: function before() {\n      var argArr = Array.prototype.slice.call(arguments);\n      var parentNode = this.parentNode,\n          prevSibling = this.previousSibling;\n\n      if (parentNode === null) {\n        return;\n      } // Find \"viable prev sibling\"; that is, prev one not in argArr\n\n\n      while (prevSibling && argArr.some(function (v) {\n        return v === prevSibling;\n      })) prevSibling = prevSibling.previousSibling; // ok, parent and sibling are saved away since this node could itself\n      // appear in argArr and we're about to move argArr to a document fragment.\n\n\n      var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);\n      var nextSibling = prevSibling ? prevSibling.nextSibling : parentNode.firstChild;\n      parentNode.insertBefore(docFrag, nextSibling);\n    }\n  },\n  // Remove this node from its parent\n  remove: {\n    value: function remove() {\n      if (this.parentNode === null) return; // Send mutation events if necessary\n\n      if (this.doc) {\n        this.doc._preremoveNodeIterators(this);\n\n        if (this.rooted) {\n          this.doc.mutateRemove(this);\n        }\n      } // Remove this node from its parents array of children\n      // and update the structure id for all ancestors\n\n\n      this._remove(); // Forget this node's parent\n\n\n      this.parentNode = null;\n    }\n  },\n  // Remove this node w/o uprooting or sending mutation events\n  // (But do update the structure id for all ancestors)\n  _remove: {\n    value: function _remove() {\n      var parent = this.parentNode;\n      if (parent === null) return;\n\n      if (parent._childNodes) {\n        parent._childNodes.splice(this.index, 1);\n      } else if (parent._firstChild === this) {\n        if (this._nextSibling === this) {\n          parent._firstChild = null;\n        } else {\n          parent._firstChild = this._nextSibling;\n        }\n      }\n\n      LinkedList.remove(this);\n      parent.modify();\n    }\n  },\n  // Replace this node with the nodes or strings provided as arguments.\n  replaceWith: {\n    value: function replaceWith() {\n      var argArr = Array.prototype.slice.call(arguments);\n      var parentNode = this.parentNode,\n          nextSibling = this.nextSibling;\n\n      if (parentNode === null) {\n        return;\n      } // Find \"viable next sibling\"; that is, next one not in argArr\n\n\n      while (nextSibling && argArr.some(function (v) {\n        return v === nextSibling;\n      })) nextSibling = nextSibling.nextSibling; // ok, parent and sibling are saved away since this node could itself\n      // appear in argArr and we're about to move argArr to a document fragment.\n\n\n      var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);\n\n      if (this.parentNode === parentNode) {\n        parentNode.replaceChild(docFrag, this);\n      } else {\n        // `this` was inserted into docFrag\n        parentNode.insertBefore(docFrag, nextSibling);\n      }\n    }\n  }\n};\nmodule.exports = ChildNode;","map":null,"metadata":{},"sourceType":"script"}