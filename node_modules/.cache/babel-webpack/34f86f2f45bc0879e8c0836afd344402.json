{"ast":null,"code":"import _classCallCheck from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { EventEmitter, Directive, forwardRef, ElementRef, NgZone, Input, Output, NgModule, Renderer2 } from '@angular/core';\nimport FroalaEditor from 'froala-editor';\nimport * as Éµngcc0 from '@angular/core';\n\nvar FroalaEditorDirective = /*#__PURE__*/function () {\n  function FroalaEditorDirective(el, zone) {\n    _classCallCheck(this, FroalaEditorDirective);\n\n    this.zone = zone; // editor options\n\n    this._opts = {\n      immediateAngularModelUpdate: false,\n      angularIgnoreAttrs: null\n    };\n    this.SPECIAL_TAGS = ['img', 'button', 'input', 'a'];\n    this.INNER_HTML_ATTR = 'innerHTML';\n    this._hasSpecialTag = false;\n    this._editorInitialized = false;\n    this._oldModel = null; // Begin ControlValueAccesor methods.\n\n    this.onChange = function (_) {};\n\n    this.onTouched = function () {}; // froalaModel directive as output: update model if editor contentChanged\n\n\n    this.froalaModelChange = new EventEmitter(); // froalaInit directive as output: send manual editor initialization\n\n    this.froalaInit = new EventEmitter();\n    var element = el.nativeElement; // check if the element is a special tag\n\n    if (this.SPECIAL_TAGS.indexOf(element.tagName.toLowerCase()) != -1) {\n      this._hasSpecialTag = true;\n    }\n\n    this._element = element;\n    this.zone = zone;\n  } // Form model content changed.\n\n\n  return _createClass(FroalaEditorDirective, [{\n    key: \"writeValue\",\n    value: function writeValue(content) {\n      this.updateEditor(content);\n    }\n  }, {\n    key: \"registerOnChange\",\n    value: function registerOnChange(fn) {\n      this.onChange = fn;\n    }\n  }, {\n    key: \"registerOnTouched\",\n    value: function registerOnTouched(fn) {\n      this.onTouched = fn;\n    } // End ControlValueAccesor methods.\n    // froalaEditor directive as input: store the editor options\n\n  }, {\n    key: \"froalaEditor\",\n    set: function set(opts) {\n      this._opts = this.clone(opts || this._opts);\n      this._opts = Object.assign({}, this._opts);\n    } // TODO: replace clone method with better possible alternate \n\n  }, {\n    key: \"clone\",\n    value: function clone(item) {\n      var me = this;\n\n      if (!item) {\n        return item;\n      } // null, undefined values check\n\n\n      var types = [Number, String, Boolean],\n          result; // normalizing primitives if someone did new String('aaa'), or new Number('444');\n\n      types.forEach(function (type) {\n        if (item instanceof type) {\n          result = type(item);\n        }\n      });\n\n      if (typeof result == \"undefined\") {\n        if (Object.prototype.toString.call(item) === \"[object Array]\") {\n          result = [];\n          item.forEach(function (child, index, array) {\n            result[index] = me.clone(child);\n          });\n        } else if (typeof item == \"object\") {\n          // testing that this is DOM\n          if (item.nodeType && typeof item.cloneNode == \"function\") {\n            result = item.cloneNode(true);\n          } else if (!item.prototype) {\n            // check that this is a literal\n            if (item instanceof Date) {\n              result = new Date(item);\n            } else {\n              // it is an object literal\n              result = {};\n\n              for (var i in item) {\n                result[i] = me.clone(item[i]);\n              }\n            }\n          } else {\n            if (false && item.constructor) {\n              result = new item.constructor();\n            } else {\n              result = item;\n            }\n          }\n        } else {\n          result = item;\n        }\n      }\n\n      return result;\n    } // froalaModel directive as input: store initial editor content\n\n  }, {\n    key: \"froalaModel\",\n    set: function set(content) {\n      this.updateEditor(content);\n    } // Update editor with model contents.\n\n  }, {\n    key: \"updateEditor\",\n    value: function updateEditor(content) {\n      if (JSON.stringify(this._oldModel) == JSON.stringify(content)) {\n        return;\n      }\n\n      if (!this._hasSpecialTag) {\n        this._oldModel = content;\n      } else {\n        this._model = content;\n      }\n\n      if (this._editorInitialized) {\n        if (!this._hasSpecialTag) {\n          this._editor.html.set(content);\n        } else {\n          this.setContent();\n        }\n      } else {\n        if (!this._hasSpecialTag) {\n          this._element.innerHTML = content || '';\n        } else {\n          this.setContent();\n        }\n      }\n    } // update model if editor contentChanged\n\n  }, {\n    key: \"updateModel\",\n    value: function updateModel() {\n      var _this = this;\n\n      this.zone.run(function () {\n        var modelContent = null;\n\n        if (_this._hasSpecialTag) {\n          var attributeNodes = _this._element.attributes;\n          var attrs = {};\n\n          for (var i = 0; i < attributeNodes.length; i++) {\n            var attrName = attributeNodes[i].name;\n\n            if (_this._opts.angularIgnoreAttrs && _this._opts.angularIgnoreAttrs.indexOf(attrName) != -1) {\n              continue;\n            }\n\n            attrs[attrName] = attributeNodes[i].value;\n          }\n\n          if (_this._element.innerHTML) {\n            attrs[_this.INNER_HTML_ATTR] = _this._element.innerHTML;\n          }\n\n          modelContent = attrs;\n        } else {\n          var returnedHtml = _this._editor.html.get();\n\n          if (typeof returnedHtml === 'string') {\n            modelContent = returnedHtml;\n          }\n        }\n\n        if (_this._oldModel !== modelContent) {\n          _this._oldModel = modelContent; // Update froalaModel.\n\n          _this.froalaModelChange.emit(modelContent); // Update form model.\n\n\n          _this.onChange(modelContent);\n        }\n      });\n    }\n  }, {\n    key: \"registerEvent\",\n    value: function registerEvent(eventName, callback) {\n      if (!eventName || !callback) {\n        return;\n      }\n\n      if (!this._opts.events) {\n        this._opts.events = {};\n      }\n\n      this._opts.events[eventName] = callback;\n    }\n  }, {\n    key: \"initListeners\",\n    value: function initListeners() {\n      var self = this; // Check if we have events on the editor.\n\n      if (this._editor.events) {\n        // bind contentChange and keyup event to froalaModel\n        this._editor.events.on('contentChanged', function () {\n          self.updateModel();\n        });\n\n        this._editor.events.on('mousedown', function () {\n          setTimeout(function () {\n            self.onTouched();\n          }, 0);\n        });\n\n        if (this._opts.immediateAngularModelUpdate) {\n          this._editor.events.on('keyup', function () {\n            setTimeout(function () {\n              self.updateModel();\n            }, 0);\n          });\n        }\n      }\n\n      this._editorInitialized = true;\n    }\n  }, {\n    key: \"createEditor\",\n    value: function createEditor() {\n      var _this2 = this;\n\n      if (this._editorInitialized) {\n        return;\n      }\n\n      this.setContent(true); // init editor\n\n      this.zone.runOutsideAngular(function () {\n        // Add listeners on initialized event.\n        if (!_this2._opts.events) _this2._opts.events = {}; // Register initialized event.\n\n        _this2.registerEvent('initialized', _this2._opts.events && _this2._opts.events.initialized);\n\n        var existingInitCallback = _this2._opts.events.initialized; // Default initialized event.\n\n        if (!_this2._opts.events.initialized || !_this2._opts.events.initialized.overridden) {\n          _this2._opts.events.initialized = function () {\n            _this2.initListeners();\n\n            existingInitCallback && existingInitCallback.call(_this2._editor, _this2);\n          };\n\n          _this2._opts.events.initialized.overridden = true;\n        } // Initialize the Froala Editor.\n\n\n        _this2._editor = new FroalaEditor(_this2._element, _this2._opts);\n      });\n    }\n  }, {\n    key: \"setHtml\",\n    value: function setHtml() {\n      this._editor.html.set(this._model || \"\"); // This will reset the undo stack everytime the model changes externally. Can we fix this?\n\n\n      this._editor.undo.reset();\n\n      this._editor.undo.saveStep();\n    }\n  }, {\n    key: \"setContent\",\n    value: function setContent() {\n      var firstTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var self = this; // Set initial content\n\n      if (this._model || this._model == '') {\n        this._oldModel = this._model;\n\n        if (this._hasSpecialTag) {\n          var tags = this._model; // add tags on element\n\n          if (tags) {\n            for (var attr in tags) {\n              if (tags.hasOwnProperty(attr) && attr != this.INNER_HTML_ATTR) {\n                this._element.setAttribute(attr, tags[attr]);\n              }\n            }\n\n            if (tags.hasOwnProperty(this.INNER_HTML_ATTR)) {\n              this._element.innerHTML = tags[this.INNER_HTML_ATTR];\n            }\n          }\n        } else {\n          if (firstTime) {\n            this.registerEvent('initialized', function () {\n              self.setHtml();\n            });\n          } else {\n            self.setHtml();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"destroyEditor\",\n    value: function destroyEditor() {\n      if (this._editorInitialized) {\n        this._editor.destroy();\n\n        this._editorInitialized = false;\n      }\n    }\n  }, {\n    key: \"getEditor\",\n    value: function getEditor() {\n      if (this._element) {\n        return this._editor;\n      }\n\n      return null;\n    } // send manual editor initialization\n\n  }, {\n    key: \"generateManualController\",\n    value: function generateManualController() {\n      var controls = {\n        initialize: this.createEditor.bind(this),\n        destroy: this.destroyEditor.bind(this),\n        getEditor: this.getEditor.bind(this)\n      };\n      this.froalaInit.emit(controls);\n    } // TODO not sure if ngOnInit is executed after @inputs\n\n  }, {\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      // check if output froalaInit is present. Maybe observers is private and should not be used?? TODO how to better test that an output directive is present.\n      if (!this.froalaInit.observers.length) {\n        this.createEditor();\n      } else {\n        this.generateManualController();\n      }\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.destroyEditor();\n    }\n  }, {\n    key: \"setDisabledState\",\n    value: function setDisabledState(isDisabled) {}\n  }]);\n}();\n\nFroalaEditorDirective.Éµfac = function FroalaEditorDirective_Factory(t) {\n  return new (t || FroalaEditorDirective)(Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ElementRef), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.NgZone));\n};\n\nFroalaEditorDirective.Éµdir = Éµngcc0.ÉµÉµdefineDirective({\n  type: FroalaEditorDirective,\n  selectors: [[\"\", \"froalaEditor\", \"\"]],\n  inputs: {\n    froalaEditor: \"froalaEditor\",\n    froalaModel: \"froalaModel\"\n  },\n  outputs: {\n    froalaModelChange: \"froalaModelChange\",\n    froalaInit: \"froalaInit\"\n  },\n  exportAs: [\"froalaEditor\"],\n  features: [Éµngcc0.ÉµÉµProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(function () {\n      return FroalaEditorDirective;\n    }),\n    multi: true\n  }])]\n});\n/** @nocollapse */\n\nFroalaEditorDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: NgZone\n  }];\n};\n\nFroalaEditorDirective.propDecorators = {\n  froalaEditor: [{\n    type: Input\n  }],\n  froalaModel: [{\n    type: Input\n  }],\n  froalaModelChange: [{\n    type: Output\n  }],\n  froalaInit: [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(FroalaEditorDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[froalaEditor]',\n      exportAs: 'froalaEditor',\n      providers: [{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: forwardRef(function () {\n          return FroalaEditorDirective;\n        }),\n        multi: true\n      }]\n    }]\n  }], function () {\n    return [{\n      type: Éµngcc0.ElementRef\n    }, {\n      type: Éµngcc0.NgZone\n    }];\n  }, {\n    froalaModelChange: [{\n      type: Output\n    }],\n    froalaInit: [{\n      type: Output\n    }],\n    froalaEditor: [{\n      type: Input\n    }],\n    froalaModel: [{\n      type: Input\n    }]\n  });\n})();\n\nvar FroalaEditorModule = /*#__PURE__*/function () {\n  function FroalaEditorModule() {\n    _classCallCheck(this, FroalaEditorModule);\n  }\n\n  return _createClass(FroalaEditorModule, null, [{\n    key: \"forRoot\",\n    value: function forRoot() {\n      return {\n        ngModule: FroalaEditorModule,\n        providers: []\n      };\n    }\n  }]);\n}();\n\nFroalaEditorModule.Éµfac = function FroalaEditorModule_Factory(t) {\n  return new (t || FroalaEditorModule)();\n};\n\nFroalaEditorModule.Éµmod = Éµngcc0.ÉµÉµdefineNgModule({\n  type: FroalaEditorModule\n});\nFroalaEditorModule.Éµinj = Éµngcc0.ÉµÉµdefineInjector({});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(FroalaEditorModule, {\n    declarations: [FroalaEditorDirective],\n    exports: [FroalaEditorDirective]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(FroalaEditorModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [FroalaEditorDirective],\n      exports: [FroalaEditorDirective]\n    }]\n  }], null, null);\n})();\n\nvar FroalaViewDirective = /*#__PURE__*/function () {\n  function FroalaViewDirective(renderer, element) {\n    _classCallCheck(this, FroalaViewDirective);\n\n    this.renderer = renderer;\n    this._element = element.nativeElement;\n  } // update content model as it comes\n\n\n  return _createClass(FroalaViewDirective, [{\n    key: \"froalaView\",\n    set: function set(content) {\n      this._element.innerHTML = content;\n    }\n  }, {\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      this.renderer.addClass(this._element, \"fr-view\");\n    }\n  }]);\n}();\n\nFroalaViewDirective.Éµfac = function FroalaViewDirective_Factory(t) {\n  return new (t || FroalaViewDirective)(Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.Renderer2), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ElementRef));\n};\n\nFroalaViewDirective.Éµdir = Éµngcc0.ÉµÉµdefineDirective({\n  type: FroalaViewDirective,\n  selectors: [[\"\", \"froalaView\", \"\"]],\n  inputs: {\n    froalaView: \"froalaView\"\n  }\n});\n/** @nocollapse */\n\nFroalaViewDirective.ctorParameters = function () {\n  return [{\n    type: Renderer2\n  }, {\n    type: ElementRef\n  }];\n};\n\nFroalaViewDirective.propDecorators = {\n  froalaView: [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(FroalaViewDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[froalaView]'\n    }]\n  }], function () {\n    return [{\n      type: Éµngcc0.Renderer2\n    }, {\n      type: Éµngcc0.ElementRef\n    }];\n  }, {\n    froalaView: [{\n      type: Input\n    }]\n  });\n})();\n\nvar FroalaViewModule = /*#__PURE__*/function () {\n  function FroalaViewModule() {\n    _classCallCheck(this, FroalaViewModule);\n  }\n\n  return _createClass(FroalaViewModule, null, [{\n    key: \"forRoot\",\n    value: function forRoot() {\n      return {\n        ngModule: FroalaViewModule,\n        providers: []\n      };\n    }\n  }]);\n}();\n\nFroalaViewModule.Éµfac = function FroalaViewModule_Factory(t) {\n  return new (t || FroalaViewModule)();\n};\n\nFroalaViewModule.Éµmod = Éµngcc0.ÉµÉµdefineNgModule({\n  type: FroalaViewModule\n});\nFroalaViewModule.Éµinj = Éµngcc0.ÉµÉµdefineInjector({});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(FroalaViewModule, {\n    declarations: [FroalaViewDirective],\n    exports: [FroalaViewDirective]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(FroalaViewModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [FroalaViewDirective],\n      exports: [FroalaViewDirective]\n    }]\n  }], null, null);\n})();\n\nvar FERootModule = /*#__PURE__*/_createClass(function FERootModule() {\n  _classCallCheck(this, FERootModule);\n});\n\nFERootModule.Éµfac = function FERootModule_Factory(t) {\n  return new (t || FERootModule)();\n};\n\nFERootModule.Éµmod = Éµngcc0.ÉµÉµdefineNgModule({\n  type: FERootModule\n});\nFERootModule.Éµinj = Éµngcc0.ÉµÉµdefineInjector({\n  imports: [[FroalaEditorModule.forRoot(), FroalaViewModule.forRoot()], FroalaEditorModule, FroalaViewModule]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(FERootModule, {\n    imports: [FroalaEditorModule, FroalaViewModule],\n    exports: [FroalaEditorModule, FroalaViewModule]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(FERootModule, [{\n    type: NgModule,\n    args: [{\n      imports: [FroalaEditorModule.forRoot(), FroalaViewModule.forRoot()],\n      exports: [FroalaEditorModule, FroalaViewModule]\n    }]\n  }], null, null);\n})();\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { FERootModule, FroalaEditorDirective, FroalaEditorModule, FroalaViewDirective, FroalaViewModule }; //# sourceMappingURL=angular-froala-wysiwyg.js.map","map":null,"metadata":{},"sourceType":"module"}