{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{\"+1VR\":function(t,e,i){\"use strict\";var n=i(\"SQLu\");e.mergeScan=function(t,e,i){return void 0===i&&(i=Number.POSITIVE_INFINITY),n.mergeScan(t,e,i)(this)}},\"+2+e\":function(t,e,i){\"use strict\";var n=i(\"/WK6\");function r(t){var e=t.Symbol;if(\"function\"==typeof e)return e.iterator||(e.iterator=e(\"iterator polyfill\")),e.iterator;var i=t.Set;if(i&&\"function\"==typeof(new i)[\"@@iterator\"])return\"@@iterator\";var n=t.Map;if(n)for(var r=Object.getOwnPropertyNames(n.prototype),s=0;s<r.length;++s){var o=r[s];if(\"entries\"!==o&&\"size\"!==o&&n.prototype[o]===n.prototype.entries)return o}return\"@@iterator\"}e.symbolIteratorPonyfill=r,e.iterator=r(n.root),e.$$iterator=e.iterator},\"+24W\":function(t,e,i){\"use strict\";var n=i(\"VVja\");e.switchMap=function(t,e){return n.switchMap(t,e)(this)}},\"+PC9\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"36rE\");e.repeat=function(t){return void 0===t&&(t=-1),function(e){return 0===t?new s.EmptyObservable:e.lift(new o(t<0?-1:t-1,e))}};var o=function(){function t(t,e){this.count=t,this.source=e}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.count,this.source))},t}(),c=function(t){function e(e,i,n){t.call(this,e),this.count=i,this.source=n}return n(e,t),e.prototype.complete=function(){if(!this.isStopped){var e=this.source,i=this.count;if(0===i)return t.prototype.complete.call(this);i>-1&&(this.count=i-1),e.subscribe(this._unsubscribeAndRecycle())}},e}(r.Subscriber)},\"+UM1\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(e,i,n){t.call(this),this.start=e,this._count=i,this.scheduler=n}return n(e,t),e.create=function(t,i,n){return void 0===t&&(t=0),void 0===i&&(i=0),new e(t,i,n)},e.dispatch=function(t){var e=t.start,i=t.index,n=t.subscriber;i>=t.count?n.complete():(n.next(e),n.closed||(t.index=i+1,t.start=e+1,this.schedule(t)))},e.prototype._subscribe=function(t){var i=0,n=this.start,r=this._count,s=this.scheduler;if(s)return s.schedule(e.dispatch,0,{index:i,count:r,start:n,subscriber:t});for(;;){if(i++>=r){t.complete();break}if(t.next(n++),t.closed)break}},e}(i(\"AZf1\").Observable);e.RangeObservable=r},\"+Whv\":function(t,e,i){\"use strict\";e.using=i(\"JX5i\").UsingObservable.create},\"+WiC\":function(t,e,i){\"use strict\";var n=i(\"lf2g\");e.concatMap=function(t,e){return n.mergeMap(t,e,1)}},\"+djB\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"zKHA\"),o=i(\"AJP0\"),c=i(\"9jZZ\"),a=i(\"Irel\");e.windowWhen=function(t){return function(e){return e.lift(new u(t))}};var u=function(){function t(t){this.closingSelector=t}return t.prototype.call=function(t,e){return e.subscribe(new l(t,this.closingSelector))},t}(),l=function(t){function e(e,i){t.call(this,e),this.destination=e,this.closingSelector=i,this.openWindow()}return n(e,t),e.prototype.notifyNext=function(t,e,i,n,r){this.openWindow(r)},e.prototype.notifyError=function(t,e){this._error(t)},e.prototype.notifyComplete=function(t){this.openWindow(t)},e.prototype._next=function(t){this.window.next(t)},e.prototype._error=function(t){this.window.error(t),this.destination.error(t),this.unsubscribeClosingNotification()},e.prototype._complete=function(){this.window.complete(),this.destination.complete(),this.unsubscribeClosingNotification()},e.prototype.unsubscribeClosingNotification=function(){this.closingNotification&&this.closingNotification.unsubscribe()},e.prototype.openWindow=function(t){void 0===t&&(t=null),t&&(this.remove(t),t.unsubscribe());var e=this.window;e&&e.complete();var i=this.window=new r.Subject;this.destination.next(i);var n=s.tryCatch(this.closingSelector)();if(n===o.errorObject){var c=o.errorObject.e;this.destination.error(c),this.window.error(c)}else this.add(this.closingNotification=a.subscribeToResult(this,n))},e}(c.OuterSubscriber)},\"+fDQ\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"G2HO\"),s=i(\"foHw\"),o=i(\"RGvf\"),c=i(\"r2oo\"),a=i(\"m+NU\"),u=i(\"rVFa\"),l=i(\"04+N\"),h=i(\"+2+e\"),p=i(\"AZf1\"),f=i(\"0zyO\"),d=i(\"WU5C\"),b=function(t){function e(e,i){t.call(this,null),this.ish=e,this.scheduler=i}return n(e,t),e.create=function(t,i){if(null!=t){if(\"function\"==typeof t[d.observable])return t instanceof p.Observable&&!i?t:new e(t,i);if(r.isArray(t))return new u.ArrayObservable(t,i);if(o.isPromise(t))return new c.PromiseObservable(t,i);if(\"function\"==typeof t[h.iterator]||\"string\"==typeof t)return new a.IteratorObservable(t,i);if(s.isArrayLike(t))return new l.ArrayLikeObservable(t,i)}throw new TypeError((null!==t&&typeof t||t)+\" is not observable\")},e.prototype._subscribe=function(t){var e=this.ish,i=this.scheduler;return null==i?e[d.observable]().subscribe(t):e[d.observable]().subscribe(new f.ObserveOnSubscriber(t,i,0))},e}(p.Observable);e.FromObservable=b},\"+t3k\":function(t,e,i){\"use strict\";var n=i(\"L/jt\");e.first=function(t,e,i){return n.first(t,e,i)(this)}},\"/3m9\":function(t,e,i){\"use strict\";var n=i(\"OMR/\");e.combineAll=function(t){return n.combineAll(t)(this)}},\"/AUE\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"y2i3\"),o=function(t){function e(e,i){t.call(this,function(t){var e=this,i=e.logSubscribedFrame();return t.add(new s.Subscription(function(){e.logUnsubscribedFrame(i)})),e.scheduleMessages(t),t}),this.messages=e,this.subscriptions=[],this.scheduler=i}return n(e,t),e.prototype.scheduleMessages=function(t){for(var e=this.messages.length,i=0;i<e;i++){var n=this.messages[i];t.add(this.scheduler.schedule(function(t){t.message.notification.observe(t.subscriber)},n.frame,{message:n,subscriber:t}))}},e}(r.Observable);e.ColdObservable=o},\"/Gz8\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"Vmj7\");n.Observable.prototype.bufferTime=r.bufferTime},\"/QDG\":function(t,e,i){\"use strict\";var n=i(\"fEEN\");e.mergeMapTo=function(t,e,i){return void 0===i&&(i=Number.POSITIVE_INFINITY),n.mergeMapTo(t,e,i)(this)}},\"/WK6\":function(t,e,i){\"use strict\";var n=\"undefined\"!=typeof window&&window,r=\"undefined\"!=typeof self&&\"undefined\"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,s=\"undefined\"!=typeof global&&global;e.root=n||s||r},\"/mOC\":function(t,e,i){\"use strict\";e.MapPolyfill=function(){function t(){this.size=0,this._values=[],this._keys=[]}return t.prototype.get=function(t){var e=this._keys.indexOf(t);return-1===e?void 0:this._values[e]},t.prototype.set=function(t,e){var i=this._keys.indexOf(t);return-1===i?(this._keys.push(t),this._values.push(e),this.size++):this._values[i]=e,this},t.prototype.delete=function(t){var e=this._keys.indexOf(t);return-1!==e&&(this._values.splice(e,1),this._keys.splice(e,1),this.size--,!0)},t.prototype.clear=function(){this._keys.length=0,this._values.length=0,this.size=0},t.prototype.forEach=function(t,e){for(var i=0;i<this.size;i++)t.call(e,this._values[i],this._keys[i])},t}()},\"/mgN\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"urEZ\");n.Observable.prototype.repeatWhen=r.repeatWhen},\"01WU\":function(t,e,i){\"use strict\";var n=i(\"PxRv\");e.elementAt=function(t,e){return n.elementAt(t,e)(this)}},\"04+N\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"8x9D\"),o=i(\"36rE\"),c=function(t){function e(e,i){t.call(this),this.arrayLike=e,this.scheduler=i,i||1!==e.length||(this._isScalar=!0,this.value=e[0])}return n(e,t),e.create=function(t,i){var n=t.length;return 0===n?new o.EmptyObservable:1===n?new s.ScalarObservable(t[0],i):new e(t,i)},e.dispatch=function(t){var e=t.arrayLike,i=t.index,n=t.subscriber;n.closed||(i>=t.length?n.complete():(n.next(e[i]),t.index=i+1,this.schedule(t)))},e.prototype._subscribe=function(t){var i=this.arrayLike,n=this.scheduler,r=i.length;if(n)return n.schedule(e.dispatch,0,{arrayLike:i,index:0,length:r,subscriber:t});for(var s=0;s<r&&!t.closed;s++)t.next(i[s]);t.complete()},e}(r.Observable);e.ArrayLikeObservable=c},\"07YY\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"qKmH\");n.Observable.generate=r.generate},\"0Iwa\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"9jZZ\"),o=i(\"Irel\");e.window=function(t){return function(e){return e.lift(new c(t))}};var c=function(){function t(t){this.windowBoundaries=t}return t.prototype.call=function(t,e){var i=new a(t),n=e.subscribe(i);return n.closed||i.add(o.subscribeToResult(i,this.windowBoundaries)),n},t}(),a=function(t){function e(e){t.call(this,e),this.window=new r.Subject,e.next(this.window)}return n(e,t),e.prototype.notifyNext=function(t,e,i,n,r){this.openWindow()},e.prototype.notifyError=function(t,e){this._error(t)},e.prototype.notifyComplete=function(t){this._complete()},e.prototype._next=function(t){this.window.next(t)},e.prototype._error=function(t){this.window.error(t),this.destination.error(t)},e.prototype._complete=function(){this.window.complete(),this.destination.complete()},e.prototype._unsubscribe=function(){this.window=null},e.prototype.openWindow=function(){var t=this.window;t&&t.complete();var e=this.destination,i=this.window=new r.Subject;e.next(i)},e}(s.OuterSubscriber)},\"0Qin\":function(t,e,i){\"use strict\";var n=i(\"BjeI\");e.shareReplay=function(t,e,i){return function(r){return r.lift(function(t,e,i){var r,s,o=0,c=!1,a=!1;return function(u){o++,r&&!c||(c=!1,r=new n.ReplaySubject(t,e,i),s=u.subscribe({next:function(t){r.next(t)},error:function(t){c=!0,r.error(t)},complete:function(){a=!0,r.complete()}}));var l=r.subscribe(this);return function(){o--,l.unsubscribe(),s&&0===o&&a&&s.unsubscribe()}}}(t,e,i))}}},\"0U/2\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"Ontn\");n.Observable.prototype.retryWhen=r.retryWhen},\"0dxg\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"Irel\"),o=i(\"9jZZ\"),c=function(t){function e(e){t.call(this),this.observableFactory=e}return n(e,t),e.create=function(t){return new e(t)},e.prototype._subscribe=function(t){return new a(t,this.observableFactory)},e}(r.Observable);e.DeferObservable=c;var a=function(t){function e(e,i){t.call(this,e),this.factory=i,this.tryDefer()}return n(e,t),e.prototype.tryDefer=function(){try{this._callFactory()}catch(t){this._error(t)}},e.prototype._callFactory=function(){var t=this.factory();t&&this.add(s.subscribeToResult(this,t))},e}(o.OuterSubscriber)},\"0j0j\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"zKHA\"),o=i(\"AJP0\"),c=i(\"9jZZ\"),a=i(\"Irel\");e.repeatWhen=function(t){return function(e){return e.lift(new u(t))}};var u=function(){function t(t){this.notifier=t}return t.prototype.call=function(t,e){return e.subscribe(new l(t,this.notifier,e))},t}(),l=function(t){function e(e,i,n){t.call(this,e),this.notifier=i,this.source=n,this.sourceIsBeingSubscribedTo=!0}return n(e,t),e.prototype.notifyNext=function(t,e,i,n,r){this.sourceIsBeingSubscribedTo=!0,this.source.subscribe(this)},e.prototype.notifyComplete=function(e){if(!1===this.sourceIsBeingSubscribedTo)return t.prototype.complete.call(this)},e.prototype.complete=function(){if(this.sourceIsBeingSubscribedTo=!1,!this.isStopped){if(this.retries||this.subscribeToRetries(),!this.retriesSubscription||this.retriesSubscription.closed)return t.prototype.complete.call(this);this._unsubscribeAndRecycle(),this.notifications.next()}},e.prototype._unsubscribe=function(){var t=this.notifications,e=this.retriesSubscription;t&&(t.unsubscribe(),this.notifications=null),e&&(e.unsubscribe(),this.retriesSubscription=null),this.retries=null},e.prototype._unsubscribeAndRecycle=function(){var e=this,i=e.notifications,n=e.retries,r=e.retriesSubscription;return this.notifications=null,this.retries=null,this.retriesSubscription=null,t.prototype._unsubscribeAndRecycle.call(this),this.notifications=i,this.retries=n,this.retriesSubscription=r,this},e.prototype.subscribeToRetries=function(){this.notifications=new r.Subject;var e=s.tryCatch(this.notifier)(this.notifications);if(e===o.errorObject)return t.prototype.complete.call(this);this.retries=e,this.retriesSubscription=a.subscribeToResult(this,e)},e}(c.OuterSubscriber)},\"0jD2\":function(t,e,i){\"use strict\";var n=i(\"iYe0\");e.count=function(t){return n.count(t)(this)}},\"0p2S\":function(t,e,i){\"use strict\";var n=i(\"lf2g\"),r=i(\"LAU0\");e.mergeAll=function(t){return void 0===t&&(t=Number.POSITIVE_INFINITY),n.mergeMap(r.identity,null,t)}},\"0zyO\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"9x29\");e.observeOn=function(t,e){return void 0===e&&(e=0),function(i){return i.lift(new o(t,e))}};var o=function(){function t(t,e){void 0===e&&(e=0),this.scheduler=t,this.delay=e}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.scheduler,this.delay))},t}();e.ObserveOnOperator=o;var c=function(t){function e(e,i,n){void 0===n&&(n=0),t.call(this,e),this.scheduler=i,this.delay=n}return n(e,t),e.dispatch=function(t){t.notification.observe(t.destination),this.unsubscribe()},e.prototype.scheduleMessage=function(t){this.add(this.scheduler.schedule(e.dispatch,this.delay,new a(t,this.destination)))},e.prototype._next=function(t){this.scheduleMessage(s.Notification.createNext(t))},e.prototype._error=function(t){this.scheduleMessage(s.Notification.createError(t))},e.prototype._complete=function(){this.scheduleMessage(s.Notification.createComplete())},e}(r.Subscriber);e.ObserveOnSubscriber=c;var a=function(){return function(t,e){this.notification=t,this.destination=e}}();e.ObserveOnMessage=a},\"16yF\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.bufferCount=function(t,e){return void 0===e&&(e=null),function(i){return i.lift(new s(t,e))}};var s=function(){function t(t,e){this.bufferSize=t,this.startBufferEvery=e,this.subscriberClass=e&&t!==e?c:o}return t.prototype.call=function(t,e){return e.subscribe(new this.subscriberClass(t,this.bufferSize,this.startBufferEvery))},t}(),o=function(t){function e(e,i){t.call(this,e),this.bufferSize=i,this.buffer=[]}return n(e,t),e.prototype._next=function(t){var e=this.buffer;e.push(t),e.length==this.bufferSize&&(this.destination.next(e),this.buffer=[])},e.prototype._complete=function(){var e=this.buffer;e.length>0&&this.destination.next(e),t.prototype._complete.call(this)},e}(r.Subscriber),c=function(t){function e(e,i,n){t.call(this,e),this.bufferSize=i,this.startBufferEvery=n,this.buffers=[],this.count=0}return n(e,t),e.prototype._next=function(t){var e=this,i=e.bufferSize,n=e.startBufferEvery,r=e.buffers,s=e.count;this.count++,s%n==0&&r.push([]);for(var o=r.length;o--;){var c=r[o];c.push(t),c.length===i&&(r.splice(o,1),this.destination.next(c))}},e.prototype._complete=function(){for(var e=this.buffers,i=this.destination;e.length>0;){var n=e.shift();n.length>0&&i.next(n)}t.prototype._complete.call(this)},e}(r.Subscriber)},\"1BBg\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"sYdX\");n.Observable.empty=r.empty},\"1DV/\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.skip=function(t){return function(e){return e.lift(new s(t))}};var s=function(){function t(t){this.total=t}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.total))},t}(),o=function(t){function e(e,i){t.call(this,e),this.total=i,this.count=0}return n(e,t),e.prototype._next=function(t){++this.count>this.total&&this.destination.next(t)},e}(r.Subscriber)},\"1G/o\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"e7/H\");n.Observable.prototype.subscribeOn=r.subscribeOn},\"1jHa\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"gIzs\");n.Observable.prototype.merge=r.merge},\"1nIg\":function(t,e,i){\"use strict\";var n=i(\"O/EN\");e.publishLast=function(){return n.publishLast()(this)}},\"1uGz\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"PFc+\"),s=i(\"y2i3\"),o=i(\"yz70\"),c=i(\"nkkL\"),a=function(t){function e(e,i,n){switch(t.call(this),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=o.empty;break;case 1:if(!e){this.destination=o.empty;break}if(\"object\"==typeof e){if(l(e)){var r=e[c.rxSubscriber]();this.syncErrorThrowable=r.syncErrorThrowable,this.destination=r,r.add(this)}else this.syncErrorThrowable=!0,this.destination=new u(this,e);break}default:this.syncErrorThrowable=!0,this.destination=new u(this,e,i,n)}}return n(e,t),e.prototype[c.rxSubscriber]=function(){return this},e.create=function(t,i,n){var r=new e(t,i,n);return r.syncErrorThrowable=!1,r},e.prototype.next=function(t){this.isStopped||this._next(t)},e.prototype.error=function(t){this.isStopped||(this.isStopped=!0,this._error(t))},e.prototype.complete=function(){this.isStopped||(this.isStopped=!0,this._complete())},e.prototype.unsubscribe=function(){this.closed||(this.isStopped=!0,t.prototype.unsubscribe.call(this))},e.prototype._next=function(t){this.destination.next(t)},e.prototype._error=function(t){this.destination.error(t),this.unsubscribe()},e.prototype._complete=function(){this.destination.complete(),this.unsubscribe()},e.prototype._unsubscribeAndRecycle=function(){var t=this._parent,e=this._parents;return this._parent=null,this._parents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parent=t,this._parents=e,this},e}(s.Subscription);e.Subscriber=a;var u=function(t){function e(e,i,n,s){var c;t.call(this),this._parentSubscriber=e;var a=this;r.isFunction(i)?c=i:i&&(c=i.next,n=i.error,s=i.complete,i!==o.empty&&(a=Object.create(i),r.isFunction(a.unsubscribe)&&this.add(a.unsubscribe.bind(a)),a.unsubscribe=this.unsubscribe.bind(this))),this._context=a,this._next=c,this._error=n,this._complete=s}return n(e,t),e.prototype.next=function(t){if(!this.isStopped&&this._next){var e=this._parentSubscriber;e.syncErrorThrowable?this.__tryOrSetError(e,this._next,t)&&this.unsubscribe():this.__tryOrUnsub(this._next,t)}},e.prototype.error=function(t){if(!this.isStopped){var e=this._parentSubscriber;if(this._error)e.syncErrorThrowable?(this.__tryOrSetError(e,this._error,t),this.unsubscribe()):(this.__tryOrUnsub(this._error,t),this.unsubscribe());else{if(!e.syncErrorThrowable)throw this.unsubscribe(),t;e.syncErrorValue=t,e.syncErrorThrown=!0,this.unsubscribe()}}},e.prototype.complete=function(){var t=this;if(!this.isStopped){var e=this._parentSubscriber;if(this._complete){var i=function(){return t._complete.call(t._context)};e.syncErrorThrowable?(this.__tryOrSetError(e,i),this.unsubscribe()):(this.__tryOrUnsub(i),this.unsubscribe())}else this.unsubscribe()}},e.prototype.__tryOrUnsub=function(t,e){try{t.call(this._context,e)}catch(i){throw this.unsubscribe(),i}},e.prototype.__tryOrSetError=function(t,e,i){try{e.call(this._context,i)}catch(n){return t.syncErrorValue=n,t.syncErrorThrown=!0,!0}return!1},e.prototype._unsubscribe=function(){var t=this._parentSubscriber;this._context=null,this._parentSubscriber=null,t.unsubscribe()},e}(a);function l(t){return t instanceof a||\"syncErrorThrowable\"in t&&t[c.rxSubscriber]}},\"1xzA\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"l9aY\");n.Observable.prototype.distinctUntilChanged=r.distinctUntilChanged},\"27EW\":function(t,e,i){\"use strict\";var n=i(\"VthU\");e.switchMapTo=function(t,e){return n.switchMapTo(t,e)(this)}},\"2FQM\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"8pZU\");n.Observable.prototype.materialize=r.materialize},\"2Go0\":function(t,e,i){\"use strict\";e.pairs=i(\"Zo/K\").PairsObservable.create},\"2HR8\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"Al8V\");n.Observable.prototype.pairwise=r.pairwise},\"2Tbn\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.defaultIfEmpty=function(t){return void 0===t&&(t=null),function(e){return e.lift(new s(t))}};var s=function(){function t(t){this.defaultValue=t}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.defaultValue))},t}(),o=function(t){function e(e,i){t.call(this,e),this.defaultValue=i,this.isEmpty=!0}return n(e,t),e.prototype._next=function(t){this.isEmpty=!1,this.destination.next(t)},e.prototype._complete=function(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()},e}(r.Subscriber)},\"2Wg+\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.withLatestFrom=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return function(e){var i;return\"function\"==typeof t[t.length-1]&&(i=t.pop()),e.lift(new o(t,i))}};var o=function(){function t(t,e){this.observables=t,this.project=e}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.observables,this.project))},t}(),c=function(t){function e(e,i,n){t.call(this,e),this.observables=i,this.project=n,this.toRespond=[];var r=i.length;this.values=new Array(r);for(var o=0;o<r;o++)this.toRespond.push(o);for(o=0;o<r;o++){var c=i[o];this.add(s.subscribeToResult(this,c,c,o))}}return n(e,t),e.prototype.notifyNext=function(t,e,i,n,r){this.values[i]=e;var s=this.toRespond;if(s.length>0){var o=s.indexOf(i);-1!==o&&s.splice(o,1)}},e.prototype.notifyComplete=function(){},e.prototype._next=function(t){if(0===this.toRespond.length){var e=[t].concat(this.values);this.project?this._tryProject(e):this.destination.next(e)}},e.prototype._tryProject=function(t){var e;try{e=this.project.apply(this,t)}catch(i){return void this.destination.error(i)}this.destination.next(e)},e}(r.OuterSubscriber)},\"2fIB\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(){var e=t.call(this,\"no elements in sequence\");this.name=e.name=\"EmptyError\",this.stack=e.stack,this.message=e.message}return n(e,t),e}(Error);e.EmptyError=r},\"2gSr\":function(t,e,i){\"use strict\";var n=i(\"/WK6\");function r(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];for(var n=e.length,r=0;r<n;r++){var s=e[r];for(var o in s)s.hasOwnProperty(o)&&(t[o]=s[o])}return t}function s(t){return t.Object.assign||r}e.assignImpl=r,e.getAssign=s,e.assign=s(n.root)},\"2qLy\":function(t,e,i){\"use strict\";var n=i(\"MHPA\");e.takeUntil=function(t){return n.takeUntil(t)(this)}},\"36rE\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(e){t.call(this),this.scheduler=e}return n(e,t),e.create=function(t){return new e(t)},e.dispatch=function(t){t.subscriber.complete()},e.prototype._subscribe=function(t){var i=this.scheduler;if(i)return i.schedule(e.dispatch,0,{subscriber:t});t.complete()},e}(i(\"AZf1\").Observable);e.EmptyObservable=r},\"3Ind\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"zKHA\"),o=i(\"AJP0\");e.sequenceEqual=function(t,e){return function(i){return i.lift(new c(t,e))}};var c=function(){function t(t,e){this.compareTo=t,this.comparor=e}return t.prototype.call=function(t,e){return e.subscribe(new a(t,this.compareTo,this.comparor))},t}();e.SequenceEqualOperator=c;var a=function(t){function e(e,i,n){t.call(this,e),this.compareTo=i,this.comparor=n,this._a=[],this._b=[],this._oneComplete=!1,this.add(i.subscribe(new u(e,this)))}return n(e,t),e.prototype._next=function(t){this._oneComplete&&0===this._b.length?this.emit(!1):(this._a.push(t),this.checkValues())},e.prototype._complete=function(){this._oneComplete?this.emit(0===this._a.length&&0===this._b.length):this._oneComplete=!0},e.prototype.checkValues=function(){for(var t=this,e=t._a,i=t._b,n=t.comparor;e.length>0&&i.length>0;){var r=e.shift(),c=i.shift(),a=!1;n?(a=s.tryCatch(n)(r,c))===o.errorObject&&this.destination.error(o.errorObject.e):a=r===c,a||this.emit(!1)}},e.prototype.emit=function(t){var e=this.destination;e.next(t),e.complete()},e.prototype.nextB=function(t){this._oneComplete&&0===this._a.length?this.emit(!1):(this._b.push(t),this.checkValues())},e}(r.Subscriber);e.SequenceEqualSubscriber=a;var u=function(t){function e(e,i){t.call(this,e),this.parent=i}return n(e,t),e.prototype._next=function(t){this.parent.nextB(t)},e.prototype._error=function(t){this.parent.error(t)},e.prototype._complete=function(){this.parent._complete()},e}(r.Subscriber)},\"3Tlz\":function(t,e,i){\"use strict\";e.defer=i(\"0dxg\").DeferObservable.create},\"3VCA\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"AZf1\"),o=i(\"1uGz\"),c=i(\"y2i3\"),a=i(\"pk/4\"),u=function(t){function e(e,i){t.call(this),this.source=e,this.subjectFactory=i,this._refCount=0,this._isComplete=!1}return n(e,t),e.prototype._subscribe=function(t){return this.getSubject().subscribe(t)},e.prototype.getSubject=function(){var t=this._subject;return t&&!t.isStopped||(this._subject=this.subjectFactory()),this._subject},e.prototype.connect=function(){var t=this._connection;return t||(this._isComplete=!1,(t=this._connection=new c.Subscription).add(this.source.subscribe(new h(this.getSubject(),this))),t.closed?(this._connection=null,t=c.Subscription.EMPTY):this._connection=t),t},e.prototype.refCount=function(){return a.refCount()(this)},e}(s.Observable);e.ConnectableObservable=u;var l=u.prototype;e.connectableObservableDescriptor={operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:l._subscribe},_isComplete:{value:l._isComplete,writable:!0},getSubject:{value:l.getSubject},connect:{value:l.connect},refCount:{value:l.refCount}};var h=function(t){function e(e,i){t.call(this,e),this.connectable=i}return n(e,t),e.prototype._error=function(e){this._unsubscribe(),t.prototype._error.call(this,e)},e.prototype._complete=function(){this.connectable._isComplete=!0,this._unsubscribe(),t.prototype._complete.call(this)},e.prototype._unsubscribe=function(){var t=this.connectable;if(t){this.connectable=null;var e=t._connection;t._refCount=0,t._subject=null,t._connection=null,e&&e.unsubscribe()}},e}(r.SubjectSubscriber);!function(t){function e(e,i){t.call(this,e),this.connectable=i}n(e,t),e.prototype._unsubscribe=function(){var t=this.connectable;if(t){this.connectable=null;var e=t._refCount;if(e<=0)this.connection=null;else if(t._refCount=e-1,e>1)this.connection=null;else{var i=this.connection,n=t._connection;this.connection=null,!n||i&&n!==i||n.unsubscribe()}}else this.connection=null}}(o.Subscriber)},\"3W7U\":function(t,e,i){\"use strict\";var n=i(\"3jsl\");e.takeWhile=function(t){return n.takeWhile(t)(this)}},\"3WZS\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"Re0n\"),o=i(\"1uGz\"),c=i(\"zZI/\"),a=i(\"NwwV\");e.windowTime=function(t){var e=s.async,i=null,n=Number.POSITIVE_INFINITY;return a.isScheduler(arguments[3])&&(e=arguments[3]),a.isScheduler(arguments[2])?e=arguments[2]:c.isNumeric(arguments[2])&&(n=arguments[2]),a.isScheduler(arguments[1])?e=arguments[1]:c.isNumeric(arguments[1])&&(i=arguments[1]),function(r){return r.lift(new u(t,i,n,e))}};var u=function(){function t(t,e,i,n){this.windowTimeSpan=t,this.windowCreationInterval=e,this.maxWindowSize=i,this.scheduler=n}return t.prototype.call=function(t,e){return e.subscribe(new h(t,this.windowTimeSpan,this.windowCreationInterval,this.maxWindowSize,this.scheduler))},t}(),l=function(t){function e(){t.apply(this,arguments),this._numberOfNextedValues=0}return n(e,t),e.prototype.next=function(e){this._numberOfNextedValues++,t.prototype.next.call(this,e)},Object.defineProperty(e.prototype,\"numberOfNextedValues\",{get:function(){return this._numberOfNextedValues},enumerable:!0,configurable:!0}),e}(r.Subject),h=function(t){function e(e,i,n,r,s){t.call(this,e),this.destination=e,this.windowTimeSpan=i,this.windowCreationInterval=n,this.maxWindowSize=r,this.scheduler=s,this.windows=[];var o=this.openWindow();if(null!==n&&n>=0){var c={windowTimeSpan:i,windowCreationInterval:n,subscriber:this,scheduler:s};this.add(s.schedule(d,i,{subscriber:this,window:o,context:null})),this.add(s.schedule(f,n,c))}else this.add(s.schedule(p,i,{subscriber:this,window:o,windowTimeSpan:i}))}return n(e,t),e.prototype._next=function(t){for(var e=this.windows,i=e.length,n=0;n<i;n++){var r=e[n];r.closed||(r.next(t),r.numberOfNextedValues>=this.maxWindowSize&&this.closeWindow(r))}},e.prototype._error=function(t){for(var e=this.windows;e.length>0;)e.shift().error(t);this.destination.error(t)},e.prototype._complete=function(){for(var t=this.windows;t.length>0;){var e=t.shift();e.closed||e.complete()}this.destination.complete()},e.prototype.openWindow=function(){var t=new l;return this.windows.push(t),this.destination.next(t),t},e.prototype.closeWindow=function(t){t.complete();var e=this.windows;e.splice(e.indexOf(t),1)},e}(o.Subscriber);function p(t){var e=t.subscriber,i=t.windowTimeSpan,n=t.window;n&&e.closeWindow(n),t.window=e.openWindow(),this.schedule(t,i)}function f(t){var e=t.windowTimeSpan,i=t.subscriber,n=t.scheduler,r=t.windowCreationInterval,s=i.openWindow(),o=this,c={action:o,subscription:null};c.subscription=n.schedule(d,e,{subscriber:i,window:s,context:c}),o.add(c.subscription),o.schedule(t,r)}function d(t){var e=t.subscriber,i=t.window,n=t.context;n&&n.action&&n.subscription&&n.action.remove(n.subscription),e.closeWindow(i)}},\"3hIw\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"8kg7\"),o=i(\"36rE\");e.take=function(t){return function(e){return 0===t?new o.EmptyObservable:e.lift(new c(t))}};var c=function(){function t(t){if(this.total=t,this.total<0)throw new s.ArgumentOutOfRangeError}return t.prototype.call=function(t,e){return e.subscribe(new a(t,this.total))},t}(),a=function(t){function e(e,i){t.call(this,e),this.total=i,this.count=0}return n(e,t),e.prototype._next=function(t){var e=this.total,i=++this.count;i<=e&&(this.destination.next(t),i===e&&(this.destination.complete(),this.unsubscribe()))},e}(r.Subscriber)},\"3jsl\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.takeWhile=function(t){return function(e){return e.lift(new s(t))}};var s=function(){function t(t){this.predicate=t}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.predicate))},t}(),o=function(t){function e(e,i){t.call(this,e),this.predicate=i,this.index=0}return n(e,t),e.prototype._next=function(t){var e,i=this.destination;try{e=this.predicate(t,this.index++)}catch(n){return void i.error(n)}this.nextOrComplete(t,e)},e.prototype.nextOrComplete=function(t,e){var i=this.destination;Boolean(e)?i.next(t):i.complete()},e}(r.Subscriber)},\"3zH1\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"zKHA\"),o=i(\"AJP0\"),c=i(\"8G9e\"),a=function(t){function e(e,i,n,r,s){t.call(this),this.callbackFunc=e,this.selector=i,this.args=n,this.context=r,this.scheduler=s}return n(e,t),e.create=function(t,i,n){return void 0===i&&(i=void 0),function(){for(var r=[],s=0;s<arguments.length;s++)r[s-0]=arguments[s];return new e(t,i,r,this,n)}},e.prototype._subscribe=function(t){var e=this.callbackFunc,i=this.args,n=this.scheduler,r=this.subject;if(n)return n.schedule(u,0,{source:this,subscriber:t,context:this.context});if(!r){r=this.subject=new c.AsyncSubject;var a=function t(){for(var e=[],i=0;i<arguments.length;i++)e[i-0]=arguments[i];var n=t.source,r=n.selector,c=n.subject,a=e.shift();if(a)c.error(a);else if(r){var u=s.tryCatch(r).apply(this,e);u===o.errorObject?c.error(o.errorObject.e):(c.next(u),c.complete())}else c.next(e.length<=1?e[0]:e),c.complete()};a.source=this,s.tryCatch(e).apply(this.context,i.concat(a))===o.errorObject&&r.error(o.errorObject.e)}return r.subscribe(t)},e}(r.Observable);function u(t){var e=this,i=t.source,n=t.subscriber,r=t.context,a=i.callbackFunc,u=i.args,p=i.scheduler,f=i.subject;if(!f){f=i.subject=new c.AsyncSubject;var d=function t(){for(var i=[],n=0;n<arguments.length;n++)i[n-0]=arguments[n];var r=t.source,c=r.selector,a=r.subject,u=i.shift();if(u)e.add(p.schedule(h,0,{err:u,subject:a}));else if(c){var f=s.tryCatch(c).apply(this,i);e.add(f===o.errorObject?p.schedule(h,0,{err:o.errorObject.e,subject:a}):p.schedule(l,0,{value:f,subject:a}))}else{var d=i.length<=1?i[0]:i;e.add(p.schedule(l,0,{value:d,subject:a}))}};d.source=i,s.tryCatch(a).apply(r,u.concat(d))===o.errorObject&&e.add(p.schedule(h,0,{err:o.errorObject.e,subject:f}))}e.add(f.subscribe(n))}function l(t){var e=t.subject;e.next(t.value),e.complete()}function h(t){t.subject.error(t.err)}e.BoundNodeCallbackObservable=a},\"4BFK\":function(t,e,i){\"use strict\";var n=i(\"SX7S\");e.skipWhile=function(t){return n.skipWhile(t)(this)}},\"4GoQ\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"AZf1\"),o=i(\"9jZZ\"),c=i(\"Irel\");e.delayWhen=function(t,e){return e?function(i){return new l(i,e).lift(new a(t))}:function(e){return e.lift(new a(t))}};var a=function(){function t(t){this.delayDurationSelector=t}return t.prototype.call=function(t,e){return e.subscribe(new u(t,this.delayDurationSelector))},t}(),u=function(t){function e(e,i){t.call(this,e),this.delayDurationSelector=i,this.completed=!1,this.delayNotifierSubscriptions=[],this.values=[]}return n(e,t),e.prototype.notifyNext=function(t,e,i,n,r){this.destination.next(t),this.removeSubscription(r),this.tryComplete()},e.prototype.notifyError=function(t,e){this._error(t)},e.prototype.notifyComplete=function(t){var e=this.removeSubscription(t);e&&this.destination.next(e),this.tryComplete()},e.prototype._next=function(t){try{var e=this.delayDurationSelector(t);e&&this.tryDelay(e,t)}catch(i){this.destination.error(i)}},e.prototype._complete=function(){this.completed=!0,this.tryComplete()},e.prototype.removeSubscription=function(t){t.unsubscribe();var e=this.delayNotifierSubscriptions.indexOf(t),i=null;return-1!==e&&(i=this.values[e],this.delayNotifierSubscriptions.splice(e,1),this.values.splice(e,1)),i},e.prototype.tryDelay=function(t,e){var i=c.subscribeToResult(this,t,e);i&&!i.closed&&(this.add(i),this.delayNotifierSubscriptions.push(i)),this.values.push(e)},e.prototype.tryComplete=function(){this.completed&&0===this.delayNotifierSubscriptions.length&&this.destination.complete()},e}(o.OuterSubscriber),l=function(t){function e(e,i){t.call(this),this.source=e,this.subscriptionDelay=i}return n(e,t),e.prototype._subscribe=function(t){this.subscriptionDelay.subscribe(new h(t,this.source))},e}(s.Observable),h=function(t){function e(e,i){t.call(this),this.parent=e,this.source=i,this.sourceSubscribed=!1}return n(e,t),e.prototype._next=function(t){this.subscribeToSource()},e.prototype._error=function(t){this.unsubscribe(),this.parent.error(t)},e.prototype._complete=function(){this.subscribeToSource()},e.prototype.subscribeToSource=function(){this.sourceSubscribed||(this.sourceSubscribed=!0,this.unsubscribe(),this.source.subscribe(this.parent))},e}(r.Subscriber)},\"4JC2\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"rPn0\");n.Observable.prototype.publishBehavior=r.publishBehavior},\"4WIM\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"1uGz\"),o=i(\"y2i3\"),c=i(\"PCq3\"),a=i(\"NNAl\"),u=i(\"nkkL\"),l=function(t){function e(e){t.call(this,e),this.destination=e}return n(e,t),e}(s.Subscriber);e.SubjectSubscriber=l;var h=function(t){function e(){t.call(this),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}return n(e,t),e.prototype[u.rxSubscriber]=function(){return new l(this)},e.prototype.lift=function(t){var e=new p(this,this);return e.operator=t,e},e.prototype.next=function(t){if(this.closed)throw new c.ObjectUnsubscribedError;if(!this.isStopped)for(var e=this.observers,i=e.length,n=e.slice(),r=0;r<i;r++)n[r].next(t)},e.prototype.error=function(t){if(this.closed)throw new c.ObjectUnsubscribedError;this.hasError=!0,this.thrownError=t,this.isStopped=!0;for(var e=this.observers,i=e.length,n=e.slice(),r=0;r<i;r++)n[r].error(t);this.observers.length=0},e.prototype.complete=function(){if(this.closed)throw new c.ObjectUnsubscribedError;this.isStopped=!0;for(var t=this.observers,e=t.length,i=t.slice(),n=0;n<e;n++)i[n].complete();this.observers.length=0},e.prototype.unsubscribe=function(){this.isStopped=!0,this.closed=!0,this.observers=null},e.prototype._trySubscribe=function(e){if(this.closed)throw new c.ObjectUnsubscribedError;return t.prototype._trySubscribe.call(this,e)},e.prototype._subscribe=function(t){if(this.closed)throw new c.ObjectUnsubscribedError;return this.hasError?(t.error(this.thrownError),o.Subscription.EMPTY):this.isStopped?(t.complete(),o.Subscription.EMPTY):(this.observers.push(t),new a.SubjectSubscription(this,t))},e.prototype.asObservable=function(){var t=new r.Observable;return t.source=this,t},e.create=function(t,e){return new p(t,e)},e}(r.Observable);e.Subject=h;var p=function(t){function e(e,i){t.call(this),this.destination=e,this.source=i}return n(e,t),e.prototype.next=function(t){var e=this.destination;e&&e.next&&e.next(t)},e.prototype.error=function(t){var e=this.destination;e&&e.error&&this.destination.error(t)},e.prototype.complete=function(){var t=this.destination;t&&t.complete&&this.destination.complete()},e.prototype._subscribe=function(t){return this.source?this.source.subscribe(t):o.Subscription.EMPTY},e}(h);e.AnonymousSubject=p},\"4dTV\":function(t,e,i){\"use strict\";var n=i(\"UUzK\");e.raceStatic=i(\"6VCA\").race,e.race=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return n.race.apply(void 0,t)(this)}},\"4qOA\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(){var e=t.call(this,\"Timeout has occurred\");this.name=e.name=\"TimeoutError\",this.stack=e.stack,this.message=e.message}return n(e,t),e}(Error);e.TimeoutError=r},\"5/1k\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"Ui6c\");n.Observable.prototype.repeat=r.repeat},\"53d5\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"Az9W\");n.Observable.prototype.delayWhen=r.delayWhen},\"5My3\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"JB8t\"),o=i(\"zZI/\"),c=function(t){function e(e,i,n){void 0===i&&(i=0),void 0===n&&(n=s.asap),t.call(this),this.source=e,this.delayTime=i,this.scheduler=n,(!o.isNumeric(i)||i<0)&&(this.delayTime=0),n&&\"function\"==typeof n.schedule||(this.scheduler=s.asap)}return n(e,t),e.create=function(t,i,n){return void 0===i&&(i=0),void 0===n&&(n=s.asap),new e(t,i,n)},e.dispatch=function(t){return this.add(t.source.subscribe(t.subscriber))},e.prototype._subscribe=function(t){return this.scheduler.schedule(e.dispatch,this.delayTime,{source:this.source,subscriber:t})},e}(r.Observable);e.SubscribeOnObservable=c},\"5TWj\":function(t,e,i){\"use strict\";e.SubscriptionLog=function(){return function(t,e){void 0===e&&(e=Number.POSITIVE_INFINITY),this.subscribedFrame=t,this.unsubscribedFrame=e}}()},\"5UB+\":function(t,e,i){\"use strict\";var n=i(\"8pnh\");e.windowToggle=function(t,e){return n.windowToggle(t,e)(this)}},\"5aaB\":function(t,e,i){\"use strict\";var n=i(\"6fvh\");e.max=function(t){return n.reduce(\"function\"==typeof t?function(e,i){return t(e,i)>0?e:i}:function(t,e){return t>e?t:e})}},\"5sLA\":function(t,e,i){\"use strict\";var n=i(\"WO4J\");e.takeLast=function(t){return n.takeLast(t)(this)}},\"6GWt\":function(t,e,i){\"use strict\";var n=i(\"6fvh\");e.reduce=function(t,e){return arguments.length>=2?n.reduce(t,e)(this):n.reduce(t)(this)}},\"6Tb1\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"xQMj\");n.Observable.prototype.filter=r.filter},\"6VCA\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"G2HO\"),s=i(\"rVFa\"),o=i(\"9jZZ\"),c=i(\"Irel\");e.race=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];if(1===t.length){if(!r.isArray(t[0]))return t[0];t=t[0]}return new s.ArrayObservable(t).lift(new a)};var a=function(){function t(){}return t.prototype.call=function(t,e){return e.subscribe(new u(t))},t}();e.RaceOperator=a;var u=function(t){function e(e){t.call(this,e),this.hasFirst=!1,this.observables=[],this.subscriptions=[]}return n(e,t),e.prototype._next=function(t){this.observables.push(t)},e.prototype._complete=function(){var t=this.observables,e=t.length;if(0===e)this.destination.complete();else{for(var i=0;i<e&&!this.hasFirst;i++){var n=t[i],r=c.subscribeToResult(this,n,n,i);this.subscriptions&&this.subscriptions.push(r),this.add(r)}this.observables=null}},e.prototype.notifyNext=function(t,e,i,n,r){if(!this.hasFirst){this.hasFirst=!0;for(var s=0;s<this.subscriptions.length;s++)if(s!==i){var o=this.subscriptions[s];o.unsubscribe(),this.remove(o)}this.subscriptions=null}this.destination.next(e)},e}(o.OuterSubscriber);e.RaceSubscriber=u},\"6fvh\":function(t,e,i){\"use strict\";var n=i(\"n8Qg\"),r=i(\"WO4J\"),s=i(\"2Tbn\"),o=i(\"GyLc\");e.reduce=function(t,e){return arguments.length>=2?function(i){return o.pipe(n.scan(t,e),r.takeLast(1),s.defaultIfEmpty(e))(i)}:function(e){return o.pipe(n.scan(function(e,i,n){return t(e,i,n+1)}),r.takeLast(1))(e)}}},\"6m09\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"xFrw\");n.Observable.prototype.groupBy=r.groupBy},\"6oB3\":function(t,e,i){\"use strict\";var n=i(\"NwwV\"),r=i(\"tHdp\"),s=i(\"9Kp9\"),o=i(\"A0iX\");e.concat=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return 1===t.length||2===t.length&&n.isScheduler(t[1])?s.from(t[0]):o.concatAll()(r.of.apply(void 0,t))}},\"78Oa\":function(t,e,i){\"use strict\";e.ajax=i(\"oemf\").AjaxObservable.create},\"7LGj\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"Re0n\");e.sampleTime=function(t,e){return void 0===e&&(e=s.async),function(i){return i.lift(new o(t,e))}};var o=function(){function t(t,e){this.period=t,this.scheduler=e}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.period,this.scheduler))},t}(),c=function(t){function e(e,i,n){t.call(this,e),this.period=i,this.scheduler=n,this.hasValue=!1,this.add(n.schedule(a,i,{subscriber:this,period:i}))}return n(e,t),e.prototype._next=function(t){this.lastValue=t,this.hasValue=!0},e.prototype.notifyNext=function(){this.hasValue&&(this.hasValue=!1,this.destination.next(this.lastValue))},e}(r.Subscriber);function a(t){var e=t.period;t.subscriber.notifyNext(),this.schedule(t,e)}},\"7Nkz\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"8kg7\");e.skipLast=function(t){return function(e){return e.lift(new o(t))}};var o=function(){function t(t){if(this._skipCount=t,this._skipCount<0)throw new s.ArgumentOutOfRangeError}return t.prototype.call=function(t,e){return e.subscribe(0===this._skipCount?new r.Subscriber(t):new c(t,this._skipCount))},t}(),c=function(t){function e(e,i){t.call(this,e),this._skipCount=i,this._count=0,this._ring=new Array(i)}return n(e,t),e.prototype._next=function(t){var e=this._skipCount,i=this._count++;if(i<e)this._ring[i]=t;else{var n=i%e,r=this._ring,s=r[n];r[n]=t,this.destination.next(s)}},e}(r.Subscriber)},\"7W5b\":function(t,e,i){\"use strict\";var n=i(\"lf2g\");e.mergeMap=function(t,e,i){return void 0===i&&(i=Number.POSITIVE_INFINITY),n.mergeMap(t,e,i)(this)}},\"7bsd\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"klBC\");n.Observable.prototype.map=r.map},\"7c4m\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.retry=function(t){return void 0===t&&(t=-1),function(e){return e.lift(new s(t,e))}};var s=function(){function t(t,e){this.count=t,this.source=e}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.count,this.source))},t}(),o=function(t){function e(e,i,n){t.call(this,e),this.count=i,this.source=n}return n(e,t),e.prototype.error=function(e){if(!this.isStopped){var i=this.source,n=this.count;if(0===n)return t.prototype.error.call(this,e);n>-1&&(this.count=n-1),i.subscribe(this._unsubscribeAndRecycle())}},e}(r.Subscriber)},\"7f6I\":function(t,e,i){\"use strict\";var n=i(\"Bx9r\"),r=i(\"cf1P\");e.publishBehavior=function(t){return function(e){return r.multicast(new n.BehaviorSubject(t))(e)}}},\"7lXC\":function(t,e,i){\"use strict\";var n=i(\"XNQH\");e.isEmpty=function(){return n.isEmpty()(this)}},\"7qd/\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"Yjb7\");n.Observable.combineLatest=r.combineLatest},\"8FKM\":function(t,e,i){\"use strict\";var n=i(\"3Ind\");e.sequenceEqual=function(t,e){return n.sequenceEqual(t,e)(this)}},\"8G9e\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"y2i3\"),o=function(t){function e(){t.apply(this,arguments),this.value=null,this.hasNext=!1,this.hasCompleted=!1}return n(e,t),e.prototype._subscribe=function(e){return this.hasError?(e.error(this.thrownError),s.Subscription.EMPTY):this.hasCompleted&&this.hasNext?(e.next(this.value),e.complete(),s.Subscription.EMPTY):t.prototype._subscribe.call(this,e)},e.prototype.next=function(t){this.hasCompleted||(this.value=t,this.hasNext=!0)},e.prototype.error=function(e){this.hasCompleted||t.prototype.error.call(this,e)},e.prototype.complete=function(){this.hasCompleted=!0,this.hasNext&&t.prototype.next.call(this,this.value),t.prototype.complete.call(this)},e}(r.Subject);e.AsyncSubject=o},\"8JYq\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(e,i){t.call(this)}return n(e,t),e.prototype.schedule=function(t,e){return void 0===e&&(e=0),this},e}(i(\"y2i3\").Subscription);e.Action=r},\"8SF3\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"+t3k\");n.Observable.prototype.first=r.first},\"8kg7\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(){var e=t.call(this,\"argument out of range\");this.name=e.name=\"ArgumentOutOfRangeError\",this.stack=e.stack,this.message=e.message}return n(e,t),e}(Error);e.ArgumentOutOfRangeError=r},\"8pZU\":function(t,e,i){\"use strict\";var n=i(\"oGc9\");e.materialize=function(){return n.materialize()(this)}},\"8pnh\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"y2i3\"),o=i(\"zKHA\"),c=i(\"AJP0\"),a=i(\"9jZZ\"),u=i(\"Irel\");e.windowToggle=function(t,e){return function(i){return i.lift(new l(t,e))}};var l=function(){function t(t,e){this.openings=t,this.closingSelector=e}return t.prototype.call=function(t,e){return e.subscribe(new h(t,this.openings,this.closingSelector))},t}(),h=function(t){function e(e,i,n){t.call(this,e),this.openings=i,this.closingSelector=n,this.contexts=[],this.add(this.openSubscription=u.subscribeToResult(this,i,i))}return n(e,t),e.prototype._next=function(t){var e=this.contexts;if(e)for(var i=e.length,n=0;n<i;n++)e[n].window.next(t)},e.prototype._error=function(e){var i=this.contexts;if(this.contexts=null,i)for(var n=i.length,r=-1;++r<n;){var s=i[r];s.window.error(e),s.subscription.unsubscribe()}t.prototype._error.call(this,e)},e.prototype._complete=function(){var e=this.contexts;if(this.contexts=null,e)for(var i=e.length,n=-1;++n<i;){var r=e[n];r.window.complete(),r.subscription.unsubscribe()}t.prototype._complete.call(this)},e.prototype._unsubscribe=function(){var t=this.contexts;if(this.contexts=null,t)for(var e=t.length,i=-1;++i<e;){var n=t[i];n.window.unsubscribe(),n.subscription.unsubscribe()}},e.prototype.notifyNext=function(t,e,i,n,a){if(t===this.openings){var l=o.tryCatch(this.closingSelector)(e);if(l===c.errorObject)return this.error(c.errorObject.e);var h=new r.Subject,p=new s.Subscription,f={window:h,subscription:p};this.contexts.push(f);var d=u.subscribeToResult(this,l,f);d.closed?this.closeWindow(this.contexts.length-1):(d.context=f,p.add(d)),this.destination.next(h)}else this.closeWindow(this.contexts.indexOf(t))},e.prototype.notifyError=function(t){this.error(t)},e.prototype.notifyComplete=function(t){t!==this.openSubscription&&this.closeWindow(this.contexts.indexOf(t.context))},e.prototype.closeWindow=function(t){if(-1!==t){var e=this.contexts,i=e[t],n=i.window,r=i.subscription;e.splice(t,1),n.complete(),r.unsubscribe()}},e}(a.OuterSubscriber)},\"8qff\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(e,i){t.call(this,e,i),this.scheduler=e,this.work=i}return n(e,t),e.prototype.schedule=function(e,i){return void 0===i&&(i=0),i>0?t.prototype.schedule.call(this,e,i):(this.delay=i,this.state=e,this.scheduler.flush(this),this)},e.prototype.execute=function(e,i){return i>0||this.closed?t.prototype.execute.call(this,e,i):this._execute(e,i)},e.prototype.requestAsyncId=function(e,i,n){return void 0===n&&(n=0),null!==n&&n>0||null===n&&this.delay>0?t.prototype.requestAsyncId.call(this,e,i,n):e.flush(this)},e}(i(\"g2Fv\").AsyncAction);e.QueueAction=r},\"8rll\":function(t,e,i){\"use strict\";var n=i(\"n8Qg\");e.scan=function(t,e){return arguments.length>=2?n.scan(t,e)(this):n.scan(t)(this)}},\"8t1O\":function(t,e,i){\"use strict\";var n=i(\"5TWj\");e.SubscriptionLoggable=function(){function t(){this.subscriptions=[]}return t.prototype.logSubscribedFrame=function(){return this.subscriptions.push(new n.SubscriptionLog(this.scheduler.now())),this.subscriptions.length-1},t.prototype.logUnsubscribedFrame=function(t){var e=this.subscriptions;e[t]=new n.SubscriptionLog(e[t].subscribedFrame,this.scheduler.now())},t}()},\"8tnl\":function(t,e,i){\"use strict\";e._if=i(\"zx+L\").IfObservable.create},\"8x9D\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(e,i){t.call(this),this.value=e,this.scheduler=i,this._isScalar=!0,i&&(this._isScalar=!1)}return n(e,t),e.create=function(t,i){return new e(t,i)},e.dispatch=function(t){var e=t.value,i=t.subscriber;t.done?i.complete():(i.next(e),i.closed||(t.done=!0,this.schedule(t)))},e.prototype._subscribe=function(t){var i=this.value,n=this.scheduler;if(n)return n.schedule(e.dispatch,0,{done:!1,value:i,subscriber:t});t.next(i),t.closed||t.complete()},e}(i(\"AZf1\").Observable);e.ScalarObservable=r},\"8ywx\":function(t,e,i){\"use strict\";var n=i(\"czP3\");e.pluck=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return n.pluck.apply(void 0,t)(this)}},\"90cS\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"At83\");n.Observable.onErrorResumeNext=r.onErrorResumeNext},\"98qG\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"GXS5\");n.Observable.prototype.take=r.take},\"9A9s\":function(t,e,i){\"use strict\";e.never=i(\"T3HJ\").NeverObservable.create},\"9BwH\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"Re0n\"),s=i(\"hut+\"),o=i(\"1uGz\"),c=i(\"4qOA\");e.timeout=function(t,e){void 0===e&&(e=r.async);var i=s.isDate(t),n=i?+t-e.now():Math.abs(t);return function(t){return t.lift(new a(n,i,e,new c.TimeoutError))}};var a=function(){function t(t,e,i,n){this.waitFor=t,this.absoluteTimeout=e,this.scheduler=i,this.errorInstance=n}return t.prototype.call=function(t,e){return e.subscribe(new u(t,this.absoluteTimeout,this.waitFor,this.scheduler,this.errorInstance))},t}(),u=function(t){function e(e,i,n,r,s){t.call(this,e),this.absoluteTimeout=i,this.waitFor=n,this.scheduler=r,this.errorInstance=s,this.action=null,this.scheduleTimeout()}return n(e,t),e.dispatchTimeout=function(t){t.error(t.errorInstance)},e.prototype.scheduleTimeout=function(){var t=this.action;t?this.action=t.schedule(this,this.waitFor):this.add(this.action=this.scheduler.schedule(e.dispatchTimeout,this.waitFor,this))},e.prototype._next=function(e){this.absoluteTimeout||this.scheduleTimeout(),t.prototype._next.call(this,e)},e.prototype._unsubscribe=function(){this.action=null,this.scheduler=null,this.errorInstance=null},e}(o.Subscriber)},\"9Kp9\":function(t,e,i){\"use strict\";e.from=i(\"+fDQ\").FromObservable.create},\"9Zpy\":function(t,e,i){\"use strict\";var n=i(\"WQoq\");e.sample=function(t){return n.sample(t)(this)}},\"9hG4\":function(t,e,i){\"use strict\";var n=i(\"WC+f\");e.concatStatic=i(\"6oB3\").concat,e.concat=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return n.concat.apply(void 0,t)(this)}},\"9jZZ\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(){t.apply(this,arguments)}return n(e,t),e.prototype.notifyNext=function(t,e,i,n,r){this.destination.next(e)},e.prototype.notifyError=function(t,e){this.destination.error(t)},e.prototype.notifyComplete=function(t){this.destination.complete()},e}(i(\"1uGz\").Subscriber);e.OuterSubscriber=r},\"9pdx\":function(t,e,i){\"use strict\";var n=i(\"mO1z\");e.dematerialize=function(){return n.dematerialize()(this)}},\"9x29\":function(t,e,i){\"use strict\";var n=i(\"AZf1\");e.Notification=function(){function t(t,e,i){this.kind=t,this.value=e,this.error=i,this.hasValue=\"N\"===t}return t.prototype.observe=function(t){switch(this.kind){case\"N\":return t.next&&t.next(this.value);case\"E\":return t.error&&t.error(this.error);case\"C\":return t.complete&&t.complete()}},t.prototype.do=function(t,e,i){switch(this.kind){case\"N\":return t&&t(this.value);case\"E\":return e&&e(this.error);case\"C\":return i&&i()}},t.prototype.accept=function(t,e,i){return t&&\"function\"==typeof t.next?this.observe(t):this.do(t,e,i)},t.prototype.toObservable=function(){switch(this.kind){case\"N\":return n.Observable.of(this.value);case\"E\":return n.Observable.throw(this.error);case\"C\":return n.Observable.empty()}throw new Error(\"unexpected notification kind value\")},t.createNext=function(e){return void 0!==e?new t(\"N\",e):t.undefinedValueNotification},t.createError=function(e){return new t(\"E\",void 0,e)},t.createComplete=function(){return t.completeNotification},t.completeNotification=new t(\"C\"),t.undefinedValueNotification=new t(\"N\",void 0),t}()},\"A/ap\":function(t,e,i){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var n={update:function(){if(\"undefined\"!=typeof window&&\"function\"==typeof window.addEventListener){var t=!1,e=Object.defineProperty({},\"passive\",{get:function(){t=!0}}),i=function(){};window.addEventListener(\"testPassiveEventSupport\",i,e),window.removeEventListener(\"testPassiveEventSupport\",i,e),n.hasSupport=t}}};n.update(),e.default=n},A0iX:function(t,e,i){\"use strict\";var n=i(\"0p2S\");e.concatAll=function(){return n.mergeAll(1)}},A17Z:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"/3m9\");n.Observable.prototype.combineAll=r.combineAll},A1NZ:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"DIMi\");n.Observable.prototype.expand=r.expand},ABAE:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.pairwise=function(){return function(t){return t.lift(new s)}};var s=function(){function t(){}return t.prototype.call=function(t,e){return e.subscribe(new o(t))},t}(),o=function(t){function e(e){t.call(this,e),this.hasPrev=!1}return n(e,t),e.prototype._next=function(t){this.hasPrev?this.destination.next([this.prev,t]):this.hasPrev=!0,this.prev=t},e}(r.Subscriber)},AF4n:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"l6Ej\");n.Observable.prototype.distinctUntilKeyChanged=r.distinctUntilKeyChanged},\"AI1+\":function(t,e,i){\"use strict\";e.webSocket=i(\"m8PH\").WebSocketSubject.create},AJP0:function(t,e,i){\"use strict\";e.errorObject={e:{}}},AZf1:function(t,e,i){\"use strict\";var n=i(\"/WK6\"),r=i(\"wR93\"),s=i(\"WU5C\"),o=i(\"GyLc\");e.Observable=function(){function t(t){this._isScalar=!1,t&&(this._subscribe=t)}return t.prototype.lift=function(e){var i=new t;return i.source=this,i.operator=e,i},t.prototype.subscribe=function(t,e,i){var n=this.operator,s=r.toSubscriber(t,e,i);if(n?n.call(s,this.source):s.add(this.source||!s.syncErrorThrowable?this._subscribe(s):this._trySubscribe(s)),s.syncErrorThrowable&&(s.syncErrorThrowable=!1,s.syncErrorThrown))throw s.syncErrorValue;return s},t.prototype._trySubscribe=function(t){try{return this._subscribe(t)}catch(e){t.syncErrorThrown=!0,t.syncErrorValue=e,t.error(e)}},t.prototype.forEach=function(t,e){var i=this;if(e||(n.root.Rx&&n.root.Rx.config&&n.root.Rx.config.Promise?e=n.root.Rx.config.Promise:n.root.Promise&&(e=n.root.Promise)),!e)throw new Error(\"no Promise impl found\");return new e(function(e,n){var r;r=i.subscribe(function(e){if(r)try{t(e)}catch(i){n(i),r.unsubscribe()}else t(e)},n,e)})},t.prototype._subscribe=function(t){return this.source.subscribe(t)},t.prototype[s.observable]=function(){return this},t.prototype.pipe=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return 0===t.length?this:o.pipeFromArray(t)(this)},t.prototype.toPromise=function(t){var e=this;if(t||(n.root.Rx&&n.root.Rx.config&&n.root.Rx.config.Promise?t=n.root.Rx.config.Promise:n.root.Promise&&(t=n.root.Promise)),!t)throw new Error(\"no Promise impl found\");return new t(function(t,i){var n;e.subscribe(function(t){return n=t},function(t){return i(t)},function(){return t(n)})})},t.create=function(e){return new t(e)},t}()},Al8V:function(t,e,i){\"use strict\";var n=i(\"ABAE\");e.pairwise=function(){return n.pairwise()(this)}},At83:function(t,e,i){\"use strict\";e.onErrorResumeNext=i(\"Rm1J\").onErrorResumeNextStatic},Az9W:function(t,e,i){\"use strict\";var n=i(\"4GoQ\");e.delayWhen=function(t,e){return n.delayWhen(t,e)(this)}},AzqM:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"Re0n\");e.debounceTime=function(t,e){return void 0===e&&(e=s.async),function(i){return i.lift(new o(t,e))}};var o=function(){function t(t,e){this.dueTime=t,this.scheduler=e}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.dueTime,this.scheduler))},t}(),c=function(t){function e(e,i,n){t.call(this,e),this.dueTime=i,this.scheduler=n,this.debouncedSubscription=null,this.lastValue=null,this.hasValue=!1}return n(e,t),e.prototype._next=function(t){this.clearDebounce(),this.lastValue=t,this.hasValue=!0,this.add(this.debouncedSubscription=this.scheduler.schedule(a,this.dueTime,this))},e.prototype._complete=function(){this.debouncedNext(),this.destination.complete()},e.prototype.debouncedNext=function(){this.clearDebounce(),this.hasValue&&(this.destination.next(this.lastValue),this.lastValue=null,this.hasValue=!1)},e.prototype.clearDebounce=function(){var t=this.debouncedSubscription;null!==t&&(this.remove(t),t.unsubscribe(),this.debouncedSubscription=null)},e}(r.Subscriber);function a(t){t.debouncedNext()}},BPHu:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"qQIA\");n.Observable.interval=r.interval},BQYW:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"IAWd\");n.Observable.prototype.publish=r.publish},BTim:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"Re0n\");e.timeInterval=function(t){return void 0===t&&(t=s.async),function(e){return e.lift(new c(t))}};var o=function(){return function(t,e){this.value=t,this.interval=e}}();e.TimeInterval=o;var c=function(){function t(t){this.scheduler=t}return t.prototype.call=function(t,e){return e.subscribe(new a(t,this.scheduler))},t}(),a=function(t){function e(e,i){t.call(this,e),this.scheduler=i,this.lastTime=0,this.lastTime=i.now()}return n(e,t),e.prototype._next=function(t){var e=this.scheduler.now(),i=e-this.lastTime;this.lastTime=e,this.destination.next(new o(t,i))},e}(r.Subscriber)},BWyk:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"QCIY\");e.delay=function(t,e){return void 0===e&&(e=n.async),r.delay(t,e)(this)}},BbYg:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"3Tlz\");n.Observable.defer=r.defer},Bgoh:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"3W7U\");n.Observable.prototype.takeWhile=r.takeWhile},BjeI:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"VZMG\"),o=i(\"y2i3\"),c=i(\"0zyO\"),a=i(\"PCq3\"),u=i(\"NNAl\"),l=function(t){function e(e,i,n){void 0===e&&(e=Number.POSITIVE_INFINITY),void 0===i&&(i=Number.POSITIVE_INFINITY),t.call(this),this.scheduler=n,this._events=[],this._bufferSize=e<1?1:e,this._windowTime=i<1?1:i}return n(e,t),e.prototype.next=function(e){var i=this._getNow();this._events.push(new h(i,e)),this._trimBufferThenGetEvents(),t.prototype.next.call(this,e)},e.prototype._subscribe=function(t){var e,i=this._trimBufferThenGetEvents(),n=this.scheduler;if(this.closed)throw new a.ObjectUnsubscribedError;this.hasError||this.isStopped?e=o.Subscription.EMPTY:(this.observers.push(t),e=new u.SubjectSubscription(this,t)),n&&t.add(t=new c.ObserveOnSubscriber(t,n));for(var r=i.length,s=0;s<r&&!t.closed;s++)t.next(i[s].value);return this.hasError?t.error(this.thrownError):this.isStopped&&t.complete(),e},e.prototype._getNow=function(){return(this.scheduler||s.queue).now()},e.prototype._trimBufferThenGetEvents=function(){for(var t=this._getNow(),e=this._bufferSize,i=this._windowTime,n=this._events,r=n.length,s=0;s<r&&!(t-n[s].time<i);)s++;return r>e&&(s=Math.max(s,r-e)),s>0&&n.splice(0,s),n},e}(r.Subject);e.ReplaySubject=l;var h=function(){return function(t,e){this.time=t,this.value=e}}()},BnoD:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"Re0n\"),o=i(\"o6MN\");e.throttleTime=function(t,e,i){return void 0===e&&(e=s.async),void 0===i&&(i=o.defaultThrottleConfig),function(n){return n.lift(new c(t,e,i.leading,i.trailing))}};var c=function(){function t(t,e,i,n){this.duration=t,this.scheduler=e,this.leading=i,this.trailing=n}return t.prototype.call=function(t,e){return e.subscribe(new a(t,this.duration,this.scheduler,this.leading,this.trailing))},t}(),a=function(t){function e(e,i,n,r,s){t.call(this,e),this.duration=i,this.scheduler=n,this.leading=r,this.trailing=s,this._hasTrailingValue=!1,this._trailingValue=null}return n(e,t),e.prototype._next=function(t){this.throttled?this.trailing&&(this._trailingValue=t,this._hasTrailingValue=!0):(this.add(this.throttled=this.scheduler.schedule(u,this.duration,{subscriber:this})),this.leading&&this.destination.next(t))},e.prototype.clearThrottle=function(){var t=this.throttled;t&&(this.trailing&&this._hasTrailingValue&&(this.destination.next(this._trailingValue),this._trailingValue=null,this._hasTrailingValue=!1),t.unsubscribe(),this.remove(t),this.throttled=null)},e}(r.Subscriber);function u(t){t.subscriber.clearThrottle()}},BoXX:function(t,e,i){\"use strict\";var n=i(\"WesY\");e.animationFrame=new(i(\"loW1\").AnimationFrameScheduler)(n.AnimationFrameAction)},Bx9r:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"PCq3\"),o=function(t){function e(e){t.call(this),this._value=e}return n(e,t),Object.defineProperty(e.prototype,\"value\",{get:function(){return this.getValue()},enumerable:!0,configurable:!0}),e.prototype._subscribe=function(e){var i=t.prototype._subscribe.call(this,e);return i&&!i.closed&&e.next(this._value),i},e.prototype.getValue=function(){if(this.hasError)throw this.thrownError;if(this.closed)throw new s.ObjectUnsubscribedError;return this._value},e.prototype.next=function(e){t.prototype.next.call(this,this._value=e)},e}(r.Subject);e.BehaviorSubject=o},C8RJ:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"zKHA\"),o=i(\"AJP0\"),c=i(\"9jZZ\"),a=i(\"Irel\");e.retryWhen=function(t){return function(e){return e.lift(new u(t,e))}};var u=function(){function t(t,e){this.notifier=t,this.source=e}return t.prototype.call=function(t,e){return e.subscribe(new l(t,this.notifier,this.source))},t}(),l=function(t){function e(e,i,n){t.call(this,e),this.notifier=i,this.source=n}return n(e,t),e.prototype.error=function(e){if(!this.isStopped){var i=this.errors,n=this.retries,c=this.retriesSubscription;if(n)this.errors=null,this.retriesSubscription=null;else{if(i=new r.Subject,(n=s.tryCatch(this.notifier)(i))===o.errorObject)return t.prototype.error.call(this,o.errorObject.e);c=a.subscribeToResult(this,n)}this._unsubscribeAndRecycle(),this.errors=i,this.retries=n,this.retriesSubscription=c,i.next(e)}},e.prototype._unsubscribe=function(){var t=this.errors,e=this.retriesSubscription;t&&(t.unsubscribe(),this.errors=null),e&&(e.unsubscribe(),this.retriesSubscription=null),this.retries=null},e.prototype.notifyNext=function(t,e,i,n,r){var s=this,o=s.errors,c=s.retries,a=s.retriesSubscription;this.errors=null,this.retries=null,this.retriesSubscription=null,this._unsubscribeAndRecycle(),this.errors=o,this.retries=c,this.retriesSubscription=a,this.source.subscribe(this)},e}(c.OuterSubscriber)},CxhQ:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.catchError=function(t){return function(e){var i=new o(t),n=e.lift(i);return i.caught=n}};var o=function(){function t(t){this.selector=t}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.selector,this.caught))},t}(),c=function(t){function e(e,i,n){t.call(this,e),this.selector=i,this.caught=n}return n(e,t),e.prototype.error=function(e){if(!this.isStopped){var i=void 0;try{i=this.selector(e,this.caught)}catch(n){return void t.prototype.error.call(this,n)}this._unsubscribeAndRecycle(),this.add(s.subscribeToResult(this,i))}},e}(r.OuterSubscriber)},D2MY:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(e,i,n){t.call(this),this.parent=e,this.outerValue=i,this.outerIndex=n,this.index=0}return n(e,t),e.prototype._next=function(t){this.parent.notifyNext(this.outerValue,t,this.outerIndex,this.index++,this)},e.prototype._error=function(t){this.parent.notifyError(t,this),this.unsubscribe()},e.prototype._complete=function(){this.parent.notifyComplete(this),this.unsubscribe()},e}(i(\"1uGz\").Subscriber);e.InnerSubscriber=r},D4pF:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"AzqM\");e.debounceTime=function(t,e){return void 0===e&&(e=n.async),r.debounceTime(t,e)(this)}},D9at:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"un7O\");n.Observable.prototype.concatAll=r.concatAll},DAeC:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"9hG4\");n.Observable.prototype.concat=r.concat},DFxj:function(t,e,i){\"use strict\";var n=i(\"rVFa\"),r=i(\"8x9D\"),s=i(\"36rE\"),o=i(\"6oB3\"),c=i(\"NwwV\");e.startWith=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return function(e){var i=t[t.length-1];c.isScheduler(i)?t.pop():i=null;var a=t.length;return o.concat(1===a?new r.ScalarObservable(t[0],i):a>1?new n.ArrayObservable(t,i):new s.EmptyObservable(i),e)}}},DIMi:function(t,e,i){\"use strict\";var n=i(\"we3k\");e.expand=function(t,e,i){return void 0===e&&(e=Number.POSITIVE_INFINITY),void 0===i&&(i=void 0),n.expand(t,e=(e||0)<1?Number.POSITIVE_INFINITY:e,i)(this)}},DKXc:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.find=function(t,e){if(\"function\"!=typeof t)throw new TypeError(\"predicate is not a function\");return function(i){return i.lift(new s(t,i,!1,e))}};var s=function(){function t(t,e,i,n){this.predicate=t,this.source=e,this.yieldIndex=i,this.thisArg=n}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.predicate,this.source,this.yieldIndex,this.thisArg))},t}();e.FindValueOperator=s;var o=function(t){function e(e,i,n,r,s){t.call(this,e),this.predicate=i,this.source=n,this.yieldIndex=r,this.thisArg=s,this.index=0}return n(e,t),e.prototype.notifyComplete=function(t){var e=this.destination;e.next(t),e.complete()},e.prototype._next=function(t){var e=this.predicate,i=this.thisArg,n=this.index++;try{e.call(i||this,t,n,this.source)&&this.notifyComplete(this.yieldIndex?n:t)}catch(r){this.destination.error(r)}},e.prototype._complete=function(){this.notifyComplete(this.yieldIndex?-1:void 0)},e}(r.Subscriber);e.FindValueSubscriber=o},DbqF:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"LVa5\");n.Observable.prototype.share=r.share},DsW9:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"xxrh\");n.Observable.fromPromise=r.fromPromise},DxGp:function(t,e,i){\"use strict\";var n=i(\"5My3\");e.subscribeOn=function(t,e){return void 0===e&&(e=0),function(i){return i.lift(new r(t,e))}};var r=function(){function t(t,e){this.scheduler=t,this.delay=e}return t.prototype.call=function(t,e){return new n.SubscribeOnObservable(e,this.delay,this.scheduler).subscribe(t)},t}()},ER9c:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.every=function(t,e){return function(i){return i.lift(new s(t,e,i))}};var s=function(){function t(t,e,i){this.predicate=t,this.thisArg=e,this.source=i}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.predicate,this.thisArg,this.source))},t}(),o=function(t){function e(e,i,n,r){t.call(this,e),this.predicate=i,this.thisArg=n,this.source=r,this.index=0,this.thisArg=n||this}return n(e,t),e.prototype.notifyComplete=function(t){this.destination.next(t),this.destination.complete()},e.prototype._next=function(t){var e=!1;try{e=this.predicate.call(this.thisArg,t,this.index++,this.source)}catch(i){return void this.destination.error(i)}e||this.notifyComplete(!1)},e.prototype._complete=function(){this.notifyComplete(!0)},e}(r.Subscriber)},EeVn:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"V9wX\");n.Observable.fromEvent=r.fromEvent},Etjs:function(t,e,i){\"use strict\";e.zip=i(\"oQYR\").zipStatic},FBtj:function(t,e,i){\"use strict\";var n=i(\"oQYR\");e.zipAll=function(t){return function(e){return e.lift(new n.ZipOperator(t))}}},\"FEB/\":function(t,e,i){\"use strict\";var n=i(\"nQov\");e.distinct=function(t,e){return n.distinct(t,e)(this)}},FXL7:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(){t.apply(this,arguments),this.actions=[],this.active=!1,this.scheduled=void 0}return n(e,t),e.prototype.flush=function(t){var e=this.actions;if(this.active)e.push(t);else{var i;this.active=!0;do{if(i=t.execute(t.state,t.delay))break}while(t=e.shift());if(this.active=!1,i){for(;t=e.shift();)t.unsubscribe();throw i}}},e}(i(\"ZCeS\").Scheduler);e.AsyncScheduler=r},FYEZ:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"+24W\");n.Observable.prototype.switchMap=r.switchMap},Fgpt:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"suOF\");n.Observable.prototype.timeInterval=r.timeInterval},G2HO:function(t,e,i){\"use strict\";e.isArray=Array.isArray||function(t){return t&&\"number\"==typeof t.length}},G7wb:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"c/6p\");n.Observable.prototype.multicast=r.multicast},GCyh:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"QM1w\");n.Observable.prototype.let=r.letProto,n.Observable.prototype.letBind=r.letProto},GEfX:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.exhaustMap=function(t,e){return function(i){return i.lift(new o(t,e))}};var o=function(){function t(t,e){this.project=t,this.resultSelector=e}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.project,this.resultSelector))},t}(),c=function(t){function e(e,i,n){t.call(this,e),this.project=i,this.resultSelector=n,this.hasSubscription=!1,this.hasCompleted=!1,this.index=0}return n(e,t),e.prototype._next=function(t){this.hasSubscription||this.tryNext(t)},e.prototype.tryNext=function(t){var e=this.index++,i=this.destination;try{var n=this.project(t,e);this.hasSubscription=!0,this.add(s.subscribeToResult(this,n,t,e))}catch(r){i.error(r)}},e.prototype._complete=function(){this.hasCompleted=!0,this.hasSubscription||this.destination.complete()},e.prototype.notifyNext=function(t,e,i,n,r){var s=this.destination;this.resultSelector?this.trySelectResult(t,e,i,n):s.next(e)},e.prototype.trySelectResult=function(t,e,i,n){var r=this.resultSelector,s=this.destination;try{var o=r(t,e,i,n);s.next(o)}catch(c){s.error(c)}},e.prototype.notifyError=function(t){this.destination.error(t)},e.prototype.notifyComplete=function(t){this.remove(t),this.hasSubscription=!1,this.hasCompleted&&this.destination.complete()},e}(r.OuterSubscriber)},GHBr:function(t,e,i){\"use strict\";e._throw=i(\"i45a\").ErrorObservable.create},GJlw:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"skK3\");n.Observable.prototype.zip=r.zipProto},GXS5:function(t,e,i){\"use strict\";var n=i(\"3hIw\");e.take=function(t){return n.take(t)(this)}},GyLc:function(t,e,i){\"use strict\";var n=i(\"gRDe\");function r(t){return t?1===t.length?t[0]:function(e){return t.reduce(function(t,e){return e(t)},e)}:n.noop}e.pipe=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return r(t)},e.pipeFromArray=r},H0zL:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.exhaust=function(){return function(t){return t.lift(new o)}};var o=function(){function t(){}return t.prototype.call=function(t,e){return e.subscribe(new c(t))},t}(),c=function(t){function e(e){t.call(this,e),this.hasCompleted=!1,this.hasSubscription=!1}return n(e,t),e.prototype._next=function(t){this.hasSubscription||(this.hasSubscription=!0,this.add(s.subscribeToResult(this,t)))},e.prototype._complete=function(){this.hasCompleted=!0,this.hasSubscription||this.destination.complete()},e.prototype.notifyComplete=function(t){this.remove(t),this.hasSubscription=!1,this.hasCompleted&&this.destination.complete()},e}(r.OuterSubscriber)},HH2i:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"4BFK\");n.Observable.prototype.skipWhile=r.skipWhile},HTvz:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"9Zpy\");n.Observable.prototype.sample=r.sample},Hbpk:function(t,e,i){\"use strict\";var n=i(\"/WK6\"),r=function(){function t(t){if(this.root=t,t.setImmediate&&\"function\"==typeof t.setImmediate)this.setImmediate=t.setImmediate.bind(t),this.clearImmediate=t.clearImmediate.bind(t);else{this.nextHandle=1,this.tasksByHandle={},this.currentlyRunningATask=!1,this.setImmediate=this.canUseProcessNextTick()?this.createProcessNextTickSetImmediate():this.canUsePostMessage()?this.createPostMessageSetImmediate():this.canUseMessageChannel()?this.createMessageChannelSetImmediate():this.canUseReadyStateChange()?this.createReadyStateChangeSetImmediate():this.createSetTimeoutSetImmediate();var e=function t(e){delete t.instance.tasksByHandle[e]};e.instance=this,this.clearImmediate=e}}return t.prototype.identify=function(t){return this.root.Object.prototype.toString.call(t)},t.prototype.canUseProcessNextTick=function(){return\"[object process]\"===this.identify(this.root.process)},t.prototype.canUseMessageChannel=function(){return Boolean(this.root.MessageChannel)},t.prototype.canUseReadyStateChange=function(){var t=this.root.document;return Boolean(t&&\"onreadystatechange\"in t.createElement(\"script\"))},t.prototype.canUsePostMessage=function(){var t=this.root;if(t.postMessage&&!t.importScripts){var e=!0,i=t.onmessage;return t.onmessage=function(){e=!1},t.postMessage(\"\",\"*\"),t.onmessage=i,e}return!1},t.prototype.partiallyApplied=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];var n=function t(){var e=t.handler;\"function\"==typeof e?e.apply(void 0,t.args):new Function(\"\"+e)()};return n.handler=t,n.args=e,n},t.prototype.addFromSetImmediateArguments=function(t){return this.tasksByHandle[this.nextHandle]=this.partiallyApplied.apply(void 0,t),this.nextHandle++},t.prototype.createProcessNextTickSetImmediate=function(){var t=function t(){var e=t.instance,i=e.addFromSetImmediateArguments(arguments);return e.root.process.nextTick(e.partiallyApplied(e.runIfPresent,i)),i};return t.instance=this,t},t.prototype.createPostMessageSetImmediate=function(){var t=this.root,e=\"setImmediate$\"+t.Math.random()+\"$\",i=function i(n){var r=i.instance;n.source===t&&\"string\"==typeof n.data&&0===n.data.indexOf(e)&&r.runIfPresent(+n.data.slice(e.length))};i.instance=this,t.addEventListener(\"message\",i,!1);var n=function t(){var e=t,i=e.messagePrefix,n=e.instance,r=n.addFromSetImmediateArguments(arguments);return n.root.postMessage(i+r,\"*\"),r};return n.instance=this,n.messagePrefix=e,n},t.prototype.runIfPresent=function(t){if(this.currentlyRunningATask)this.root.setTimeout(this.partiallyApplied(this.runIfPresent,t),0);else{var e=this.tasksByHandle[t];if(e){this.currentlyRunningATask=!0;try{e()}finally{this.clearImmediate(t),this.currentlyRunningATask=!1}}}},t.prototype.createMessageChannelSetImmediate=function(){var t=this,e=new this.root.MessageChannel;e.port1.onmessage=function(e){t.runIfPresent(e.data)};var i=function t(){var e=t,i=e.channel,n=e.instance,r=n.addFromSetImmediateArguments(arguments);return i.port2.postMessage(r),r};return i.channel=e,i.instance=this,i},t.prototype.createReadyStateChangeSetImmediate=function(){var t=function t(){var e=t.instance,i=e.root,n=i.document,r=n.documentElement,s=e.addFromSetImmediateArguments(arguments),o=n.createElement(\"script\");return o.onreadystatechange=function(){e.runIfPresent(s),o.onreadystatechange=null,r.removeChild(o),o=null},r.appendChild(o),s};return t.instance=this,t},t.prototype.createSetTimeoutSetImmediate=function(){var t=function t(){var e=t.instance,i=e.addFromSetImmediateArguments(arguments);return e.root.setTimeout(e.partiallyApplied(e.runIfPresent,i),0),i};return t.instance=this,t},t}();e.ImmediateDefinition=r,e.Immediate=new r(n.root)},Ht43:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"4dTV\");n.Observable.prototype.race=r.race},\"I+lI\":function(t,e,i){\"use strict\";var n=i(\"ast0\");e.windowCount=function(t,e){return void 0===e&&(e=0),n.windowCount(t,e)(this)}},IAWd:function(t,e,i){\"use strict\";var n=i(\"gcf/\");e.publish=function(t){return n.publish(t)(this)}},IEzG:function(t,e,i){\"use strict\";var n=i(\"2Wg+\");e.withLatestFrom=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return n.withLatestFrom.apply(void 0,t)(this)}},IYeR:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"0jD2\");n.Observable.prototype.count=r.count},Irel:function(t,e,i){\"use strict\";var n=i(\"/WK6\"),r=i(\"foHw\"),s=i(\"RGvf\"),o=i(\"pYXR\"),c=i(\"AZf1\"),a=i(\"+2+e\"),u=i(\"D2MY\"),l=i(\"WU5C\");e.subscribeToResult=function(t,e,i,h){var p=new u.InnerSubscriber(t,i,h);if(p.closed)return null;if(e instanceof c.Observable)return e._isScalar?(p.next(e.value),p.complete(),null):(p.syncErrorThrowable=!0,e.subscribe(p));if(r.isArrayLike(e)){for(var f=0,d=e.length;f<d&&!p.closed;f++)p.next(e[f]);p.closed||p.complete()}else{if(s.isPromise(e))return e.then(function(t){p.closed||(p.next(t),p.complete())},function(t){return p.error(t)}).then(null,function(t){n.root.setTimeout(function(){throw t})}),p;if(e&&\"function\"==typeof e[a.iterator])for(var b=e[a.iterator]();;){var v=b.next();if(v.done){p.complete();break}if(p.next(v.value),p.closed)break}else if(e&&\"function\"==typeof e[l.observable]){var y=e[l.observable]();if(\"function\"==typeof y.subscribe)return y.subscribe(new u.InnerSubscriber(t,i,h));p.error(new TypeError(\"Provided object does not correctly implement Symbol.observable\"))}else{var m=o.isObject(e)?\"an invalid object\":\"'\"+e+\"'\";p.error(new TypeError(\"You provided \"+m+\" where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.\"))}}return null}},IwEe:function(t,e,i){\"use strict\";var n=i(\"q9sB\");e._finally=function(t){return n.finalize(t)(this)}},\"J//a\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"QCDQ\");n.Observable.prototype.observeOn=r.observeOn},J9JT:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"g2Fv\"),s=function(t){function e(e,i){var n=this;void 0===e&&(e=o),void 0===i&&(i=Number.POSITIVE_INFINITY),t.call(this,e,function(){return n.frame}),this.maxFrames=i,this.frame=0,this.index=-1}return n(e,t),e.prototype.flush=function(){for(var t,e,i=this.actions,n=this.maxFrames;(e=i.shift())&&(this.frame=e.delay)<=n&&!(t=e.execute(e.state,e.delay)););if(t){for(;e=i.shift();)e.unsubscribe();throw t}},e.frameTimeFactor=10,e}(i(\"FXL7\").AsyncScheduler);e.VirtualTimeScheduler=s;var o=function(t){function e(e,i,n){void 0===n&&(n=e.index+=1),t.call(this,e,i),this.scheduler=e,this.work=i,this.index=n,this.active=!0,this.index=e.index=n}return n(e,t),e.prototype.schedule=function(i,n){if(void 0===n&&(n=0),!this.id)return t.prototype.schedule.call(this,i,n);this.active=!1;var r=new e(this.scheduler,this.work);return this.add(r),r.schedule(i,n)},e.prototype.requestAsyncId=function(t,i,n){void 0===n&&(n=0),this.delay=t.frame+n;var r=t.actions;return r.push(this),r.sort(e.sortActions),!0},e.prototype.recycleAsyncId=function(t,e,i){void 0===i&&(i=0)},e.prototype._execute=function(e,i){if(!0===this.active)return t.prototype._execute.call(this,e,i)},e.sortActions=function(t,e){return t.delay===e.delay?t.index===e.index?0:t.index>e.index?1:-1:t.delay>e.delay?1:-1},e}(r.AsyncAction);e.VirtualAction=o},JB8t:function(t,e,i){\"use strict\";var n=i(\"bIKf\");e.asap=new(i(\"q+iv\").AsapScheduler)(n.AsapAction)},JLRC:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"/QDG\");n.Observable.prototype.flatMapTo=r.mergeMapTo,n.Observable.prototype.mergeMapTo=r.mergeMapTo},JLi8:function(t,e,i){\"use strict\";e.forkJoin=i(\"od+f\").ForkJoinObservable.create},JWmB:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"2Go0\");n.Observable.pairs=r.pairs},JX5i:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"Irel\"),o=i(\"9jZZ\"),c=function(t){function e(e,i){t.call(this),this.resourceFactory=e,this.observableFactory=i}return n(e,t),e.create=function(t,i){return new e(t,i)},e.prototype._subscribe=function(t){var e,i=this.resourceFactory,n=this.observableFactory;try{return e=i(),new a(t,e,n)}catch(r){t.error(r)}},e}(r.Observable);e.UsingObservable=c;var a=function(t){function e(e,i,n){t.call(this,e),this.resource=i,this.observableFactory=n,e.add(i),this.tryUse()}return n(e,t),e.prototype.tryUse=function(){try{var t=this.observableFactory.call(this,this.resource);t&&this.add(s.subscribeToResult(this,t))}catch(e){this._error(e)}},e}(o.OuterSubscriber)},Jmzy:function(t,e){},Jvmm:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"7lXC\");n.Observable.prototype.isEmpty=r.isEmpty},K4Q0:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"KXV8\");n.Observable.prototype.ignoreElements=r.ignoreElements},\"KC+j\":function(t,e,i){\"use strict\";var n=i(\"+WiC\");e.concatMap=function(t,e){return n.concatMap(t,e)(this)}},KHtr:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"78Oa\");n.Observable.ajax=r.ajax},KXV8:function(t,e,i){\"use strict\";var n=i(\"Tb5M\");e.ignoreElements=function(){return n.ignoreElements()(this)}},Kc9Z:function(t,e,i){\"use strict\";var n=i(\"6fvh\");e.min=function(t){return n.reduce(\"function\"==typeof t?function(e,i){return t(e,i)<0?e:i}:function(t,e){return t<e?t:e})}},Kqb3:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.tap=function(t,e,i){return function(n){return n.lift(new s(t,e,i))}};var s=function(){function t(t,e,i){this.nextOrObserver=t,this.error=e,this.complete=i}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.nextOrObserver,this.error,this.complete))},t}(),o=function(t){function e(e,i,n,s){t.call(this,e);var o=new r.Subscriber(i,n,s);o.syncErrorThrowable=!0,this.add(o),this.safeSubscriber=o}return n(e,t),e.prototype._next=function(t){var e=this.safeSubscriber;e.next(t),e.syncErrorThrown?this.destination.error(e.syncErrorValue):this.destination.next(t)},e.prototype._error=function(t){var e=this.safeSubscriber;e.error(t),this.destination.error(e.syncErrorThrown?e.syncErrorValue:t)},e.prototype._complete=function(){var t=this.safeSubscriber;t.complete(),t.syncErrorThrown?this.destination.error(t.syncErrorValue):this.destination.complete()},e}(r.Subscriber)},Kwcu:function(t,e,i){\"use strict\";var n=i(\"7c4m\");e.retry=function(t){return void 0===t&&(t=-1),n.retry(t)(this)}},\"L/jt\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"2fIB\");e.first=function(t,e,i){return function(n){return n.lift(new o(t,e,i,n))}};var o=function(){function t(t,e,i,n){this.predicate=t,this.resultSelector=e,this.defaultValue=i,this.source=n}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.predicate,this.resultSelector,this.defaultValue,this.source))},t}(),c=function(t){function e(e,i,n,r,s){t.call(this,e),this.predicate=i,this.resultSelector=n,this.defaultValue=r,this.source=s,this.index=0,this.hasCompleted=!1,this._emitted=!1}return n(e,t),e.prototype._next=function(t){var e=this.index++;this.predicate?this._tryPredicate(t,e):this._emit(t,e)},e.prototype._tryPredicate=function(t,e){var i;try{i=this.predicate(t,e,this.source)}catch(n){return void this.destination.error(n)}i&&this._emit(t,e)},e.prototype._emit=function(t,e){this.resultSelector?this._tryResultSelector(t,e):this._emitFinal(t)},e.prototype._tryResultSelector=function(t,e){var i;try{i=this.resultSelector(t,e)}catch(n){return void this.destination.error(n)}this._emitFinal(i)},e.prototype._emitFinal=function(t){var e=this.destination;this._emitted||(this._emitted=!0,e.next(t),e.complete(),this.hasCompleted=!0)},e.prototype._complete=function(){var t=this.destination;this.hasCompleted||void 0===this.defaultValue?this.hasCompleted||t.error(new s.EmptyError):(t.next(this.defaultValue),t.complete())},e}(r.Subscriber)},LAU0:function(t,e,i){\"use strict\";e.identity=function(t){return t}},LLa1:function(t,e,i){\"use strict\";var n=i(\"zobD\");e.buffer=function(t){return n.buffer(t)(this)}},LVa5:function(t,e,i){\"use strict\";var n=i(\"X/dC\");e.share=function(){return n.share()(this)}},LWF9:function(t,e,i){\"use strict\";var n=i(\"/WK6\"),r=i(\"/mOC\");e.Map=n.root.Map||function(){return r.MapPolyfill}()},Lhs8:function(t,e,i){\"use strict\";var n=i(\"Kqb3\");e._do=function(t,e,i){return n.tap(t,e,i)(this)}},Lj2B:function(t,e,i){\"use strict\";var n=i(\"hY8S\");e._switch=function(){return n.switchAll()(this)}},LqmK:function(t,e,i){\"use strict\";var n=i(\"MdjT\");e.mergeStatic=i(\"MdjT\").merge,e.merge=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return function(e){return e.lift.call(n.merge.apply(void 0,[e].concat(t)))}}},M1gx:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"X7Im\");n.Observable.prototype.throttleTime=r.throttleTime},M6BU:function(t,e,i){\"use strict\";var n=i(\"6fvh\");function r(t,e,i){return 0===i?[e]:(t.push(e),t)}e.toArray=function(){return n.reduce(r,[])}},MB5B:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"wEqr\");n.Observable.prototype.partition=r.partition},MHPA:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.takeUntil=function(t){return function(e){return e.lift(new o(t))}};var o=function(){function t(t){this.notifier=t}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.notifier))},t}(),c=function(t){function e(e,i){t.call(this,e),this.notifier=i,this.add(s.subscribeToResult(this,i))}return n(e,t),e.prototype.notifyNext=function(t,e,i,n,r){this.complete()},e.prototype.notifyComplete=function(){},e}(r.OuterSubscriber)},MdjT:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"rVFa\"),s=i(\"NwwV\"),o=i(\"0p2S\");e.merge=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];var i=Number.POSITIVE_INFINITY,c=null,a=t[t.length-1];return s.isScheduler(a)?(c=t.pop(),t.length>1&&\"number\"==typeof t[t.length-1]&&(i=t.pop())):\"number\"==typeof a&&(i=t.pop()),null===c&&1===t.length&&t[0]instanceof n.Observable?t[0]:o.mergeAll(i)(new r.ArrayObservable(t,c))}},\"Mnf/\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"zZI/\"),s=i(\"AZf1\"),o=i(\"Re0n\"),c=function(t){function e(e,i){void 0===e&&(e=0),void 0===i&&(i=o.async),t.call(this),this.period=e,this.scheduler=i,(!r.isNumeric(e)||e<0)&&(this.period=0),i&&\"function\"==typeof i.schedule||(this.scheduler=o.async)}return n(e,t),e.create=function(t,i){return void 0===t&&(t=0),void 0===i&&(i=o.async),new e(t,i)},e.dispatch=function(t){var e=t.subscriber,i=t.period;e.next(t.index),e.closed||(t.index+=1,this.schedule(t,i))},e.prototype._subscribe=function(t){var i=this.period;t.add(this.scheduler.schedule(e.dispatch,i,{index:0,subscriber:t,period:i}))},e}(s.Observable);e.IntervalObservable=c},N6Zr:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"y2i3\"),s=i(\"zKHA\"),o=i(\"AJP0\"),c=i(\"9jZZ\"),a=i(\"Irel\");e.bufferWhen=function(t){return function(e){return e.lift(new u(t))}};var u=function(){function t(t){this.closingSelector=t}return t.prototype.call=function(t,e){return e.subscribe(new l(t,this.closingSelector))},t}(),l=function(t){function e(e,i){t.call(this,e),this.closingSelector=i,this.subscribing=!1,this.openBuffer()}return n(e,t),e.prototype._next=function(t){this.buffer.push(t)},e.prototype._complete=function(){var e=this.buffer;e&&this.destination.next(e),t.prototype._complete.call(this)},e.prototype._unsubscribe=function(){this.buffer=null,this.subscribing=!1},e.prototype.notifyNext=function(t,e,i,n,r){this.openBuffer()},e.prototype.notifyComplete=function(){this.subscribing?this.complete():this.openBuffer()},e.prototype.openBuffer=function(){var t=this.closingSubscription;t&&(this.remove(t),t.unsubscribe()),this.buffer&&this.destination.next(this.buffer),this.buffer=[];var e=s.tryCatch(this.closingSelector)();e===o.errorObject?this.error(o.errorObject.e):(t=new r.Subscription,this.closingSubscription=t,this.add(t),this.subscribing=!0,t.add(a.subscribeToResult(this,e)),this.subscribing=!1)},e}(c.OuterSubscriber)},NNAl:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(e,i){t.call(this),this.subject=e,this.subscriber=i,this.closed=!1}return n(e,t),e.prototype.unsubscribe=function(){if(!this.closed){this.closed=!0;var t=this.subject,e=t.observers;if(this.subject=null,e&&0!==e.length&&!t.isStopped&&!t.closed){var i=e.indexOf(this.subscriber);-1!==i&&e.splice(i,1)}}},e}(i(\"y2i3\").Subscription);e.SubjectSubscription=r},NeaI:function(t,e,i){\"use strict\";var n=i(\"o6MN\");e.throttle=function(t,e){return void 0===e&&(e=n.defaultThrottleConfig),n.throttle(t,e)(this)}},NwwV:function(t,e,i){\"use strict\";e.isScheduler=function(t){return t&&\"function\"==typeof t.schedule}},\"O/EN\":function(t,e,i){\"use strict\";var n=i(\"8G9e\"),r=i(\"cf1P\");e.publishLast=function(){return function(t){return r.multicast(new n.AsyncSubject)(t)}}},\"OMR/\":function(t,e,i){\"use strict\";var n=i(\"SWOv\");e.combineAll=function(t){return function(e){return e.lift(new n.CombineLatestOperator(t))}}},OVX6:function(t,e,i){\"use strict\";var n=i(\"ER9c\");e.every=function(t,e){return n.every(t,e)(this)}},OmKy:function(t,e,i){\"use strict\";var n=i(\"N6Zr\");e.bufferWhen=function(t){return n.bufferWhen(t)(this)}},Ontn:function(t,e,i){\"use strict\";var n=i(\"C8RJ\");e.retryWhen=function(t){return n.retryWhen(t)(this)}},OtNS:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"YJDk\");n.Observable.prototype.mapTo=r.mapTo},PCq3:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(){var e=t.call(this,\"object unsubscribed\");this.name=e.name=\"ObjectUnsubscribedError\",this.stack=e.stack,this.message=e.message}return n(e,t),e}(Error);e.ObjectUnsubscribedError=r},\"PFc+\":function(t,e,i){\"use strict\";e.isFunction=function(t){return\"function\"==typeof t}},Pg5x:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"01WU\");n.Observable.prototype.elementAt=r.elementAt},PqiM:function(t,e,i){\"use strict\";var n=i(\"WgKs\");e.skipUntil=function(t){return n.skipUntil(t)(this)}},PxRv:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"8kg7\");e.elementAt=function(t,e){return function(i){return i.lift(new o(t,e))}};var o=function(){function t(t,e){if(this.index=t,this.defaultValue=e,t<0)throw new s.ArgumentOutOfRangeError}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.index,this.defaultValue))},t}(),c=function(t){function e(e,i,n){t.call(this,e),this.index=i,this.defaultValue=n}return n(e,t),e.prototype._next=function(t){0==this.index--&&(this.destination.next(t),this.destination.complete())},e.prototype._complete=function(){var t=this.destination;this.index>=0&&(void 0!==this.defaultValue?t.next(this.defaultValue):t.error(new s.ArgumentOutOfRangeError)),t.complete()},e}(r.Subscriber)},Q0aF:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"uJFK\");n.Observable.prototype.max=r.max},Q6nm:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"y2i3\"),o=i(\"AZf1\"),c=i(\"4WIM\"),a=i(\"LWF9\"),u=i(\"Sbdl\");e.groupBy=function(t,e,i,n){return function(r){return r.lift(new l(t,e,i,n))}};var l=function(){function t(t,e,i,n){this.keySelector=t,this.elementSelector=e,this.durationSelector=i,this.subjectSelector=n}return t.prototype.call=function(t,e){return e.subscribe(new h(t,this.keySelector,this.elementSelector,this.durationSelector,this.subjectSelector))},t}(),h=function(t){function e(e,i,n,r,s){t.call(this,e),this.keySelector=i,this.elementSelector=n,this.durationSelector=r,this.subjectSelector=s,this.groups=null,this.attemptedToUnsubscribe=!1,this.count=0}return n(e,t),e.prototype._next=function(t){var e;try{e=this.keySelector(t)}catch(i){return void this.error(i)}this._group(t,e)},e.prototype._group=function(t,e){var i=this.groups;i||(i=this.groups=\"string\"==typeof e?new u.FastMap:new a.Map);var n,r=i.get(e);if(this.elementSelector)try{n=this.elementSelector(t)}catch(l){this.error(l)}else n=t;if(!r){r=this.subjectSelector?this.subjectSelector():new c.Subject,i.set(e,r);var s=new f(e,r,this);if(this.destination.next(s),this.durationSelector){var o=void 0;try{o=this.durationSelector(new f(e,r))}catch(l){return void this.error(l)}this.add(o.subscribe(new p(e,r,this)))}}r.closed||r.next(n)},e.prototype._error=function(t){var e=this.groups;e&&(e.forEach(function(e,i){e.error(t)}),e.clear()),this.destination.error(t)},e.prototype._complete=function(){var t=this.groups;t&&(t.forEach(function(t,e){t.complete()}),t.clear()),this.destination.complete()},e.prototype.removeGroup=function(t){this.groups.delete(t)},e.prototype.unsubscribe=function(){this.closed||(this.attemptedToUnsubscribe=!0,0===this.count&&t.prototype.unsubscribe.call(this))},e}(r.Subscriber),p=function(t){function e(e,i,n){t.call(this,i),this.key=e,this.group=i,this.parent=n}return n(e,t),e.prototype._next=function(t){this.complete()},e.prototype._unsubscribe=function(){var t=this.parent,e=this.key;this.key=this.parent=null,t&&t.removeGroup(e)},e}(r.Subscriber),f=function(t){function e(e,i,n){t.call(this),this.key=e,this.groupSubject=i,this.refCountSubscription=n}return n(e,t),e.prototype._subscribe=function(t){var e=new s.Subscription,i=this.refCountSubscription,n=this.groupSubject;return i&&!i.closed&&e.add(new d(i)),e.add(n.subscribe(t)),e},e}(o.Observable);e.GroupedObservable=f;var d=function(t){function e(e){t.call(this),this.parent=e,e.count++}return n(e,t),e.prototype.unsubscribe=function(){var e=this.parent;e.closed||this.closed||(t.prototype.unsubscribe.call(this),e.count-=1,0===e.count&&e.attemptedToUnsubscribe&&e.unsubscribe())},e}(s.Subscription)},QCDQ:function(t,e,i){\"use strict\";var n=i(\"0zyO\");e.observeOn=function(t,e){return void 0===e&&(e=0),n.observeOn(t,e)(this)}},QCIY:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"Re0n\"),s=i(\"hut+\"),o=i(\"1uGz\"),c=i(\"9x29\");e.delay=function(t,e){void 0===e&&(e=r.async);var i=s.isDate(t)?+t-e.now():Math.abs(t);return function(t){return t.lift(new a(i,e))}};var a=function(){function t(t,e){this.delay=t,this.scheduler=e}return t.prototype.call=function(t,e){return e.subscribe(new u(t,this.delay,this.scheduler))},t}(),u=function(t){function e(e,i,n){t.call(this,e),this.delay=i,this.scheduler=n,this.queue=[],this.active=!1,this.errored=!1}return n(e,t),e.dispatch=function(t){for(var e=t.source,i=e.queue,n=t.scheduler,r=t.destination;i.length>0&&i[0].time-n.now()<=0;)i.shift().notification.observe(r);if(i.length>0){var s=Math.max(0,i[0].time-n.now());this.schedule(t,s)}else this.unsubscribe(),e.active=!1},e.prototype._schedule=function(t){this.active=!0,this.add(t.schedule(e.dispatch,this.delay,{source:this,destination:this.destination,scheduler:t}))},e.prototype.scheduleNotification=function(t){if(!0!==this.errored){var e=this.scheduler,i=new l(e.now()+this.delay,t);this.queue.push(i),!1===this.active&&this._schedule(e)}},e.prototype._next=function(t){this.scheduleNotification(c.Notification.createNext(t))},e.prototype._error=function(t){this.errored=!0,this.queue=[],this.destination.error(t)},e.prototype._complete=function(){this.scheduleNotification(c.Notification.createComplete())},e}(o.Subscriber),l=function(){return function(t,e){this.time=t,this.notification=e}}()},QM1w:function(t,e,i){\"use strict\";e.letProto=function(t){return t(this)}},QY9E:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"nxYh\");n.Observable.prototype.bufferCount=r.bufferCount},QnAi:function(t,e,i){\"use strict\";e.applyMixins=function(t,e){for(var i=0,n=e.length;i<n;i++)for(var r=e[i],s=Object.getOwnPropertyNames(r.prototype),o=0,c=s.length;o<c;o++){var a=s[o];t.prototype[a]=r.prototype[a]}}},RGvf:function(t,e,i){\"use strict\";e.isPromise=function(t){return t&&\"function\"!=typeof t.subscribe&&\"function\"==typeof t.then}},RIQZ:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"ypDg\");n.Observable.prototype.timeout=r.timeout},\"RL+e\":function(t,e,i){\"use strict\";var n=i(\"DKXc\");e.find=function(t,e){return n.find(t,e)(this)}},RM7s:function(t,e,i){\"use strict\";var n=i(\"DFxj\");e.startWith=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return n.startWith.apply(void 0,t)(this)}},RYdh:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"zLeP\");n.Observable.prototype.skip=r.skip},Re0n:function(t,e,i){\"use strict\";var n=i(\"g2Fv\");e.async=new(i(\"FXL7\").AsyncScheduler)(n.AsyncAction)},RkF3:function(t,e,i){\"use strict\";var n=i(\"SWOv\");e.combineLatest=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return n.combineLatest.apply(void 0,t)(this)}},Rm1J:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"+fDQ\"),s=i(\"G2HO\"),o=i(\"9jZZ\"),c=i(\"Irel\");e.onErrorResumeNext=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return 1===t.length&&s.isArray(t[0])&&(t=t[0]),function(e){return e.lift(new a(t))}},e.onErrorResumeNextStatic=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];var i=null;return 1===t.length&&s.isArray(t[0])&&(t=t[0]),i=t.shift(),new r.FromObservable(i,null).lift(new a(t))};var a=function(){function t(t){this.nextSources=t}return t.prototype.call=function(t,e){return e.subscribe(new u(t,this.nextSources))},t}(),u=function(t){function e(e,i){t.call(this,e),this.destination=e,this.nextSources=i}return n(e,t),e.prototype.notifyError=function(t,e){this.subscribeToNextSource()},e.prototype.notifyComplete=function(t){this.subscribeToNextSource()},e.prototype._error=function(t){this.subscribeToNextSource()},e.prototype._complete=function(){this.subscribeToNextSource()},e.prototype.subscribeToNextSource=function(){var t=this.nextSources.shift();t?this.add(c.subscribeToResult(this,t)):this.destination.complete()},e}(o.OuterSubscriber)},S26M:function(t,e,i){\"use strict\";var n=i(\"CxhQ\");e._catch=function(t){return n.catchError(t)(this)}},SQLu:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"zKHA\"),s=i(\"AJP0\"),o=i(\"Irel\"),c=i(\"9jZZ\");e.mergeScan=function(t,e,i){return void 0===i&&(i=Number.POSITIVE_INFINITY),function(n){return n.lift(new a(t,e,i))}};var a=function(){function t(t,e,i){this.accumulator=t,this.seed=e,this.concurrent=i}return t.prototype.call=function(t,e){return e.subscribe(new u(t,this.accumulator,this.seed,this.concurrent))},t}();e.MergeScanOperator=a;var u=function(t){function e(e,i,n,r){t.call(this,e),this.accumulator=i,this.acc=n,this.concurrent=r,this.hasValue=!1,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}return n(e,t),e.prototype._next=function(t){if(this.active<this.concurrent){var e=this.index++,i=r.tryCatch(this.accumulator)(this.acc,t);i===s.errorObject?this.destination.error(s.errorObject.e):(this.active++,this._innerSub(i,t,e))}else this.buffer.push(t)},e.prototype._innerSub=function(t,e,i){this.add(o.subscribeToResult(this,t,e,i))},e.prototype._complete=function(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&(!1===this.hasValue&&this.destination.next(this.acc),this.destination.complete())},e.prototype.notifyNext=function(t,e,i,n,r){var s=this.destination;this.acc=e,this.hasValue=!0,s.next(e)},e.prototype.notifyComplete=function(t){var e=this.buffer;this.remove(t),this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&(!1===this.hasValue&&this.destination.next(this.acc),this.destination.complete())},e}(c.OuterSubscriber);e.MergeScanSubscriber=u},SWOv:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"rVFa\"),s=i(\"G2HO\"),o=i(\"9jZZ\"),c=i(\"Irel\"),a={};e.combineLatest=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];var i=null;return\"function\"==typeof t[t.length-1]&&(i=t.pop()),1===t.length&&s.isArray(t[0])&&(t=t[0].slice()),function(e){return e.lift.call(new r.ArrayObservable([e].concat(t)),new u(i))}};var u=function(){function t(t){this.project=t}return t.prototype.call=function(t,e){return e.subscribe(new l(t,this.project))},t}();e.CombineLatestOperator=u;var l=function(t){function e(e,i){t.call(this,e),this.project=i,this.active=0,this.values=[],this.observables=[]}return n(e,t),e.prototype._next=function(t){this.values.push(a),this.observables.push(t)},e.prototype._complete=function(){var t=this.observables,e=t.length;if(0===e)this.destination.complete();else{this.active=e,this.toRespond=e;for(var i=0;i<e;i++){var n=t[i];this.add(c.subscribeToResult(this,n,n,i))}}},e.prototype.notifyComplete=function(t){0==(this.active-=1)&&this.destination.complete()},e.prototype.notifyNext=function(t,e,i,n,r){var s=this.values,o=this.toRespond?s[i]===a?--this.toRespond:this.toRespond:0;s[i]=e,0===o&&(this.project?this._tryProject(s):this.destination.next(s.slice()))},e.prototype._tryProject=function(t){var e;try{e=this.project.apply(this,t)}catch(i){return void this.destination.error(i)}this.destination.next(e)},e}(o.OuterSubscriber);e.CombineLatestSubscriber=l},SX7S:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.skipWhile=function(t){return function(e){return e.lift(new s(t))}};var s=function(){function t(t){this.predicate=t}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.predicate))},t}(),o=function(t){function e(e,i){t.call(this,e),this.predicate=i,this.skipping=!0,this.index=0}return n(e,t),e.prototype._next=function(t){var e=this.destination;this.skipping&&this.tryCallPredicate(t),this.skipping||e.next(t)},e.prototype.tryCallPredicate=function(t){try{var e=this.predicate(t,this.index++);this.skipping=Boolean(e)}catch(i){this.destination.error(i)}},e}(r.Subscriber)},Sbdl:function(t,e,i){\"use strict\";e.FastMap=function(){function t(){this.values={}}return t.prototype.delete=function(t){return this.values[t]=null,!0},t.prototype.set=function(t,e){return this.values[t]=e,this},t.prototype.get=function(t){return this.values[t]},t.prototype.forEach=function(t,e){var i=this.values;for(var n in i)i.hasOwnProperty(n)&&null!==i[n]&&t.call(e,i[n],n)},t.prototype.clear=function(){this.values={}},t}()},Sevg:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"Etjs\");n.Observable.zip=r.zip},SfWB:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"AI1+\");n.Observable.webSocket=r.webSocket},T3D5:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"r9ib\");n.Observable.bindCallback=r.bindCallback},T3HJ:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"gRDe\"),o=function(t){function e(){t.call(this)}return n(e,t),e.create=function(){return new e},e.prototype._subscribe=function(t){s.noop()},e}(r.Observable);e.NeverObservable=o},Tb5M:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"gRDe\");e.ignoreElements=function(){return function(t){return t.lift(new o)}};var o=function(){function t(){}return t.prototype.call=function(t,e){return e.subscribe(new c(t))},t}(),c=function(t){function e(){t.apply(this,arguments)}return n(e,t),e.prototype._next=function(t){s.noop()},e}(r.Subscriber)},TiRI:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"y2i3\"),o=function(t){function e(e,i){t.call(this),this.messages=e,this.subscriptions=[],this.scheduler=i}return n(e,t),e.prototype._subscribe=function(e){var i=this,n=i.logSubscribedFrame();return e.add(new s.Subscription(function(){i.logUnsubscribedFrame(n)})),t.prototype._subscribe.call(this,e)},e.prototype.setup=function(){for(var t=this,e=t.messages.length,i=0;i<e;i++)!function(){var e=t.messages[i];t.scheduler.schedule(function(){e.notification.observe(t)},e.frame)}()},e}(r.Subject);e.HotObservable=o},TzlO:function(t,e,i){\"use strict\";var n=i(\"zL8T\");e.debounce=function(t){return n.debounce(t)(this)}},UCNy:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"2qLy\");n.Observable.prototype.takeUntil=r.takeUntil},UGt1:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"h8ds\");n.Observable.prototype.skipLast=r.skipLast},UUzK:function(t,e,i){\"use strict\";var n=i(\"G2HO\"),r=i(\"6VCA\");e.race=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return function(e){return 1===t.length&&n.isArray(t[0])&&(t=t[0]),e.lift.call(r.race.apply(void 0,[e].concat(t)))}}},Ui6c:function(t,e,i){\"use strict\";var n=i(\"+PC9\");e.repeat=function(t){return void 0===t&&(t=-1),n.repeat(t)(this)}},UqH8:function(t,e,i){\"use strict\";e.timer=i(\"YKi8\").TimerObservable.create},V9wX:function(t,e,i){\"use strict\";e.fromEvent=i(\"fQTG\").FromEventObservable.create},VIOb:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"onQ2\");n.Observable.prototype.exhaust=r.exhaust},VLEn:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"RM7s\");n.Observable.prototype.startWith=r.startWith},VVja:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.switchMap=function(t,e){return function(i){return i.lift(new o(t,e))}};var o=function(){function t(t,e){this.project=t,this.resultSelector=e}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.project,this.resultSelector))},t}(),c=function(t){function e(e,i,n){t.call(this,e),this.project=i,this.resultSelector=n,this.index=0}return n(e,t),e.prototype._next=function(t){var e,i=this.index++;try{e=this.project(t,i)}catch(n){return void this.destination.error(n)}this._innerSub(e,t,i)},e.prototype._innerSub=function(t,e,i){var n=this.innerSubscription;n&&n.unsubscribe(),this.add(this.innerSubscription=s.subscribeToResult(this,t,e,i))},e.prototype._complete=function(){var e=this.innerSubscription;e&&!e.closed||t.prototype._complete.call(this)},e.prototype._unsubscribe=function(){this.innerSubscription=null},e.prototype.notifyComplete=function(e){this.remove(e),this.innerSubscription=null,this.isStopped&&t.prototype._complete.call(this)},e.prototype.notifyNext=function(t,e,i,n,r){this.resultSelector?this._tryNotifyNext(t,e,i,n):this.destination.next(e)},e.prototype._tryNotifyNext=function(t,e,i,n){var r;try{r=this.resultSelector(t,e,i,n)}catch(s){return void this.destination.error(s)}this.destination.next(r)},e}(r.OuterSubscriber)},VZMG:function(t,e,i){\"use strict\";var n=i(\"8qff\");e.queue=new(i(\"X46/\").QueueScheduler)(n.QueueAction)},Vmj7:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"NwwV\"),s=i(\"wELj\");e.bufferTime=function(t){var e=arguments.length,i=n.async;r.isScheduler(arguments[arguments.length-1])&&(i=arguments[arguments.length-1],e--);var o=null;e>=2&&(o=arguments[1]);var c=Number.POSITIVE_INFINITY;return e>=3&&(c=arguments[2]),s.bufferTime(t,o,c,i)(this)}},Vo3M:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"9pdx\");n.Observable.prototype.dematerialize=r.dematerialize},Vrlg:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"27EW\");n.Observable.prototype.switchMapTo=r.switchMapTo},VthU:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.switchMapTo=function(t,e){return function(i){return i.lift(new o(t,e))}};var o=function(){function t(t,e){this.observable=t,this.resultSelector=e}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.observable,this.resultSelector))},t}(),c=function(t){function e(e,i,n){t.call(this,e),this.inner=i,this.resultSelector=n,this.index=0}return n(e,t),e.prototype._next=function(t){var e=this.innerSubscription;e&&e.unsubscribe(),this.add(this.innerSubscription=s.subscribeToResult(this,this.inner,t,this.index++))},e.prototype._complete=function(){var e=this.innerSubscription;e&&!e.closed||t.prototype._complete.call(this)},e.prototype._unsubscribe=function(){this.innerSubscription=null},e.prototype.notifyComplete=function(e){this.remove(e),this.innerSubscription=null,this.isStopped&&t.prototype._complete.call(this)},e.prototype.notifyNext=function(t,e,i,n,r){var s=this.destination;this.resultSelector?this.tryResultSelector(t,e,i,n):s.next(e)},e.prototype.tryResultSelector=function(t,e,i,n){var r,s=this.resultSelector,o=this.destination;try{r=s(t,e,i,n)}catch(c){return void o.error(c)}o.next(r)},e}(r.OuterSubscriber)},\"WC+f\":function(t,e,i){\"use strict\";var n=i(\"6oB3\");e.concatStatic=i(\"6oB3\").concat,e.concat=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return function(e){return e.lift.call(n.concat.apply(void 0,[e].concat(t)))}}},WO4J:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"8kg7\"),o=i(\"36rE\");e.takeLast=function(t){return function(e){return 0===t?new o.EmptyObservable:e.lift(new c(t))}};var c=function(){function t(t){if(this.total=t,this.total<0)throw new s.ArgumentOutOfRangeError}return t.prototype.call=function(t,e){return e.subscribe(new a(t,this.total))},t}(),a=function(t){function e(e,i){t.call(this,e),this.total=i,this.ring=new Array,this.count=0}return n(e,t),e.prototype._next=function(t){var e=this.ring,i=this.total,n=this.count++;e.length<i?e.push(t):e[n%i]=t},e.prototype._complete=function(){var t=this.destination,e=this.count;if(e>0)for(var i=this.count>=this.total?this.total:this.count,n=this.ring,r=0;r<i;r++){var s=e++%i;t.next(n[s])}t.complete()},e}(r.Subscriber)},WQoq:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.sample=function(t){return function(e){return e.lift(new o(t))}};var o=function(){function t(t){this.notifier=t}return t.prototype.call=function(t,e){var i=new c(t),n=e.subscribe(i);return n.add(s.subscribeToResult(i,this.notifier)),n},t}(),c=function(t){function e(){t.apply(this,arguments),this.hasValue=!1}return n(e,t),e.prototype._next=function(t){this.value=t,this.hasValue=!0},e.prototype.notifyNext=function(t,e,i,n,r){this.emitValue()},e.prototype.notifyComplete=function(){this.emitValue()},e.prototype.emitValue=function(){this.hasValue&&(this.hasValue=!1,this.destination.next(this.value))},e}(r.OuterSubscriber)},WU5C:function(t,e,i){\"use strict\";var n=i(\"/WK6\");function r(t){var e,i=t.Symbol;return\"function\"==typeof i?i.observable?e=i.observable:(e=i(\"observable\"),i.observable=e):e=\"@@observable\",e}e.getSymbolObservable=r,e.observable=r(n.root),e.$$observable=e.observable},WesY:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"g2Fv\"),s=i(\"Zn6/\"),o=function(t){function e(e,i){t.call(this,e,i),this.scheduler=e,this.work=i}return n(e,t),e.prototype.requestAsyncId=function(e,i,n){return void 0===n&&(n=0),null!==n&&n>0?t.prototype.requestAsyncId.call(this,e,i,n):(e.actions.push(this),e.scheduled||(e.scheduled=s.AnimationFrame.requestAnimationFrame(e.flush.bind(e,null))))},e.prototype.recycleAsyncId=function(e,i,n){if(void 0===n&&(n=0),null!==n&&n>0||null===n&&this.delay>0)return t.prototype.recycleAsyncId.call(this,e,i,n);0===e.actions.length&&(s.AnimationFrame.cancelAnimationFrame(i),e.scheduled=void 0)},e}(r.AsyncAction);e.AnimationFrameAction=o},WgKs:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.skipUntil=function(t){return function(e){return e.lift(new o(t))}};var o=function(){function t(t){this.notifier=t}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.notifier))},t}(),c=function(t){function e(e,i){t.call(this,e),this.hasValue=!1,this.isInnerStopped=!1,this.add(s.subscribeToResult(this,i))}return n(e,t),e.prototype._next=function(e){this.hasValue&&t.prototype._next.call(this,e)},e.prototype._complete=function(){this.isInnerStopped?t.prototype._complete.call(this):this.unsubscribe()},e.prototype.notifyNext=function(t,e,i,n,r){this.hasValue=!0},e.prototype.notifyComplete=function(){this.isInnerStopped=!0,this.isStopped&&t.prototype._complete.call(this)},e}(r.OuterSubscriber)},Wv9J:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"zMOc\");n.Observable.prototype.single=r.single},\"X/dC\":function(t,e,i){\"use strict\";var n=i(\"cf1P\"),r=i(\"pk/4\"),s=i(\"4WIM\");function o(){return new s.Subject}e.share=function(){return function(t){return r.refCount()(n.multicast(o)(t))}}},\"X46/\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(){t.apply(this,arguments)}return n(e,t),e}(i(\"FXL7\").AsyncScheduler);e.QueueScheduler=r},X7Im:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"o6MN\"),s=i(\"BnoD\");e.throttleTime=function(t,e,i){return void 0===e&&(e=n.async),void 0===i&&(i=r.defaultThrottleConfig),s.throttleTime(t,e,i)(this)}},XMAI:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"I+lI\");n.Observable.prototype.windowCount=r.windowCount},XNQH:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.isEmpty=function(){return function(t){return t.lift(new s)}};var s=function(){function t(){}return t.prototype.call=function(t,e){return e.subscribe(new o(t))},t}(),o=function(t){function e(e){t.call(this,e)}return n(e,t),e.prototype.notifyComplete=function(t){var e=this.destination;e.next(t),e.complete()},e.prototype._next=function(t){this.notifyComplete(!1)},e.prototype._complete=function(){this.notifyComplete(!0)},e}(r.Subscriber)},Xn12:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"MdjT\");n.Observable.merge=r.merge},Xrsd:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"2fIB\");e.single=function(t){return function(e){return e.lift(new o(t,e))}};var o=function(){function t(t,e){this.predicate=t,this.source=e}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.predicate,this.source))},t}(),c=function(t){function e(e,i,n){t.call(this,e),this.predicate=i,this.source=n,this.seenValue=!1,this.index=0}return n(e,t),e.prototype.applySingleValue=function(t){this.seenValue?this.destination.error(\"Sequence contains more than one element\"):(this.seenValue=!0,this.singleValue=t)},e.prototype._next=function(t){var e=this.index++;this.predicate?this.tryNext(t,e):this.applySingleValue(t)},e.prototype.tryNext=function(t,e){try{this.predicate(t,e,this.source)&&this.applySingleValue(t)}catch(i){this.destination.error(i)}},e.prototype._complete=function(){var t=this.destination;this.index>0?(t.next(this.seenValue?this.singleValue:void 0),t.complete()):t.error(new s.EmptyError)},e}(r.Subscriber)},XzFz:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"fTxW\");n.Observable.prototype.zipAll=r.zipAll},Y4yW:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"d+Tj\");n.Observable.prototype.audit=r.audit},YJDk:function(t,e,i){\"use strict\";var n=i(\"saxw\");e.mapTo=function(t){return n.mapTo(t)(this)}},YKi8:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"zZI/\"),s=i(\"AZf1\"),o=i(\"Re0n\"),c=i(\"NwwV\"),a=i(\"hut+\"),u=function(t){function e(e,i,n){void 0===e&&(e=0),t.call(this),this.period=-1,this.dueTime=0,r.isNumeric(i)?this.period=Number(i)<1?1:Number(i):c.isScheduler(i)&&(n=i),c.isScheduler(n)||(n=o.async),this.scheduler=n,this.dueTime=a.isDate(e)?+e-this.scheduler.now():e}return n(e,t),e.create=function(t,i,n){return void 0===t&&(t=0),new e(t,i,n)},e.dispatch=function(t){var e=t.index,i=t.period,n=t.subscriber;if(n.next(e),!n.closed){if(-1===i)return n.complete();t.index=e+1,this.schedule(t,i)}},e.prototype._subscribe=function(t){var i=this;return i.scheduler.schedule(e.dispatch,i.dueTime,{index:0,period:i.period,subscriber:t})},e}(s.Observable);e.TimerObservable=u},Yjb7:function(t,e,i){\"use strict\";var n=i(\"NwwV\"),r=i(\"G2HO\"),s=i(\"rVFa\"),o=i(\"SWOv\");e.combineLatest=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];var i=null,c=null;return n.isScheduler(t[t.length-1])&&(c=t.pop()),\"function\"==typeof t[t.length-1]&&(i=t.pop()),1===t.length&&r.isArray(t[0])&&(t=t[0]),new s.ArrayObservable(t,c).lift(new o.CombineLatestOperator(i))}},Z57B:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"aK2G\");e.timestamp=function(t){return void 0===t&&(t=n.async),r.map(function(e){return new s(e,t.now())})};var s=function(){return function(t,e){this.value=t,this.timestamp=e}}();e.Timestamp=s},ZCeS:function(t,e,i){\"use strict\";e.Scheduler=function(){function t(e,i){void 0===i&&(i=t.now),this.SchedulerAction=e,this.now=i}return t.prototype.schedule=function(t,e,i){return void 0===e&&(e=0),new this.SchedulerAction(this,t).schedule(i,e)},t.now=Date.now?Date.now:function(){return+new Date},t}()},ZTY5:function(t,e,i){\"use strict\";var n=i(\"M6BU\");e.toArray=function(){return n.toArray()(this)}},ZXB4:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.filter=function(t,e){return function(i){return i.lift(new s(t,e))}};var s=function(){function t(t,e){this.predicate=t,this.thisArg=e}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.predicate,this.thisArg))},t}(),o=function(t){function e(e,i,n){t.call(this,e),this.predicate=i,this.thisArg=n,this.count=0}return n(e,t),e.prototype._next=function(t){var e;try{e=this.predicate.call(this.thisArg,t,this.count++)}catch(i){return void this.destination.error(i)}e&&this.destination.next(t)},e}(r.Subscriber)},\"Zn6/\":function(t,e,i){\"use strict\";var n=i(\"/WK6\"),r=function(){return function(t){t.requestAnimationFrame?(this.cancelAnimationFrame=t.cancelAnimationFrame.bind(t),this.requestAnimationFrame=t.requestAnimationFrame.bind(t)):t.mozRequestAnimationFrame?(this.cancelAnimationFrame=t.mozCancelAnimationFrame.bind(t),this.requestAnimationFrame=t.mozRequestAnimationFrame.bind(t)):t.webkitRequestAnimationFrame?(this.cancelAnimationFrame=t.webkitCancelAnimationFrame.bind(t),this.requestAnimationFrame=t.webkitRequestAnimationFrame.bind(t)):t.msRequestAnimationFrame?(this.cancelAnimationFrame=t.msCancelAnimationFrame.bind(t),this.requestAnimationFrame=t.msRequestAnimationFrame.bind(t)):t.oRequestAnimationFrame?(this.cancelAnimationFrame=t.oCancelAnimationFrame.bind(t),this.requestAnimationFrame=t.oRequestAnimationFrame.bind(t)):(this.cancelAnimationFrame=t.clearTimeout.bind(t),this.requestAnimationFrame=function(e){return t.setTimeout(e,1e3/60)})}}();e.RequestAnimationFrameDefinition=r,e.AnimationFrame=new r(n.root)},ZnfZ:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"9x29\"),o=i(\"/AUE\"),c=i(\"TiRI\"),a=i(\"5TWj\"),u=i(\"J9JT\"),l=function(t){function e(e){t.call(this,u.VirtualAction,750),this.assertDeepEqual=e,this.hotObservables=[],this.coldObservables=[],this.flushTests=[]}return n(e,t),e.prototype.createTime=function(t){var i=t.indexOf(\"|\");if(-1===i)throw new Error('marble diagram for time should have a completion marker \"|\"');return i*e.frameTimeFactor},e.prototype.createColdObservable=function(t,i,n){if(-1!==t.indexOf(\"^\"))throw new Error('cold observable cannot have subscription offset \"^\"');if(-1!==t.indexOf(\"!\"))throw new Error('cold observable cannot have unsubscription marker \"!\"');var r=e.parseMarbles(t,i,n),s=new o.ColdObservable(r,this);return this.coldObservables.push(s),s},e.prototype.createHotObservable=function(t,i,n){if(-1!==t.indexOf(\"!\"))throw new Error('hot observable cannot have unsubscription marker \"!\"');var r=e.parseMarbles(t,i,n),s=new c.HotObservable(r,this);return this.hotObservables.push(s),s},e.prototype.materializeInnerObservable=function(t,e){var i=this,n=[];return t.subscribe(function(t){n.push({frame:i.frame-e,notification:s.Notification.createNext(t)})},function(t){n.push({frame:i.frame-e,notification:s.Notification.createError(t)})},function(){n.push({frame:i.frame-e,notification:s.Notification.createComplete()})}),n},e.prototype.expectObservable=function(t,i){var n=this;void 0===i&&(i=null);var o,c=[],a={actual:c,ready:!1},u=e.parseMarblesAsSubscriptions(i).unsubscribedFrame;return this.schedule(function(){o=t.subscribe(function(t){var e=t;t instanceof r.Observable&&(e=n.materializeInnerObservable(e,n.frame)),c.push({frame:n.frame,notification:s.Notification.createNext(e)})},function(t){c.push({frame:n.frame,notification:s.Notification.createError(t)})},function(){c.push({frame:n.frame,notification:s.Notification.createComplete()})})},0),u!==Number.POSITIVE_INFINITY&&this.schedule(function(){return o.unsubscribe()},u),this.flushTests.push(a),{toBe:function(t,i,n){a.ready=!0,a.expected=e.parseMarbles(t,i,n,!0)}}},e.prototype.expectSubscriptions=function(t){var i={actual:t,ready:!1};return this.flushTests.push(i),{toBe:function(t){var n=\"string\"==typeof t?[t]:t;i.ready=!0,i.expected=n.map(function(t){return e.parseMarblesAsSubscriptions(t)})}}},e.prototype.flush=function(){for(var e=this.hotObservables;e.length>0;)e.shift().setup();t.prototype.flush.call(this);for(var i=this.flushTests.filter(function(t){return t.ready});i.length>0;){var n=i.shift();this.assertDeepEqual(n.actual,n.expected)}},e.parseMarblesAsSubscriptions=function(t){if(\"string\"!=typeof t)return new a.SubscriptionLog(Number.POSITIVE_INFINITY);for(var e=t.length,i=-1,n=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY,s=0;s<e;s++){var o=s*this.frameTimeFactor,c=t[s];switch(c){case\"-\":case\" \":break;case\"(\":i=o;break;case\")\":i=-1;break;case\"^\":if(n!==Number.POSITIVE_INFINITY)throw new Error(\"found a second subscription point '^' in a subscription marble diagram. There can only be one.\");n=i>-1?i:o;break;case\"!\":if(r!==Number.POSITIVE_INFINITY)throw new Error(\"found a second subscription point '^' in a subscription marble diagram. There can only be one.\");r=i>-1?i:o;break;default:throw new Error(\"there can only be '^' and '!' markers in a subscription marble diagram. Found instead '\"+c+\"'.\")}}return r<0?new a.SubscriptionLog(n):new a.SubscriptionLog(n,r)},e.parseMarbles=function(t,e,i,n){if(void 0===n&&(n=!1),-1!==t.indexOf(\"!\"))throw new Error('conventional marble diagrams cannot have the unsubscription marker \"!\"');for(var r=t.length,c=[],a=t.indexOf(\"^\"),u=-1===a?0:a*-this.frameTimeFactor,l=\"object\"!=typeof e?function(t){return t}:function(t){return n&&e[t]instanceof o.ColdObservable?e[t].messages:e[t]},h=-1,p=0;p<r;p++){var f=p*this.frameTimeFactor+u,d=void 0,b=t[p];switch(b){case\"-\":case\" \":break;case\"(\":h=f;break;case\")\":h=-1;break;case\"|\":d=s.Notification.createComplete();break;case\"^\":break;case\"#\":d=s.Notification.createError(i||\"error\");break;default:d=s.Notification.createNext(l(b))}d&&c.push({frame:h>-1?h:f,notification:d})}return c},e}(u.VirtualTimeScheduler);e.TestScheduler=l},\"Zo/K\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)};function r(t){var e=t.index,i=t.subscriber;if(e!==t.length){var n=t.keys[e];i.next([n,t.obj[n]]),t.index=e+1,this.schedule(t)}else i.complete()}var s=function(t){function e(e,i){t.call(this),this.obj=e,this.scheduler=i,this.keys=Object.keys(e)}return n(e,t),e.create=function(t,i){return new e(t,i)},e.prototype._subscribe=function(t){var e=this.keys,i=this.scheduler,n=e.length;if(i)return i.schedule(r,0,{obj:this.obj,keys:e,length:n,index:0,subscriber:t});for(var s=0;s<n;s++){var o=e[s];t.next([o,this.obj[o]])}t.complete()},e}(i(\"AZf1\").Observable);e.PairsObservable=s},ZzdT:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"OmKy\");n.Observable.prototype.bufferWhen=r.bufferWhen},aK2G:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.map=function(t,e){return function(i){if(\"function\"!=typeof t)throw new TypeError(\"argument is not a function. Are you looking for `mapTo()`?\");return i.lift(new s(t,e))}};var s=function(){function t(t,e){this.project=t,this.thisArg=e}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.project,this.thisArg))},t}();e.MapOperator=s;var o=function(t){function e(e,i,n){t.call(this,e),this.project=i,this.count=0,this.thisArg=n||this}return n(e,t),e.prototype._next=function(t){var e;try{e=this.project.call(this.thisArg,t,this.count++)}catch(i){return void this.destination.error(i)}this.destination.next(e)},e}(r.Subscriber)},aUw6:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"GHBr\");n.Observable.throw=r._throw},aea6:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"7LGj\");e.sampleTime=function(t,e){return void 0===e&&(e=n.async),r.sampleTime(t,e)(this)}},agdi:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"uj+q\");e.timeoutWith=function(t,e,i){return void 0===i&&(i=n.async),r.timeoutWith(t,e,i)(this)}},ast0:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"4WIM\");e.windowCount=function(t,e){return void 0===e&&(e=0),function(i){return i.lift(new o(t,e))}};var o=function(){function t(t,e){this.windowSize=t,this.startWindowEvery=e}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.windowSize,this.startWindowEvery))},t}(),c=function(t){function e(e,i,n){t.call(this,e),this.destination=e,this.windowSize=i,this.startWindowEvery=n,this.windows=[new s.Subject],this.count=0,e.next(this.windows[0])}return n(e,t),e.prototype._next=function(t){for(var e=this.startWindowEvery>0?this.startWindowEvery:this.windowSize,i=this.destination,n=this.windowSize,r=this.windows,o=r.length,c=0;c<o&&!this.closed;c++)r[c].next(t);var a=this.count-n+1;if(a>=0&&a%e==0&&!this.closed&&r.shift().complete(),++this.count%e==0&&!this.closed){var u=new s.Subject;r.push(u),i.next(u)}},e.prototype._error=function(t){var e=this.windows;if(e)for(;e.length>0&&!this.closed;)e.shift().error(t);this.destination.error(t)},e.prototype._complete=function(){var t=this.windows;if(t)for(;t.length>0&&!this.closed;)t.shift().complete();this.destination.complete()},e.prototype._unsubscribe=function(){this.count=0,this.windows=null},e}(r.Subscriber)},b4nC:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"uH8Z\");n.Observable.prototype.timestamp=r.timestamp},bIKf:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"Hbpk\"),s=function(t){function e(e,i){t.call(this,e,i),this.scheduler=e,this.work=i}return n(e,t),e.prototype.requestAsyncId=function(e,i,n){return void 0===n&&(n=0),null!==n&&n>0?t.prototype.requestAsyncId.call(this,e,i,n):(e.actions.push(this),e.scheduled||(e.scheduled=r.Immediate.setImmediate(e.flush.bind(e,null))))},e.prototype.recycleAsyncId=function(e,i,n){if(void 0===n&&(n=0),null!==n&&n>0||null===n&&this.delay>0)return t.prototype.recycleAsyncId.call(this,e,i,n);0===e.actions.length&&(r.Immediate.clearImmediate(i),e.scheduled=void 0)},e}(i(\"g2Fv\").AsyncAction);e.AsapAction=s},bZxC:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"7W5b\");n.Observable.prototype.mergeMap=r.mergeMap,n.Observable.prototype.flatMap=r.mergeMap},bq7C:function(t,e,i){\"use strict\";e.not=function(t,e){function i(){return!i.pred.apply(i.thisArg,arguments)}return i.pred=t,i.thisArg=e,i}},\"c/6p\":function(t,e,i){\"use strict\";var n=i(\"cf1P\");e.multicast=function(t,e){return n.multicast(t,e)(this)}},c4YM:function(t,e,i){\"use strict\";var n=i(\"rgOj\");e.distinctUntilKeyChanged=function(t,e){return n.distinctUntilChanged(function(i,n){return e?e(i[t],n[t]):i[t]===n[t]})}},cIDA:function(t,e,i){\"use strict\";e.fromEventPattern=i(\"fImS\").FromEventPatternObservable.create},cP0Y:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"svOU\");n.Observable.prototype.windowTime=r.windowTime},cUCP:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"mdQD\"),s=i(\"UqH8\");e.auditTime=function(t,e){return void 0===e&&(e=n.async),r.audit(function(){return s.timer(t,e)})}},cWud:function(t,e,i){\"use strict\";var n=i(\"+djB\");e.windowWhen=function(t){return n.windowWhen(t)(this)}},cdxN:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"Lj2B\");n.Observable.prototype.switch=r._switch,n.Observable.prototype._switch=r._switch},cf1P:function(t,e,i){\"use strict\";var n=i(\"3VCA\");e.multicast=function(t,e){return function(i){var s;if(s=\"function\"==typeof t?t:function(){return t},\"function\"==typeof e)return i.lift(new r(s,e));var o=Object.create(i,n.connectableObservableDescriptor);return o.source=i,o.subjectFactory=s,o}};var r=function(){function t(t,e){this.subjectFactory=t,this.selector=e}return t.prototype.call=function(t,e){var i=this.selector,n=this.subjectFactory(),r=i(n).subscribe(t);return r.add(e.subscribe(n)),r},t}();e.MulticastOperator=r},codN:function(t,e,i){\"use strict\";e.bindNodeCallback=i(\"3zH1\").BoundNodeCallbackObservable.create},czP3:function(t,e,i){\"use strict\";var n=i(\"aK2G\");function r(t,e){return function(i){for(var n=i,r=0;r<e;r++){var s=n[t[r]];if(void 0===s)return;n=s}return n}}e.pluck=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];var i=t.length;if(0===i)throw new Error(\"list of properties cannot be empty.\");return function(e){return n.map(r(t,i))(e)}}},\"d+Tj\":function(t,e,i){\"use strict\";var n=i(\"mdQD\");e.audit=function(t){return n.audit(t)(this)}},dAHb:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"hw8L\");n.Observable.prototype.exhaustMap=r.exhaustMap},dxsx:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"qJ4/\");n.Observable.prototype.publishReplay=r.publishReplay},\"e7/H\":function(t,e,i){\"use strict\";var n=i(\"DxGp\");e.subscribeOn=function(t,e){return void 0===e&&(e=0),n.subscribeOn(t,e)(this)}},e7R1:function(t,e,i){\"use strict\";var n=i(\"0p2S\");e.mergeAll=function(t){return void 0===t&&(t=Number.POSITIVE_INFINITY),n.mergeAll(t)(this)}},eBTF:function(t,e,i){\"use strict\";var n=i(\"/WK6\");function r(){return function(){function t(){this._values=[]}return t.prototype.add=function(t){this.has(t)||this._values.push(t)},t.prototype.has=function(t){return-1!==this._values.indexOf(t)},Object.defineProperty(t.prototype,\"size\",{get:function(){return this._values.length},enumerable:!0,configurable:!0}),t.prototype.clear=function(){this._values.length=0},t}()}e.minimalSetImpl=r,e.Set=n.root.Set||r()},eeyt:function(t,e,i){\"use strict\";var n=i(\"qN2p\");e.findIndex=function(t,e){return n.findIndex(t,e)(this)}},f0q5:function(t,e,i){\"use strict\";e.audit=i(\"mdQD\").audit,e.auditTime=i(\"cUCP\").auditTime,e.buffer=i(\"zobD\").buffer,e.bufferCount=i(\"16yF\").bufferCount,e.bufferTime=i(\"wELj\").bufferTime,e.bufferToggle=i(\"re5B\").bufferToggle,e.bufferWhen=i(\"N6Zr\").bufferWhen,e.catchError=i(\"CxhQ\").catchError,e.combineAll=i(\"OMR/\").combineAll,e.combineLatest=i(\"SWOv\").combineLatest,e.concat=i(\"WC+f\").concat,e.concatAll=i(\"A0iX\").concatAll,e.concatMap=i(\"+WiC\").concatMap,e.concatMapTo=i(\"zVww\").concatMapTo,e.count=i(\"iYe0\").count,e.debounce=i(\"zL8T\").debounce,e.debounceTime=i(\"AzqM\").debounceTime,e.defaultIfEmpty=i(\"2Tbn\").defaultIfEmpty,e.delay=i(\"QCIY\").delay,e.delayWhen=i(\"4GoQ\").delayWhen,e.dematerialize=i(\"mO1z\").dematerialize,e.distinct=i(\"nQov\").distinct,e.distinctUntilChanged=i(\"rgOj\").distinctUntilChanged,e.distinctUntilKeyChanged=i(\"c4YM\").distinctUntilKeyChanged,e.elementAt=i(\"PxRv\").elementAt,e.every=i(\"ER9c\").every,e.exhaust=i(\"H0zL\").exhaust,e.exhaustMap=i(\"GEfX\").exhaustMap,e.expand=i(\"we3k\").expand,e.filter=i(\"ZXB4\").filter,e.finalize=i(\"q9sB\").finalize,e.find=i(\"DKXc\").find,e.findIndex=i(\"qN2p\").findIndex,e.first=i(\"L/jt\").first,e.groupBy=i(\"Q6nm\").groupBy,e.ignoreElements=i(\"Tb5M\").ignoreElements,e.isEmpty=i(\"XNQH\").isEmpty,e.last=i(\"ffiR\").last,e.map=i(\"aK2G\").map,e.mapTo=i(\"saxw\").mapTo,e.materialize=i(\"oGc9\").materialize,e.max=i(\"5aaB\").max,e.merge=i(\"LqmK\").merge,e.mergeAll=i(\"0p2S\").mergeAll,e.mergeMap=i(\"lf2g\").mergeMap,e.flatMap=i(\"lf2g\").mergeMap,e.mergeMapTo=i(\"fEEN\").mergeMapTo,e.mergeScan=i(\"SQLu\").mergeScan,e.min=i(\"Kc9Z\").min,e.multicast=i(\"cf1P\").multicast,e.observeOn=i(\"0zyO\").observeOn,e.onErrorResumeNext=i(\"Rm1J\").onErrorResumeNext,e.pairwise=i(\"ABAE\").pairwise,e.partition=i(\"gSfb\").partition,e.pluck=i(\"czP3\").pluck,e.publish=i(\"gcf/\").publish,e.publishBehavior=i(\"7f6I\").publishBehavior,e.publishLast=i(\"O/EN\").publishLast,e.publishReplay=i(\"f947\").publishReplay,e.race=i(\"UUzK\").race,e.reduce=i(\"6fvh\").reduce,e.repeat=i(\"+PC9\").repeat,e.repeatWhen=i(\"0j0j\").repeatWhen,e.retry=i(\"7c4m\").retry,e.retryWhen=i(\"C8RJ\").retryWhen,e.refCount=i(\"pk/4\").refCount,e.sample=i(\"WQoq\").sample,e.sampleTime=i(\"7LGj\").sampleTime,e.scan=i(\"n8Qg\").scan,e.sequenceEqual=i(\"3Ind\").sequenceEqual,e.share=i(\"X/dC\").share,e.shareReplay=i(\"0Qin\").shareReplay,e.single=i(\"Xrsd\").single,e.skip=i(\"1DV/\").skip,e.skipLast=i(\"7Nkz\").skipLast,e.skipUntil=i(\"WgKs\").skipUntil,e.skipWhile=i(\"SX7S\").skipWhile,e.startWith=i(\"DFxj\").startWith,e.switchAll=i(\"hY8S\").switchAll,e.switchMap=i(\"VVja\").switchMap,e.switchMapTo=i(\"VthU\").switchMapTo,e.take=i(\"3hIw\").take,e.takeLast=i(\"WO4J\").takeLast,e.takeUntil=i(\"MHPA\").takeUntil,e.takeWhile=i(\"3jsl\").takeWhile,e.tap=i(\"Kqb3\").tap,e.throttle=i(\"o6MN\").throttle,e.throttleTime=i(\"BnoD\").throttleTime,e.timeInterval=i(\"BTim\").timeInterval,e.timeout=i(\"9BwH\").timeout,e.timeoutWith=i(\"uj+q\").timeoutWith,e.timestamp=i(\"Z57B\").timestamp,e.toArray=i(\"M6BU\").toArray,e.window=i(\"0Iwa\").window,e.windowCount=i(\"ast0\").windowCount,e.windowTime=i(\"3WZS\").windowTime,e.windowToggle=i(\"8pnh\").windowToggle,e.windowWhen=i(\"+djB\").windowWhen,e.withLatestFrom=i(\"2Wg+\").withLatestFrom,e.zip=i(\"oQYR\").zip,e.zipAll=i(\"FBtj\").zipAll},f947:function(t,e,i){\"use strict\";var n=i(\"BjeI\"),r=i(\"cf1P\");e.publishReplay=function(t,e,i,s){i&&\"function\"!=typeof i&&(s=i);var o=\"function\"==typeof i?i:void 0,c=new n.ReplaySubject(t,e,s);return function(t){return r.multicast(function(){return c},o)(t)}}},fEEN:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.mergeMapTo=function(t,e,i){return void 0===i&&(i=Number.POSITIVE_INFINITY),\"number\"==typeof e&&(i=e,e=null),function(n){return n.lift(new o(t,e,i))}};var o=function(){function t(t,e,i){void 0===i&&(i=Number.POSITIVE_INFINITY),this.ish=t,this.resultSelector=e,this.concurrent=i}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.ish,this.resultSelector,this.concurrent))},t}();e.MergeMapToOperator=o;var c=function(t){function e(e,i,n,r){void 0===r&&(r=Number.POSITIVE_INFINITY),t.call(this,e),this.ish=i,this.resultSelector=n,this.concurrent=r,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}return n(e,t),e.prototype._next=function(t){if(this.active<this.concurrent){var e=this.resultSelector,i=this.index++,n=this.ish,r=this.destination;this.active++,this._innerSub(n,r,e,t,i)}else this.buffer.push(t)},e.prototype._innerSub=function(t,e,i,n,r){this.add(s.subscribeToResult(this,t,n,r))},e.prototype._complete=function(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete()},e.prototype.notifyNext=function(t,e,i,n,r){var s=this.destination;this.resultSelector?this.trySelectResult(t,e,i,n):s.next(e)},e.prototype.trySelectResult=function(t,e,i,n){var r,s=this.resultSelector,o=this.destination;try{r=s(t,e,i,n)}catch(c){return void o.error(c)}o.next(r)},e.prototype.notifyError=function(t){this.destination.error(t)},e.prototype.notifyComplete=function(t){var e=this.buffer;this.remove(t),this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()},e}(r.OuterSubscriber);e.MergeMapToSubscriber=c},fImS:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"PFc+\"),s=i(\"AZf1\"),o=i(\"y2i3\"),c=function(t){function e(e,i,n){t.call(this),this.addHandler=e,this.removeHandler=i,this.selector=n}return n(e,t),e.create=function(t,i,n){return new e(t,i,n)},e.prototype._subscribe=function(t){var e=this,i=this.removeHandler,n=this.selector?function(){for(var i=[],n=0;n<arguments.length;n++)i[n-0]=arguments[n];e._callSelector(t,i)}:function(e){t.next(e)},s=this._callAddHandler(n,t);r.isFunction(i)&&t.add(new o.Subscription(function(){i(n,s)}))},e.prototype._callSelector=function(t,e){try{var i=this.selector.apply(this,e);t.next(i)}catch(n){t.error(n)}},e.prototype._callAddHandler=function(t,e){try{return this.addHandler(t)||null}catch(i){e.error(i)}},e}(s.Observable);e.FromEventPatternObservable=c},fQTG:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"zKHA\"),o=i(\"PFc+\"),c=i(\"AJP0\"),a=i(\"y2i3\"),u=Object.prototype.toString,l=function(t){function e(e,i,n,r){t.call(this),this.sourceObj=e,this.eventName=i,this.selector=n,this.options=r}return n(e,t),e.create=function(t,i,n,r){return o.isFunction(n)&&(r=n,n=void 0),new e(t,i,r,n)},e.setupSubscription=function(t,i,n,r,s){var o;if(function(t){return!!t&&\"[object NodeList]\"===u.call(t)}(t)||function(t){return!!t&&\"[object HTMLCollection]\"===u.call(t)}(t))for(var c=0,l=t.length;c<l;c++)e.setupSubscription(t[c],i,n,r,s);else if(function(t){return!!t&&\"function\"==typeof t.addEventListener&&\"function\"==typeof t.removeEventListener}(t)){var h=t;t.addEventListener(i,n,s),o=function(){return h.removeEventListener(i,n,s)}}else if(function(t){return!!t&&\"function\"==typeof t.on&&\"function\"==typeof t.off}(t)){var p=t;t.on(i,n),o=function(){return p.off(i,n)}}else{if(!function(t){return!!t&&\"function\"==typeof t.addListener&&\"function\"==typeof t.removeListener}(t))throw new TypeError(\"Invalid event target\");var f=t;t.addListener(i,n),o=function(){return f.removeListener(i,n)}}r.add(new a.Subscription(o))},e.prototype._subscribe=function(t){var i=this.selector;e.setupSubscription(this.sourceObj,this.eventName,i?function(){for(var e=[],n=0;n<arguments.length;n++)e[n-0]=arguments[n];var r=s.tryCatch(i).apply(void 0,e);r===c.errorObject?t.error(c.errorObject.e):t.next(r)}:function(e){return t.next(e)},t,this.options)},e}(r.Observable);e.FromEventObservable=l},fTxW:function(t,e,i){\"use strict\";var n=i(\"FBtj\");e.zipAll=function(t){return n.zipAll(t)(this)}},ffiR:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"2fIB\");e.last=function(t,e,i){return function(n){return n.lift(new o(t,e,i,n))}};var o=function(){function t(t,e,i,n){this.predicate=t,this.resultSelector=e,this.defaultValue=i,this.source=n}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.predicate,this.resultSelector,this.defaultValue,this.source))},t}(),c=function(t){function e(e,i,n,r,s){t.call(this,e),this.predicate=i,this.resultSelector=n,this.defaultValue=r,this.source=s,this.hasValue=!1,this.index=0,void 0!==r&&(this.lastValue=r,this.hasValue=!0)}return n(e,t),e.prototype._next=function(t){var e=this.index++;if(this.predicate)this._tryPredicate(t,e);else{if(this.resultSelector)return void this._tryResultSelector(t,e);this.lastValue=t,this.hasValue=!0}},e.prototype._tryPredicate=function(t,e){var i;try{i=this.predicate(t,e,this.source)}catch(n){return void this.destination.error(n)}if(i){if(this.resultSelector)return void this._tryResultSelector(t,e);this.lastValue=t,this.hasValue=!0}},e.prototype._tryResultSelector=function(t,e){var i;try{i=this.resultSelector(t,e)}catch(n){return void this.destination.error(n)}this.lastValue=i,this.hasValue=!0},e.prototype._complete=function(){var t=this.destination;this.hasValue?(t.next(this.lastValue),t.complete()):t.error(new s.EmptyError)},e}(r.Subscriber)},fmye:function(t,e,i){\"use strict\";var n=i(\"ffiR\");e.last=function(t,e,i){return n.last(t,e,i)(this)}},foHw:function(t,e,i){\"use strict\";e.isArrayLike=function(t){return t&&\"number\"==typeof t.length}},g1x8:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"cIDA\");n.Observable.fromEventPattern=r.fromEventPattern},g2Fv:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"/WK6\"),s=function(t){function e(e,i){t.call(this,e,i),this.scheduler=e,this.pending=!1,this.work=i}return n(e,t),e.prototype.schedule=function(t,e){if(void 0===e&&(e=0),this.closed)return this;this.state=t,this.pending=!0;var i=this.id,n=this.scheduler;return null!=i&&(this.id=this.recycleAsyncId(n,i,e)),this.delay=e,this.id=this.id||this.requestAsyncId(n,this.id,e),this},e.prototype.requestAsyncId=function(t,e,i){return void 0===i&&(i=0),r.root.setInterval(t.flush.bind(t,this),i)},e.prototype.recycleAsyncId=function(t,e,i){if(void 0===i&&(i=0),null!==i&&this.delay===i&&!1===this.pending)return e;r.root.clearInterval(e)},e.prototype.execute=function(t,e){if(this.closed)return new Error(\"executing a cancelled action\");this.pending=!1;var i=this._execute(t,e);if(i)return i;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))},e.prototype._execute=function(t,e){var i=!1,n=void 0;try{this.work(t)}catch(r){i=!0,n=!!r&&r||new Error(r)}if(i)return this.unsubscribe(),n},e.prototype._unsubscribe=function(){var t=this.id,e=this.scheduler,i=e.actions,n=i.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==n&&i.splice(n,1),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null},e}(i(\"8JYq\").Action);e.AsyncAction=s},gIzs:function(t,e,i){\"use strict\";var n=i(\"LqmK\");e.mergeStatic=i(\"MdjT\").merge,e.merge=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return n.merge.apply(void 0,t)(this)}},gRDe:function(t,e,i){\"use strict\";e.noop=function(){}},gSfb:function(t,e,i){\"use strict\";var n=i(\"bq7C\"),r=i(\"ZXB4\");e.partition=function(t,e){return function(i){return[r.filter(t,e)(i),r.filter(n.not(t,e))(i)]}}},\"gcf/\":function(t,e,i){\"use strict\";var n=i(\"4WIM\"),r=i(\"cf1P\");e.publish=function(t){return t?r.multicast(function(){return new n.Subject},t):r.multicast(new n.Subject)}},gugg:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"rOew\");n.Observable.prototype.shareReplay=r.shareReplay},h8ds:function(t,e,i){\"use strict\";var n=i(\"7Nkz\");e.skipLast=function(t){return n.skipLast(t)(this)}},hV2K:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"cUCP\");e.auditTime=function(t,e){return void 0===e&&(e=n.async),r.auditTime(t,e)(this)}},hY8S:function(t,e,i){\"use strict\";var n=i(\"VVja\"),r=i(\"LAU0\");e.switchAll=function(){return n.switchMap(r.identity)}},hgYf:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"BWyk\");n.Observable.prototype.delay=r.delay},\"hut+\":function(t,e,i){\"use strict\";e.isDate=function(t){return t instanceof Date&&!isNaN(+t)}},hw8L:function(t,e,i){\"use strict\";var n=i(\"GEfX\");e.exhaustMap=function(t,e){return n.exhaustMap(t,e)(this)}},i45a:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(e,i){t.call(this),this.error=e,this.scheduler=i}return n(e,t),e.create=function(t,i){return new e(t,i)},e.dispatch=function(t){t.subscriber.error(t.error)},e.prototype._subscribe=function(t){var i=this.error,n=this.scheduler;if(t.syncErrorThrowable=!0,n)return n.schedule(e.dispatch,0,{error:i,subscriber:t});t.error(i)},e}(i(\"AZf1\").Observable);e.ErrorObservable=r},iYe0:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.count=function(t){return function(e){return e.lift(new s(t,e))}};var s=function(){function t(t,e){this.predicate=t,this.source=e}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.predicate,this.source))},t}(),o=function(t){function e(e,i,n){t.call(this,e),this.predicate=i,this.source=n,this.count=0,this.index=0}return n(e,t),e.prototype._next=function(t){this.predicate?this._tryPredicate(t):this.count++},e.prototype._tryPredicate=function(t){var e;try{e=this.predicate(t,this.index++,this.source)}catch(i){return void this.destination.error(i)}e&&this.count++},e.prototype._complete=function(){this.destination.next(this.count),this.destination.complete()},e}(r.Subscriber)},iaCc:function(t,e,i){\"use strict\";e.range=i(\"+UM1\").RangeObservable.create},jNrO:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"aea6\");n.Observable.prototype.sampleTime=r.sampleTime},\"jRt/\":function(t,e,i){\"use strict\";var n=i(\"Kc9Z\");e.min=function(t){return n.min(t)(this)}},jc2T:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"8ywx\");n.Observable.prototype.pluck=r.pluck},klBC:function(t,e,i){\"use strict\";var n=i(\"aK2G\");e.map=function(t,e){return n.map(t,e)(this)}},ks6M:function(t,e,i){\"use strict\";var n=i(\"re5B\");e.bufferToggle=function(t,e){return n.bufferToggle(t,e)(this)}},kwlx:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(e){t.call(this),this.errors=e;var i=Error.call(this,e?e.length+\" errors occurred during unsubscription:\\n  \"+e.map(function(t,e){return e+1+\") \"+t.toString()}).join(\"\\n  \"):\"\");this.name=i.name=\"UnsubscriptionError\",this.stack=i.stack,this.message=i.message}return n(e,t),e}(Error);e.UnsubscriptionError=r},\"l/bX\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"agdi\");n.Observable.prototype.timeoutWith=r.timeoutWith},l1g9:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"5sLA\");n.Observable.prototype.takeLast=r.takeLast},l6Ej:function(t,e,i){\"use strict\";var n=i(\"c4YM\");e.distinctUntilKeyChanged=function(t,e){return n.distinctUntilKeyChanged(t,e)(this)}},l9aY:function(t,e,i){\"use strict\";var n=i(\"rgOj\");e.distinctUntilChanged=function(t,e){return n.distinctUntilChanged(t,e)(this)}},lBaL:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"RkF3\");n.Observable.prototype.combineLatest=r.combineLatest},lCqY:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"S26M\");n.Observable.prototype.catch=r._catch,n.Observable.prototype._catch=r._catch},laXh:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"+1VR\");n.Observable.prototype.mergeScan=r.mergeScan},lf2g:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"Irel\"),s=i(\"9jZZ\");e.mergeMap=function(t,e,i){return void 0===i&&(i=Number.POSITIVE_INFINITY),function(n){return\"number\"==typeof e&&(i=e,e=null),n.lift(new o(t,e,i))}};var o=function(){function t(t,e,i){void 0===i&&(i=Number.POSITIVE_INFINITY),this.project=t,this.resultSelector=e,this.concurrent=i}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.project,this.resultSelector,this.concurrent))},t}();e.MergeMapOperator=o;var c=function(t){function e(e,i,n,r){void 0===r&&(r=Number.POSITIVE_INFINITY),t.call(this,e),this.project=i,this.resultSelector=n,this.concurrent=r,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}return n(e,t),e.prototype._next=function(t){this.active<this.concurrent?this._tryNext(t):this.buffer.push(t)},e.prototype._tryNext=function(t){var e,i=this.index++;try{e=this.project(t,i)}catch(n){return void this.destination.error(n)}this.active++,this._innerSub(e,t,i)},e.prototype._innerSub=function(t,e,i){this.add(r.subscribeToResult(this,t,e,i))},e.prototype._complete=function(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete()},e.prototype.notifyNext=function(t,e,i,n,r){this.resultSelector?this._notifyResultSelector(t,e,i,n):this.destination.next(e)},e.prototype._notifyResultSelector=function(t,e,i,n){var r;try{r=this.resultSelector(t,e,i,n)}catch(s){return void this.destination.error(s)}this.destination.next(r)},e.prototype.notifyComplete=function(t){var e=this.buffer;this.remove(t),this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()},e}(s.OuterSubscriber);e.MergeMapSubscriber=c},loW1:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(){t.apply(this,arguments)}return n(e,t),e.prototype.flush=function(t){this.active=!0,this.scheduled=void 0;var e,i=this.actions,n=-1,r=i.length;t=t||i.shift();do{if(e=t.execute(t.state,t.delay))break}while(++n<r&&(t=i.shift()));if(this.active=!1,e){for(;++n<r&&(t=i.shift());)t.unsubscribe();throw e}},e}(i(\"FXL7\").AsyncScheduler);e.AnimationFrameScheduler=r},\"m+NU\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"/WK6\"),s=i(\"AZf1\"),o=i(\"+2+e\"),c=function(t){function e(e,i){if(t.call(this),this.scheduler=i,null==e)throw new Error(\"iterator cannot be null.\");this.iterator=function(t){var e=t[o.iterator];if(!e&&\"string\"==typeof t)return new a(t);if(!e&&void 0!==t.length)return new u(t);if(!e)throw new TypeError(\"object is not iterable\");return t[o.iterator]()}(e)}return n(e,t),e.create=function(t,i){return new e(t,i)},e.dispatch=function(t){var e=t.index,i=t.iterator,n=t.subscriber;if(t.hasError)n.error(t.error);else{var r=i.next();r.done?n.complete():(n.next(r.value),t.index=e+1,n.closed?\"function\"==typeof i.return&&i.return():this.schedule(t))}},e.prototype._subscribe=function(t){var i=this.iterator,n=this.scheduler;if(n)return n.schedule(e.dispatch,0,{index:0,iterator:i,subscriber:t});for(;;){var r=i.next();if(r.done){t.complete();break}if(t.next(r.value),t.closed){\"function\"==typeof i.return&&i.return();break}}},e}(s.Observable);e.IteratorObservable=c;var a=function(){function t(t,e,i){void 0===e&&(e=0),void 0===i&&(i=t.length),this.str=t,this.idx=e,this.len=i}return t.prototype[o.iterator]=function(){return this},t.prototype.next=function(){return this.idx<this.len?{done:!1,value:this.str.charAt(this.idx++)}:{done:!0,value:void 0}},t}(),u=function(){function t(t,e,i){void 0===e&&(e=0),void 0===i&&(i=function(t){var e,i=+t.length;return isNaN(i)?0:0!==i&&\"number\"==typeof(e=i)&&r.root.isFinite(e)?(i=function(t){var e=+t;return 0===e||isNaN(e)?e:e<0?-1:1}(i)*Math.floor(Math.abs(i)))<=0?0:i>l?l:i:i}(t)),this.arr=t,this.idx=e,this.len=i}return t.prototype[o.iterator]=function(){return this},t.prototype.next=function(){return this.idx<this.len?{done:!1,value:this.arr[this.idx++]}:{done:!0,value:void 0}},t}(),l=Math.pow(2,53)-1},m8PH:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"4WIM\"),s=i(\"1uGz\"),o=i(\"AZf1\"),c=i(\"y2i3\"),a=i(\"/WK6\"),u=i(\"BjeI\"),l=i(\"zKHA\"),h=i(\"AJP0\"),p=i(\"2gSr\"),f=function(t){function e(e,i){if(e instanceof o.Observable)t.call(this,i,e);else{if(t.call(this),this.WebSocketCtor=a.root.WebSocket,this._output=new r.Subject,\"string\"==typeof e?this.url=e:p.assign(this,e),!this.WebSocketCtor)throw new Error(\"no WebSocket constructor can be found\");this.destination=new u.ReplaySubject}}return n(e,t),e.prototype.resultSelector=function(t){return JSON.parse(t.data)},e.create=function(t){return new e(t)},e.prototype.lift=function(t){var i=new e(this,this.destination);return i.operator=t,i},e.prototype._resetState=function(){this.socket=null,this.source||(this.destination=new u.ReplaySubject),this._output=new r.Subject},e.prototype.multiplex=function(t,e,i){var n=this;return new o.Observable(function(r){var s=l.tryCatch(t)();s===h.errorObject?r.error(h.errorObject.e):n.next(s);var o=n.subscribe(function(t){var e=l.tryCatch(i)(t);e===h.errorObject?r.error(h.errorObject.e):e&&r.next(t)},function(t){return r.error(t)},function(){return r.complete()});return function(){var t=l.tryCatch(e)();t===h.errorObject?r.error(h.errorObject.e):n.next(t),o.unsubscribe()}})},e.prototype._connectSocket=function(){var t=this,e=this.WebSocketCtor,i=this._output,n=null;try{n=this.protocol?new e(this.url,this.protocol):new e(this.url),this.socket=n,this.binaryType&&(this.socket.binaryType=this.binaryType)}catch(o){return void i.error(o)}var r=new c.Subscription(function(){t.socket=null,n&&1===n.readyState&&n.close()});n.onopen=function(e){var o=t.openObserver;o&&o.next(e);var c=t.destination;t.destination=s.Subscriber.create(function(t){return 1===n.readyState&&n.send(t)},function(e){var r=t.closingObserver;r&&r.next(void 0),e&&e.code?n.close(e.code,e.reason):i.error(new TypeError(\"WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }\")),t._resetState()},function(){var e=t.closingObserver;e&&e.next(void 0),n.close(),t._resetState()}),c&&c instanceof u.ReplaySubject&&r.add(c.subscribe(t.destination))},n.onerror=function(e){t._resetState(),i.error(e)},n.onclose=function(e){t._resetState();var n=t.closeObserver;n&&n.next(e),e.wasClean?i.complete():i.error(e)},n.onmessage=function(e){var n=l.tryCatch(t.resultSelector)(e);n===h.errorObject?i.error(h.errorObject.e):i.next(n)}},e.prototype._subscribe=function(t){var e=this,i=this.source;if(i)return i.subscribe(t);this.socket||this._connectSocket();var n=new c.Subscription;return n.add(this._output.subscribe(t)),n.add(function(){var t=e.socket;0===e._output.observers.length&&(t&&1===t.readyState&&t.close(),e._resetState())}),n},e.prototype.unsubscribe=function(){var e=this.source,i=this.socket;i&&1===i.readyState&&(i.close(),this._resetState()),t.prototype.unsubscribe.call(this),e||(this.destination=new u.ReplaySubject)},e}(r.AnonymousSubject);e.WebSocketSubject=f},mO1z:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.dematerialize=function(){return function(t){return t.lift(new s)}};var s=function(){function t(){}return t.prototype.call=function(t,e){return e.subscribe(new o(t))},t}(),o=function(t){function e(e){t.call(this,e)}return n(e,t),e.prototype._next=function(t){t.observe(this.destination)},e}(r.Subscriber)},mSFr:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"Kwcu\");n.Observable.prototype.retry=r.retry},mXuN:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"PqiM\");n.Observable.prototype.skipUntil=r.skipUntil},mdQD:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"zKHA\"),s=i(\"AJP0\"),o=i(\"9jZZ\"),c=i(\"Irel\");e.audit=function(t){return function(e){return e.lift(new a(t))}};var a=function(){function t(t){this.durationSelector=t}return t.prototype.call=function(t,e){return e.subscribe(new u(t,this.durationSelector))},t}(),u=function(t){function e(e,i){t.call(this,e),this.durationSelector=i,this.hasValue=!1}return n(e,t),e.prototype._next=function(t){if(this.value=t,this.hasValue=!0,!this.throttled){var e=r.tryCatch(this.durationSelector)(t);if(e===s.errorObject)this.destination.error(s.errorObject.e);else{var i=c.subscribeToResult(this,e);i.closed?this.clearThrottle():this.add(this.throttled=i)}}},e.prototype.clearThrottle=function(){var t=this,e=t.value,i=t.hasValue,n=t.throttled;n&&(this.remove(n),this.throttled=null,n.unsubscribe()),i&&(this.value=null,this.hasValue=!1,this.destination.next(e))},e.prototype.notifyNext=function(t,e,i,n){this.clearThrottle()},e.prototype.notifyComplete=function(){this.clearThrottle()},e}(o.OuterSubscriber)},mz1d:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"qnn9\");n.Observable.prototype.concatMapTo=r.concatMapTo},n8Qg:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.scan=function(t,e){var i=!1;return arguments.length>=2&&(i=!0),function(n){return n.lift(new s(t,e,i))}};var s=function(){function t(t,e,i){void 0===i&&(i=!1),this.accumulator=t,this.seed=e,this.hasSeed=i}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.accumulator,this.seed,this.hasSeed))},t}(),o=function(t){function e(e,i,n,r){t.call(this,e),this.accumulator=i,this._seed=n,this.hasSeed=r,this.index=0}return n(e,t),Object.defineProperty(e.prototype,\"seed\",{get:function(){return this._seed},set:function(t){this.hasSeed=!0,this._seed=t},enumerable:!0,configurable:!0}),e.prototype._next=function(t){if(this.hasSeed)return this._tryNext(t);this.seed=t,this.destination.next(t)},e.prototype._tryNext=function(t){var e,i=this.index++;try{e=this.accumulator(this.seed,t,i)}catch(n){this.destination.error(n)}this.seed=e,this.destination.next(e)},e}(r.Subscriber)},nD5C:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"6GWt\");n.Observable.prototype.reduce=r.reduce},nQov:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\"),o=i(\"eBTF\");e.distinct=function(t,e){return function(i){return i.lift(new c(t,e))}};var c=function(){function t(t,e){this.keySelector=t,this.flushes=e}return t.prototype.call=function(t,e){return e.subscribe(new a(t,this.keySelector,this.flushes))},t}(),a=function(t){function e(e,i,n){t.call(this,e),this.keySelector=i,this.values=new o.Set,n&&this.add(s.subscribeToResult(this,n))}return n(e,t),e.prototype.notifyNext=function(t,e,i,n,r){this.values.clear()},e.prototype.notifyError=function(t,e){this._error(t)},e.prototype._next=function(t){this.keySelector?this._useKeySelector(t):this._finalizeNext(t,t)},e.prototype._useKeySelector=function(t){var e,i=this.destination;try{e=this.keySelector(t)}catch(n){return void i.error(n)}this._finalizeNext(e,t)},e.prototype._finalizeNext=function(t,e){var i=this.values;i.has(t)||(i.add(t),this.destination.next(e))},e}(r.OuterSubscriber);e.DistinctSubscriber=a},nXmG:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"onNu\");n.Observable.prototype.onErrorResumeNext=r.onErrorResumeNext},nfiU:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"KC+j\");n.Observable.prototype.concatMap=r.concatMap},nkkL:function(t,e,i){\"use strict\";var n=i(\"/WK6\").root.Symbol;e.rxSubscriber=\"function\"==typeof n&&\"function\"==typeof n.for?n.for(\"rxSubscriber\"):\"@@rxSubscriber\",e.$$rxSubscriber=e.rxSubscriber},nxYh:function(t,e,i){\"use strict\";var n=i(\"16yF\");e.bufferCount=function(t,e){return void 0===e&&(e=null),n.bufferCount(t,e)(this)}},\"o/sf\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"9A9s\");n.Observable.never=r.never},o6MN:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.defaultThrottleConfig={leading:!0,trailing:!1},e.throttle=function(t,i){return void 0===i&&(i=e.defaultThrottleConfig),function(e){return e.lift(new o(t,i.leading,i.trailing))}};var o=function(){function t(t,e,i){this.durationSelector=t,this.leading=e,this.trailing=i}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.durationSelector,this.leading,this.trailing))},t}(),c=function(t){function e(e,i,n,r){t.call(this,e),this.destination=e,this.durationSelector=i,this._leading=n,this._trailing=r,this._hasTrailingValue=!1}return n(e,t),e.prototype._next=function(t){if(this.throttled)this._trailing&&(this._hasTrailingValue=!0,this._trailingValue=t);else{var e=this.tryDurationSelector(t);e&&this.add(this.throttled=s.subscribeToResult(this,e)),this._leading&&(this.destination.next(t),this._trailing&&(this._hasTrailingValue=!0,this._trailingValue=t))}},e.prototype.tryDurationSelector=function(t){try{return this.durationSelector(t)}catch(e){return this.destination.error(e),null}},e.prototype._unsubscribe=function(){var t=this.throttled;this._trailingValue=null,this._hasTrailingValue=!1,t&&(this.remove(t),this.throttled=null,t.unsubscribe())},e.prototype._sendTrailing=function(){var t=this;t.throttled&&t._trailing&&t._hasTrailingValue&&(t.destination.next(t._trailingValue),this._trailingValue=null,this._hasTrailingValue=!1)},e.prototype.notifyNext=function(t,e,i,n,r){this._sendTrailing(),this._unsubscribe()},e.prototype.notifyComplete=function(){this._sendTrailing(),this._unsubscribe()},e}(r.OuterSubscriber)},oGc9:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"9x29\");e.materialize=function(){return function(t){return t.lift(new o)}};var o=function(){function t(){}return t.prototype.call=function(t,e){return e.subscribe(new c(t))},t}(),c=function(t){function e(e){t.call(this,e)}return n(e,t),e.prototype._next=function(t){this.destination.next(s.Notification.createNext(t))},e.prototype._error=function(t){var e=this.destination;e.next(s.Notification.createError(t)),e.complete()},e.prototype._complete=function(){var t=this.destination;t.next(s.Notification.createComplete()),t.complete()},e}(r.Subscriber)},oQYR:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"rVFa\"),s=i(\"G2HO\"),o=i(\"1uGz\"),c=i(\"9jZZ\"),a=i(\"Irel\"),u=i(\"+2+e\");function l(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];var i=t[t.length-1];return\"function\"==typeof i&&t.pop(),new r.ArrayObservable(t).lift(new h(i))}e.zip=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return function(e){return e.lift.call(l.apply(void 0,[e].concat(t)))}},e.zipStatic=l;var h=function(){function t(t){this.project=t}return t.prototype.call=function(t,e){return e.subscribe(new p(t,this.project))},t}();e.ZipOperator=h;var p=function(t){function e(e,i,n){void 0===n&&(n=Object.create(null)),t.call(this,e),this.iterators=[],this.active=0,this.project=\"function\"==typeof i?i:null,this.values=n}return n(e,t),e.prototype._next=function(t){var e=this.iterators;s.isArray(t)?e.push(new d(t)):e.push(\"function\"==typeof t[u.iterator]?new f(t[u.iterator]()):new b(this.destination,this,t))},e.prototype._complete=function(){var t=this.iterators,e=t.length;if(0!==e){this.active=e;for(var i=0;i<e;i++){var n=t[i];n.stillUnsubscribed?this.add(n.subscribe(n,i)):this.active--}}else this.destination.complete()},e.prototype.notifyInactive=function(){this.active--,0===this.active&&this.destination.complete()},e.prototype.checkIterators=function(){for(var t=this.iterators,e=t.length,i=this.destination,n=0;n<e;n++)if(\"function\"==typeof(o=t[n]).hasValue&&!o.hasValue())return;var r=!1,s=[];for(n=0;n<e;n++){var o,c=(o=t[n]).next();if(o.hasCompleted()&&(r=!0),c.done)return void i.complete();s.push(c.value)}this.project?this._tryProject(s):i.next(s),r&&i.complete()},e.prototype._tryProject=function(t){var e;try{e=this.project.apply(this,t)}catch(i){return void this.destination.error(i)}this.destination.next(e)},e}(o.Subscriber);e.ZipSubscriber=p;var f=function(){function t(t){this.iterator=t,this.nextResult=t.next()}return t.prototype.hasValue=function(){return!0},t.prototype.next=function(){var t=this.nextResult;return this.nextResult=this.iterator.next(),t},t.prototype.hasCompleted=function(){var t=this.nextResult;return t&&t.done},t}(),d=function(){function t(t){this.array=t,this.index=0,this.length=0,this.length=t.length}return t.prototype[u.iterator]=function(){return this},t.prototype.next=function(t){var e=this.index++;return e<this.length?{value:this.array[e],done:!1}:{value:null,done:!0}},t.prototype.hasValue=function(){return this.array.length>this.index},t.prototype.hasCompleted=function(){return this.array.length===this.index},t}(),b=function(t){function e(e,i,n){t.call(this,e),this.parent=i,this.observable=n,this.stillUnsubscribed=!0,this.buffer=[],this.isComplete=!1}return n(e,t),e.prototype[u.iterator]=function(){return this},e.prototype.next=function(){var t=this.buffer;return 0===t.length&&this.isComplete?{value:null,done:!0}:{value:t.shift(),done:!1}},e.prototype.hasValue=function(){return this.buffer.length>0},e.prototype.hasCompleted=function(){return 0===this.buffer.length&&this.isComplete},e.prototype.notifyComplete=function(){this.buffer.length>0?(this.isComplete=!0,this.parent.notifyInactive()):this.destination.complete()},e.prototype.notifyNext=function(t,e,i,n,r){this.buffer.push(e),this.parent.checkIterators()},e.prototype.subscribe=function(t,e){return a.subscribeToResult(this,this.observable,this,e)},e}(c.OuterSubscriber)},\"od+f\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"36rE\"),o=i(\"G2HO\"),c=i(\"Irel\"),a=i(\"9jZZ\"),u=function(t){function e(e,i){t.call(this),this.sources=e,this.resultSelector=i}return n(e,t),e.create=function(){for(var t=[],i=0;i<arguments.length;i++)t[i-0]=arguments[i];if(null===t||0===arguments.length)return new s.EmptyObservable;var n=null;return\"function\"==typeof t[t.length-1]&&(n=t.pop()),1===t.length&&o.isArray(t[0])&&(t=t[0]),0===t.length?new s.EmptyObservable:new e(t,n)},e.prototype._subscribe=function(t){return new l(t,this.sources,this.resultSelector)},e}(r.Observable);e.ForkJoinObservable=u;var l=function(t){function e(e,i,n){t.call(this,e),this.sources=i,this.resultSelector=n,this.completed=0,this.haveValues=0;var r=i.length;this.total=r,this.values=new Array(r);for(var s=0;s<r;s++){var o=c.subscribeToResult(this,i[s],null,s);o&&(o.outerIndex=s,this.add(o))}}return n(e,t),e.prototype.notifyNext=function(t,e,i,n,r){this.values[i]=e,r._hasValue||(r._hasValue=!0,this.haveValues++)},e.prototype.notifyComplete=function(t){var e=this.destination,i=this,n=i.haveValues,r=i.resultSelector,s=i.values,o=s.length;if(t._hasValue){if(this.completed++,this.completed===o){if(n===o){var c=r?r.apply(this,s):s;e.next(c)}e.complete()}}else e.complete()},e}(a.OuterSubscriber)},oemf:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"/WK6\"),s=i(\"zKHA\"),o=i(\"AJP0\"),c=i(\"AZf1\"),a=i(\"1uGz\"),u=i(\"aK2G\");function l(){if(r.root.XMLHttpRequest)return new r.root.XMLHttpRequest;if(r.root.XDomainRequest)return new r.root.XDomainRequest;throw new Error(\"CORS is not supported by your browser\")}function h(t,e){return void 0===e&&(e=null),new m({method:\"GET\",url:t,headers:e})}function p(t,e,i){return new m({method:\"POST\",url:t,body:e,headers:i})}function f(t,e){return new m({method:\"DELETE\",url:t,headers:e})}function d(t,e,i){return new m({method:\"PUT\",url:t,body:e,headers:i})}function b(t,e,i){return new m({method:\"PATCH\",url:t,body:e,headers:i})}e.ajaxGet=h,e.ajaxPost=p,e.ajaxDelete=f,e.ajaxPut=d,e.ajaxPatch=b;var v=u.map(function(t,e){return t.response});function y(t,e){return v(new m({method:\"GET\",url:t,responseType:\"json\",headers:e}))}e.ajaxGetJSON=y;var m=function(t){function e(e){t.call(this);var i={async:!0,createXHR:function(){return this.crossDomain?l.call(this):function(){if(r.root.XMLHttpRequest)return new r.root.XMLHttpRequest;var t=void 0;try{for(var e=[\"Msxml2.XMLHTTP\",\"Microsoft.XMLHTTP\",\"Msxml2.XMLHTTP.4.0\"],i=0;i<3;i++)try{if(new r.root.ActiveXObject(t=e[i]))break}catch(n){}return new r.root.ActiveXObject(t)}catch(n){throw new Error(\"XMLHttpRequest is not supported by your browser\")}}()},crossDomain:!1,withCredentials:!1,headers:{},method:\"GET\",responseType:\"json\",timeout:0};if(\"string\"==typeof e)i.url=e;else for(var n in e)e.hasOwnProperty(n)&&(i[n]=e[n]);this.request=i}var i;return n(e,t),e.prototype._subscribe=function(t){return new g(t,this.request)},e.create=((i=function(t){return new e(t)}).get=h,i.post=p,i.delete=f,i.put=d,i.patch=b,i.getJSON=y,i),e}(c.Observable);e.AjaxObservable=m;var g=function(t){function e(e,i){t.call(this,e),this.request=i,this.done=!1;var n=i.headers=i.headers||{};i.crossDomain||n[\"X-Requested-With\"]||(n[\"X-Requested-With\"]=\"XMLHttpRequest\"),\"Content-Type\"in n||r.root.FormData&&i.body instanceof r.root.FormData||void 0===i.body||(n[\"Content-Type\"]=\"application/x-www-form-urlencoded; charset=UTF-8\"),i.body=this.serializeBody(i.body,i.headers[\"Content-Type\"]),this.send()}return n(e,t),e.prototype.next=function(t){this.done=!0;var e=this,i=e.destination,n=new w(t,e.xhr,e.request);i.next(n)},e.prototype.send=function(){var t=this.request,e=this.request,i=e.user,n=e.method,r=e.url,c=e.async,a=e.password,u=e.headers,l=e.body,h=s.tryCatch(t.createXHR).call(t);if(h===o.errorObject)this.error(o.errorObject.e);else{if(this.xhr=h,this.setupEvents(h,t),(i?s.tryCatch(h.open).call(h,n,r,c,i,a):s.tryCatch(h.open).call(h,n,r,c))===o.errorObject)return this.error(o.errorObject.e),null;if(c&&(h.timeout=t.timeout,h.responseType=t.responseType),\"withCredentials\"in h&&(h.withCredentials=!!t.withCredentials),this.setHeaders(h,u),(l?s.tryCatch(h.send).call(h,l):s.tryCatch(h.send).call(h))===o.errorObject)return this.error(o.errorObject.e),null}return h},e.prototype.serializeBody=function(t,e){if(!t||\"string\"==typeof t)return t;if(r.root.FormData&&t instanceof r.root.FormData)return t;if(e){var i=e.indexOf(\";\");-1!==i&&(e=e.substring(0,i))}switch(e){case\"application/x-www-form-urlencoded\":return Object.keys(t).map(function(e){return encodeURIComponent(e)+\"=\"+encodeURIComponent(t[e])}).join(\"&\");case\"application/json\":return JSON.stringify(t);default:return t}},e.prototype.setHeaders=function(t,e){for(var i in e)e.hasOwnProperty(i)&&t.setRequestHeader(i,e[i])},e.prototype.setupEvents=function(t,e){var i,n,s=e.progressSubscriber;function o(t){var e=o.subscriber,i=o.progressSubscriber,n=o.request;i&&i.error(t),e.error(new x(this,n))}function c(t){var e=c.subscriber,i=c.progressSubscriber,n=c.request;if(4===this.readyState){var r=1223===this.status?204:this.status;0===r&&(r=(\"text\"===this.responseType?this.response||this.responseText:this.response)?200:0),200<=r&&r<300?(i&&i.complete(),e.next(t),e.complete()):(i&&i.error(t),e.error(new O(\"ajax error \"+r,this,n)))}}t.ontimeout=o,o.request=e,o.subscriber=this,o.progressSubscriber=s,t.upload&&\"withCredentials\"in t&&(s&&(i=function(t){i.progressSubscriber.next(t)},r.root.XDomainRequest?t.onprogress=i:t.upload.onprogress=i,i.progressSubscriber=s),t.onerror=n=function(t){var e=n.progressSubscriber,i=n.subscriber,r=n.request;e&&e.error(t),i.error(new O(\"ajax error\",this,r))},n.request=e,n.subscriber=this,n.progressSubscriber=s),t.onreadystatechange=c,c.subscriber=this,c.progressSubscriber=s,c.request=e},e.prototype.unsubscribe=function(){var e=this.xhr;!this.done&&e&&4!==e.readyState&&\"function\"==typeof e.abort&&e.abort(),t.prototype.unsubscribe.call(this)},e}(a.Subscriber);e.AjaxSubscriber=g;var w=function(){return function(t,e,i){this.originalEvent=t,this.xhr=e,this.request=i,this.status=e.status,this.responseType=e.responseType||i.responseType,this.response=S(this.responseType,e)}}();e.AjaxResponse=w;var O=function(t){function e(e,i,n){t.call(this,e),this.message=e,this.xhr=i,this.request=n,this.status=i.status,this.responseType=i.responseType||n.responseType,this.response=S(this.responseType,i)}return n(e,t),e}(Error);function S(t,e){switch(t){case\"json\":return\"response\"in e?e.responseType?e.response:JSON.parse(e.response||e.responseText||\"null\"):JSON.parse(e.responseText||\"null\");case\"xml\":return e.responseXML;case\"text\":default:return\"response\"in e?e.response:e.responseText}}e.AjaxError=O;var x=function(t){function e(e,i){t.call(this,\"ajax timeout\",e,i)}return n(e,t),e}(O);e.AjaxTimeoutError=x},onNu:function(t,e,i){\"use strict\";var n=i(\"Rm1J\");e.onErrorResumeNext=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return n.onErrorResumeNext.apply(void 0,t)(this)}},onQ2:function(t,e,i){\"use strict\";var n=i(\"H0zL\");e.exhaust=function(){return n.exhaust()(this)}},oonV:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"+Whv\");n.Observable.using=r.using},pNQw:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"UqH8\");n.Observable.timer=r.timer},pYXR:function(t,e,i){\"use strict\";e.isObject=function(t){return null!=t&&\"object\"==typeof t}},pZ8H:function(t,e,i){\"use strict\";var n=i(\"2Tbn\");e.defaultIfEmpty=function(t){return void 0===t&&(t=null),n.defaultIfEmpty(t)(this)}},\"pi/U\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"D4pF\");n.Observable.prototype.debounceTime=r.debounceTime},\"pk/4\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.refCount=function(){return function(t){return t.lift(new s(t))}};var s=function(){function t(t){this.connectable=t}return t.prototype.call=function(t,e){var i=this.connectable;i._refCount++;var n=new o(t,i),r=e.subscribe(n);return n.closed||(n.connection=i.connect()),r},t}(),o=function(t){function e(e,i){t.call(this,e),this.connectable=i}return n(e,t),e.prototype._unsubscribe=function(){var t=this.connectable;if(t){this.connectable=null;var e=t._refCount;if(e<=0)this.connection=null;else if(t._refCount=e-1,e>1)this.connection=null;else{var i=this.connection,n=t._connection;this.connection=null,!n||i&&n!==i||n.unsubscribe()}}else this.connection=null},e}(r.Subscriber)},puri:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"1nIg\");n.Observable.prototype.publishLast=r.publishLast},\"q+iv\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=function(t){function e(){t.apply(this,arguments)}return n(e,t),e.prototype.flush=function(t){this.active=!0,this.scheduled=void 0;var e,i=this.actions,n=-1,r=i.length;t=t||i.shift();do{if(e=t.execute(t.state,t.delay))break}while(++n<r&&(t=i.shift()));if(this.active=!1,e){for(;++n<r&&(t=i.shift());)t.unsubscribe();throw e}},e}(i(\"FXL7\").AsyncScheduler);e.AsapScheduler=r},q6z3:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"IEzG\");n.Observable.prototype.withLatestFrom=r.withLatestFrom},q9sB:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"y2i3\");e.finalize=function(t){return function(e){return e.lift(new o(t))}};var o=function(){function t(t){this.callback=t}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.callback))},t}(),c=function(t){function e(e,i){t.call(this,e),this.add(new s.Subscription(i))}return n(e,t),e}(r.Subscriber)},\"qJ4/\":function(t,e,i){\"use strict\";var n=i(\"f947\");e.publishReplay=function(t,e,i,r){return n.publishReplay(t,e,i,r)(this)}},qKmH:function(t,e,i){\"use strict\";e.generate=i(\"yl3g\").GenerateObservable.create},qN2p:function(t,e,i){\"use strict\";var n=i(\"DKXc\");e.findIndex=function(t,e){return function(i){return i.lift(new n.FindValueOperator(t,i,!0,e))}}},qQIA:function(t,e,i){\"use strict\";e.interval=i(\"Mnf/\").IntervalObservable.create},qnU5:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"JLi8\");n.Observable.forkJoin=r.forkJoin},qnn9:function(t,e,i){\"use strict\";var n=i(\"zVww\");e.concatMapTo=function(t,e){return n.concatMapTo(t,e)(this)}},r2oo:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"/WK6\"),s=function(t){function e(e,i){t.call(this),this.promise=e,this.scheduler=i}return n(e,t),e.create=function(t,i){return new e(t,i)},e.prototype._subscribe=function(t){var e=this,i=this.promise,n=this.scheduler;if(null==n)this._isScalar?t.closed||(t.next(this.value),t.complete()):i.then(function(i){e.value=i,e._isScalar=!0,t.closed||(t.next(i),t.complete())},function(e){t.closed||t.error(e)}).then(null,function(t){r.root.setTimeout(function(){throw t})});else if(this._isScalar){if(!t.closed)return n.schedule(o,0,{value:this.value,subscriber:t})}else i.then(function(i){e.value=i,e._isScalar=!0,t.closed||t.add(n.schedule(o,0,{value:i,subscriber:t}))},function(e){t.closed||t.add(n.schedule(c,0,{err:e,subscriber:t}))}).then(null,function(t){r.root.setTimeout(function(){throw t})})},e}(i(\"AZf1\").Observable);function o(t){var e=t.subscriber;e.closed||(e.next(t.value),e.complete())}function c(t){var e=t.subscriber;e.closed||e.error(t.err)}e.PromiseObservable=s},r9ib:function(t,e,i){\"use strict\";e.bindCallback=i(\"w1ve\").BoundCallbackObservable.create},rOew:function(t,e,i){\"use strict\";var n=i(\"0Qin\");e.shareReplay=function(t,e,i){return n.shareReplay(t,e,i)(this)}},rPn0:function(t,e,i){\"use strict\";var n=i(\"7f6I\");e.publishBehavior=function(t){return n.publishBehavior(t)(this)}},rVFa:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"8x9D\"),o=i(\"36rE\"),c=i(\"NwwV\"),a=function(t){function e(e,i){t.call(this),this.array=e,this.scheduler=i,i||1!==e.length||(this._isScalar=!0,this.value=e[0])}return n(e,t),e.create=function(t,i){return new e(t,i)},e.of=function(){for(var t=[],i=0;i<arguments.length;i++)t[i-0]=arguments[i];var n=t[t.length-1];c.isScheduler(n)?t.pop():n=null;var r=t.length;return r>1?new e(t,n):1===r?new s.ScalarObservable(t[0],n):new o.EmptyObservable(n)},e.dispatch=function(t){var e=t.array,i=t.index,n=t.subscriber;i>=t.count?n.complete():(n.next(e[i]),n.closed||(t.index=i+1,this.schedule(t)))},e.prototype._subscribe=function(t){var i=this.array,n=i.length,r=this.scheduler;if(r)return r.schedule(e.dispatch,0,{array:i,index:0,count:n,subscriber:t});for(var s=0;s<n&&!t.closed;s++)t.next(i[s]);t.complete()},e}(r.Observable);e.ArrayObservable=a},rYxE:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"fmye\");n.Observable.prototype.last=r.last},re5B:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"y2i3\"),s=i(\"Irel\"),o=i(\"9jZZ\");e.bufferToggle=function(t,e){return function(i){return i.lift(new c(t,e))}};var c=function(){function t(t,e){this.openings=t,this.closingSelector=e}return t.prototype.call=function(t,e){return e.subscribe(new a(t,this.openings,this.closingSelector))},t}(),a=function(t){function e(e,i,n){t.call(this,e),this.openings=i,this.closingSelector=n,this.contexts=[],this.add(s.subscribeToResult(this,i))}return n(e,t),e.prototype._next=function(t){for(var e=this.contexts,i=e.length,n=0;n<i;n++)e[n].buffer.push(t)},e.prototype._error=function(e){for(var i=this.contexts;i.length>0;){var n=i.shift();n.subscription.unsubscribe(),n.buffer=null,n.subscription=null}this.contexts=null,t.prototype._error.call(this,e)},e.prototype._complete=function(){for(var e=this.contexts;e.length>0;){var i=e.shift();this.destination.next(i.buffer),i.subscription.unsubscribe(),i.buffer=null,i.subscription=null}this.contexts=null,t.prototype._complete.call(this)},e.prototype.notifyNext=function(t,e,i,n,r){t?this.closeBuffer(t):this.openBuffer(e)},e.prototype.notifyComplete=function(t){this.closeBuffer(t.context)},e.prototype.openBuffer=function(t){try{var e=this.closingSelector.call(this,t);e&&this.trySubscribe(e)}catch(i){this._error(i)}},e.prototype.closeBuffer=function(t){var e=this.contexts;if(e&&t){var i=t.subscription;this.destination.next(t.buffer),e.splice(e.indexOf(t),1),this.remove(i),i.unsubscribe()}},e.prototype.trySubscribe=function(t){var e=this.contexts,i=new r.Subscription,n={buffer:[],subscription:i};e.push(n);var o=s.subscribeToResult(this,t,n);!o||o.closed?this.closeBuffer(n):(o.context=n,this.add(o),i.add(o))},e}(o.OuterSubscriber)},rgOj:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\"),s=i(\"zKHA\"),o=i(\"AJP0\");e.distinctUntilChanged=function(t,e){return function(i){return i.lift(new c(t,e))}};var c=function(){function t(t,e){this.compare=t,this.keySelector=e}return t.prototype.call=function(t,e){return e.subscribe(new a(t,this.compare,this.keySelector))},t}(),a=function(t){function e(e,i,n){t.call(this,e),this.keySelector=n,this.hasKey=!1,\"function\"==typeof i&&(this.compare=i)}return n(e,t),e.prototype.compare=function(t,e){return t===e},e.prototype._next=function(t){var e=t;if(this.keySelector&&(e=s.tryCatch(this.keySelector)(t))===o.errorObject)return this.destination.error(o.errorObject.e);var i=!1;if(this.hasKey){if((i=s.tryCatch(this.compare)(this.key,e))===o.errorObject)return this.destination.error(o.errorObject.e)}else this.hasKey=!0;!1===Boolean(i)&&(this.key=e,this.destination.next(t))},e}(r.Subscriber)},rgyr:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"8rll\");n.Observable.prototype.scan=r.scan},ri69:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"NeaI\");n.Observable.prototype.throttle=r.throttle},\"s3E+\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"Lhs8\");n.Observable.prototype.do=r._do,n.Observable.prototype._do=r._do},s6Xu:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"e7R1\");n.Observable.prototype.mergeAll=r.mergeAll},sBlj:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"TzlO\");n.Observable.prototype.debounce=r.debounce},sUHN:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"ZTY5\");n.Observable.prototype.toArray=r.toArray},sYdX:function(t,e,i){\"use strict\";e.empty=i(\"36rE\").EmptyObservable.create},saxw:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"1uGz\");e.mapTo=function(t){return function(e){return e.lift(new s(t))}};var s=function(){function t(t){this.value=t}return t.prototype.call=function(t,e){return e.subscribe(new o(t,this.value))},t}(),o=function(t){function e(e,i){t.call(this,e),this.value=i}return n(e,t),e.prototype._next=function(t){this.destination.next(this.value)},e}(r.Subscriber)},skK3:function(t,e,i){\"use strict\";var n=i(\"oQYR\");e.zipProto=function(){for(var t=[],e=0;e<arguments.length;e++)t[e-0]=arguments[e];return n.zip.apply(void 0,t)(this)}},suOF:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"BTim\");e.TimeInterval=r.TimeInterval,e.timeInterval=function(t){return void 0===t&&(t=n.async),r.timeInterval(t)(this)}},svOU:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"zZI/\"),s=i(\"NwwV\"),o=i(\"3WZS\");e.windowTime=function(t){var e=n.async,i=null,c=Number.POSITIVE_INFINITY;return s.isScheduler(arguments[3])&&(e=arguments[3]),s.isScheduler(arguments[2])?e=arguments[2]:r.isNumeric(arguments[2])&&(c=arguments[2]),s.isScheduler(arguments[1])?e=arguments[1]:r.isNumeric(arguments[1])&&(i=arguments[1]),o.windowTime(t,i,c,e)(this)}},t4k3:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"9Kp9\");n.Observable.from=r.from},tHdp:function(t,e,i){\"use strict\";e.of=i(\"rVFa\").ArrayObservable.of},tTnh:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"FEB/\");n.Observable.prototype.distinct=r.distinct},tq08:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"tHdp\");n.Observable.of=r.of},tyYb:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"codN\");n.Observable.bindNodeCallback=r.bindNodeCallback},uH8Z:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"Z57B\");e.timestamp=function(t){return void 0===t&&(t=n.async),r.timestamp(t)(this)}},uJFK:function(t,e,i){\"use strict\";var n=i(\"5aaB\");e.max=function(t){return n.max(t)(this)}},uQuL:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"IwEe\");n.Observable.prototype.finally=r._finally,n.Observable.prototype._finally=r._finally},\"uj+q\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"Re0n\"),s=i(\"hut+\"),o=i(\"9jZZ\"),c=i(\"Irel\");e.timeoutWith=function(t,e,i){return void 0===i&&(i=r.async),function(n){var r=s.isDate(t),o=r?+t-i.now():Math.abs(t);return n.lift(new a(o,r,e,i))}};var a=function(){function t(t,e,i,n){this.waitFor=t,this.absoluteTimeout=e,this.withObservable=i,this.scheduler=n}return t.prototype.call=function(t,e){return e.subscribe(new u(t,this.absoluteTimeout,this.waitFor,this.withObservable,this.scheduler))},t}(),u=function(t){function e(e,i,n,r,s){t.call(this,e),this.absoluteTimeout=i,this.waitFor=n,this.withObservable=r,this.scheduler=s,this.action=null,this.scheduleTimeout()}return n(e,t),e.dispatchTimeout=function(t){var e=t.withObservable;t._unsubscribeAndRecycle(),t.add(c.subscribeToResult(t,e))},e.prototype.scheduleTimeout=function(){var t=this.action;t?this.action=t.schedule(this,this.waitFor):this.add(this.action=this.scheduler.schedule(e.dispatchTimeout,this.waitFor,this))},e.prototype._next=function(e){this.absoluteTimeout||this.scheduleTimeout(),t.prototype._next.call(this,e)},e.prototype._unsubscribe=function(){this.action=null,this.scheduler=null,this.withObservable=null},e}(o.OuterSubscriber)},un7O:function(t,e,i){\"use strict\";var n=i(\"A0iX\");e.concatAll=function(){return n.concatAll()(this)}},urEZ:function(t,e,i){\"use strict\";var n=i(\"0j0j\");e.repeatWhen=function(t){return n.repeatWhen(t)(this)}},\"v/g4\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"cWud\");n.Observable.prototype.windowWhen=r.windowWhen},vIOj:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"LLa1\");n.Observable.prototype.buffer=r.buffer},vqpL:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"8tnl\");n.Observable.if=r._if},w1ve:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"zKHA\"),o=i(\"AJP0\"),c=i(\"8G9e\"),a=function(t){function e(e,i,n,r,s){t.call(this),this.callbackFunc=e,this.selector=i,this.args=n,this.context=r,this.scheduler=s}return n(e,t),e.create=function(t,i,n){return void 0===i&&(i=void 0),function(){for(var r=[],s=0;s<arguments.length;s++)r[s-0]=arguments[s];return new e(t,i,r,this,n)}},e.prototype._subscribe=function(t){var i=this.callbackFunc,n=this.args,r=this.scheduler,a=this.subject;if(r)return r.schedule(e.dispatch,0,{source:this,subscriber:t,context:this.context});if(!a){a=this.subject=new c.AsyncSubject;var u=function t(){for(var e=[],i=0;i<arguments.length;i++)e[i-0]=arguments[i];var n=t.source,r=n.selector,c=n.subject;if(r){var a=s.tryCatch(r).apply(this,e);a===o.errorObject?c.error(o.errorObject.e):(c.next(a),c.complete())}else c.next(e.length<=1?e[0]:e),c.complete()};u.source=this,s.tryCatch(i).apply(this.context,n.concat(u))===o.errorObject&&a.error(o.errorObject.e)}return a.subscribe(t)},e.dispatch=function(t){var e=this,i=t.source,n=t.subscriber,r=t.context,a=i.callbackFunc,h=i.args,p=i.scheduler,f=i.subject;if(!f){f=i.subject=new c.AsyncSubject;var d=function t(){for(var i=[],n=0;n<arguments.length;n++)i[n-0]=arguments[n];var r=t.source,c=r.selector,a=r.subject;if(c){var h=s.tryCatch(c).apply(this,i);e.add(h===o.errorObject?p.schedule(l,0,{err:o.errorObject.e,subject:a}):p.schedule(u,0,{value:h,subject:a}))}else{var f=i.length<=1?i[0]:i;e.add(p.schedule(u,0,{value:f,subject:a}))}};d.source=i,s.tryCatch(a).apply(r,h.concat(d))===o.errorObject&&f.error(o.errorObject.e)}e.add(f.subscribe(n))},e}(r.Observable);function u(t){var e=t.subject;e.next(t.value),e.complete()}function l(t){t.subject.error(t.err)}e.BoundCallbackObservable=a},wELj:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"Re0n\"),s=i(\"1uGz\"),o=i(\"NwwV\");e.bufferTime=function(t){var e=arguments.length,i=r.async;o.isScheduler(arguments[arguments.length-1])&&(i=arguments[arguments.length-1],e--);var n=null;e>=2&&(n=arguments[1]);var s=Number.POSITIVE_INFINITY;return e>=3&&(s=arguments[2]),function(e){return e.lift(new c(t,n,s,i))}};var c=function(){function t(t,e,i,n){this.bufferTimeSpan=t,this.bufferCreationInterval=e,this.maxBufferSize=i,this.scheduler=n}return t.prototype.call=function(t,e){return e.subscribe(new u(t,this.bufferTimeSpan,this.bufferCreationInterval,this.maxBufferSize,this.scheduler))},t}(),a=function(){return function(){this.buffer=[]}}(),u=function(t){function e(e,i,n,r,s){t.call(this,e),this.bufferTimeSpan=i,this.bufferCreationInterval=n,this.maxBufferSize=r,this.scheduler=s,this.contexts=[];var o=this.openContext();if(this.timespanOnly=null==n||n<0,this.timespanOnly)this.add(o.closeAction=s.schedule(l,i,{subscriber:this,context:o,bufferTimeSpan:i}));else{var c={bufferTimeSpan:i,bufferCreationInterval:n,subscriber:this,scheduler:s};this.add(o.closeAction=s.schedule(p,i,{subscriber:this,context:o})),this.add(s.schedule(h,n,c))}}return n(e,t),e.prototype._next=function(t){for(var e,i=this.contexts,n=i.length,r=0;r<n;r++){var s=i[r],o=s.buffer;o.push(t),o.length==this.maxBufferSize&&(e=s)}e&&this.onBufferFull(e)},e.prototype._error=function(e){this.contexts.length=0,t.prototype._error.call(this,e)},e.prototype._complete=function(){for(var e=this.contexts,i=this.destination;e.length>0;){var n=e.shift();i.next(n.buffer)}t.prototype._complete.call(this)},e.prototype._unsubscribe=function(){this.contexts=null},e.prototype.onBufferFull=function(t){this.closeContext(t);var e=t.closeAction;if(e.unsubscribe(),this.remove(e),!this.closed&&this.timespanOnly){t=this.openContext();var i=this.bufferTimeSpan;this.add(t.closeAction=this.scheduler.schedule(l,i,{subscriber:this,context:t,bufferTimeSpan:i}))}},e.prototype.openContext=function(){var t=new a;return this.contexts.push(t),t},e.prototype.closeContext=function(t){this.destination.next(t.buffer);var e=this.contexts;(e?e.indexOf(t):-1)>=0&&e.splice(e.indexOf(t),1)},e}(s.Subscriber);function l(t){var e=t.subscriber,i=t.context;i&&e.closeContext(i),e.closed||(t.context=e.openContext(),t.context.closeAction=this.schedule(t,t.bufferTimeSpan))}function h(t){var e=t.bufferCreationInterval,i=t.bufferTimeSpan,n=t.subscriber,r=t.scheduler,s=n.openContext();n.closed||(n.add(s.closeAction=r.schedule(p,i,{subscriber:n,context:s})),this.schedule(t,e))}function p(t){t.subscriber.closeContext(t.context)}},wEqr:function(t,e,i){\"use strict\";var n=i(\"gSfb\");e.partition=function(t,e){return n.partition(t,e)(this)}},wR93:function(t,e,i){\"use strict\";var n=i(\"1uGz\"),r=i(\"nkkL\"),s=i(\"yz70\");e.toSubscriber=function(t,e,i){if(t){if(t instanceof n.Subscriber)return t;if(t[r.rxSubscriber])return t[r.rxSubscriber]()}return t||e||i?new n.Subscriber(t,e,i):new n.Subscriber(s.empty)}},we3k:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"zKHA\"),s=i(\"AJP0\"),o=i(\"9jZZ\"),c=i(\"Irel\");e.expand=function(t,e,i){return void 0===e&&(e=Number.POSITIVE_INFINITY),void 0===i&&(i=void 0),e=(e||0)<1?Number.POSITIVE_INFINITY:e,function(n){return n.lift(new a(t,e,i))}};var a=function(){function t(t,e,i){this.project=t,this.concurrent=e,this.scheduler=i}return t.prototype.call=function(t,e){return e.subscribe(new u(t,this.project,this.concurrent,this.scheduler))},t}();e.ExpandOperator=a;var u=function(t){function e(e,i,n,r){t.call(this,e),this.project=i,this.concurrent=n,this.scheduler=r,this.index=0,this.active=0,this.hasCompleted=!1,n<Number.POSITIVE_INFINITY&&(this.buffer=[])}return n(e,t),e.dispatch=function(t){t.subscriber.subscribeToProjection(t.result,t.value,t.index)},e.prototype._next=function(t){var i=this.destination;if(i.closed)this._complete();else{var n=this.index++;if(this.active<this.concurrent){i.next(t);var o=r.tryCatch(this.project)(t,n);o===s.errorObject?i.error(s.errorObject.e):this.scheduler?this.add(this.scheduler.schedule(e.dispatch,0,{subscriber:this,result:o,value:t,index:n})):this.subscribeToProjection(o,t,n)}else this.buffer.push(t)}},e.prototype.subscribeToProjection=function(t,e,i){this.active++,this.add(c.subscribeToResult(this,t,e,i))},e.prototype._complete=function(){this.hasCompleted=!0,this.hasCompleted&&0===this.active&&this.destination.complete()},e.prototype.notifyNext=function(t,e,i,n,r){this._next(e)},e.prototype.notifyComplete=function(t){var e=this.buffer;this.remove(t),this.active--,e&&e.length>0&&this._next(e.shift()),this.hasCompleted&&0===this.active&&this.destination.complete()},e}(o.OuterSubscriber);e.ExpandSubscriber=u},wowj:function(t,e,i){\"use strict\";var n=i(\"0Iwa\");e.window=function(t){return n.window(t)(this)}},wqBB:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"8FKM\");n.Observable.prototype.sequenceEqual=r.sequenceEqual},xFrw:function(t,e,i){\"use strict\";var n=i(\"Q6nm\");e.GroupedObservable=n.GroupedObservable,e.groupBy=function(t,e,i,r){return n.groupBy(t,e,i,r)(this)}},\"xL+R\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"jRt/\");n.Observable.prototype.min=r.min},xLgF:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"iaCc\");n.Observable.range=r.range},xQMj:function(t,e,i){\"use strict\";var n=i(\"ZXB4\");e.filter=function(t,e){return n.filter(t,e)(this)}},xxrh:function(t,e,i){\"use strict\";e.fromPromise=i(\"r2oo\").PromiseObservable.create},xzWc:function(t,e,i){\"use strict\";var n=i(\"4WIM\");e.Subject=n.Subject,e.AnonymousSubject=n.AnonymousSubject,e.Observable=i(\"AZf1\").Observable,e.Subscription=i(\"y2i3\").Subscription,e.Subscriber=i(\"1uGz\").Subscriber,e.AsyncSubject=i(\"8G9e\").AsyncSubject,e.ReplaySubject=i(\"BjeI\").ReplaySubject,e.BehaviorSubject=i(\"Bx9r\").BehaviorSubject,e.ConnectableObservable=i(\"3VCA\").ConnectableObservable,e.Notification=i(\"9x29\").Notification,e.EmptyError=i(\"2fIB\").EmptyError,e.ArgumentOutOfRangeError=i(\"8kg7\").ArgumentOutOfRangeError,e.ObjectUnsubscribedError=i(\"PCq3\").ObjectUnsubscribedError,e.TimeoutError=i(\"4qOA\").TimeoutError,e.UnsubscriptionError=i(\"kwlx\").UnsubscriptionError,e.TimeInterval=i(\"suOF\").TimeInterval,e.Timestamp=i(\"Z57B\").Timestamp,e.TestScheduler=i(\"ZnfZ\").TestScheduler,e.VirtualTimeScheduler=i(\"J9JT\").VirtualTimeScheduler;var r=i(\"oemf\");e.AjaxResponse=r.AjaxResponse,e.AjaxError=r.AjaxError,e.AjaxTimeoutError=r.AjaxTimeoutError,e.pipe=i(\"GyLc\").pipe;var s=i(\"JB8t\"),o=i(\"Re0n\"),c=i(\"VZMG\"),a=i(\"BoXX\"),u=i(\"nkkL\"),l=i(\"+2+e\"),h=i(\"WU5C\");e.operators=i(\"f0q5\"),e.Scheduler={asap:s.asap,queue:c.queue,animationFrame:a.animationFrame,async:o.async},e.Symbol={rxSubscriber:u.rxSubscriber,observable:h.observable,iterator:l.iterator}},y2i3:function(t,e,i){\"use strict\";var n=i(\"G2HO\"),r=i(\"pYXR\"),s=i(\"PFc+\"),o=i(\"zKHA\"),c=i(\"AJP0\"),a=i(\"kwlx\");function u(t){return t.reduce(function(t,e){return t.concat(e instanceof a.UnsubscriptionError?e.errors:e)},[])}e.Subscription=function(){function t(t){this.closed=!1,this._parent=null,this._parents=null,this._subscriptions=null,t&&(this._unsubscribe=t)}var e;return t.prototype.unsubscribe=function(){var t,e=!1;if(!this.closed){var i=this,l=i._parent,h=i._parents,p=i._unsubscribe,f=i._subscriptions;this.closed=!0,this._parent=null,this._parents=null,this._subscriptions=null;for(var d=-1,b=h?h.length:0;l;)l.remove(this),l=++d<b&&h[d]||null;if(s.isFunction(p)&&o.tryCatch(p).call(this)===c.errorObject&&(e=!0,t=t||(c.errorObject.e instanceof a.UnsubscriptionError?u(c.errorObject.e.errors):[c.errorObject.e])),n.isArray(f))for(d=-1,b=f.length;++d<b;){var v=f[d];if(r.isObject(v)&&o.tryCatch(v.unsubscribe).call(v)===c.errorObject){e=!0,t=t||[];var y=c.errorObject.e;y instanceof a.UnsubscriptionError?t=t.concat(u(y.errors)):t.push(y)}}if(e)throw new a.UnsubscriptionError(t)}},t.prototype.add=function(e){if(!e||e===t.EMPTY)return t.EMPTY;if(e===this)return this;var i=e;switch(typeof e){case\"function\":i=new t(e);case\"object\":if(i.closed||\"function\"!=typeof i.unsubscribe)return i;if(this.closed)return i.unsubscribe(),i;if(\"function\"!=typeof i._addParent){var n=i;(i=new t)._subscriptions=[n]}break;default:throw new Error(\"unrecognized teardown \"+e+\" added to Subscription.\")}return(this._subscriptions||(this._subscriptions=[])).push(i),i._addParent(this),i},t.prototype.remove=function(t){var e=this._subscriptions;if(e){var i=e.indexOf(t);-1!==i&&e.splice(i,1)}},t.prototype._addParent=function(t){var e=this._parent,i=this._parents;e&&e!==t?i?-1===i.indexOf(t)&&i.push(t):this._parents=[t]:this._parent=t},t.EMPTY=((e=new t).closed=!0,e),t}()},y7vd:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"6VCA\");n.Observable.race=r.race},yA04:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"OVX6\");n.Observable.prototype.every=r.every},yP7H:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"pZ8H\");n.Observable.prototype.defaultIfEmpty=r.defaultIfEmpty},ybuh:function(t,e,i){\"use strict\";i.r(e),i.d(e,\"ProductsModule\",function(){return mi});var n=i(\"ofXK\"),r=i(\"3Pt+\"),s=i(\"tyNb\"),o=i(\"sYmb\"),c=i(\"hzby\"),a=i(\"Lm2G\"),u=(i(\"rePB\"),i(\"1OyB\")),l=i(\"vuIU\"),h=i(\"fXoL\"),p=function(){var t=function(){function t(){Object(u.a)(this,t)}return Object(l.a)(t,null,[{key:\"forRoot\",value:function(){return{ngModule:t,providers:[]}}}])}();return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275mod=h.Kb({type:t}),t.\\u0275inj=h.Jb({imports:[[n.c]]}),t}(),f=i(\"md7G\"),d=i(\"2WcH\"),b=i(\"foSv\"),v=i(\"Ji7U\"),y=i(\"2Vo4\"),m=i(\"2oBD\");function g(t,e){1&t&&(h.Sb(0,\"td\"),h.Dc(1,\"\\xa0\\xa0\\xa0\"),h.Rb())}function w(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"td\"),h.Sb(1,\"a\",1),h.Zb(\"click\",function(){h.vc(i);var t=h.bc();return t.changeMinutes(t.minuteStep)}),h.Nb(2,\"span\",2),h.Rb(),h.Rb()}if(2&t){var n=h.bc();h.Ab(1),h.Eb(\"disabled\",!n.canIncrementMinutes||!n.isEditable)}}function O(t,e){1&t&&(h.Sb(0,\"td\"),h.Dc(1,\"\\xa0\"),h.Rb())}function S(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"td\"),h.Sb(1,\"a\",1),h.Zb(\"click\",function(){h.vc(i);var t=h.bc();return t.changeSeconds(t.secondsStep)}),h.Nb(2,\"span\",2),h.Rb(),h.Rb()}if(2&t){var n=h.bc();h.Ab(1),h.Eb(\"disabled\",!n.canIncrementSeconds||!n.isEditable)}}function x(t,e){1&t&&(h.Sb(0,\"td\"),h.Dc(1,\"\\xa0\\xa0\\xa0\"),h.Rb())}function _(t,e){1&t&&h.Nb(0,\"td\")}function k(t,e){1&t&&(h.Sb(0,\"td\"),h.Dc(1,\"\\xa0:\\xa0\"),h.Rb())}function E(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"td\",4),h.Sb(1,\"input\",5),h.Zb(\"wheel\",function(t){h.vc(i);var e=h.bc();return e.prevDef(t),e.changeMinutes(e.minuteStep*e.wheelSign(t),\"wheel\")})(\"keydown.ArrowUp\",function(){h.vc(i);var t=h.bc();return t.changeMinutes(t.minuteStep,\"key\")})(\"keydown.ArrowDown\",function(){h.vc(i);var t=h.bc();return t.changeMinutes(-t.minuteStep,\"key\")})(\"change\",function(t){return h.vc(i),h.bc().updateMinutes(t.target.value)}),h.Rb(),h.Rb()}if(2&t){var n=h.bc();h.Eb(\"has-error\",n.invalidMinutes),h.Ab(1),h.Eb(\"is-invalid\",n.invalidMinutes),h.ic(\"placeholder\",n.minutesPlaceholder)(\"readonly\",n.readonlyInput)(\"disabled\",n.disabled)(\"value\",n.minutes),h.Bb(\"aria-label\",n.labelMinutes)}}function A(t,e){1&t&&(h.Sb(0,\"td\"),h.Dc(1,\"\\xa0:\\xa0\"),h.Rb())}function T(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"td\",4),h.Sb(1,\"input\",5),h.Zb(\"wheel\",function(t){h.vc(i);var e=h.bc();return e.prevDef(t),e.changeSeconds(e.secondsStep*e.wheelSign(t),\"wheel\")})(\"keydown.ArrowUp\",function(){h.vc(i);var t=h.bc();return t.changeSeconds(t.secondsStep,\"key\")})(\"keydown.ArrowDown\",function(){h.vc(i);var t=h.bc();return t.changeSeconds(-t.secondsStep,\"key\")})(\"change\",function(t){return h.vc(i),h.bc().updateSeconds(t.target.value)}),h.Rb(),h.Rb()}if(2&t){var n=h.bc();h.Eb(\"has-error\",n.invalidSeconds),h.Ab(1),h.Eb(\"is-invalid\",n.invalidSeconds),h.ic(\"placeholder\",n.secondsPlaceholder)(\"readonly\",n.readonlyInput)(\"disabled\",n.disabled)(\"value\",n.seconds),h.Bb(\"aria-label\",n.labelSeconds)}}function C(t,e){1&t&&(h.Sb(0,\"td\"),h.Dc(1,\"\\xa0\\xa0\\xa0\"),h.Rb())}function j(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"td\"),h.Sb(1,\"button\",8),h.Zb(\"click\",function(){return h.vc(i),h.bc().toggleMeridian()}),h.Dc(2),h.Rb(),h.Rb()}if(2&t){var n=h.bc();h.Ab(1),h.Eb(\"disabled\",!n.isEditable||!n.canToggleMeridian),h.ic(\"disabled\",!n.isEditable||!n.canToggleMeridian),h.Ab(1),h.Fc(\"\",n.meridian,\" \")}}function P(t,e){1&t&&(h.Sb(0,\"td\"),h.Dc(1,\"\\xa0\\xa0\\xa0\"),h.Rb())}function I(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"td\"),h.Sb(1,\"a\",1),h.Zb(\"click\",function(){h.vc(i);var t=h.bc();return t.changeMinutes(-t.minuteStep)}),h.Nb(2,\"span\",7),h.Rb(),h.Rb()}if(2&t){var n=h.bc();h.Ab(1),h.Eb(\"disabled\",!n.canDecrementMinutes||!n.isEditable)}}function M(t,e){1&t&&(h.Sb(0,\"td\"),h.Dc(1,\"\\xa0\"),h.Rb())}function L(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"td\"),h.Sb(1,\"a\",1),h.Zb(\"click\",function(){h.vc(i);var t=h.bc();return t.changeSeconds(-t.secondsStep)}),h.Nb(2,\"span\",7),h.Rb(),h.Rb()}if(2&t){var n=h.bc();h.Ab(1),h.Eb(\"disabled\",!n.canDecrementSeconds||!n.isEditable)}}function V(t,e){1&t&&(h.Sb(0,\"td\"),h.Dc(1,\"\\xa0\\xa0\\xa0\"),h.Rb())}function N(t,e){1&t&&h.Nb(0,\"td\")}var R=function(){var t=function(){function t(){Object(u.a)(this,t)}return Object(l.a)(t,[{key:\"writeValue\",value:function(e){return{type:t.WRITE_VALUE,payload:e}}},{key:\"changeHours\",value:function(e){return{type:t.CHANGE_HOURS,payload:e}}},{key:\"changeMinutes\",value:function(e){return{type:t.CHANGE_MINUTES,payload:e}}},{key:\"changeSeconds\",value:function(e){return{type:t.CHANGE_SECONDS,payload:e}}},{key:\"setTime\",value:function(e){return{type:t.SET_TIME_UNIT,payload:e}}},{key:\"updateControls\",value:function(e){return{type:t.UPDATE_CONTROLS,payload:e}}}])}();return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275prov=h.Ib({token:t,factory:t.\\u0275fac}),t.WRITE_VALUE=\"[timepicker] write value from ng model\",t.CHANGE_HOURS=\"[timepicker] change hours\",t.CHANGE_MINUTES=\"[timepicker] change minutes\",t.CHANGE_SECONDS=\"[timepicker] change seconds\",t.SET_TIME_UNIT=\"[timepicker] set time unit\",t.UPDATE_CONTROLS=\"[timepicker] update controls\",t}();function H(t){return!!t&&!(t instanceof Date&&isNaN(t.getHours()))&&(\"string\"!=typeof t||H(new Date(t)))}function F(t,e){return!(t.min&&e<t.min||t.max&&e>t.max)}function B(t){return\"number\"==typeof t?t:parseInt(t,10)}function D(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=B(t);return isNaN(i)||i<0||i>(e?12:24)?NaN:i}function Z(t){var e=B(t);return isNaN(e)||e<0||e>60?NaN:e}function z(t){var e=B(t);return isNaN(e)||e<0||e>60?NaN:e}function U(t){return\"string\"==typeof t?new Date(t):t}function W(t,e){if(!t)return W(q(new Date,0,0,0),e);var i=t.getHours(),n=t.getMinutes(),r=t.getSeconds();return e.hour&&(i+=B(e.hour)),e.minute&&(n+=B(e.minute)),e.seconds&&(r+=B(e.seconds)),q(t,i,n,r)}function G(t,e){var i=D(e.hour),n=Z(e.minute),r=z(e.seconds)||0;return e.isPM&&12!==i&&(i+=12),t?isNaN(i)||isNaN(n)?t:q(t,i,n,r):isNaN(i)||isNaN(n)?t:q(new Date,i,n,r)}function q(t,e,i,n){var r=new Date(t.getFullYear(),t.getMonth(),t.getDate(),e,i,n,t.getMilliseconds());return r.setFullYear(t.getFullYear()),r.setMonth(t.getMonth()),r.setDate(t.getDate()),r}function K(t){var e=t.toString();return e.length>1?e:\"0\".concat(e)}function Y(t,e){return!isNaN(D(t,e))}function X(t){return!isNaN(Z(t))}function J(t){return!isNaN(z(t))}function Q(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"0\",i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:\"0\",n=arguments.length>3?arguments[3]:void 0;return Y(t,n)&&X(e)&&J(i)}function $(t,e){if(t.readonlyInput||t.disabled)return!1;if(e){if(\"wheel\"===e.source&&!t.mousewheel)return!1;if(\"key\"===e.source&&!t.arrowkeys)return!1}return!0}function tt(t,e){return!(!t.step||t.step>0&&!e.canIncrementHours||t.step<0&&!e.canDecrementHours)}function et(t,e){return!(!t.step||t.step>0&&!e.canIncrementMinutes||t.step<0&&!e.canDecrementMinutes)}function it(t,e){return!(!t.step||t.step>0&&!e.canIncrementSeconds||t.step<0&&!e.canDecrementSeconds)}function nt(t){return{hourStep:t.hourStep,minuteStep:t.minuteStep,secondsStep:t.secondsStep,readonlyInput:t.readonlyInput,disabled:t.disabled,mousewheel:t.mousewheel,arrowkeys:t.arrowkeys,showSpinners:t.showSpinners,showMeridian:t.showMeridian,showSeconds:t.showSeconds,meridians:t.meridians,min:t.min,max:t.max}}function rt(t,e){var i=e.min,n=e.max,r=e.hourStep,s=e.minuteStep,o=e.secondsStep,c=e.showSeconds,a={canIncrementHours:!0,canIncrementMinutes:!0,canIncrementSeconds:!0,canDecrementHours:!0,canDecrementMinutes:!0,canDecrementSeconds:!0,canToggleMeridian:!0};if(!t)return a;if(n){var u=W(t,{hour:r});if(a.canIncrementHours=n>u&&t.getHours()+r<24,!a.canIncrementHours){var l=W(t,{minute:s});a.canIncrementMinutes=c?n>l:n>=l}if(!a.canIncrementMinutes){var h=W(t,{seconds:o});a.canIncrementSeconds=n>=h}t.getHours()<12&&(a.canToggleMeridian=W(t,{hour:12})<n)}if(i){var p=W(t,{hour:-r});if(a.canDecrementHours=i<p,!a.canDecrementHours){var f=W(t,{minute:-s});a.canDecrementMinutes=c?i<f:i<=f}if(!a.canDecrementMinutes){var d=W(t,{seconds:-o});a.canDecrementSeconds=i<=d}t.getHours()>=12&&(a.canToggleMeridian=W(t,{hour:-12})>i)}return a}var st=function(){var t=Object(l.a)(function t(){Object(u.a)(this,t),this.hourStep=1,this.minuteStep=5,this.secondsStep=10,this.showMeridian=!0,this.meridians=[\"AM\",\"PM\"],this.readonlyInput=!1,this.disabled=!1,this.mousewheel=!0,this.arrowkeys=!0,this.showSpinners=!0,this.showSeconds=!1,this.showMinutes=!0,this.hoursPlaceholder=\"HH\",this.minutesPlaceholder=\"MM\",this.secondsPlaceholder=\"SS\",this.ariaLabelHours=\"hours\",this.ariaLabelMinutes=\"minutes\",this.ariaLabelSeconds=\"seconds\"});return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275prov=Object(h.Ib)({factory:function(){return new t},token:t,providedIn:\"root\"}),t}(),ot={value:null,config:new st,controls:{canIncrementHours:!0,canIncrementMinutes:!0,canIncrementSeconds:!0,canDecrementHours:!0,canDecrementMinutes:!0,canDecrementSeconds:!0,canToggleMeridian:!0}};function ct(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:ot,e=arguments.length>1?arguments[1]:void 0;switch(e.type){case R.WRITE_VALUE:return Object.assign({},t,{value:e.payload});case R.CHANGE_HOURS:if(!$(t.config,e.payload)||!tt(e.payload,t.controls))return t;var i=W(t.value,{hour:e.payload.step});return!t.config.max&&!t.config.min||F(t.config,i)?Object.assign({},t,{value:i}):t;case R.CHANGE_MINUTES:if(!$(t.config,e.payload)||!et(e.payload,t.controls))return t;var n=W(t.value,{minute:e.payload.step});return!t.config.max&&!t.config.min||F(t.config,n)?Object.assign({},t,{value:n}):t;case R.CHANGE_SECONDS:if(!$(t.config,e.payload)||!it(e.payload,t.controls))return t;var r=W(t.value,{seconds:e.payload.step});return!t.config.max&&!t.config.min||F(t.config,r)?Object.assign({},t,{value:r}):t;case R.SET_TIME_UNIT:if(!$(t.config))return t;var s=G(t.value,e.payload);return Object.assign({},t,{value:s});case R.UPDATE_CONTROLS:var o=rt(t.value,e.payload),c={value:t.value,config:e.payload,controls:o};return t.config.showMeridian!==c.config.showMeridian&&t.value&&(c.value=new Date(t.value)),Object.assign({},t,c);default:return t}}var at=function(){var t=function(t){function e(){Object(u.a)(this,e);var t,i,n,r=new y.a({type:\"[mini-ngrx] dispatcher init\"});return t=this,i=e,n=[r,ct,new m.a(ot,r,ct)],i=Object(b.a)(i),Object(f.a)(t,Object(d.a)()?Reflect.construct(i,n||[],Object(b.a)(t).constructor):i.apply(t,n))}return Object(v.a)(e,t),Object(l.a)(e)}(m.b);return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275prov=h.Ib({token:t,factory:t.\\u0275fac}),t}(),ut={provide:r.h,useExisting:Object(h.T)(function(){return lt}),multi:!0},lt=function(){var t=function(){return Object(l.a)(function t(e,i,n,r){var s=this;Object(u.a)(this,t),this._cd=i,this._store=n,this._timepickerActions=r,this.isValid=new h.n,this.invalidHours=!1,this.invalidMinutes=!1,this.invalidSeconds=!1,this.onChange=Function.prototype,this.onTouched=Function.prototype,Object.assign(this,e),this.timepickerSub=n.select(function(t){return t.value}).subscribe(function(t){s._renderTime(t),s.onChange(t),s._store.dispatch(s._timepickerActions.updateControls(nt(s)))}),n.select(function(t){return t.controls}).subscribe(function(t){s.isValid.emit(Q(s.hours,s.minutes,s.seconds,s.isPM())),Object.assign(s,t),i.markForCheck()})},[{key:\"isSpinnersVisible\",get:function(){return this.showSpinners&&!this.readonlyInput}},{key:\"isEditable\",get:function(){return!(this.readonlyInput||this.disabled)}},{key:\"resetValidation\",value:function(){this.invalidHours=!1,this.invalidMinutes=!1,this.invalidSeconds=!1}},{key:\"isPM\",value:function(){return this.showMeridian&&this.meridian===this.meridians[1]}},{key:\"prevDef\",value:function(t){t.preventDefault()}},{key:\"wheelSign\",value:function(t){return-1*Math.sign(t.deltaY)}},{key:\"ngOnChanges\",value:function(t){this._store.dispatch(this._timepickerActions.updateControls(nt(this)))}},{key:\"changeHours\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\";this.resetValidation(),this._store.dispatch(this._timepickerActions.changeHours({step:t,source:e}))}},{key:\"changeMinutes\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\";this.resetValidation(),this._store.dispatch(this._timepickerActions.changeMinutes({step:t,source:e}))}},{key:\"changeSeconds\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\";this.resetValidation(),this._store.dispatch(this._timepickerActions.changeSeconds({step:t,source:e}))}},{key:\"updateHours\",value:function(t){if(this.resetValidation(),this.hours=t,!Y(this.hours,this.isPM())||!this.isValidLimit())return this.invalidHours=!0,this.isValid.emit(!1),void this.onChange(null);this._updateTime()}},{key:\"updateMinutes\",value:function(t){if(this.resetValidation(),this.minutes=t,!X(this.minutes)||!this.isValidLimit())return this.invalidMinutes=!0,this.isValid.emit(!1),void this.onChange(null);this._updateTime()}},{key:\"updateSeconds\",value:function(t){if(this.resetValidation(),this.seconds=t,!J(this.seconds)||!this.isValidLimit())return this.invalidSeconds=!0,this.isValid.emit(!1),void this.onChange(null);this._updateTime()}},{key:\"isValidLimit\",value:function(){return t={hour:this.hours,minute:this.minutes,seconds:this.seconds,isPM:this.isPM()},e=this.max,i=this.min,n=G(new Date,t),!(e&&n>e||i&&n<i);var t,e,i,n}},{key:\"_updateTime\",value:function(){if(!Q(this.hours,this.showMinutes?this.minutes:void 0,this.showSeconds?this.seconds:void 0,this.isPM()))return this.isValid.emit(!1),void this.onChange(null);this._store.dispatch(this._timepickerActions.setTime({hour:this.hours,minute:this.minutes,seconds:this.seconds,isPM:this.isPM()}))}},{key:\"toggleMeridian\",value:function(){this.showMeridian&&this.isEditable&&this._store.dispatch(this._timepickerActions.changeHours({step:12,source:\"\"}))}},{key:\"writeValue\",value:function(t){H(t)?this._store.dispatch(this._timepickerActions.writeValue(U(t))):null==t&&this._store.dispatch(this._timepickerActions.writeValue(null))}},{key:\"registerOnChange\",value:function(t){this.onChange=t}},{key:\"registerOnTouched\",value:function(t){this.onTouched=t}},{key:\"setDisabledState\",value:function(t){this.disabled=t,this._cd.markForCheck()}},{key:\"ngOnDestroy\",value:function(){this.timepickerSub.unsubscribe()}},{key:\"_renderTime\",value:function(t){if(!H(t))return this.hours=\"\",this.minutes=\"\",this.seconds=\"\",void(this.meridian=this.meridians[0]);var e=U(t),i=e.getHours();this.showMeridian&&(this.meridian=this.meridians[i>=12?1:0],0==(i%=12)&&(i=12)),this.hours=K(i),this.minutes=K(e.getMinutes()),this.seconds=K(e.getUTCSeconds())}}])}();return t.\\u0275fac=function(e){return new(e||t)(h.Mb(st),h.Mb(h.h),h.Mb(at),h.Mb(R))},t.\\u0275cmp=h.Gb({type:t,selectors:[[\"timepicker\"]],inputs:{disabled:\"disabled\",hourStep:\"hourStep\",minuteStep:\"minuteStep\",secondsStep:\"secondsStep\",readonlyInput:\"readonlyInput\",mousewheel:\"mousewheel\",arrowkeys:\"arrowkeys\",showSpinners:\"showSpinners\",showMeridian:\"showMeridian\",showMinutes:\"showMinutes\",showSeconds:\"showSeconds\",meridians:\"meridians\",min:\"min\",max:\"max\",hoursPlaceholder:\"hoursPlaceholder\",minutesPlaceholder:\"minutesPlaceholder\",secondsPlaceholder:\"secondsPlaceholder\"},outputs:{isValid:\"isValid\"},features:[h.zb([ut,at]),h.yb],decls:31,vars:33,consts:[[1,\"text-center\",3,\"hidden\"],[1,\"btn\",\"btn-link\",3,\"click\"],[1,\"bs-chevron\",\"bs-chevron-up\"],[4,\"ngIf\"],[1,\"form-group\"],[\"type\",\"text\",\"maxlength\",\"2\",1,\"form-control\",\"text-center\",\"bs-timepicker-field\",3,\"placeholder\",\"readonly\",\"disabled\",\"value\",\"wheel\",\"keydown.ArrowUp\",\"keydown.ArrowDown\",\"change\"],[\"class\",\"form-group\",3,\"has-error\",4,\"ngIf\"],[1,\"bs-chevron\",\"bs-chevron-down\"],[\"type\",\"button\",1,\"btn\",\"btn-default\",\"text-center\",3,\"disabled\",\"click\"]],template:function(t,e){1&t&&(h.Sb(0,\"table\"),h.Sb(1,\"tbody\"),h.Sb(2,\"tr\",0),h.Sb(3,\"td\"),h.Sb(4,\"a\",1),h.Zb(\"click\",function(){return e.changeHours(e.hourStep)}),h.Nb(5,\"span\",2),h.Rb(),h.Rb(),h.Bc(6,g,2,0,\"td\",3),h.Bc(7,w,3,2,\"td\",3),h.Bc(8,O,2,0,\"td\",3),h.Bc(9,S,3,2,\"td\",3),h.Bc(10,x,2,0,\"td\",3),h.Bc(11,_,1,0,\"td\",3),h.Rb(),h.Sb(12,\"tr\"),h.Sb(13,\"td\",4),h.Sb(14,\"input\",5),h.Zb(\"wheel\",function(t){return e.prevDef(t),e.changeHours(e.hourStep*e.wheelSign(t),\"wheel\")})(\"keydown.ArrowUp\",function(){return e.changeHours(e.hourStep,\"key\")})(\"keydown.ArrowDown\",function(){return e.changeHours(-e.hourStep,\"key\")})(\"change\",function(t){return e.updateHours(t.target.value)}),h.Rb(),h.Rb(),h.Bc(15,k,2,0,\"td\",3),h.Bc(16,E,2,9,\"td\",6),h.Bc(17,A,2,0,\"td\",3),h.Bc(18,T,2,9,\"td\",6),h.Bc(19,C,2,0,\"td\",3),h.Bc(20,j,3,4,\"td\",3),h.Rb(),h.Sb(21,\"tr\",0),h.Sb(22,\"td\"),h.Sb(23,\"a\",1),h.Zb(\"click\",function(){return e.changeHours(-e.hourStep)}),h.Nb(24,\"span\",7),h.Rb(),h.Rb(),h.Bc(25,P,2,0,\"td\",3),h.Bc(26,I,3,2,\"td\",3),h.Bc(27,M,2,0,\"td\",3),h.Bc(28,L,3,2,\"td\",3),h.Bc(29,V,2,0,\"td\",3),h.Bc(30,N,1,0,\"td\",3),h.Rb(),h.Rb(),h.Rb()),2&t&&(h.Ab(2),h.ic(\"hidden\",!e.showSpinners),h.Ab(2),h.Eb(\"disabled\",!e.canIncrementHours||!e.isEditable),h.Ab(2),h.ic(\"ngIf\",e.showMinutes),h.Ab(1),h.ic(\"ngIf\",e.showMinutes),h.Ab(1),h.ic(\"ngIf\",e.showSeconds),h.Ab(1),h.ic(\"ngIf\",e.showSeconds),h.Ab(1),h.ic(\"ngIf\",e.showMeridian),h.Ab(1),h.ic(\"ngIf\",e.showMeridian),h.Ab(2),h.Eb(\"has-error\",e.invalidHours),h.Ab(1),h.Eb(\"is-invalid\",e.invalidHours),h.ic(\"placeholder\",e.hoursPlaceholder)(\"readonly\",e.readonlyInput)(\"disabled\",e.disabled)(\"value\",e.hours),h.Bb(\"aria-label\",e.labelHours),h.Ab(1),h.ic(\"ngIf\",e.showMinutes),h.Ab(1),h.ic(\"ngIf\",e.showMinutes),h.Ab(1),h.ic(\"ngIf\",e.showSeconds),h.Ab(1),h.ic(\"ngIf\",e.showSeconds),h.Ab(1),h.ic(\"ngIf\",e.showMeridian),h.Ab(1),h.ic(\"ngIf\",e.showMeridian),h.Ab(1),h.ic(\"hidden\",!e.showSpinners),h.Ab(2),h.Eb(\"disabled\",!e.canDecrementHours||!e.isEditable),h.Ab(2),h.ic(\"ngIf\",e.showMinutes),h.Ab(1),h.ic(\"ngIf\",e.showMinutes),h.Ab(1),h.ic(\"ngIf\",e.showSeconds),h.Ab(1),h.ic(\"ngIf\",e.showSeconds),h.Ab(1),h.ic(\"ngIf\",e.showMeridian),h.Ab(1),h.ic(\"ngIf\",e.showMeridian))},directives:[n.l],styles:[\"\\n    .bs-chevron {\\n      border-style: solid;\\n      display: block;\\n      width: 9px;\\n      height: 9px;\\n      position: relative;\\n      border-width: 3px 0px 0 3px;\\n    }\\n\\n    .bs-chevron-up {\\n      -webkit-transform: rotate(45deg);\\n      transform: rotate(45deg);\\n      top: 2px;\\n    }\\n\\n    .bs-chevron-down {\\n      -webkit-transform: rotate(-135deg);\\n      transform: rotate(-135deg);\\n      top: -2px;\\n    }\\n\\n    .bs-timepicker-field {\\n      width: 50px;\\n      padding: .375rem .55rem;\\n    }\\n  \"],encapsulation:2,changeDetection:0}),t}(),ht=function(){var t=function(){function t(){Object(u.a)(this,t)}return Object(l.a)(t,null,[{key:\"forRoot\",value:function(){return{ngModule:t,providers:[R,at]}}}])}();return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275mod=h.Kb({type:t}),t.\\u0275inj=h.Jb({imports:[[n.c]]}),t}(),pt=i(\"bhfF\"),ft=i(\"uFwe\"),dt=i(\"xzWc\"),bt=i(\"f0q5\"),vt=i(\"A/ap\"),yt=i.n(vt);function mt(t,e,i){return e=Object(b.a)(e),Object(f.a)(t,Object(d.a)()?Reflect.construct(e,i||[],Object(b.a)(t).constructor):e.apply(t,i))}var gt=[\"tooltipTemplate\"],wt=[\"leftOuterSelectionBar\"],Ot=[\"rightOuterSelectionBar\"],St=[\"fullBar\"],xt=[\"selectionBar\"],_t=[\"minHandle\"],kt=[\"maxHandle\"],Et=[\"floorLabel\"],At=[\"ceilLabel\"],Tt=[\"minHandleLabel\"],Ct=[\"maxHandleLabel\"],jt=[\"combinedLabel\"],Pt=[\"ticksElement\"];function It(t,e){if(1&t&&h.Nb(0,\"ng5-slider-tooltip-wrapper\",31),2&t){var i=h.bc().$implicit,n=h.bc();h.ic(\"template\",n.tooltipTemplate)(\"tooltip\",i.valueTooltip)(\"placement\",i.valueTooltipPlacement)(\"content\",i.value)}}function Mt(t,e){if(1&t&&h.Nb(0,\"span\",32),2&t){var i=h.bc().$implicit;h.ic(\"innerHTML\",i.legend,h.wc)}}var Lt=function(t){return{\"ng5-slider-selected\":t}};function Vt(t,e){if(1&t&&(h.Sb(0,\"span\",27),h.Nb(1,\"ng5-slider-tooltip-wrapper\",28),h.Bc(2,It,1,4,\"ng5-slider-tooltip-wrapper\",29),h.Bc(3,Mt,1,1,\"span\",30),h.Rb()),2&t){var i=e.$implicit,n=h.bc();h.ic(\"ngClass\",h.mc(7,Lt,i.selected))(\"ngStyle\",i.style),h.Ab(1),h.ic(\"template\",n.tooltipTemplate)(\"tooltip\",i.tooltip)(\"placement\",i.tooltipPlacement),h.Ab(1),h.ic(\"ngIf\",null!=i.value),h.Ab(1),h.ic(\"ngIf\",null!=i.legend)}}function Nt(t,e){}function Rt(t,e){1&t&&h.Bc(0,Nt,0,0,\"ng-template\")}var Ht=function(t,e,i){return{tooltip:t,placement:e,content:i}};function Ft(t,e){if(1&t&&(h.Qb(0),h.Bc(1,Rt,1,0,void 0,1),h.Pb()),2&t){var i=h.bc();h.Ab(1),h.ic(\"ngTemplateOutlet\",i.template)(\"ngTemplateOutletContext\",h.oc(2,Ht,i.tooltip,i.placement,i.content))}}function Bt(t,e){if(1&t&&(h.Qb(0),h.Sb(1,\"div\",2),h.Dc(2),h.Rb(),h.Pb()),2&t){var i=h.bc();h.Ab(1),h.Bb(\"title\",i.tooltip)(\"data-tooltip-placement\",i.placement),h.Ab(1),h.Fc(\" \",i.content,\" \")}}var Dt={Min:0,Max:1};Dt[Dt.Min]=\"Min\",Dt[Dt.Max]=\"Max\";var Zt={Low:0,High:1,Floor:2,Ceil:3,TickValue:4};Zt[Zt.Low]=\"Low\",Zt[Zt.High]=\"High\",Zt[Zt.Floor]=\"Floor\",Zt[Zt.Ceil]=\"Ceil\",Zt[Zt.TickValue]=\"TickValue\";var zt=Object(l.a)(function t(){Object(u.a)(this,t),this.floor=0,this.ceil=null,this.step=1,this.minRange=null,this.maxRange=null,this.pushRange=!1,this.minLimit=null,this.maxLimit=null,this.translate=null,this.combineLabels=null,this.getLegend=null,this.stepsArray=null,this.bindIndexForStepsArray=!1,this.draggableRange=!1,this.draggableRangeOnly=!1,this.showSelectionBar=!1,this.showSelectionBarEnd=!1,this.showSelectionBarFromValue=null,this.showOuterSelectionBars=!1,this.hidePointerLabels=!1,this.hideLimitLabels=!1,this.autoHideLimitLabels=!0,this.readOnly=!1,this.disabled=!1,this.mouseEventsInterval=50,this.touchEventsInterval=50,this.inputEventsInterval=100,this.outputEventsInterval=100,this.showTicks=!1,this.showTicksValues=!1,this.tickStep=null,this.tickValueStep=1,this.ticksArray=null,this.ticksTooltip=null,this.ticksValuesTooltip=null,this.vertical=!1,this.getSelectionBarColor=null,this.getTickColor=null,this.getPointerColor=null,this.keyboardSupport=!0,this.scale=1,this.enforceStep=!0,this.enforceRange=!0,this.noSwitching=!1,this.onlyBindHandles=!1,this.rightToLeft=!1,this.reversedControls=!1,this.boundPointerLabels=!0,this.logScale=!1,this.customValueToPosition=null,this.customPositionToValue=null,this.precisionLimit=12,this.selectionBarGradient=null,this.ariaLabel=null,this.ariaLabelledBy=null,this.ariaLabelHigh=null,this.ariaLabelledByHigh=null,this.handleDimension=null,this.barDimension=null,this.animate=!0}),Ut=Object(l.a)(function t(){Object(u.a)(this,t)}),Wt=function(){return Object(l.a)(function t(){Object(u.a)(this,t)},null,[{key:\"isNullOrUndefined\",value:function(t){return null==t}},{key:\"linearValueToPosition\",value:function(t,e,i){return(t-e)/(i-e)}},{key:\"logValueToPosition\",value:function(t,e,i){return((t=Math.log(t))-(e=Math.log(e)))/((i=Math.log(i))-e)}},{key:\"linearPositionToValue\",value:function(t,e,i){return t*(i-e)+e}},{key:\"logPositionToValue\",value:function(t,e,i){return e=Math.log(e),i=Math.log(i),Math.exp(t*(i-e)+e)}},{key:\"findStepIndex\",value:function(t,e){for(var i=e.map(function(e){return Math.abs(t-e.value)}),n=0,r=0;r<e.length;r++)i[r]!==i[n]&&i[r]<i[n]&&(n=r);return n}}])}(),Gt=function(){return Object(l.a)(function t(){Object(u.a)(this,t)},null,[{key:\"isTouchEvent\",value:function(t){return void 0!==window.TouchEvent?t instanceof TouchEvent:void 0!==t.touches}},{key:\"isResizeObserverAvailable\",value:function(){return void 0!==window.ResizeObserver}}])}(),qt=function(){return Object(l.a)(function t(){Object(u.a)(this,t)},null,[{key:\"roundToPrecisionLimit\",value:function(t,e){return+t.toPrecision(e)}},{key:\"clampToRange\",value:function(t,e,i){return Math.min(Math.max(t,e),i)}}])}(),Kt=Object(l.a)(function t(){Object(u.a)(this,t),this.eventName=null,this.events=null,this.eventsSubscription=null,this.teardownCallback=null}),Yt=function(){return Object(l.a)(function t(e){Object(u.a)(this,t),this.renderer=e},[{key:\"attachPassiveEventListener\",value:function(t,e,i,n){if(!0!==yt.a.hasSupport)return this.attachEventListener(t,e,i,n);var r=new Kt;r.eventName=e,r.events=new dt.Subject;var s=function(t){r.events.next(t)};return t.addEventListener(e,s,{passive:!0,capture:!1}),r.teardownCallback=function(){t.removeEventListener(e,s,{passive:!0,capture:!1})},r.eventsSubscription=r.events.pipe(Wt.isNullOrUndefined(n)?Object(bt.tap)(function(){}):Object(bt.throttleTime)(n,void 0,{leading:!0,trailing:!0})).subscribe(function(t){i(t)}),r}},{key:\"detachEventListener\",value:function(t){Wt.isNullOrUndefined(t.eventsSubscription)||(t.eventsSubscription.unsubscribe(),t.eventsSubscription=null),Wt.isNullOrUndefined(t.events)||(t.events.complete(),t.events=null),Wt.isNullOrUndefined(t.teardownCallback)||(t.teardownCallback(),t.teardownCallback=null)}},{key:\"attachEventListener\",value:function(t,e,i,n){var r=new Kt;return r.eventName=e,r.events=new dt.Subject,r.teardownCallback=this.renderer.listen(t,e,function(t){r.events.next(t)}),r.eventsSubscription=r.events.pipe(Wt.isNullOrUndefined(n)?Object(bt.tap)(function(){}):Object(bt.throttleTime)(n,void 0,{leading:!0,trailing:!0})).subscribe(function(t){i(t)}),r}}])}(),Xt=function(){var t=function(){return Object(l.a)(function t(e,i,n){Object(u.a)(this,t),this.elemRef=e,this.renderer=i,this.changeDetectionRef=n,this._position=0,this._dimension=0,this._alwaysHide=!1,this._vertical=!1,this._scale=1,this.opacity=1,this.visibility=\"visible\",this.left=\"\",this.bottom=\"\",this.height=\"\",this.width=\"\",this.eventListeners=[],this.eventListenerHelper=new Yt(this.renderer)},[{key:\"position\",get:function(){return this._position}},{key:\"dimension\",get:function(){return this._dimension}},{key:\"alwaysHide\",get:function(){return this._alwaysHide}},{key:\"vertical\",get:function(){return this._vertical}},{key:\"scale\",get:function(){return this._scale}},{key:\"setAlwaysHide\",value:function(t){this._alwaysHide=t,this.visibility=t?\"hidden\":\"visible\"}},{key:\"hide\",value:function(){this.opacity=0}},{key:\"show\",value:function(){this.alwaysHide||(this.opacity=1)}},{key:\"isVisible\",value:function(){return!this.alwaysHide&&0!==this.opacity}},{key:\"setVertical\",value:function(t){this._vertical=t,this._vertical?(this.left=\"\",this.width=\"\"):(this.bottom=\"\",this.height=\"\")}},{key:\"setScale\",value:function(t){this._scale=t}},{key:\"setPosition\",value:function(t){this._position===t||this.isRefDestroyed()||this.changeDetectionRef.markForCheck(),this._position=t,this._vertical?this.bottom=Math.round(t)+\"px\":this.left=Math.round(t)+\"px\"}},{key:\"calculateDimension\",value:function(){var t=this.getBoundingClientRect();this._dimension=this.vertical?(t.bottom-t.top)*this.scale:(t.right-t.left)*this.scale}},{key:\"setDimension\",value:function(t){this._dimension===t||this.isRefDestroyed()||this.changeDetectionRef.markForCheck(),this._dimension=t,this._vertical?this.height=Math.round(t)+\"px\":this.width=Math.round(t)+\"px\"}},{key:\"getBoundingClientRect\",value:function(){return this.elemRef.nativeElement.getBoundingClientRect()}},{key:\"on\",value:function(t,e,i){var n=this.eventListenerHelper.attachEventListener(this.elemRef.nativeElement,t,e,i);this.eventListeners.push(n)}},{key:\"onPassive\",value:function(t,e,i){var n=this.eventListenerHelper.attachPassiveEventListener(this.elemRef.nativeElement,t,e,i);this.eventListeners.push(n)}},{key:\"off\",value:function(t){var e,i;Wt.isNullOrUndefined(t)?(e=[],i=this.eventListeners):(e=this.eventListeners.filter(function(e){return e.eventName!==t}),i=this.eventListeners.filter(function(e){return e.eventName===t}));var n,r=Object(ft.a)(i);try{for(r.s();!(n=r.n()).done;)this.eventListenerHelper.detachEventListener(n.value)}catch(s){r.e(s)}finally{r.f()}this.eventListeners=e}},{key:\"isRefDestroyed\",value:function(){return Wt.isNullOrUndefined(this.changeDetectionRef)||this.changeDetectionRef.destroyed}}])}();return t.\\u0275fac=function(e){return new(e||t)(h.Mb(h.l),h.Mb(h.E),h.Mb(h.h))},t.\\u0275dir=h.Hb({type:t,selectors:[[\"\",\"ng5SliderElement\",\"\"]],hostVars:12,hostBindings:function(t,e){2&t&&h.zc(\"opacity\",e.opacity)(\"visibility\",e.visibility)(\"left\",e.left)(\"bottom\",e.bottom)(\"height\",e.height)(\"width\",e.width)}}),t}(),Jt=function(){var t=function(t){function e(t,i,n){var r;return Object(u.a)(this,e),(r=mt(this,e,[t,i,n])).active=!1,r.role=\"\",r.tabindex=\"\",r.ariaOrientation=\"\",r.ariaLabel=\"\",r.ariaLabelledBy=\"\",r.ariaValueNow=\"\",r.ariaValueText=\"\",r.ariaValueMin=\"\",r.ariaValueMax=\"\",r}return Object(v.a)(e,t),Object(l.a)(e,[{key:\"focus\",value:function(){this.elemRef.nativeElement.focus()}}])}(Xt);return t.\\u0275fac=function(e){return new(e||t)(h.Mb(h.l),h.Mb(h.E),h.Mb(h.h))},t.\\u0275dir=h.Hb({type:t,selectors:[[\"\",\"ng5SliderHandle\",\"\"]],hostVars:11,hostBindings:function(t,e){2&t&&(h.Bb(\"role\",e.role)(\"tabindex\",e.tabindex)(\"aria-orientation\",e.ariaOrientation)(\"aria-label\",e.ariaLabel)(\"aria-labelledby\",e.ariaLabelledBy)(\"aria-valuenow\",e.ariaValueNow)(\"aria-valuetext\",e.ariaValueText)(\"aria-valuemin\",e.ariaValueMin)(\"aria-valuemax\",e.ariaValueMax),h.Eb(\"ng5-slider-active\",e.active))},features:[h.xb]}),t}(),Qt=function(){var t=function(t){function e(t,i,n){var r;return Object(u.a)(this,e),(r=mt(this,e,[t,i,n]))._value=null,r}return Object(v.a)(e,t),Object(l.a)(e,[{key:\"value\",get:function(){return this._value}},{key:\"setValue\",value:function(t){var e=!1;!this.alwaysHide&&(Wt.isNullOrUndefined(this.value)||this.value.length!==t.length||this.value.length>0&&0===this.dimension)&&(e=!0),this._value=t,this.elemRef.nativeElement.innerHTML=t,e&&this.calculateDimension()}}])}(Xt);return t.\\u0275fac=function(e){return new(e||t)(h.Mb(h.l),h.Mb(h.E),h.Mb(h.h))},t.\\u0275dir=h.Hb({type:t,selectors:[[\"\",\"ng5SliderLabel\",\"\"]],features:[h.xb]}),t}(),$t=Object(l.a)(function t(){Object(u.a)(this,t),this.selected=!1,this.style={},this.tooltip=null,this.tooltipPlacement=null,this.value=null,this.valueTooltip=null,this.valueTooltipPlacement=null,this.legend=null}),te=Object(l.a)(function t(){Object(u.a)(this,t),this.active=!1,this.value=0,this.difference=0,this.position=0,this.lowLimit=0,this.highLimit=0}),ee=function(){return Object(l.a)(function t(){Object(u.a)(this,t)},null,[{key:\"compare\",value:function(t,e){return!(Wt.isNullOrUndefined(t)&&Wt.isNullOrUndefined(e)||Wt.isNullOrUndefined(t)!==Wt.isNullOrUndefined(e)||t.value!==e.value||t.highValue!==e.highValue)}}])}(),ie=function(t){function e(){return Object(u.a)(this,e),mt(this,e,arguments)}return Object(v.a)(e,t),Object(l.a)(e,null,[{key:\"compare\",value:function(t,e){return!(Wt.isNullOrUndefined(t)&&Wt.isNullOrUndefined(e)||Wt.isNullOrUndefined(t)!==Wt.isNullOrUndefined(e)||t.value!==e.value||t.highValue!==e.highValue||t.forceChange!==e.forceChange)}}])}(ee),ne={provide:r.h,useExisting:Object(h.T)(function(){return re}),multi:!0},re=function(){var t=function(){return Object(l.a)(function t(e,i,n,r){Object(u.a)(this,t),this.renderer=e,this.elementRef=i,this.changeDetectionRef=n,this.zone=r,this.value=null,this.valueChange=new h.n,this.highValue=null,this.highValueChange=new h.n,this.options=new zt,this.userChangeStart=new h.n,this.userChange=new h.n,this.userChangeEnd=new h.n,this.initHasRun=!1,this.inputModelChangeSubject=new dt.Subject,this.inputModelChangeSubscription=null,this.outputModelChangeSubject=new dt.Subject,this.outputModelChangeSubscription=null,this.viewLowValue=null,this.viewHighValue=null,this.viewOptions=new zt,this.handleHalfDimension=0,this.maxHandlePosition=0,this.currentTrackingPointer=null,this.currentFocusPointer=null,this.firstKeyDown=!1,this.touchId=null,this.dragging=new te,this.sliderElementVerticalClass=!1,this.sliderElementAnimateClass=!1,this.sliderElementDisabledAttr=null,this.barStyle={},this.minPointerStyle={},this.maxPointerStyle={},this.fullBarTransparentClass=!1,this.selectionBarDraggableClass=!1,this.ticksUnderValuesClass=!1,this.intermediateTicks=!1,this.ticks=[],this.eventListenerHelper=null,this.onMoveEventListener=null,this.onEndEventListener=null,this.resizeObserver=null,this.onTouchedCallback=null,this.onChangeCallback=null,this.eventListenerHelper=new Yt(this.renderer)},[{key:\"manualRefresh\",set:function(t){var e=this;this.unsubscribeManualRefresh(),this.manualRefreshSubscription=t.subscribe(function(){setTimeout(function(){return e.calculateViewDimensionsAndDetectChanges()})})}},{key:\"triggerFocus\",set:function(t){var e=this;this.unsubscribeTriggerFocus(),this.triggerFocusSubscription=t.subscribe(function(t){e.focusPointer(t)})}},{key:\"range\",get:function(){return!Wt.isNullOrUndefined(this.value)&&!Wt.isNullOrUndefined(this.highValue)}},{key:\"showTicks\",get:function(){return this.viewOptions.showTicks}},{key:\"ngOnInit\",value:function(){this.viewOptions=new zt,Object.assign(this.viewOptions,this.options),this.updateDisabledState(),this.updateVerticalState()}},{key:\"ngAfterViewInit\",value:function(){this.applyOptions(),this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval),this.subscribeOutputModelChangeSubject(this.viewOptions.outputEventsInterval),this.renormaliseModelValues(),this.viewLowValue=this.modelValueToViewValue(this.value),this.viewHighValue=this.range?this.modelValueToViewValue(this.highValue):null,this.updateVerticalState(),this.manageElementsStyle(),this.updateDisabledState(),this.calculateViewDimensions(),this.addAccessibility(),this.updateCeilLabel(),this.updateFloorLabel(),this.initHandles(),this.manageEventsBindings(),this.subscribeResizeObserver(),this.initHasRun=!0,this.isRefDestroyed()||this.changeDetectionRef.detectChanges()}},{key:\"ngOnChanges\",value:function(t){Wt.isNullOrUndefined(t.options)||this.onChangeOptions(),Wt.isNullOrUndefined(t.value)&&Wt.isNullOrUndefined(t.highValue)||this.inputModelChangeSubject.next({value:this.value,highValue:this.highValue,forceChange:!1,internalChange:!1})}},{key:\"ngOnDestroy\",value:function(){this.unbindEvents(),this.unsubscribeResizeObserver(),this.unsubscribeInputModelChangeSubject(),this.unsubscribeOutputModelChangeSubject(),this.unsubscribeManualRefresh(),this.unsubscribeTriggerFocus()}},{key:\"writeValue\",value:function(t){t instanceof Array?(this.value=t[0],this.highValue=t[1]):this.value=t,this.inputModelChangeSubject.next({value:this.value,highValue:this.highValue,forceChange:!1,internalChange:!1})}},{key:\"registerOnChange\",value:function(t){this.onChangeCallback=t}},{key:\"registerOnTouched\",value:function(t){this.onTouchedCallback=t}},{key:\"setDisabledState\",value:function(t){this.viewOptions.disabled=t,this.updateDisabledState()}},{key:\"onResize\",value:function(t){this.calculateViewDimensionsAndDetectChanges()}},{key:\"subscribeInputModelChangeSubject\",value:function(t){var e=this;this.inputModelChangeSubscription=this.inputModelChangeSubject.pipe(Object(bt.distinctUntilChanged)(ie.compare),Object(bt.filter)(function(t){return!t.forceChange&&!t.internalChange}),Wt.isNullOrUndefined(t)?Object(bt.tap)(function(){}):Object(bt.throttleTime)(t,void 0,{leading:!0,trailing:!0})).subscribe(function(t){return e.applyInputModelChange(t)})}},{key:\"subscribeOutputModelChangeSubject\",value:function(t){var e=this;this.outputModelChangeSubscription=this.outputModelChangeSubject.pipe(Object(bt.distinctUntilChanged)(ie.compare),Wt.isNullOrUndefined(t)?Object(bt.tap)(function(){}):Object(bt.throttleTime)(t,void 0,{leading:!0,trailing:!0})).subscribe(function(t){return e.publishOutputModelChange(t)})}},{key:\"subscribeResizeObserver\",value:function(){var t=this;Gt.isResizeObserverAvailable()&&(this.resizeObserver=new ResizeObserver(function(){return t.calculateViewDimensionsAndDetectChanges()}),this.resizeObserver.observe(this.elementRef.nativeElement))}},{key:\"unsubscribeResizeObserver\",value:function(){Gt.isResizeObserverAvailable()&&null!==this.resizeObserver&&(this.resizeObserver.disconnect(),this.resizeObserver=null)}},{key:\"unsubscribeOnMove\",value:function(){Wt.isNullOrUndefined(this.onMoveEventListener)||(this.eventListenerHelper.detachEventListener(this.onMoveEventListener),this.onMoveEventListener=null)}},{key:\"unsubscribeOnEnd\",value:function(){Wt.isNullOrUndefined(this.onEndEventListener)||(this.eventListenerHelper.detachEventListener(this.onEndEventListener),this.onEndEventListener=null)}},{key:\"unsubscribeInputModelChangeSubject\",value:function(){Wt.isNullOrUndefined(this.inputModelChangeSubscription)||(this.inputModelChangeSubscription.unsubscribe(),this.inputModelChangeSubscription=null)}},{key:\"unsubscribeOutputModelChangeSubject\",value:function(){Wt.isNullOrUndefined(this.outputModelChangeSubscription)||(this.outputModelChangeSubscription.unsubscribe(),this.outputModelChangeSubscription=null)}},{key:\"unsubscribeManualRefresh\",value:function(){Wt.isNullOrUndefined(this.manualRefreshSubscription)||(this.manualRefreshSubscription.unsubscribe(),this.manualRefreshSubscription=null)}},{key:\"unsubscribeTriggerFocus\",value:function(){Wt.isNullOrUndefined(this.triggerFocusSubscription)||(this.triggerFocusSubscription.unsubscribe(),this.triggerFocusSubscription=null)}},{key:\"getPointerElement\",value:function(t){return t===Dt.Min?this.minHandleElement:t===Dt.Max?this.maxHandleElement:null}},{key:\"getCurrentTrackingValue\",value:function(){return this.currentTrackingPointer===Dt.Min?this.viewLowValue:this.currentTrackingPointer===Dt.Max?this.viewHighValue:null}},{key:\"modelValueToViewValue\",value:function(t){return Wt.isNullOrUndefined(t)?NaN:Wt.isNullOrUndefined(this.viewOptions.stepsArray)||this.viewOptions.bindIndexForStepsArray?+t:Wt.findStepIndex(+t,this.viewOptions.stepsArray)}},{key:\"viewValueToModelValue\",value:function(t){return Wt.isNullOrUndefined(this.viewOptions.stepsArray)||this.viewOptions.bindIndexForStepsArray?t:this.getStepValue(t)}},{key:\"getStepValue\",value:function(t){var e=this.viewOptions.stepsArray[t];return Wt.isNullOrUndefined(e)?NaN:e.value}},{key:\"applyViewChange\",value:function(){this.value=this.viewValueToModelValue(this.viewLowValue),this.range&&(this.highValue=this.viewValueToModelValue(this.viewHighValue)),this.outputModelChangeSubject.next({value:this.value,highValue:this.highValue,userEventInitiated:!0,forceChange:!1}),this.inputModelChangeSubject.next({value:this.value,highValue:this.highValue,forceChange:!1,internalChange:!0})}},{key:\"applyInputModelChange\",value:function(t){var e=this.normaliseModelValues(t),i=!ee.compare(t,e);i&&(this.value=e.value,this.highValue=e.highValue),this.viewLowValue=this.modelValueToViewValue(e.value),this.viewHighValue=this.range?this.modelValueToViewValue(e.highValue):null,this.updateLowHandle(this.valueToPosition(this.viewLowValue)),this.range&&this.updateHighHandle(this.valueToPosition(this.viewHighValue)),this.updateSelectionBar(),this.updateTicksScale(),this.updateAriaAttributes(),this.range&&this.updateCombinedLabel(),this.outputModelChangeSubject.next({value:e.value,highValue:e.highValue,forceChange:i,userEventInitiated:!1})}},{key:\"publishOutputModelChange\",value:function(t){var e=this,i=function(){e.valueChange.emit(t.value),e.range&&e.highValueChange.emit(t.highValue),Wt.isNullOrUndefined(e.onChangeCallback)||e.onChangeCallback(e.range?[t.value,t.highValue]:t.value),Wt.isNullOrUndefined(e.onTouchedCallback)||e.onTouchedCallback(e.range?[t.value,t.highValue]:t.value)};t.userEventInitiated?(i(),this.userChange.emit(this.getChangeContext())):setTimeout(function(){i()})}},{key:\"normaliseModelValues\",value:function(t){var e=new ee;if(e.value=t.value,e.highValue=t.highValue,this.viewOptions.enforceStep&&(e.value=this.roundStep(e.value),this.range&&(e.highValue=this.roundStep(e.highValue))),!Wt.isNullOrUndefined(this.viewOptions.stepsArray)||!this.viewOptions.enforceRange)return e;if(e.value=qt.clampToRange(e.value,this.viewOptions.floor,this.viewOptions.ceil),this.range&&(e.highValue=qt.clampToRange(e.highValue,this.viewOptions.floor,this.viewOptions.ceil)),this.range&&t.value>t.highValue)if(this.viewOptions.noSwitching)e.value=e.highValue;else{var i=t.value;e.value=t.highValue,e.highValue=i}return e}},{key:\"renormaliseModelValues\",value:function(){var t={value:this.value,highValue:this.highValue},e=this.normaliseModelValues(t);ee.compare(e,t)||(this.value=e.value,this.highValue=e.highValue,this.outputModelChangeSubject.next({value:this.value,highValue:this.highValue,forceChange:!0,userEventInitiated:!1}))}},{key:\"onChangeOptions\",value:function(){if(this.initHasRun){var t=this.viewOptions.inputEventsInterval,e=this.viewOptions.outputEventsInterval;this.applyOptions(),t!==this.viewOptions.inputEventsInterval&&(this.unsubscribeInputModelChangeSubject(),this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval)),e!==this.viewOptions.outputEventsInterval&&(this.unsubscribeInputModelChangeSubject(),this.subscribeInputModelChangeSubject(this.viewOptions.outputEventsInterval)),this.renormaliseModelValues(),this.viewLowValue=this.modelValueToViewValue(this.value),this.viewHighValue=this.range?this.modelValueToViewValue(this.highValue):null,this.resetSlider()}}},{key:\"applyOptions\",value:function(){if(this.viewOptions=new zt,Object.assign(this.viewOptions,this.options),this.viewOptions.draggableRange=this.range&&this.viewOptions.draggableRange,this.viewOptions.draggableRangeOnly=this.range&&this.viewOptions.draggableRangeOnly,this.viewOptions.draggableRangeOnly&&(this.viewOptions.draggableRange=!0),this.viewOptions.showTicks=this.viewOptions.showTicks||this.viewOptions.showTicksValues||!Wt.isNullOrUndefined(this.viewOptions.ticksArray),!this.viewOptions.showTicks||Wt.isNullOrUndefined(this.viewOptions.tickStep)&&Wt.isNullOrUndefined(this.viewOptions.ticksArray)||(this.intermediateTicks=!0),this.viewOptions.showSelectionBar=this.viewOptions.showSelectionBar||this.viewOptions.showSelectionBarEnd||!Wt.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue),Wt.isNullOrUndefined(this.viewOptions.stepsArray)?this.applyFloorCeilOptions():this.applyStepsArrayOptions(),Wt.isNullOrUndefined(this.viewOptions.combineLabels)&&(this.viewOptions.combineLabels=function(t,e){return t+\" - \"+e}),this.viewOptions.logScale&&0===this.viewOptions.floor)throw Error(\"Can't use floor=0 with logarithmic scale\")}},{key:\"applyStepsArrayOptions\",value:function(){var t=this;this.viewOptions.floor=0,this.viewOptions.ceil=this.viewOptions.stepsArray.length-1,this.viewOptions.step=1,Wt.isNullOrUndefined(this.viewOptions.translate)&&(this.viewOptions.translate=function(e){return String(t.viewOptions.bindIndexForStepsArray?t.getStepValue(e):e)}),this.viewOptions.getLegend=function(e){return t.viewOptions.stepsArray[e].legend}}},{key:\"applyFloorCeilOptions\",value:function(){if(Wt.isNullOrUndefined(this.viewOptions.step)?this.viewOptions.step=1:(this.viewOptions.step=+this.viewOptions.step,this.viewOptions.step<=0&&(this.viewOptions.step=1)),Wt.isNullOrUndefined(this.viewOptions.ceil)||Wt.isNullOrUndefined(this.viewOptions.floor))throw Error(\"floor and ceil options must be supplied\");this.viewOptions.ceil=+this.viewOptions.ceil,this.viewOptions.floor=+this.viewOptions.floor,Wt.isNullOrUndefined(this.viewOptions.translate)&&(this.viewOptions.translate=function(t){return String(t)})}},{key:\"resetSlider\",value:function(){this.manageElementsStyle(),this.addAccessibility(),this.updateCeilLabel(),this.updateFloorLabel(),this.unbindEvents(),this.manageEventsBindings(),this.updateDisabledState(),this.calculateViewDimensions(),this.refocusPointerIfNeeded()}},{key:\"focusPointer\",value:function(t){t!==Dt.Min&&t!==Dt.Max&&(t=Dt.Min),t===Dt.Min?this.minHandleElement.focus():this.range&&t===Dt.Max&&this.maxHandleElement.focus()}},{key:\"refocusPointerIfNeeded\",value:function(){Wt.isNullOrUndefined(this.currentFocusPointer)||(this.onPointerFocus(this.currentFocusPointer),this.getPointerElement(this.currentFocusPointer).focus())}},{key:\"manageElementsStyle\",value:function(){var t=this;this.updateScale(),this.floorLabelElement.setAlwaysHide(this.viewOptions.showTicksValues||this.viewOptions.hideLimitLabels),this.ceilLabelElement.setAlwaysHide(this.viewOptions.showTicksValues||this.viewOptions.hideLimitLabels);var e=this.viewOptions.showTicksValues&&!this.intermediateTicks;this.minHandleLabelElement.setAlwaysHide(e||this.viewOptions.hidePointerLabels),this.maxHandleLabelElement.setAlwaysHide(e||!this.range||this.viewOptions.hidePointerLabels),this.combinedLabelElement.setAlwaysHide(e||!this.range||this.viewOptions.hidePointerLabels),this.selectionBarElement.setAlwaysHide(!this.range&&!this.viewOptions.showSelectionBar),this.leftOuterSelectionBarElement.setAlwaysHide(!this.range||!this.viewOptions.showOuterSelectionBars),this.rightOuterSelectionBarElement.setAlwaysHide(!this.range||!this.viewOptions.showOuterSelectionBars),this.fullBarTransparentClass=this.range&&this.viewOptions.showOuterSelectionBars,this.selectionBarDraggableClass=this.viewOptions.draggableRange&&!this.viewOptions.onlyBindHandles,this.ticksUnderValuesClass=this.intermediateTicks&&this.options.showTicksValues,this.sliderElementVerticalClass!==this.viewOptions.vertical&&(this.updateVerticalState(),setTimeout(function(){t.resetSlider()})),this.sliderElementAnimateClass!==this.viewOptions.animate&&setTimeout(function(){t.sliderElementAnimateClass=t.viewOptions.animate})}},{key:\"manageEventsBindings\",value:function(){this.viewOptions.disabled||this.viewOptions.readOnly?this.unbindEvents():this.bindEvents()}},{key:\"updateDisabledState\",value:function(){this.sliderElementDisabledAttr=this.viewOptions.disabled?\"disabled\":null}},{key:\"updateVerticalState\",value:function(){this.sliderElementVerticalClass=this.viewOptions.vertical;var t,e=Object(ft.a)(this.getAllSliderElements());try{for(e.s();!(t=e.n()).done;){var i=t.value;Wt.isNullOrUndefined(i)||i.setVertical(this.viewOptions.vertical)}}catch(n){e.e(n)}finally{e.f()}}},{key:\"updateScale\",value:function(){var t,e=Object(ft.a)(this.getAllSliderElements());try{for(e.s();!(t=e.n()).done;)t.value.setScale(this.viewOptions.scale)}catch(i){e.e(i)}finally{e.f()}}},{key:\"getAllSliderElements\",value:function(){return[this.leftOuterSelectionBarElement,this.rightOuterSelectionBarElement,this.fullBarElement,this.selectionBarElement,this.minHandleElement,this.maxHandleElement,this.floorLabelElement,this.ceilLabelElement,this.minHandleLabelElement,this.maxHandleLabelElement,this.combinedLabelElement,this.ticksElement]}},{key:\"initHandles\",value:function(){this.updateLowHandle(this.valueToPosition(this.viewLowValue)),this.range&&this.updateHighHandle(this.valueToPosition(this.viewHighValue)),this.updateSelectionBar(),this.range&&this.updateCombinedLabel(),this.updateTicksScale()}},{key:\"addAccessibility\",value:function(){this.updateAriaAttributes(),this.minHandleElement.role=\"slider\",this.minHandleElement.tabindex=!this.viewOptions.keyboardSupport||this.viewOptions.readOnly||this.viewOptions.disabled?\"\":\"0\",this.viewOptions.vertical&&(this.minHandleElement.ariaOrientation=\"vertical\"),Wt.isNullOrUndefined(this.viewOptions.ariaLabel)?Wt.isNullOrUndefined(this.viewOptions.ariaLabelledBy)||(this.minHandleElement.ariaLabelledBy=this.viewOptions.ariaLabelledBy):this.minHandleElement.ariaLabel=this.viewOptions.ariaLabel,this.range&&(this.maxHandleElement.role=\"slider\",this.maxHandleElement.tabindex=!this.viewOptions.keyboardSupport||this.viewOptions.readOnly||this.viewOptions.disabled?\"\":\"0\",this.maxHandleElement.ariaOrientation=this.viewOptions.vertical?\"vertical\":\"horizontal\",Wt.isNullOrUndefined(this.viewOptions.ariaLabelHigh)?Wt.isNullOrUndefined(this.viewOptions.ariaLabelledByHigh)||(this.maxHandleElement.ariaLabelledBy=this.viewOptions.ariaLabelledByHigh):this.maxHandleElement.ariaLabel=this.viewOptions.ariaLabelHigh)}},{key:\"updateAriaAttributes\",value:function(){this.minHandleElement.ariaValueNow=(+this.value).toString(),this.minHandleElement.ariaValueText=this.viewOptions.translate(+this.value,Zt.Low),this.minHandleElement.ariaValueMin=this.viewOptions.floor.toString(),this.minHandleElement.ariaValueMax=this.viewOptions.ceil.toString(),this.range&&(this.maxHandleElement.ariaValueNow=(+this.highValue).toString(),this.maxHandleElement.ariaValueText=this.viewOptions.translate(+this.highValue,Zt.High),this.maxHandleElement.ariaValueMin=this.viewOptions.floor.toString(),this.maxHandleElement.ariaValueMax=this.viewOptions.ceil.toString())}},{key:\"calculateViewDimensions\",value:function(){Wt.isNullOrUndefined(this.viewOptions.handleDimension)?this.minHandleElement.calculateDimension():this.minHandleElement.setDimension(this.viewOptions.handleDimension);var t=this.minHandleElement.dimension;this.handleHalfDimension=t/2,Wt.isNullOrUndefined(this.viewOptions.barDimension)?this.fullBarElement.calculateDimension():this.fullBarElement.setDimension(this.viewOptions.barDimension),this.maxHandlePosition=this.fullBarElement.dimension-t,this.initHasRun&&(this.updateFloorLabel(),this.updateCeilLabel(),this.initHandles())}},{key:\"calculateViewDimensionsAndDetectChanges\",value:function(){this.calculateViewDimensions(),this.isRefDestroyed()||this.changeDetectionRef.detectChanges()}},{key:\"isRefDestroyed\",value:function(){return this.changeDetectionRef.destroyed}},{key:\"updateTicksScale\",value:function(){var t=this;if(this.viewOptions.showTicks){var e=Wt.isNullOrUndefined(this.viewOptions.ticksArray)?this.getTicksArray():this.viewOptions.ticksArray,i=this.viewOptions.vertical?\"translateY\":\"translateX\";this.viewOptions.rightToLeft&&e.reverse();var n=e.map(function(e){var n=t.valueToPosition(e);t.viewOptions.vertical&&(n=t.maxHandlePosition-n);var r=i+\"(\"+Math.round(n)+\"px)\",s=new $t;if(s.selected=t.isTickSelected(e),s.style={\"-webkit-transform\":r,\"-moz-transform\":r,\"-o-transform\":r,\"-ms-transform\":r,transform:r},s.selected&&!Wt.isNullOrUndefined(t.viewOptions.getSelectionBarColor)&&(s.style[\"background-color\"]=t.getSelectionBarColor()),s.selected||Wt.isNullOrUndefined(t.viewOptions.getTickColor)||(s.style[\"background-color\"]=t.getTickColor(e)),Wt.isNullOrUndefined(t.viewOptions.ticksTooltip)||(s.tooltip=t.viewOptions.ticksTooltip(e),s.tooltipPlacement=t.viewOptions.vertical?\"right\":\"top\"),t.viewOptions.showTicksValues&&e%t.viewOptions.tickValueStep==0&&(s.value=t.getDisplayValue(e,Zt.TickValue),Wt.isNullOrUndefined(t.viewOptions.ticksValuesTooltip)||(s.valueTooltip=t.viewOptions.ticksValuesTooltip(e),s.valueTooltipPlacement=t.viewOptions.vertical?\"right\":\"top\")),!Wt.isNullOrUndefined(t.viewOptions.getLegend)){var o=t.viewOptions.getLegend(e);Wt.isNullOrUndefined(o)||(s.legend=o)}return s});if(Wt.isNullOrUndefined(this.ticks)||this.ticks.length!==n.length)this.ticks=n;else for(var r=0;r<n.length;++r)Object.assign(this.ticks[r],n[r]);this.isRefDestroyed()||this.changeDetectionRef.detectChanges()}}},{key:\"getTicksArray\",value:function(){for(var t=Wt.isNullOrUndefined(this.viewOptions.tickStep)?this.viewOptions.step:this.viewOptions.tickStep,e=[],i=this.viewOptions.floor;i<=this.viewOptions.ceil;i+=t)e.push(i);return e}},{key:\"isTickSelected\",value:function(t){if(!this.range)if(Wt.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)){if(this.viewOptions.showSelectionBarEnd){if(t>=this.viewLowValue)return!0}else if(this.viewOptions.showSelectionBar&&t<=this.viewLowValue)return!0}else{var e=this.viewOptions.showSelectionBarFromValue;if(this.viewLowValue>e&&t>=e&&t<=this.viewLowValue)return!0;if(this.viewLowValue<e&&t<=e&&t>=this.viewLowValue)return!0}return!!(this.range&&t>=this.viewLowValue&&t<=this.viewHighValue)}},{key:\"updateFloorLabel\",value:function(){this.floorLabelElement.alwaysHide||(this.floorLabelElement.setValue(this.getDisplayValue(this.viewOptions.floor,Zt.Floor)),this.floorLabelElement.calculateDimension(),this.floorLabelElement.setPosition(this.viewOptions.rightToLeft?this.fullBarElement.dimension-this.floorLabelElement.dimension:0))}},{key:\"updateCeilLabel\",value:function(){this.ceilLabelElement.alwaysHide||(this.ceilLabelElement.setValue(this.getDisplayValue(this.viewOptions.ceil,Zt.Ceil)),this.ceilLabelElement.calculateDimension(),this.ceilLabelElement.setPosition(this.viewOptions.rightToLeft?0:this.fullBarElement.dimension-this.ceilLabelElement.dimension))}},{key:\"updateHandles\",value:function(t,e){t===Dt.Min?this.updateLowHandle(e):t===Dt.Max&&this.updateHighHandle(e),this.updateSelectionBar(),this.updateTicksScale(),this.range&&this.updateCombinedLabel()}},{key:\"getHandleLabelPos\",value:function(t,e){var i=t===Dt.Min?this.minHandleLabelElement.dimension:this.maxHandleLabelElement.dimension,n=e-i/2+this.handleHalfDimension,r=this.fullBarElement.dimension-i;return this.viewOptions.boundPointerLabels?this.viewOptions.rightToLeft&&t===Dt.Min||!this.viewOptions.rightToLeft&&t===Dt.Max?Math.min(n,r):Math.min(Math.max(n,0),r):n}},{key:\"updateLowHandle\",value:function(t){this.minHandleElement.setPosition(t),this.minHandleLabelElement.setValue(this.getDisplayValue(this.viewLowValue,Zt.Low)),this.minHandleLabelElement.setPosition(this.getHandleLabelPos(Dt.Min,t)),Wt.isNullOrUndefined(this.viewOptions.getPointerColor)||(this.minPointerStyle={backgroundColor:this.getPointerColor(Dt.Min)}),this.viewOptions.autoHideLimitLabels&&this.updateFloorAndCeilLabelsVisibility()}},{key:\"updateHighHandle\",value:function(t){this.maxHandleElement.setPosition(t),this.maxHandleLabelElement.setValue(this.getDisplayValue(this.viewHighValue,Zt.High)),this.maxHandleLabelElement.setPosition(this.getHandleLabelPos(Dt.Max,t)),Wt.isNullOrUndefined(this.viewOptions.getPointerColor)||(this.maxPointerStyle={backgroundColor:this.getPointerColor(Dt.Max)}),this.viewOptions.autoHideLimitLabels&&this.updateFloorAndCeilLabelsVisibility()}},{key:\"updateFloorAndCeilLabelsVisibility\",value:function(){if(!this.viewOptions.hidePointerLabels){var t=!1,e=!1,i=this.isLabelBelowFloorLabel(this.minHandleLabelElement),n=this.isLabelAboveCeilLabel(this.minHandleLabelElement),r=this.isLabelAboveCeilLabel(this.maxHandleLabelElement),s=this.isLabelBelowFloorLabel(this.combinedLabelElement),o=this.isLabelAboveCeilLabel(this.combinedLabelElement);if(i?(t=!0,this.floorLabelElement.hide()):(t=!1,this.floorLabelElement.show()),n?(e=!0,this.ceilLabelElement.hide()):(e=!1,this.ceilLabelElement.show()),this.range){var c=this.combinedLabelElement.isVisible()?o:r,a=this.combinedLabelElement.isVisible()?s:i;c?this.ceilLabelElement.hide():e||this.ceilLabelElement.show(),a?this.floorLabelElement.hide():t||this.floorLabelElement.show()}}}},{key:\"isLabelBelowFloorLabel\",value:function(t){var e=t.position,i=this.floorLabelElement.position;return this.viewOptions.rightToLeft?e+t.dimension>=i-2:e<=i+this.floorLabelElement.dimension+2}},{key:\"isLabelAboveCeilLabel\",value:function(t){var e=t.position,i=this.ceilLabelElement.position;return this.viewOptions.rightToLeft?e<=i+this.ceilLabelElement.dimension+2:e+t.dimension>=i-2}},{key:\"updateSelectionBar\",value:function(){var t=0,e=0,i=this.viewOptions.rightToLeft?!this.viewOptions.showSelectionBarEnd:this.viewOptions.showSelectionBarEnd,n=this.viewOptions.rightToLeft?this.maxHandleElement.position+this.handleHalfDimension:this.minHandleElement.position+this.handleHalfDimension;if(this.range)e=Math.abs(this.maxHandleElement.position-this.minHandleElement.position),t=n;else if(Wt.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue))i?(e=Math.ceil(Math.abs(this.maxHandlePosition-this.minHandleElement.position)+this.handleHalfDimension),t=Math.floor(this.minHandleElement.position+this.handleHalfDimension)):(e=this.minHandleElement.position+this.handleHalfDimension,t=0);else{var r=this.viewOptions.showSelectionBarFromValue,s=this.valueToPosition(r);(this.viewOptions.rightToLeft?this.viewLowValue<=r:this.viewLowValue>r)?(e=this.minHandleElement.position-s,t=s+this.handleHalfDimension):(e=s-this.minHandleElement.position,t=this.minHandleElement.position+this.handleHalfDimension)}if(this.selectionBarElement.setDimension(e),this.selectionBarElement.setPosition(t),this.range&&this.viewOptions.showOuterSelectionBars&&(this.viewOptions.rightToLeft?(this.rightOuterSelectionBarElement.setDimension(t),this.rightOuterSelectionBarElement.setPosition(0),this.fullBarElement.calculateDimension(),this.leftOuterSelectionBarElement.setDimension(this.fullBarElement.dimension-(t+e)),this.leftOuterSelectionBarElement.setPosition(t+e)):(this.leftOuterSelectionBarElement.setDimension(t),this.leftOuterSelectionBarElement.setPosition(0),this.fullBarElement.calculateDimension(),this.rightOuterSelectionBarElement.setDimension(this.fullBarElement.dimension-(t+e)),this.rightOuterSelectionBarElement.setPosition(t+e))),Wt.isNullOrUndefined(this.viewOptions.getSelectionBarColor)){if(!Wt.isNullOrUndefined(this.viewOptions.selectionBarGradient)){var o=Wt.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)?0:this.valueToPosition(this.viewOptions.showSelectionBarFromValue),c=o-t>0&&!i||o-t<=0&&i;this.barStyle={backgroundImage:\"linear-gradient(to \"+(this.viewOptions.vertical?c?\"bottom\":\"top\":c?\"left\":\"right\")+\", \"+this.viewOptions.selectionBarGradient.from+\" 0%,\"+this.viewOptions.selectionBarGradient.to+\" 100%)\"},this.viewOptions.vertical?(this.barStyle.backgroundPosition=\"center \"+(o+e+t+(c?-this.handleHalfDimension:0))+\"px\",this.barStyle.backgroundSize=\"100% \"+(this.fullBarElement.dimension-this.handleHalfDimension)+\"px\"):(this.barStyle.backgroundPosition=o-t+(c?this.handleHalfDimension:0)+\"px center\",this.barStyle.backgroundSize=this.fullBarElement.dimension-this.handleHalfDimension+\"px 100%\")}}else{var a=this.getSelectionBarColor();this.barStyle={backgroundColor:a}}}},{key:\"getSelectionBarColor\",value:function(){return this.range?this.viewOptions.getSelectionBarColor(this.value,this.highValue):this.viewOptions.getSelectionBarColor(this.value)}},{key:\"getPointerColor\",value:function(t){return this.viewOptions.getPointerColor(t===Dt.Max?this.highValue:this.value,t)}},{key:\"getTickColor\",value:function(t){return this.viewOptions.getTickColor(t)}},{key:\"updateCombinedLabel\",value:function(){if(this.viewOptions.rightToLeft?this.minHandleLabelElement.position-this.minHandleLabelElement.dimension-10<=this.maxHandleLabelElement.position:this.minHandleLabelElement.position+this.minHandleLabelElement.dimension+10>=this.maxHandleLabelElement.position){var t=this.getDisplayValue(this.viewLowValue,Zt.Low),e=this.getDisplayValue(this.viewHighValue,Zt.High),i=this.viewOptions.rightToLeft?this.viewOptions.combineLabels(e,t):this.viewOptions.combineLabels(t,e);this.combinedLabelElement.setValue(i);var n=this.viewOptions.boundPointerLabels?Math.min(Math.max(this.selectionBarElement.position+this.selectionBarElement.dimension/2-this.combinedLabelElement.dimension/2,0),this.fullBarElement.dimension-this.combinedLabelElement.dimension):this.selectionBarElement.position+this.selectionBarElement.dimension/2-this.combinedLabelElement.dimension/2;this.combinedLabelElement.setPosition(n),this.minHandleLabelElement.hide(),this.maxHandleLabelElement.hide(),this.combinedLabelElement.show()}else this.updateHighHandle(this.valueToPosition(this.viewHighValue)),this.updateLowHandle(this.valueToPosition(this.viewLowValue)),this.maxHandleLabelElement.show(),this.minHandleLabelElement.show(),this.combinedLabelElement.hide();this.viewOptions.autoHideLimitLabels&&this.updateFloorAndCeilLabelsVisibility()}},{key:\"getDisplayValue\",value:function(t,e){return Wt.isNullOrUndefined(this.viewOptions.stepsArray)||this.viewOptions.bindIndexForStepsArray||(t=this.getStepValue(t)),this.viewOptions.translate(t,e)}},{key:\"roundStep\",value:function(t,e){var i=Wt.isNullOrUndefined(e)?this.viewOptions.step:e,n=qt.roundToPrecisionLimit((t-this.viewOptions.floor)/i,this.viewOptions.precisionLimit);return n=Math.round(n)*i,qt.roundToPrecisionLimit(this.viewOptions.floor+n,this.viewOptions.precisionLimit)}},{key:\"valueToPosition\",value:function(t){var e=Wt.linearValueToPosition;Wt.isNullOrUndefined(this.viewOptions.customValueToPosition)?this.viewOptions.logScale&&(e=Wt.logValueToPosition):e=this.viewOptions.customValueToPosition;var i=e(t=qt.clampToRange(t,this.viewOptions.floor,this.viewOptions.ceil),this.viewOptions.floor,this.viewOptions.ceil);return Wt.isNullOrUndefined(i)&&(i=0),this.viewOptions.rightToLeft&&(i=1-i),i*this.maxHandlePosition}},{key:\"positionToValue\",value:function(t){var e=t/this.maxHandlePosition;this.viewOptions.rightToLeft&&(e=1-e);var i=Wt.linearPositionToValue;Wt.isNullOrUndefined(this.viewOptions.customPositionToValue)?this.viewOptions.logScale&&(i=Wt.logPositionToValue):i=this.viewOptions.customPositionToValue;var n=i(e,this.viewOptions.floor,this.viewOptions.ceil);return Wt.isNullOrUndefined(n)?0:n}},{key:\"getEventXY\",value:function(t,e){if(t instanceof MouseEvent)return this.viewOptions.vertical?t.clientY:t.clientX;var i=0,n=t.touches;if(!Wt.isNullOrUndefined(e))for(var r=0;r<n.length;r++)if(n[r].identifier===e){i=r;break}return this.viewOptions.vertical?n[i].clientY:n[i].clientX}},{key:\"getEventPosition\",value:function(t,e){var i=this.elementRef.nativeElement.getBoundingClientRect(),n=this.viewOptions.vertical?i.bottom:i.left;return(this.viewOptions.vertical?-this.getEventXY(t,e)+n:this.getEventXY(t,e)-n)*this.viewOptions.scale-this.handleHalfDimension}},{key:\"getNearestHandle\",value:function(t){if(!this.range)return Dt.Min;var e=this.getEventPosition(t),i=Math.abs(e-this.minHandleElement.position),n=Math.abs(e-this.maxHandleElement.position);return i<n?Dt.Min:i>n?Dt.Max:this.viewOptions.rightToLeft?e>this.minHandleElement.position?Dt.Min:Dt.Max:e<this.minHandleElement.position?Dt.Min:Dt.Max}},{key:\"bindEvents\",value:function(){var t=this,e=this.viewOptions.draggableRange;this.viewOptions.onlyBindHandles||this.selectionBarElement.on(\"mousedown\",function(i){return t.onBarStart(null,e,i,!0,!0,!0)}),this.viewOptions.draggableRangeOnly?(this.minHandleElement.on(\"mousedown\",function(i){return t.onBarStart(Dt.Min,e,i,!0,!0)}),this.maxHandleElement.on(\"mousedown\",function(i){return t.onBarStart(Dt.Max,e,i,!0,!0)})):(this.minHandleElement.on(\"mousedown\",function(e){return t.onStart(Dt.Min,e,!0,!0)}),this.range&&this.maxHandleElement.on(\"mousedown\",function(e){return t.onStart(Dt.Max,e,!0,!0)}),this.viewOptions.onlyBindHandles||(this.fullBarElement.on(\"mousedown\",function(e){return t.onStart(null,e,!0,!0,!0)}),this.ticksElement.on(\"mousedown\",function(e){return t.onStart(null,e,!0,!0,!0,!0)}))),this.viewOptions.onlyBindHandles||this.selectionBarElement.onPassive(\"touchstart\",function(i){return t.onBarStart(null,e,i,!0,!0,!0)}),this.viewOptions.draggableRangeOnly?(this.minHandleElement.onPassive(\"touchstart\",function(i){return t.onBarStart(Dt.Min,e,i,!0,!0)}),this.maxHandleElement.onPassive(\"touchstart\",function(i){return t.onBarStart(Dt.Max,e,i,!0,!0)})):(this.minHandleElement.onPassive(\"touchstart\",function(e){return t.onStart(Dt.Min,e,!0,!0)}),this.range&&this.maxHandleElement.onPassive(\"touchstart\",function(e){return t.onStart(Dt.Max,e,!0,!0)}),this.viewOptions.onlyBindHandles||(this.fullBarElement.onPassive(\"touchstart\",function(e){return t.onStart(null,e,!0,!0,!0)}),this.ticksElement.onPassive(\"touchstart\",function(e){return t.onStart(null,e,!1,!1,!0,!0)}))),this.viewOptions.keyboardSupport&&(this.minHandleElement.on(\"focus\",function(){return t.onPointerFocus(Dt.Min)}),this.range&&this.maxHandleElement.on(\"focus\",function(){return t.onPointerFocus(Dt.Max)}))}},{key:\"unbindEvents\",value:function(){this.unsubscribeOnMove(),this.unsubscribeOnEnd();var t,e=Object(ft.a)(this.getAllSliderElements());try{for(e.s();!(t=e.n()).done;){var i=t.value;Wt.isNullOrUndefined(i)||i.off()}}catch(n){e.e(n)}finally{e.f()}}},{key:\"onBarStart\",value:function(t,e,i,n,r,s,o){e?this.onDragStart(t,i,n,r):this.onStart(t,i,n,r,s,o)}},{key:\"onStart\",value:function(t,e,i,n,r,s){var o=this;e.stopPropagation(),Gt.isTouchEvent(e)&&yt.a.hasSupport||e.preventDefault(),this.calculateViewDimensions(),Wt.isNullOrUndefined(t)&&(t=this.getNearestHandle(e)),this.currentTrackingPointer=t;var c=this.getPointerElement(t);if(c.active=!0,this.viewOptions.keyboardSupport&&c.focus(),i){this.unsubscribeOnMove();var a=function(t){return o.dragging.active?o.onDragMove(t):o.onMove(t)};this.onMoveEventListener=Gt.isTouchEvent(e)?this.eventListenerHelper.attachPassiveEventListener(document,\"touchmove\",a,this.viewOptions.touchEventsInterval):this.eventListenerHelper.attachEventListener(document,\"mousemove\",a,this.viewOptions.mouseEventsInterval)}if(n){this.unsubscribeOnEnd();var u=function(t){return o.onEnd(t)};this.onEndEventListener=Gt.isTouchEvent(e)?this.eventListenerHelper.attachPassiveEventListener(document,\"touchend\",u):this.eventListenerHelper.attachEventListener(document,\"mouseup\",u)}this.userChangeStart.emit(this.getChangeContext()),Gt.isTouchEvent(e)&&!Wt.isNullOrUndefined(e.changedTouches)&&Wt.isNullOrUndefined(this.touchId)&&(this.touchId=e.changedTouches[0].identifier),r&&this.onMove(e,!0),s&&this.onEnd(e)}},{key:\"onMove\",value:function(t,e){var i=null;if(Gt.isTouchEvent(t)){for(var n=t.changedTouches,r=0;r<n.length;r++)if(n[r].identifier===this.touchId){i=n[r];break}if(Wt.isNullOrUndefined(i))return}var s,o=Wt.isNullOrUndefined(i)?this.getEventPosition(t):this.getEventPosition(t,i.identifier);o<=0?s=this.viewOptions.rightToLeft?this.viewOptions.ceil:this.viewOptions.floor:o>=this.maxHandlePosition?s=this.viewOptions.rightToLeft?this.viewOptions.floor:this.viewOptions.ceil:(s=this.positionToValue(o),s=e&&!Wt.isNullOrUndefined(this.viewOptions.tickStep)?this.roundStep(s,this.viewOptions.tickStep):this.roundStep(s)),this.positionTrackingHandle(s)}},{key:\"onEnd\",value:function(t){Gt.isTouchEvent(t)&&t.changedTouches[0].identifier!==this.touchId||(this.touchId=null,this.viewOptions.keyboardSupport||(this.minHandleElement.active=!1,this.maxHandleElement.active=!1,this.currentTrackingPointer=null),this.dragging.active=!1,this.unsubscribeOnMove(),this.unsubscribeOnEnd(),this.userChangeEnd.emit(this.getChangeContext()))}},{key:\"onPointerFocus\",value:function(t){var e=this,i=this.getPointerElement(t);i.on(\"blur\",function(){return e.onPointerBlur(i)}),i.on(\"keydown\",function(t){return e.onKeyboardEvent(t)}),i.on(\"keyup\",function(){return e.onKeyUp()}),i.active=!0,this.currentTrackingPointer=t,this.currentFocusPointer=t,this.firstKeyDown=!0}},{key:\"onKeyUp\",value:function(){this.firstKeyDown=!0,this.userChangeEnd.emit(this.getChangeContext())}},{key:\"onPointerBlur\",value:function(t){t.off(\"blur\"),t.off(\"keydown\"),t.off(\"keyup\"),t.active=!1,Wt.isNullOrUndefined(this.touchId)&&(this.currentTrackingPointer=null,this.currentFocusPointer=null)}},{key:\"getKeyActions\",value:function(t){var e=this.viewOptions.ceil-this.viewOptions.floor,i=t+this.viewOptions.step,n=t-this.viewOptions.step,r=t+e/10,s=t-e/10;this.viewOptions.reversedControls&&(i=t-this.viewOptions.step,n=t+this.viewOptions.step,r=t-e/10,s=t+e/10);var o={UP:i,DOWN:n,LEFT:n,RIGHT:i,PAGEUP:r,PAGEDOWN:s,HOME:this.viewOptions.reversedControls?this.viewOptions.ceil:this.viewOptions.floor,END:this.viewOptions.reversedControls?this.viewOptions.floor:this.viewOptions.ceil};return this.viewOptions.rightToLeft&&(o.LEFT=i,o.RIGHT=n,this.viewOptions.vertical&&(o.UP=n,o.DOWN=i)),o}},{key:\"onKeyboardEvent\",value:function(t){var e=this.getCurrentTrackingValue(),i=Wt.isNullOrUndefined(t.keyCode)?t.which:t.keyCode,n=this.getKeyActions(e)[{38:\"UP\",40:\"DOWN\",37:\"LEFT\",39:\"RIGHT\",33:\"PAGEUP\",34:\"PAGEDOWN\",36:\"HOME\",35:\"END\"}[i]];if(!Wt.isNullOrUndefined(n)&&!Wt.isNullOrUndefined(this.currentTrackingPointer)){t.preventDefault(),this.firstKeyDown&&(this.firstKeyDown=!1,this.userChangeStart.emit(this.getChangeContext()));var r=qt.clampToRange(n,this.viewOptions.floor,this.viewOptions.ceil),s=this.roundStep(r);if(this.viewOptions.draggableRangeOnly){var o,c,a=this.viewHighValue-this.viewLowValue;this.currentTrackingPointer===Dt.Min?(o=s,(c=s+a)>this.viewOptions.ceil&&(o=(c=this.viewOptions.ceil)-a)):this.currentTrackingPointer===Dt.Max&&(c=s,(o=s-a)<this.viewOptions.floor&&(c=(o=this.viewOptions.floor)+a)),this.positionTrackingBar(o,c)}else this.positionTrackingHandle(s)}}},{key:\"onDragStart\",value:function(t,e,i,n){var r=this.getEventPosition(e);this.dragging=new te,this.dragging.active=!0,this.dragging.value=this.positionToValue(r),this.dragging.difference=this.viewHighValue-this.viewLowValue,this.dragging.lowLimit=this.viewOptions.rightToLeft?this.minHandleElement.position-r:r-this.minHandleElement.position,this.dragging.highLimit=this.viewOptions.rightToLeft?r-this.maxHandleElement.position:this.maxHandleElement.position-r,this.onStart(t,e,i,n)}},{key:\"getMinValue\",value:function(t,e,i){var n,r=this.viewOptions.rightToLeft;return n=e?i?r?this.viewOptions.floor:this.viewOptions.ceil-this.dragging.difference:r?this.viewOptions.ceil-this.dragging.difference:this.viewOptions.floor:this.positionToValue(r?t+this.dragging.lowLimit:t-this.dragging.lowLimit),this.roundStep(n)}},{key:\"getMaxValue\",value:function(t,e,i){var n,r=this.viewOptions.rightToLeft;return n=e?i?r?this.viewOptions.floor+this.dragging.difference:this.viewOptions.ceil:r?this.viewOptions.ceil:this.viewOptions.floor+this.dragging.difference:r?this.positionToValue(t+this.dragging.lowLimit)+this.dragging.difference:this.positionToValue(t-this.dragging.lowLimit)+this.dragging.difference,this.roundStep(n)}},{key:\"onDragMove\",value:function(t){var e,i,n,r,s=this.getEventPosition(t);this.viewOptions.rightToLeft?(e=this.dragging.lowLimit,i=this.dragging.highLimit,n=this.maxHandleElement,r=this.minHandleElement):(e=this.dragging.highLimit,i=this.dragging.lowLimit,n=this.minHandleElement,r=this.maxHandleElement);var o,c,a=s>=this.maxHandlePosition-e;if(s<=i){if(0===n.position)return;o=this.getMinValue(s,!0,!1),c=this.getMaxValue(s,!0,!1)}else if(a){if(r.position===this.maxHandlePosition)return;c=this.getMaxValue(s,!0,!0),o=this.getMinValue(s,!0,!0)}else o=this.getMinValue(s,!1,!1),c=this.getMaxValue(s,!1,!1);this.positionTrackingBar(o,c)}},{key:\"positionTrackingBar\",value:function(t,e){!Wt.isNullOrUndefined(this.viewOptions.minLimit)&&t<this.viewOptions.minLimit&&(e=qt.roundToPrecisionLimit((t=this.viewOptions.minLimit)+this.dragging.difference,this.viewOptions.precisionLimit)),!Wt.isNullOrUndefined(this.viewOptions.maxLimit)&&e>this.viewOptions.maxLimit&&(t=qt.roundToPrecisionLimit((e=this.viewOptions.maxLimit)-this.dragging.difference,this.viewOptions.precisionLimit)),this.viewLowValue=t,this.viewHighValue=e,this.applyViewChange(),this.updateHandles(Dt.Min,this.valueToPosition(t)),this.updateHandles(Dt.Max,this.valueToPosition(e))}},{key:\"positionTrackingHandle\",value:function(t){t=this.applyMinMaxLimit(t),this.range&&(this.viewOptions.pushRange?t=this.applyPushRange(t):(this.viewOptions.noSwitching&&(this.currentTrackingPointer===Dt.Min&&t>this.viewHighValue?t=this.applyMinMaxRange(this.viewHighValue):this.currentTrackingPointer===Dt.Max&&t<this.viewLowValue&&(t=this.applyMinMaxRange(this.viewLowValue))),t=this.applyMinMaxRange(t),this.currentTrackingPointer===Dt.Min&&t>this.viewHighValue?(this.viewLowValue=this.viewHighValue,this.applyViewChange(),this.updateHandles(Dt.Min,this.maxHandleElement.position),this.updateAriaAttributes(),this.currentTrackingPointer=Dt.Max,this.minHandleElement.active=!1,this.maxHandleElement.active=!0,this.viewOptions.keyboardSupport&&this.maxHandleElement.focus()):this.currentTrackingPointer===Dt.Max&&t<this.viewLowValue&&(this.viewHighValue=this.viewLowValue,this.applyViewChange(),this.updateHandles(Dt.Max,this.minHandleElement.position),this.updateAriaAttributes(),this.currentTrackingPointer=Dt.Min,this.maxHandleElement.active=!1,this.minHandleElement.active=!0,this.viewOptions.keyboardSupport&&this.minHandleElement.focus()))),this.getCurrentTrackingValue()!==t&&(this.currentTrackingPointer===Dt.Min?(this.viewLowValue=t,this.applyViewChange()):this.currentTrackingPointer===Dt.Max&&(this.viewHighValue=t,this.applyViewChange()),this.updateHandles(this.currentTrackingPointer,this.valueToPosition(t)),this.updateAriaAttributes())}},{key:\"applyMinMaxLimit\",value:function(t){return!Wt.isNullOrUndefined(this.viewOptions.minLimit)&&t<this.viewOptions.minLimit?this.viewOptions.minLimit:!Wt.isNullOrUndefined(this.viewOptions.maxLimit)&&t>this.viewOptions.maxLimit?this.viewOptions.maxLimit:t}},{key:\"applyMinMaxRange\",value:function(t){var e=Math.abs(t-(this.currentTrackingPointer===Dt.Min?this.viewHighValue:this.viewLowValue));if(!Wt.isNullOrUndefined(this.viewOptions.minRange)&&e<this.viewOptions.minRange){if(this.currentTrackingPointer===Dt.Min)return qt.roundToPrecisionLimit(this.viewHighValue-this.viewOptions.minRange,this.viewOptions.precisionLimit);if(this.currentTrackingPointer===Dt.Max)return qt.roundToPrecisionLimit(this.viewLowValue+this.viewOptions.minRange,this.viewOptions.precisionLimit)}if(!Wt.isNullOrUndefined(this.viewOptions.maxRange)&&e>this.viewOptions.maxRange){if(this.currentTrackingPointer===Dt.Min)return qt.roundToPrecisionLimit(this.viewHighValue-this.viewOptions.maxRange,this.viewOptions.precisionLimit);if(this.currentTrackingPointer===Dt.Max)return qt.roundToPrecisionLimit(this.viewLowValue+this.viewOptions.maxRange,this.viewOptions.precisionLimit)}return t}},{key:\"applyPushRange\",value:function(t){var e=this.currentTrackingPointer===Dt.Min?this.viewHighValue-t:t-this.viewLowValue,i=Wt.isNullOrUndefined(this.viewOptions.minRange)?this.viewOptions.step:this.viewOptions.minRange,n=this.viewOptions.maxRange;return e<i?(this.currentTrackingPointer===Dt.Min?(this.viewHighValue=qt.roundToPrecisionLimit(Math.min(t+i,this.viewOptions.ceil),this.viewOptions.precisionLimit),t=qt.roundToPrecisionLimit(this.viewHighValue-i,this.viewOptions.precisionLimit),this.applyViewChange(),this.updateHandles(Dt.Max,this.valueToPosition(this.viewHighValue))):this.currentTrackingPointer===Dt.Max&&(this.viewLowValue=qt.roundToPrecisionLimit(Math.max(t-i,this.viewOptions.floor),this.viewOptions.precisionLimit),t=qt.roundToPrecisionLimit(this.viewLowValue+i,this.viewOptions.precisionLimit),this.applyViewChange(),this.updateHandles(Dt.Min,this.valueToPosition(this.viewLowValue))),this.updateAriaAttributes()):!Wt.isNullOrUndefined(n)&&e>n&&(this.currentTrackingPointer===Dt.Min?(this.viewHighValue=qt.roundToPrecisionLimit(t+n,this.viewOptions.precisionLimit),this.applyViewChange(),this.updateHandles(Dt.Max,this.valueToPosition(this.viewHighValue))):this.currentTrackingPointer===Dt.Max&&(this.viewLowValue=qt.roundToPrecisionLimit(t-n,this.viewOptions.precisionLimit),this.applyViewChange(),this.updateHandles(Dt.Min,this.valueToPosition(this.viewLowValue))),this.updateAriaAttributes()),t}},{key:\"getChangeContext\",value:function(){var t=new Ut;return t.pointerType=this.currentTrackingPointer,t.value=+this.value,this.range&&(t.highValue=+this.highValue),t}}])}();return t.\\u0275fac=function(e){return new(e||t)(h.Mb(h.E),h.Mb(h.l),h.Mb(h.h),h.Mb(h.A))},t.\\u0275cmp=h.Gb({type:t,selectors:[[\"ng5-slider\"]],contentQueries:function(t,e,i){var n;1&t&&h.Fb(i,gt,1),2&t&&h.rc(n=h.ac())&&(e.tooltipTemplate=n.first)},viewQuery:function(t,e){var i;1&t&&(h.Ic(wt,1,Xt),h.Ic(Ot,1,Xt),h.Ic(St,1,Xt),h.Ic(xt,1,Xt),h.Ic(_t,1,Jt),h.Ic(kt,1,Jt),h.Ic(Et,1,Qt),h.Ic(At,1,Qt),h.Ic(Tt,1,Qt),h.Ic(Ct,1,Qt),h.Ic(jt,1,Qt),h.Ic(Pt,1,Xt)),2&t&&(h.rc(i=h.ac())&&(e.leftOuterSelectionBarElement=i.first),h.rc(i=h.ac())&&(e.rightOuterSelectionBarElement=i.first),h.rc(i=h.ac())&&(e.fullBarElement=i.first),h.rc(i=h.ac())&&(e.selectionBarElement=i.first),h.rc(i=h.ac())&&(e.minHandleElement=i.first),h.rc(i=h.ac())&&(e.maxHandleElement=i.first),h.rc(i=h.ac())&&(e.floorLabelElement=i.first),h.rc(i=h.ac())&&(e.ceilLabelElement=i.first),h.rc(i=h.ac())&&(e.minHandleLabelElement=i.first),h.rc(i=h.ac())&&(e.maxHandleLabelElement=i.first),h.rc(i=h.ac())&&(e.combinedLabelElement=i.first),h.rc(i=h.ac())&&(e.ticksElement=i.first))},hostAttrs:[1,\"ng5-slider\"],hostVars:5,hostBindings:function(t,e){1&t&&h.Zb(\"resize\",function(t){return e.onResize(t)},!1,h.uc),2&t&&(h.Bb(\"disabled\",e.sliderElementDisabledAttr),h.Eb(\"vertical\",e.sliderElementVerticalClass)(\"animate\",e.sliderElementAnimateClass))},inputs:{value:\"value\",highValue:\"highValue\",options:\"options\",manualRefresh:\"manualRefresh\",triggerFocus:\"triggerFocus\"},outputs:{valueChange:\"valueChange\",highValueChange:\"highValueChange\",userChangeStart:\"userChangeStart\",userChange:\"userChange\",userChangeEnd:\"userChangeEnd\"},features:[h.zb([ne]),h.yb],decls:29,vars:13,consts:[[\"ng5SliderElement\",\"\",1,\"ng5-slider-span\",\"ng5-slider-bar-wrapper\",\"ng5-slider-left-out-selection\"],[\"leftOuterSelectionBar\",\"\"],[1,\"ng5-slider-span\",\"ng5-slider-bar\"],[\"ng5SliderElement\",\"\",1,\"ng5-slider-span\",\"ng5-slider-bar-wrapper\",\"ng5-slider-right-out-selection\"],[\"rightOuterSelectionBar\",\"\"],[\"ng5SliderElement\",\"\",1,\"ng5-slider-span\",\"ng5-slider-bar-wrapper\",\"ng5-slider-full-bar\"],[\"fullBar\",\"\"],[\"ng5SliderElement\",\"\",1,\"ng5-slider-span\",\"ng5-slider-bar-wrapper\",\"ng5-slider-selection-bar\"],[\"selectionBar\",\"\"],[1,\"ng5-slider-span\",\"ng5-slider-bar\",\"ng5-slider-selection\",3,\"ngStyle\"],[\"ng5SliderHandle\",\"\",1,\"ng5-slider-span\",\"ng5-slider-pointer\",\"ng5-slider-pointer-min\",3,\"ngStyle\"],[\"minHandle\",\"\"],[\"ng5SliderHandle\",\"\",1,\"ng5-slider-span\",\"ng5-slider-pointer\",\"ng5-slider-pointer-max\",3,\"ngStyle\"],[\"maxHandle\",\"\"],[\"ng5SliderLabel\",\"\",1,\"ng5-slider-span\",\"ng5-slider-bubble\",\"ng5-slider-limit\",\"ng5-slider-floor\"],[\"floorLabel\",\"\"],[\"ng5SliderLabel\",\"\",1,\"ng5-slider-span\",\"ng5-slider-bubble\",\"ng5-slider-limit\",\"ng5-slider-ceil\"],[\"ceilLabel\",\"\"],[\"ng5SliderLabel\",\"\",1,\"ng5-slider-span\",\"ng5-slider-bubble\",\"ng5-slider-model-value\"],[\"minHandleLabel\",\"\"],[\"ng5SliderLabel\",\"\",1,\"ng5-slider-span\",\"ng5-slider-bubble\",\"ng5-slider-model-high\"],[\"maxHandleLabel\",\"\"],[\"ng5SliderLabel\",\"\",1,\"ng5-slider-span\",\"ng5-slider-bubble\",\"ng5-slider-combined\"],[\"combinedLabel\",\"\"],[\"ng5SliderElement\",\"\",1,\"ng5-slider-ticks\",3,\"hidden\"],[\"ticksElement\",\"\"],[\"class\",\"ng5-slider-tick\",3,\"ngClass\",\"ngStyle\",4,\"ngFor\",\"ngForOf\"],[1,\"ng5-slider-tick\",3,\"ngClass\",\"ngStyle\"],[3,\"template\",\"tooltip\",\"placement\"],[\"class\",\"ng5-slider-span ng5-slider-tick-value\",3,\"template\",\"tooltip\",\"placement\",\"content\",4,\"ngIf\"],[\"class\",\"ng5-slider-span ng5-slider-tick-legend\",3,\"innerHTML\",4,\"ngIf\"],[1,\"ng5-slider-span\",\"ng5-slider-tick-value\",3,\"template\",\"tooltip\",\"placement\",\"content\"],[1,\"ng5-slider-span\",\"ng5-slider-tick-legend\",3,\"innerHTML\"]],template:function(t,e){1&t&&(h.Sb(0,\"span\",0,1),h.Nb(2,\"span\",2),h.Rb(),h.Sb(3,\"span\",3,4),h.Nb(5,\"span\",2),h.Rb(),h.Sb(6,\"span\",5,6),h.Nb(8,\"span\",2),h.Rb(),h.Sb(9,\"span\",7,8),h.Nb(11,\"span\",9),h.Rb(),h.Nb(12,\"span\",10,11),h.Nb(14,\"span\",12,13),h.Nb(16,\"span\",14,15),h.Nb(18,\"span\",16,17),h.Nb(20,\"span\",18,19),h.Nb(22,\"span\",20,21),h.Nb(24,\"span\",22,23),h.Sb(26,\"span\",24,25),h.Bc(28,Vt,4,9,\"span\",26),h.Rb()),2&t&&(h.Ab(6),h.Eb(\"ng5-slider-transparent\",e.fullBarTransparentClass),h.Ab(3),h.Eb(\"ng5-slider-draggable\",e.selectionBarDraggableClass),h.Ab(2),h.ic(\"ngStyle\",e.barStyle),h.Ab(1),h.ic(\"ngStyle\",e.minPointerStyle),h.Ab(2),h.zc(\"display\",e.range?\"inherit\":\"none\"),h.ic(\"ngStyle\",e.maxPointerStyle),h.Ab(12),h.Eb(\"ng5-slider-ticks-values-under\",e.ticksUnderValuesClass),h.ic(\"hidden\",!e.showTicks),h.Ab(2),h.ic(\"ngForOf\",e.ticks))},directives:function(){return[Xt,n.m,Jt,Qt,n.k,n.j,se,n.l]},styles:[\".ng5-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:pan-y;touch-action:pan-y}  .ng5-slider.with-legend{margin-bottom:40px}  .ng5-slider[disabled]{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}  .ng5-slider[disabled] .ng5-slider-draggable{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-selection{background:#8b91a2}  .ng5-slider[disabled] .ng5-slider-tick{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-tick.ng5-slider-selected{background:#8b91a2}  .ng5-slider .ng5-slider-span{white-space:nowrap;position:absolute;display:inline-block}  .ng5-slider .ng5-slider-base{width:100%;height:100%;padding:0}  .ng5-slider .ng5-slider-bar-wrapper{left:0;-webkit-box-sizing:border-box;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}  .ng5-slider .ng5-slider-draggable{cursor:move}  .ng5-slider .ng5-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-transparent .ng5-slider-bar{background:0 0}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-left-out-selection .ng5-slider-bar{background:#df002d}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-right-out-selection .ng5-slider-bar{background:#03a688}  .ng5-slider .ng5-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}  .ng5-slider .ng5-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}  .ng5-slider .ng5-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}  .ng5-slider .ng5-slider-pointer:hover:after{background-color:#fff}  .ng5-slider .ng5-slider-pointer.ng5-slider-active{z-index:4}  .ng5-slider .ng5-slider-pointer.ng5-slider-active:after{background-color:#451aff}  .ng5-slider .ng5-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}  .ng5-slider .ng5-slider-bubble.ng5-slider-limit{color:#55637d}  .ng5-slider .ng5-slider-ticks{-webkit-box-sizing:border-box;box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}  .ng5-slider .ng5-slider-ticks-values-under .ng5-slider-tick-value{top:auto;bottom:-36px}  .ng5-slider .ng5-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}  .ng5-slider .ng5-slider-tick.ng5-slider-selected{background:#0db9f0}  .ng5-slider .ng5-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}  .ng5-slider .ng5-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}  .ng5-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;-ms-touch-action:pan-x;touch-action:pan-x}  .ng5-slider.vertical .ng5-slider-base{width:100%;height:100%;padding:0}  .ng5-slider.vertical .ng5-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}  .ng5-slider.vertical .ng5-slider-bar{bottom:0;left:auto;width:4px;height:100%}  .ng5-slider.vertical .ng5-slider-pointer{left:-14px!important;top:auto;bottom:0}  .ng5-slider.vertical .ng5-slider-bubble{left:16px!important;bottom:0}  .ng5-slider.vertical .ng5-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}  .ng5-slider.vertical .ng5-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}  .ng5-slider.vertical .ng5-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}  .ng5-slider.vertical .ng5-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}  .ng5-slider.vertical .ng5-slider-ticks-values-under .ng5-slider-tick-value{bottom:auto;left:auto;right:24px}  .ng5-slider *{-webkit-transition:none;transition:none}  .ng5-slider.animate .ng5-slider-bar-wrapper{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-selection{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}  .ng5-slider.animate .ng5-slider-pointer{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-bubble{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-bubble.ng5-slider-limit{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}  .ng5-slider.animate .ng5-slider-bubble.ng5-slider-combined{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}  .ng5-slider.animate .ng5-slider-tick{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}\"]}),t}(),se=function(){var t=Object(l.a)(function t(){Object(u.a)(this,t)});return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275cmp=h.Gb({type:t,selectors:[[\"ng5-slider-tooltip-wrapper\"]],inputs:{template:\"template\",tooltip:\"tooltip\",placement:\"placement\",content:\"content\"},decls:2,vars:2,consts:[[4,\"ngIf\"],[4,\"ngTemplateOutlet\",\"ngTemplateOutletContext\"],[1,\"ng5-slider-inner-tooltip\"]],template:function(t,e){1&t&&(h.Bc(0,Ft,2,6,\"ng-container\",0),h.Bc(1,Bt,3,3,\"ng-container\",0)),2&t&&(h.ic(\"ngIf\",e.template),h.Ab(1),h.ic(\"ngIf\",!e.template))},directives:[n.l,n.q],styles:[\".ng5-slider-inner-tooltip[_ngcontent-%COMP%]{height:100%}\"]}),t}(),oe=function(){var t=Object(l.a)(function t(){Object(u.a)(this,t)});return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275mod=h.Kb({type:t}),t.\\u0275inj=h.Jb({imports:[[n.c]]}),t}(),ce=i(\"R0Ic\"),ae=\"400ms cubic-bezier(0.4,0.0,0.2,1)\",ue=[Object(ce.h)({height:0,visibility:\"hidden\"}),Object(ce.e)(ae,Object(ce.h)({height:\"*\",visibility:\"visible\"}))],le=[Object(ce.h)({height:\"*\",visibility:\"visible\"}),Object(ce.e)(ae,Object(ce.h)({height:0,visibility:\"hidden\"}))],he=function(){var t=function(){return Object(l.a)(function t(e,i,n){Object(u.a)(this,t),this._el=e,this._renderer=i,this.collapsed=new h.n,this.collapses=new h.n,this.expanded=new h.n,this.expands=new h.n,this.isExpanded=!0,this.collapseNewValue=!0,this.isCollapsed=!1,this.isCollapse=!0,this.isCollapsing=!1,this.isAnimated=!1,this._display=\"block\",this._stylesLoaded=!1,this._COLLAPSE_ACTION_NAME=\"collapse\",this._EXPAND_ACTION_NAME=\"expand\",this._factoryCollapseAnimation=n.build(le),this._factoryExpandAnimation=n.build(ue)},[{key:\"display\",set:function(t){this.isAnimated?(this._display=t,\"none\"!==t?this.show():this.hide()):this._renderer.setStyle(this._el.nativeElement,\"display\",t)}},{key:\"collapse\",get:function(){return this.isExpanded},set:function(t){this.collapseNewValue=t,this._player&&!this._isAnimationDone||(this.isExpanded=t,this.toggle())}},{key:\"ngAfterViewChecked\",value:function(){this._stylesLoaded=!0,this._player&&this._isAnimationDone&&(this._player.reset(),this._renderer.setStyle(this._el.nativeElement,\"height\",\"*\"))}},{key:\"toggle\",value:function(){this.isExpanded?this.hide():this.show()}},{key:\"hide\",value:function(){var t=this;this.isCollapsing=!0,this.isExpanded=!1,this.isCollapsed=!0,this.isCollapsing=!1,this.collapses.emit(this),this._isAnimationDone=!1,this.animationRun(this.isAnimated,this._COLLAPSE_ACTION_NAME)(function(){t._isAnimationDone=!0,t.collapseNewValue!==t.isCollapsed&&t.isAnimated?t.show():(t.collapsed.emit(t),t._renderer.setStyle(t._el.nativeElement,\"display\",\"none\"))})}},{key:\"show\",value:function(){var t=this;this._renderer.setStyle(this._el.nativeElement,\"display\",this._display),this.isCollapsing=!0,this.isExpanded=!0,this.isCollapsed=!1,this.isCollapsing=!1,this.expands.emit(this),this._isAnimationDone=!1,this.animationRun(this.isAnimated,this._EXPAND_ACTION_NAME)(function(){t._isAnimationDone=!0,t.collapseNewValue!==t.isCollapsed&&t.isAnimated?t.hide():(t.expanded.emit(t),t._renderer.removeStyle(t._el.nativeElement,\"overflow\"))})}},{key:\"animationRun\",value:function(t,e){var i=this;if(!t||!this._stylesLoaded)return function(t){return t()};this._renderer.setStyle(this._el.nativeElement,\"overflow\",\"hidden\"),this._renderer.addClass(this._el.nativeElement,\"collapse\");var n=e===this._EXPAND_ACTION_NAME?this._factoryExpandAnimation:this._factoryCollapseAnimation;return this._player&&this._player.destroy(),this._player=n.create(this._el.nativeElement),this._player.play(),function(t){return i._player.onDone(t)}}}])}();return t.\\u0275fac=function(e){return new(e||t)(h.Mb(h.l),h.Mb(h.E),h.Mb(ce.b))},t.\\u0275dir=h.Hb({type:t,selectors:[[\"\",\"collapse\",\"\"]],hostVars:10,hostBindings:function(t,e){2&t&&(h.Bb(\"aria-expanded\",e.isExpanded)(\"aria-hidden\",e.isCollapsed),h.Eb(\"collapse\",e.isCollapse)(\"in\",e.isExpanded)(\"show\",e.isExpanded)(\"collapsing\",e.isCollapsing))},inputs:{isAnimated:\"isAnimated\",display:\"display\",collapse:\"collapse\"},outputs:{collapsed:\"collapsed\",collapses:\"collapses\",expanded:\"expanded\",expands:\"expands\"},exportAs:[\"bs-collapse\"]}),t}(),pe=function(){var t=function(){function t(){Object(u.a)(this,t)}return Object(l.a)(t,null,[{key:\"forRoot\",value:function(){return{ngModule:t,providers:[]}}}])}();return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275mod=h.Kb({type:t}),t.\\u0275inj=h.Jb({}),t}(),fe=i(\"wf0l\"),de=i(\"grbu\"),be=i(\"WEVr\"),ve=i(\"IXfK\"),ye=i(\"u37Z\"),me=i(\"n8hT\"),ge=i(\"oHwy\"),we=i(\"jnmN\"),Oe=i(\"q2mU\"),Se=i(\"s+OP\"),xe=i(\"DZKH\"),_e=i(\"xa+l\"),ke=i(\"L65D\"),Ee=function(t,e){return{\"fa-chevron-right\":t,\"fa-chevron-down\":e}};function Ae(t,e){if(1&t&&h.Nb(0,\"i\",33),2&t){var i=h.bc().$implicit,n=h.bc();h.ic(\"ngClass\",h.nc(1,Ee,1==n.collapsedMenu.includes(i.id),0==n.collapsedMenu.includes(i.id)))}}var Te=function(t){return[t]};function Ce(t,e){if(1&t&&(h.Sb(0,\"li\",34),h.Sb(1,\"div\",35),h.Sb(2,\"div\",36),h.Dc(3),h.Rb(),h.Rb(),h.Rb()),2&t){var i=e.$implicit;h.Ab(1),h.ic(\"routerLink\",h.mc(2,Te,\"/san-pham/\"+i.link)),h.Ab(2),h.Fc(\" \",i.name,\" \")}}var je=function(t){return{active:t}};function Pe(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"li\"),h.Sb(1,\"div\",29),h.Zb(\"click\",function(){h.vc(i);var t=e.$implicit;return h.bc().collapseMenu(t.id)}),h.Sb(2,\"div\"),h.Dc(3),h.Rb(),h.Bc(4,Ae,1,4,\"i\",30),h.Rb(),h.Sb(5,\"ul\",31),h.Bc(6,Ce,4,4,\"li\",32),h.Rb(),h.Rb()}if(2&t){var n=e.$implicit,r=h.bc();h.Ab(1),h.ic(\"routerLink\",h.mc(7,Te,\"/san-pham/\"+n.link))(\"ngClass\",h.mc(9,je,0==r.collapsedMenu.includes(n.id))),h.Ab(2),h.Ec(n.name),h.Ab(1),h.ic(\"ngIf\",n.data&&+n.data.length>0),h.Ab(1),h.ic(\"collapse\",1==r.collapsedMenu.includes(n.id))(\"isAnimated\",!0),h.Ab(1),h.ic(\"ngForOf\",n.data)}}var Ie=function(t){return{count:t}};function Me(t,e){if(1&t&&(h.Sb(0,\"div\",37),h.Dc(1),h.cc(2,\"translate\"),h.Rb()),2&t){var i=h.bc();h.Ab(1),h.Fc(\" \",h.ec(2,1,\"FEProduct.count\",h.mc(4,Ie,i.count)),\" \")}}function Le(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"div\",38),h.Sb(1,\"span\",39),h.Dc(2),h.cc(3,\"translate\"),h.Rb(),h.Sb(4,\"button\",40),h.Zb(\"click\",function(){h.vc(i);var t=e.$implicit;return h.bc().cwstable._sorting(t.field,\"desc\")}),h.Nb(5,\"i\",41),h.Rb(),h.Sb(6,\"button\",42),h.Zb(\"click\",function(){h.vc(i);var t=e.$implicit;return h.bc().cwstable._sorting(t.field,\"asc\")}),h.Nb(7,\"i\",43),h.Rb(),h.Rb()}if(2&t){var n=e.$implicit;h.Ab(2),h.Fc(\"\",h.dc(3,1,n.title),\":\")}}function Ve(t,e){if(1&t&&(h.Sb(0,\"div\",48),h.Nb(1,\"app-box-product\",49),h.Rb()),2&t){var i=e.$implicit;h.Ab(1),h.ic(\"item\",i)}}function Ne(t,e){1&t&&(h.Sb(0,\"div\",50),h.Sb(1,\"h4\"),h.Dc(2),h.cc(3,\"translate\"),h.Rb(),h.Rb()),2&t&&(h.Ab(2),h.Ec(h.dc(3,1,\"FEProduct.NotHaveProduct\")))}function Re(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"div\",51),h.Sb(1,\"pagination\",52),h.Zb(\"pageChanged\",function(t){return h.vc(i),h.bc(2).Pagination.change(t)}),h.Rb(),h.Rb()}if(2&t){var n=h.bc(2);h.Ab(1),h.ic(\"directionLinks\",!1)(\"totalItems\",n.cwstable.cached.length)(\"itemsPerPage\",n.Pagination.itemsPerPage)(\"maxSize\",n.Pagination.maxSize)}}function He(t,e){if(1&t&&(h.Sb(0,\"div\",44),h.Bc(1,Ve,2,1,\"div\",45),h.Bc(2,Ne,4,3,\"div\",46),h.Bc(3,Re,2,4,\"div\",47),h.Rb()),2&t){var i=h.bc();h.Ab(1),h.ic(\"ngForOf\",i.cwstable.data),h.Ab(1),h.ic(\"ngIf\",!i.cwstable.data||0==i.cwstable.data.length),h.Ab(1),h.ic(\"ngIf\",i.cwstable.cached.length>i.Pagination.itemsPerPage)}}function Fe(t,e){1&t&&(h.Sb(0,\"div\",12),h.Sb(1,\"div\",50),h.Sb(2,\"h4\"),h.Dc(3),h.cc(4,\"translate\"),h.Rb(),h.Rb(),h.Rb()),2&t&&(h.Ab(3),h.Ec(h.dc(4,1,\"FEProduct.NotHaveProduct\")))}var Be=function(){return[\"/\"]},De=function(){return{exact:!0}},Ze=function(){function t(t,e,i,n,r){var s=this;this.globals=t,this.route=e,this.router=i,this.toSlug=n,this.translate=r,this.cwstable=new Se.a,this.searchValue=\"\",this.show=-1,this.price={min:0,max:0},this.page={},this.data=[],this.categories=[],this.cateListId=[],this.token={getProduct:\"api/product/getproduct\",getLink:\"api/product/getlink\",productCategory:\"api/home/getcategories\"},this.width=document.body.getBoundingClientRect().width,this.collapsedMenu=[],this.openMobileFilter=!1,this.count=0,this.cols=[{title:\"FEProduct.sortName\",field:\"name\",filter:!0,active:!0},{title:\"FEProduct.sortPrice\",field:\"price\",filter:!0,type:\"number\"}],this.minValue=0,this.maxValue=100,this.options={floor:0,ceil:100,translate:function(t,e){switch(e){case Zt.Low:return'<b style=\"font-size:12px\">Min: '+s.setnumber(t)+\" \\u0111 </b>\";case Zt.High:return'<b style=\"font-size:12px\">Max: '+s.setnumber(t)+\" \\u0111 </b>\";default:return s.setnumber(t)}}},this.Pagination={maxSize:5,itemsPerPage:16,change:function(t){s.cwstable.data=s.cwstable.cached.slice((t.page-1)*t.itemsPerPage,t.page*t.itemsPerPage),document.getElementById(\"ListData\"),window.scrollTo({top:0,left:0,behavior:\"smooth\"})}},this.extract=function(){var t={},e={},i={min:0,max:0};s.cwstable.cachedList.length>0&&(i.min=+s.cwstable.cachedList[0].price_sale>0?+s.cwstable.cachedList[0].price_sale:+s.cwstable.cachedList[0].price,s.cwstable.cachedList.reduce(function(n,r,o){r.brand_id&&+r.brand_id>0&&(t[r.brand_id]||(t[r.brand_id]={id:r.brand_id,name:r.brand_name,count:0}),t[r.brand_id]&&(t[r.brand_id].count=+t[r.brand_id].count+1)),r.page_id&&+r.page_id>0&&(e[r.page_id]||(e[r.page_id]={id:r.page_id,name:r.parent_name,count:0}),e[r.page_id]&&(e[r.page_id].count=+e[r.page_id].count+1));var c=+r.price_sale>0?+r.price_sale:+r.price;return i.min=c<i.min?c:i.min,i.max=c>i.max?c:i.max,s.changeOptions({floor:0,ceil:i.max}),n},{}),s.price=i)},this.groupCategory={data:[],value:[],filter:function(t,e){void 0===e&&(e=0);var i=\"page_id\",n=s.cwstable._getFilter(i);(n.value?n.value.reduce(function(t,e){return t[e]=e,t},{}):{})[t]?s.groupCategory.value=n.value.filter(function(i){return 1==e||+i!=t}):s.groupCategory.value.push(t),0==s.groupCategory.value.length?s.cwstable._delFilter(i):s.cwstable._setFilter(i,s.groupCategory.value,\"in\")}},this.connect=this.globals.result.subscribe(function(t){switch(t.token){case\"getProduct\":s.data=[],s.count=-1,console.log(\"\\ud83d\\ude80 ~ file: list.component.ts:74 ~ ListProductComponent ~ this.connect=this.globals.result.subscribe ~ this.count:\",s.count),t.data.length>0&&(s.data=t.data.filter(function(t){return t.price_actual=+t.price_sale&&+t.price_sale>0?+t.price_sale:+t.price})),s.show=s.data&&s.data.length>0?1:0,s.count=s.data&&s.data.length>0?s.data.length:0,console.log(\"\\ud83d\\ude80 ~ file: list.component.ts:79 ~ ListProductComponent ~ this.connect=this.globals.result.subscribe ~ this.count:\",s.count),s.cwstable._concat(s.data,!0),s.extract(),setTimeout(function(){s.catFilter(s.data.id)},50);break;case\"getLink\":s.page={},s.page=t.data;break;case\"productCategory\":s.categories=s.compaid(t.data),s.cateListId=t.data.reduce(function(t,e){return t[e.id]=e,t},[])}})}return t.prototype.ngOnInit=function(){var t=this;this.globals.send({path:this.token.productCategory,token:\"productCategory\"}),this.cwstable._ini({data:[],cols:this.cols,keyword:\"getProduct\",count:this.Pagination.itemsPerPage,sorting:{field:\"name\",sort:\"\",type:\"number\"}}),this.route.params.subscribe(function(e){t.data=[],t.count=-1,t.globals.send({path:t.token.getLink,token:\"getLink\",params:{link:e.links&&e.links.length>0?e.links:e.link||\"san-pham\"}}),t.globals.send(e.link&&e.link.length>0||e.links&&e.links.length>0?{path:t.token.getProduct,token:\"getProduct\",params:{link:e.links&&e.links.length>0?e.links:e.link}}:{path:t.token.getProduct,token:\"getProduct\"})})},t.prototype.ngOnChanges=function(t){},t.prototype.catFilter=function(t){var e=this;this.cateListId[+t]&&this.cateListId[+t].length>0?this.cateListId[+t].filter(function(t){e.groupCategory.filter(t.id,1)}):(+t<3||+t>4)&&this.groupCategory.filter(t,1)},t.prototype.changeOptions=function(t){var e=Object.assign({},this.options);e.ceil=t.ceil,e.floor=t.floor,this.options=e,this.minValue=t.floor,this.maxValue=t.ceil},t.prototype.onUserChangeEnd=function(t){this.cwstable._setFilter(\"price_actual\",[t.value,t.highValue],\"between\")},t.prototype.setnumber=function(t){return new Number(t).toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g,\".\")},t.prototype.collapseMenu=function(t){if(!0===this.collapsedMenu.includes(t)){var e=this.collapsedMenu.indexOf(t);this.collapsedMenu.splice(e,1)}else this.collapsedMenu.push(t)},t.prototype.setMenuMobile=function(t){var e=document.getElementsByTagName(\"body\")[0];this.openMobileFilter=t,e.style.position=t?\"fixed\":\"inherit\"},t.prototype.compaid=function(t){for(var e=[],i=function(i){t=t.filter(function(n){var r=+n.page_id==+t[i].id?+n.page_id:0;return 0!=r&&e.push(n),0==r})},n=0;n<t.length;n++)i(n);var r=function(t,i,n){if(void 0===n&&(n=0),n+=1,1==i)return t;for(var s=function(i){var s=[];e=e.filter(function(e){var n=+e.page_id!=+t[i].id;return t[i].page_id>0&&+e.page_id==+t[i].id&&(t[i].static=!0),0==n&&s.push(e),n});var o=0==s.length;t[i].level=n,t[i].data=r(s,o,n)},o=0;o<t.length;o++)s(o);return t};return r(t,!1)},t.\\u0275fac=function(e){return new(e||t)(h.Mb(_e.a),h.Mb(s.a),h.Mb(s.c),h.Mb(xe.a),h.Mb(o.e))},t.\\u0275cmp=h.Gb({type:t,selectors:[[\"app-product\"]],features:[h.zb([xe.a]),h.yb],decls:42,vars:23,consts:[[1,\"bg-light\",\"py-md-5\",\"py-3\"],[1,\"container-main\"],[1,\"container-fluid\"],[1,\"title-page\"],[1,\"d-md-flex\",\"align-items-center\",\"justify-content-between\"],[1,\"mb-0\",\"text-uppercase\"],[\"aria-label\",\"breadcrumb\"],[1,\"breadcrumb\",\"bg-transparent\",\"border-0\",\"m-0\",\"p-0\"],[\"aria-current\",\"page\",1,\"breadcrumb-item\"],[\"routerLinkActive\",\"router-link-active\",3,\"routerLink\"],[\"routerLinkActive\",\"is--active\",3,\"routerLink\",\"routerLinkActiveOptions\"],[\"id\",\"list-product\",1,\"bg-light\"],[1,\"row\"],[1,\"col-3\",\"d-none\",\"d-md-block\"],[1,\"card\",\"rounded-0\",\"border-0\"],[1,\"pl-0\",\"mb-0\"],[4,\"ngFor\",\"ngForOf\"],[1,\"card\",\"mt-2\",\"rounded-0\",\"border-0\"],[1,\"title\",\"p-3\",\"d-flex\",\"justify-content-between\"],[1,\"card-body\",\"p-2\"],[3,\"value\",\"highValue\",\"options\",\"userChangeEnd\",\"valueChange\",\"highValueChange\"],[1,\"col-12\",\"col-md-9\",\"pb-4\"],[1,\"d-flex\",\"justify-content-between\",\"align-items-center\",\"w-100\",\"bg-white\",\"p-2\",\"mb-3\"],[1,\"d-flex\",\"align-items-center\",\"justify-content-between\"],[\"style\",\"color: #595959\",4,\"ngIf\"],[1,\"d-none\",\"d-md-flex\",\"align-items-center\",\"justify-content-between\"],[\"class\",\"mr-md-3 d-flex align-items-center\",4,\"ngFor\",\"ngForOf\"],[\"id\",\"ListData\",\"class\",\"row px-2\",4,\"ngIf\"],[\"class\",\"row\",4,\"ngIf\"],[\"routerLinkActive\",\"router-link-active\",1,\"title\",\"p-3\",\"d-flex\",\"justify-content-between\",3,\"routerLink\",\"ngClass\",\"click\"],[\"class\",\"fas\",3,\"ngClass\",4,\"ngIf\"],[1,\"pl-1\",3,\"collapse\",\"isAnimated\"],[\"class\",\"px-3 pb-3\",\"style\",\"overflow:hidden\",4,\"ngFor\",\"ngForOf\"],[1,\"fas\",3,\"ngClass\"],[1,\"px-3\",\"pb-3\",2,\"overflow\",\"hidden\"],[\"routerLinkActive\",\"router-link-active\",1,\"d-flex\",\"align-items-center\",\"justify-content-between\",3,\"routerLink\"],[1,\"item-title\"],[2,\"color\",\"#595959\"],[1,\"mr-md-3\",\"d-flex\",\"align-items-center\"],[1,\"mr-1\"],[1,\"btn\",\"btn-sm\",\"rounded\",\"mr-2\",\"border\",\"px-2\",\"py-1\",3,\"click\"],[1,\"fas\",\"fa-sort-amount-down\"],[1,\"btn\",\"btn-sm\",\"border\",\"rounded\",\"px-2\",\"py-1\",3,\"click\"],[1,\"fas\",\"fa-sort-amount-up\"],[\"id\",\"ListData\",1,\"row\",\"px-2\"],[\"class\",\"col-lg-3 col-md-4 col-6 px-2 mb-4\",4,\"ngFor\",\"ngForOf\"],[\"class\",\"col-12 text-center pt-4 pb-4\",4,\"ngIf\"],[\"class\",\"col-12\",4,\"ngIf\"],[1,\"col-lg-3\",\"col-md-4\",\"col-6\",\"px-2\",\"mb-4\"],[3,\"item\"],[1,\"col-12\",\"text-center\",\"pt-4\",\"pb-4\"],[1,\"col-12\"],[1,\"d-flex\",\"justify-content-end\",\"pt-lg-4\",3,\"directionLinks\",\"totalItems\",\"itemsPerPage\",\"maxSize\",\"pageChanged\"]],template:function(t,e){1&t&&(h.Sb(0,\"div\",0),h.Sb(1,\"div\",1),h.Sb(2,\"div\",2),h.Sb(3,\"div\",3),h.Sb(4,\"div\",4),h.Sb(5,\"h4\",5),h.Dc(6),h.Rb(),h.Sb(7,\"nav\",6),h.Sb(8,\"ol\",7),h.Sb(9,\"li\",8),h.Sb(10,\"a\",9),h.Dc(11),h.cc(12,\"translate\"),h.Rb(),h.Rb(),h.Sb(13,\"li\",8),h.Sb(14,\"a\",10),h.Dc(15),h.cc(16,\"translate\"),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Sb(17,\"div\",11),h.Sb(18,\"div\",1),h.Sb(19,\"div\",2),h.Sb(20,\"div\",12),h.Sb(21,\"div\",13),h.Sb(22,\"div\",14),h.Sb(23,\"ul\",15),h.Bc(24,Pe,7,11,\"li\",16),h.Rb(),h.Rb(),h.Sb(25,\"div\",17),h.Sb(26,\"ul\",15),h.Sb(27,\"li\"),h.Sb(28,\"div\",18),h.Sb(29,\"div\"),h.Dc(30),h.cc(31,\"translate\"),h.Rb(),h.Rb(),h.Sb(32,\"div\",19),h.Sb(33,\"ng5-slider\",20),h.Zb(\"userChangeEnd\",function(t){return e.onUserChangeEnd(t)})(\"valueChange\",function(t){return e.minValue=t})(\"highValueChange\",function(t){return e.maxValue=t}),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Sb(34,\"div\",21),h.Sb(35,\"div\",22),h.Sb(36,\"div\",23),h.Bc(37,Me,3,6,\"div\",24),h.Rb(),h.Sb(38,\"div\",25),h.Bc(39,Le,8,3,\"div\",26),h.Rb(),h.Rb(),h.Bc(40,He,4,3,\"div\",27),h.Bc(41,Fe,5,3,\"div\",28),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb()),2&t&&(h.Ab(6),h.Ec(e.page.name),h.Ab(4),h.ic(\"routerLink\",h.lc(21,Be)),h.Ab(1),h.Fc(\" \",h.dc(12,15,\"lblHome\"),\" \"),h.Ab(3),h.ic(\"routerLink\",\"/san-pham/\")(\"routerLinkActiveOptions\",h.lc(22,De)),h.Ab(1),h.Fc(\" \",h.dc(16,17,\"FEProduct.product\"),\" \"),h.Ab(9),h.ic(\"ngForOf\",e.categories),h.Ab(6),h.Ec(h.dc(31,19,\"FEProduct.price\")),h.Ab(3),h.ic(\"value\",e.minValue)(\"highValue\",e.maxValue)(\"options\",e.options),h.Ab(4),h.ic(\"ngIf\",e.count>-1),h.Ab(2),h.ic(\"ngForOf\",e.cwstable.cols),h.Ab(1),h.ic(\"ngIf\",1==e.show),h.Ab(1),h.ic(\"ngIf\",0==e.show))},directives:[s.f,s.e,n.k,re,n.l,s.d,n.j,he,ke.a,a.a],pipes:[o.d],styles:[\"ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{list-style:none}.title[_ngcontent-%COMP%]{font-size:.95rem;cursor:pointer}.btn[_ngcontent-%COMP%]:focus{color:#e24861}.active[_ngcontent-%COMP%], .item-title[_ngcontent-%COMP%]:hover, input[_ngcontent-%COMP%]{cursor:pointer}#mobile-filter[_ngcontent-%COMP%]{height:100%;width:100%;position:fixed;z-index:9999;top:0;left:0;background-color:rgba(0,0,0,.6);overflow-x:hidden;transition:.5s}#mobile-filter[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{position:relative;top:0;width:100%;text-align:center}\"]}),t}(),ze=i(\"tk/3\"),Ue=function(){function t(t,e){this.http=t,this.globals=e}return t.prototype.getDetail=function(t){return void 0===t&&(t={}),this.http.get(this.globals.BASE_API_URL+\"api/product/getdetail\"+this.globals._params.process(t),this.globals.headersReject).pipe()},t.\\u0275fac=function(e){return new(e||t)(h.Wb(ze.b),h.Wb(_e.a))},t.\\u0275prov=h.Ib({token:t,factory:t.\\u0275fac,providedIn:\"root\"}),t}(),We=i(\"a9SS\"),Ge=i(\"tMUy\"),qe=i(\"nSbU\"),Ke=i(\"NqMM\"),Ye=[\"owlLibrary\"],Xe=function(t){return[t]};function Je(t,e){if(1&t&&(h.Sb(0,\"div\"),h.Sb(1,\"div\"),h.Sb(2,\"a\",51),h.Nb(3,\"img\",52),h.cc(4,\"translate\"),h.Rb(),h.Rb(),h.Rb()),2&t){var i=h.bc();h.Ab(2),h.ic(\"routerLink\",h.mc(8,Xe,\"/san-pham/\"+i.item.href+\"/\"+i.item.link)),h.Ab(1),h.ic(\"routerLink\",h.mc(10,Xe,\"/san-pham/\"+i.item.href+\"/\"+i.item.link))(\"defaultImage\",h.dc(4,6,\"FEImagesProduct\"))(\"lazyLoad\",i.item.images)(\"title\",i.item.name)(\"alt\",i.item.name)}}function Qe(t,e){if(1&t&&(h.Sb(0,\"a\",60),h.Nb(1,\"img\",61),h.Rb()),2&t){var i=h.bc().$implicit,n=h.bc(2);h.ic(\"href\",n.globals.BASE_API_URL+\"public/products/\"+i,h.xc),h.Ab(1),h.ic(\"defaultImage\",n.globals.BASE_API_URL+\"public/products/\"+i)(\"lazyLoad\",n.globals.BASE_API_URL+\"public/products/\"+i)(\"alt\",i)(\"name\",i)}}function $e(t,e){if(1&t&&(h.Qb(0),h.Bc(1,Qe,2,5,\"ng-template\",59),h.Pb()),2&t){var i=e.index;h.Ab(1),h.ic(\"id\",\"images-\"+i)}}var ti=function(t){return{\"d-none \":t}};function ei(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"div\",62),h.Sb(1,\"img\",63),h.Zb(\"click\",function(){h.vc(i);var t=e.index;h.bc();var n=h.sc(2);return h.bc().detail.onClickImageChild(\"images-\"+t+\"-child\"),n.to(\"images-\"+t)}),h.cc(2,\"translate\"),h.Rb(),h.Rb()}if(2&t){var n=e.$implicit,r=e.index,s=h.bc(2);h.Ab(1),h.ic(\"ngClass\",h.mc(8,ti,r>4))(\"id\",\"images-\"+r+\"-child\")(\"defaultImage\",h.dc(2,6,\"FEImagesProduct\"))(\"lazyLoad\",s.globals.BASE_API_URL+\"public/products/\"+n)(\"alt\",n)(\"name\",n)}}function ii(t,e){if(1&t&&(h.Sb(0,\"div\",62),h.Nb(1,\"img\",64),h.Sb(2,\"a\",65),h.Sb(3,\"div\",66),h.Sb(4,\"div\",67),h.Nb(5,\"i\",68),h.Rb(),h.Rb(),h.Rb(),h.Rb()),2&t){var i=h.bc(2);h.Ab(1),h.ic(\"defaultImage\",\"../../../../assets/img/default.png\")(\"lazyLoad\",i.globals.BASE_API_URL+\"public/products/\"+i.detail.data.video),h.Ab(1),h.ic(\"href\",i.detail.data.video_link,h.xc)}}function ni(t,e){if(1&t){var i=h.Tb();h.Sb(0,\"div\"),h.Sb(1,\"owl-carousel-o\",53,54),h.Zb(\"changed\",function(t){return h.vc(i),h.bc().detail.getPassedData(t)})(\"initialized\",function(t){return h.vc(i),h.bc().detail.getPassedData(t)}),h.Bc(3,$e,2,1,\"ng-container\",55),h.Rb(),h.Sb(4,\"div\",56),h.Bc(5,ei,3,10,\"div\",57),h.Bc(6,ii,6,3,\"div\",58),h.Rb(),h.Rb()}if(2&t){var n=h.bc();h.Ab(1),h.ic(\"options\",n.customOptions),h.Ab(2),h.ic(\"ngForOf\",n.listImages.data),h.Ab(2),h.ic(\"ngForOf\",n.listImages.data),h.Ab(1),h.ic(\"ngIf\",n.detail.data.video_link&&n.detail.data.video)}}var ri=function(){return{maximumFractionDigits:5}};function si(t,e){if(1&t&&(h.Sb(0,\"div\",69),h.Sb(1,\"div\",70),h.Dc(2),h.Rb(),h.Rb()),2&t){var i=h.bc();h.Ab(2),h.Fc(\" \",i.detail.data.price>=0?i.detail.data.price.toLocaleString(\"vi\",h.lc(1,ri)):\"\",\" \\u0111 \")}}function oi(t,e){if(1&t&&(h.Sb(0,\"div\",69),h.Sb(1,\"div\",71),h.Dc(2),h.Rb(),h.Sb(3,\"div\",72),h.Dc(4),h.Rb(),h.Rb()),2&t){var i=h.bc();h.Ab(2),h.Fc(\" \",i.detail.data.price_sale>=0?i.detail.data.price_sale.toLocaleString(\"vi\",h.lc(2,ri)):\"\",\" \\u0111 \"),h.Ab(2),h.Fc(\" \",i.detail.data.price?i.detail.data.price.toLocaleString(\"vi\",h.lc(3,ri)):\"\",\" \\u0111 \")}}function ci(t,e){1&t&&(h.Sb(0,\"span\",73),h.Dc(1,\" H\\u1ebft h\\xe0ng \"),h.Rb())}function ai(t,e){1&t&&(h.Sb(0,\"span\",73),h.Dc(1,\" C\\xf2n h\\xe0ng \"),h.Rb())}function ui(t,e){if(1&t&&(h.Sb(0,\"div\"),h.Nb(1,\"div\",74),h.cc(2,\"sanitizeHtml\"),h.Rb()),2&t){var i=h.bc();h.Ab(1),h.ic(\"innerHTML\",h.dc(2,1,i.detail.data.detail),h.wc)}}function li(t,e){1&t&&(h.Sb(0,\"div\",75),h.Sb(1,\"div\"),h.Sb(2,\"a\",76),h.cc(3,\"translate\"),h.Nb(4,\"img\",77),h.Rb(),h.Rb(),h.Sb(5,\"div\",38),h.Sb(6,\"a\",39),h.cc(7,\"translate\"),h.Dc(8),h.cc(9,\"translate\"),h.Rb(),h.Rb(),h.Rb()),2&t&&(h.Ab(2),h.kc(\"href\",\"tel:\",h.dc(3,3,\"FEPhone\"),\"\",h.xc),h.Ab(4),h.kc(\"href\",\"tel:\",h.dc(7,5,\"FEPhone\"),\"\",h.xc),h.Ab(2),h.Fc(\" \",h.dc(9,7,\"FEPhone\"),\" \"))}function hi(t,e){if(1&t&&(h.Sb(0,\"div\",75),h.Sb(1,\"div\"),h.Sb(2,\"a\",76),h.cc(3,\"translate\"),h.Nb(4,\"img\",77),h.Rb(),h.Rb(),h.Sb(5,\"div\",38),h.Sb(6,\"a\",39),h.Dc(7),h.Rb(),h.Rb(),h.Rb()),2&t){var i=h.bc().$implicit;h.Ab(2),h.kc(\"href\",\"tel:\",h.dc(3,3,\"FEPhone\"),\"\",h.xc),h.Ab(4),h.ic(\"href\",\"tel:\"+i.phone,h.xc),h.Ab(1),h.Fc(\" \",i.phone,\" \")}}function pi(t,e){if(1&t&&(h.Sb(0,\"div\",40),h.Sb(1,\"div\"),h.Nb(2,\"img\",41),h.Rb(),h.Sb(3,\"div\",38),h.Sb(4,\"a\",42),h.Dc(5),h.Rb(),h.Rb(),h.Rb()),2&t){var i=h.bc().$implicit;h.Ab(5),h.Ec(i.address)}}function fi(t,e){if(1&t&&(h.Sb(0,\"div\",78),h.Sb(1,\"h6\",79),h.Dc(2),h.Rb(),h.Bc(3,hi,8,5,\"div\",35),h.cc(4,\"translate\"),h.cc(5,\"translate\"),h.Sb(6,\"div\",36),h.Sb(7,\"div\"),h.Nb(8,\"img\",37),h.Rb(),h.Sb(9,\"div\",38),h.Sb(10,\"a\",39),h.Dc(11),h.Rb(),h.Rb(),h.Rb(),h.Bc(12,pi,6,1,\"div\",80),h.Rb()),2&t){var i=e.$implicit;h.Ab(2),h.Ec(i.name),h.Ab(1),h.ic(\"ngIf\",\"FEPhone\"!=h.dc(4,5,\"FEPhone\")&&\"\"!=h.dc(5,7,\"FEPhone\")),h.Ab(7),h.ic(\"href\",\"mailto:\"+i.email,h.xc),h.Ab(1),h.Fc(\" \",i.email,\" \"),h.Ab(1),h.ic(\"ngIf\",i.address)}}function di(t,e){if(1&t&&(h.Sb(0,\"div\",81),h.Nb(1,\"app-box-product\",82),h.Rb()),2&t){var i=e.$implicit;h.Ab(1),h.ic(\"item\",i)}}var bi=function(){function t(t,e,i,n,r,s,o){var c=this;this.route=t,this.router=e,this.productService=i,this.apiCart=n,this.homeService=r,this.globals=s,this.footerService=o,this.item={},this.listImages={data:[],cached:[],active:0},this.showOwl=!1,this.count=1,this.width=0,this.link=\"\",this.detail={amount:1,images:\"\",data:[],get:function(){c.productService.getDetail({link:c.link}).subscribe(function(t){if(1==t.status){c.detail.data=t.data,c.detail.images=t.data.images;var e=t.data.listimages&&t.data.listimages.length>5?JSON.parse(t.data.listimages):[];c.listImages.cached=e,c.detail.data.images&&c.detail.data.images.length>4?c.listImages.cached=[c.detail.data.images].concat(e):c.detail.data.images=e.length>0?e[0]:\"\",c.listImages.data=Object.values(c.listImages.cached)}})},changeAmount:function(){(c.detail.amount<=0||!Number.isInteger(c.detail.amount))&&(c.detail.amount=1)},addCart:function(){c.detail.data.images=c.globals.BASE_API_URL+\"public/products/\"+c.detail.images;var t=c.apiCart.reduce();if(t[c.detail.data.id]){var e=isNaN(+t[c.detail.data.id].amount)?1:+t[c.detail.data.id].amount;c.detail.data.amount=+e+c.detail.amount}else c.detail.data.amount=c.detail.amount;c.apiCart.edit(c.detail.data,c.detail.data.id);var i=document.getElementById(\"cart\");window.scroll({top:i.offsetTop,behavior:\"smooth\"}),document.getElementById(\"notification\").classList.add(\"d-block\")},getPassedData:function(t){c.activeSlides=t,c.selected=t.slides[0]?t.slides[0].id:\"\",c.detail.data.images=c.selected,setTimeout(function(){c.detail.onClickImageChild(c.selected+\"-child\")},200)},onClickImageChild:function(t){for(var e=document.querySelectorAll(\".img-child\"),i=0;i<e.length;i++)e[i].style.opacity=.5,e[i].classList.remove(\"border\"),e[i].classList.remove(\"border-danger\");document.getElementById(t).style.opacity=\"1\",document.getElementById(t).classList.add(\"border\"),document.getElementById(t).classList.add(\"border-danger\")}},this.address={show:-1,data:[],_ini:function(t){t&&t.length>0&&(c.address.data=t,c.address.show=t[0].id)},_onShow:function(t){c.address.show=c.address.show!=t?t:-1}},this.renderHtml=function(){var t=document.getElementById(\"contentDetail\");if(t){var e=t.querySelectorAll(\"table\");if(e)for(var i=0;i<e.length;i++){var n=document.createElement(\"div\");n.className=\"table-responsive table-bordered m-0 border-0\",e[i].parentNode.insertBefore(n,e[i]),e[i].className=\"table\",e[i].setAttribute(\"class\",\"table\"),e[i].getAttribute(\"class\");var r=\"<table class='table'>\"+e[i].innerHTML+\"</table>\";e[i].remove(),n.innerHTML=r}var s=t.querySelectorAll(\"img\");if(s)for(i=0;i<s.length;i++){var o=document.createElement(\"div\");o.className=\"images-deatil d-inline\",s[i].parentNode.insertBefore(o,s[i]);var a=s[i].currentSrc,u='<a  class=\"fancybox\" data-fancybox=\"images-preview\" data-thumbs=\"{&quot;autoStart&quot;:true}\" href=\"'+a+'\">  <img class=\"mb-2\" width=\"'+(s[i].width||0)+'px\" heigth=\"'+(s[i].width||0)+'px\" src=\"'+a+'\" style=\"'+s[i].style.cssText+'\" alt=\"'+c.data.name+'\" />   </a>';s[i].remove(),o.innerHTML=u}}},this.customOptions={autoplayTimeout:8e3,autoplaySpeed:1500,autoWidth:!0,mouseDrag:!0,touchDrag:!0,pullDrag:!0,dots:!1,mergeFit:!1,navSpeed:500,items:5,responsive:{300:{items:1,nav:!1,loop:!0,center:!1,margin:280,mergeFit:!0},600:{items:1,nav:!1,loop:!0,center:!1,margin:200,mergeFit:!0},1e3:{items:1,center:!1}}},this.images=[\"../assets/img/bg/shape-1.png\",\"../assets/img/login.jpg\"],this.product={data:[],get:function(){c.homeService.getProduct().subscribe(function(t){1==t.status&&(c.product.data=t.data.featured)})}},this.width=document.body.getBoundingClientRect().width,this.route.params.subscribe(function(t){c.link=t.link,c.parent_link=t.parent_link,c.parent_links=t.parent_links})}return t.prototype.ngOnInit=function(){var t=this;this.getAddress(),this.route.params.subscribe(function(e){t.link=e.link,t.detail.get(),t.product.get()})},t.prototype.getAddress=function(){var t=this;this.footerService.getAddress().subscribe(function(e){return t.address._ini(e.data)})},t.prototype.setCount=function(t){1==t?this.count=Math.max(this.count-=1,1):this.count+=1},t.\\u0275fac=function(e){return new(e||t)(h.Mb(s.a),h.Mb(s.c),h.Mb(Ue),h.Mb(We.a),h.Mb(Ge.a),h.Mb(_e.a),h.Mb(qe.a))},t.\\u0275cmp=h.Gb({type:t,selectors:[[\"app-detail-product\"]],viewQuery:function(t,e){var i;1&t&&h.Ic(Ye,1),2&t&&h.rc(i=h.ac())&&(e.owlLibrary=i.first)},inputs:{data:\"data\"},decls:93,vars:38,consts:[[1,\"bg-light\"],[1,\"container-main\"],[1,\"container-fluid\"],[1,\"py-md-4\",\"py-3\"],[1,\"breadcrumb\",\"bg-transparent\",\"border-0\",\"m-0\",\"p-0\"],[1,\"breadcrumb-item\"],[\"href\",\"\"],[2,\"text-decoration\",\"none\",3,\"routerLink\"],[1,\"breadcrumb-item\",\"active\"],[1,\"bg-white\",\"p-3\"],[1,\"row\"],[1,\"col-md-9\"],[1,\"col-md-5\",\"col-12\"],[4,\"ngIf\"],[1,\"col-md-7\",\"col-12\"],[1,\"w-100\",\"py-1\"],[\"class\",\"d-flex align-items-baseline\",4,\"ngIf\"],[1,\"py-3\"],[\"class\",\"font-weight-bold\",4,\"ngIf\"],[1,\"d-flex\",\"align-items-end\"],[1,\"mr-md-5\",\"mr-3\"],[1,\"group-input\",\"position-relative\",\"mt-2\"],[3,\"click\"],[\"type\",\"number\",\"min\",\"1\",1,\"input\",\"pr-3\",3,\"ngModel\",\"value\",\"ngModelChange\",\"focusout\"],[1,\"position-absolute\",3,\"click\"],[1,\"btn\",\"btn-cart\",\"btn-outline-danger\",\"d-flex\",\"align-items-center\",\"justify-content-center\",\"text-uppercase\",\"font-weight-bold\",\"p-2\",3,\"click\"],[1,\"fas\",\"fa-cart-plus\",\"mr-2\"],[1,\"detail-title\"],[1,\"mb-0\",\"font-weight-bold\",\"text-uppercase\",\"d-inline-block\",\"text-danger\",\"bg-white\"],[1,\"detail-content\",\"mt-3\"],[1,\"col-md-3\"],[2,\"position\",\"sticky\",\"z-index\",\"0\",\"top\",\"0\"],[1,\"bg-white\"],[1,\"card-header\",\"text-white\",\"text-uppercase\",\"font-weight-bold\",\"border-0\",\"text-center\",2,\"background-color\",\"#ff0000\"],[1,\"card-body\",\"pl-2\",\"pr-2\",\"border\"],[\"class\",\" d-flex align-items-center \",4,\"ngIf\"],[1,\"mt-2\",\"d-flex\",\"align-items-center\"],[\"src\",\"../../../assets/img/mail1.png \",1,\"mr-2\",2,\"width\",\"20px\"],[2,\"font-size\",\"15px\"],[1,\"ml-1\",\"text-dark\",3,\"href\"],[1,\"mt-2\",\"d-flex\"],[\"src\",\"../../../assets/img/address.png \",1,\"mr-2\",2,\"width\",\"20px\"],[1,\"ml-1\",\"text-dark\"],[1,\"card-header\",\"text-white\",\"text-uppercase\",\"font-weight-bold\",\"border-0\",\"text-center\",\"mt-3\",\"bg-primary\"],[1,\"card-body\",\"pl-2\",\"pr-2\",\"border\",2,\"max-height\",\"400px\",\"overflow\",\"auto\"],[\"class\",\"mb-4\",4,\"ngFor\",\"ngForOf\"],[1,\"bg-light\",\"pt-4\",\"pb-5\"],[1,\"border-bottom\",\"border-primary\",\"mb-3\",\"d-flex\",\"align-items-center\",\"justify-content-between\"],[1,\"text-white\",\"bg-primary\",\"d-inline-flex\",\"text-nowrap\",\"p-2\",\"mb-0\"],[1,\"row\",\"px-2\"],[\"class\",\"col-6 col-md-3 col-xl-2dot4 px-2 mb-3\",4,\"ngFor\",\"ngForOf\"],[1,\"p-0\",\"w-100\",\"h-100\",3,\"routerLink\"],[1,\"box-img\",\"w-100\",3,\"routerLink\",\"defaultImage\",\"lazyLoad\",\"title\",\"alt\"],[1,\"owl-product\",2,\"overflow\",\"hidden\",3,\"options\",\"changed\",\"initialized\"],[\"owlLibrary\",\"\"],[4,\"ngFor\",\"ngForOf\"],[1,\"pt-2\",\"d-flex\",\"justify-content-center\",\"overflow-hidden\"],[\"class\",\"position-relative\",4,\"ngFor\",\"ngForOf\"],[\"class\",\"position-relative\",4,\"ngIf\"],[\"carouselSlide\",\"\",\"style\",\"overflow:hidden; \",3,\"id\"],[\"data-fancybox\",\"images-preview-desk\",\"data-thumbs\",'{\"autoStart\":true}',3,\"href\"],[1,\"rounded\",\"images-detail\",3,\"defaultImage\",\"lazyLoad\",\"alt\",\"name\"],[1,\"position-relative\"],[1,\"img-child\",3,\"ngClass\",\"id\",\"defaultImage\",\"lazyLoad\",\"alt\",\"name\",\"click\"],[1,\"img-child\",2,\"object-fit\",\"cover\",3,\"defaultImage\",\"lazyLoad\"],[\"data-fancybox\",\"\",1,\"venobox\",\"vbox-item\",3,\"href\"],[1,\"icon-video\"],[1,\"icon-video-circle\",\"d-flex\",\"justify-content-center\",\"align-items-center\"],[1,\"fa\",\"fa-play\",\"text-white\",2,\"font-size\",\"8px\"],[1,\"d-flex\",\"align-items-baseline\"],[1,\"text-danger\",\"font-weight-bold\",\"price-sale\"],[1,\"text-danger\",\"font-weight-bold\",\"price-sale\",\"mr-3\"],[1,\"price-default\",\"text-muted\",\"p-1\",\"font-weight-bold\"],[1,\"font-weight-bold\"],[\"id\",\"page-detail\",1,\"fr-view\",\"pt-3\",3,\"innerHTML\"],[1,\"d-flex\",\"align-items-center\"],[1,\"text-white\",\"mr-1\",3,\"href\"],[\"src\",\"../../../../assets//img/phone-call.png \",1,\"mr-2\",2,\"width\",\"20px\"],[1,\"mb-4\"],[1,\"\"],[\"class\",\" mt-2 d-flex \",4,\"ngIf\"],[1,\"col-6\",\"col-md-3\",\"col-xl-2dot4\",\"px-2\",\"mb-3\"],[3,\"item\"]],template:function(t,e){1&t&&(h.Sb(0,\"div\",0),h.Sb(1,\"div\",1),h.Sb(2,\"div\",2),h.Sb(3,\"nav\",3),h.Sb(4,\"ol\",4),h.Sb(5,\"li\",5),h.Sb(6,\"a\",6),h.Dc(7),h.cc(8,\"translate\"),h.Rb(),h.Rb(),h.Sb(9,\"li\",5),h.Sb(10,\"a\",7),h.Dc(11),h.Rb(),h.Rb(),h.Sb(12,\"li\",8),h.Dc(13),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Sb(14,\"div\",0),h.Sb(15,\"div\",1),h.Sb(16,\"div\",2),h.Sb(17,\"div\",9),h.Sb(18,\"div\",10),h.Sb(19,\"div\",11),h.Sb(20,\"div\",10),h.Sb(21,\"div\",12),h.Bc(22,Je,5,12,\"div\",13),h.Bc(23,ni,7,4,\"div\",13),h.Rb(),h.Sb(24,\"div\",14),h.Sb(25,\"h4\"),h.Dc(26),h.Rb(),h.Sb(27,\"div\",15),h.Bc(28,si,3,2,\"div\",16),h.Bc(29,oi,5,4,\"div\",16),h.Rb(),h.Sb(30,\"div\",17),h.Dc(31,\" Tr\\u1ea1ng th\\xe1i: \"),h.Bc(32,ci,2,0,\"span\",18),h.Bc(33,ai,2,0,\"span\",18),h.Rb(),h.Sb(34,\"div\",19),h.Sb(35,\"div\",20),h.Dc(36,\" S\\u1ed1 l\\u01b0\\u1ee3ng \"),h.Sb(37,\"div\",21),h.Sb(38,\"button\",22),h.Zb(\"click\",function(){return e.detail.amount=e.detail.amount<=1?1:e.detail.amount-1}),h.Dc(39,\"-\"),h.Rb(),h.Sb(40,\"input\",23),h.Zb(\"ngModelChange\",function(t){return e.detail.amount=t})(\"focusout\",function(){return e.detail.changeAmount()}),h.Rb(),h.Sb(41,\"button\",24),h.Zb(\"click\",function(){return e.detail.amount=+e.detail.amount>0?+e.detail.amount+1:1}),h.Dc(42,\"+\"),h.Rb(),h.Rb(),h.Rb(),h.Sb(43,\"div\"),h.Sb(44,\"button\",25),h.Zb(\"click\",function(){return e.detail.addCart()}),h.Nb(45,\"i\",26),h.Sb(46,\"span\"),h.Dc(47,\"Th\\xeam gi\\u1ecf h\\xe0ng\"),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Sb(48,\"div\",17),h.Sb(49,\"div\",27),h.Sb(50,\"h3\",28),h.Dc(51,\" Th\\xf4ng tin chi ti\\u1ebft \"),h.Rb(),h.Rb(),h.Sb(52,\"div\",29),h.Sb(53,\"h1\"),h.Dc(54),h.Rb(),h.Bc(55,ui,3,3,\"div\",13),h.Rb(),h.Rb(),h.Rb(),h.Sb(56,\"div\",30),h.Sb(57,\"div\",31),h.Sb(58,\"div\",32),h.Sb(59,\"div\",33),h.Dc(60),h.cc(61,\"translate\"),h.Rb(),h.Sb(62,\"div\",34),h.Bc(63,li,10,9,\"div\",35),h.cc(64,\"translate\"),h.cc(65,\"translate\"),h.Sb(66,\"div\",36),h.Sb(67,\"div\"),h.Nb(68,\"img\",37),h.Rb(),h.Sb(69,\"div\",38),h.Sb(70,\"a\",39),h.cc(71,\"translate\"),h.Dc(72),h.cc(73,\"translate\"),h.Rb(),h.Rb(),h.Rb(),h.Sb(74,\"div\",40),h.Sb(75,\"div\"),h.Nb(76,\"img\",41),h.Rb(),h.Sb(77,\"div\",38),h.Sb(78,\"a\",42),h.Dc(79),h.cc(80,\"translate\"),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Sb(81,\"div\",43),h.Dc(82,\" H\\u1ec6 TH\\u1ed0NG C\\u1ee6A H\\xc0NG \"),h.Rb(),h.Sb(83,\"div\",44),h.Bc(84,fi,13,9,\"div\",45),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Rb(),h.Sb(85,\"div\",46),h.Sb(86,\"div\",1),h.Sb(87,\"div\",2),h.Sb(88,\"div\",47),h.Sb(89,\"h5\",48),h.Dc(90,\" S\\u1ea3n ph\\u1ea9m n\\u1ed5i b\\u1eadt \"),h.Rb(),h.Rb(),h.Sb(91,\"div\",49),h.Bc(92,di,2,1,\"div\",50),h.Rb(),h.Rb(),h.Rb(),h.Rb()),2&t&&(h.Ab(7),h.Fc(\" \",h.dc(8,22,\"lblHome\"),\" \"),h.Ab(3),h.ic(\"routerLink\",h.mc(36,Xe,\"/san-pham/\"+e.detail.data.href)),h.Ab(1),h.Fc(\" \",e.detail.data.parent_name,\" \"),h.Ab(2),h.Fc(\" \",e.detail.data.name,\" \"),h.Ab(9),h.ic(\"ngIf\",0==e.listImages.data.length),h.Ab(1),h.ic(\"ngIf\",e.listImages.data&&e.listImages.data.length>0),h.Ab(3),h.Ec(e.detail.data.name),h.Ab(2),h.ic(\"ngIf\",0==e.detail.data.price_sale),h.Ab(1),h.ic(\"ngIf\",e.detail.data.price_sale>0),h.Ab(3),h.ic(\"ngIf\",0==e.detail.data.status),h.Ab(1),h.ic(\"ngIf\",1==e.detail.data.status),h.Ab(7),h.ic(\"ngModel\",e.detail.amount)(\"value\",e.detail.amount),h.Ab(14),h.Fc(\"\",e.detail.data.name,\":\"),h.Ab(1),h.ic(\"ngIf\",e.detail.data.detail&&e.detail.data.detail.length>0),h.Ab(5),h.Fc(\" \",h.dc(61,24,\"lblContact\"),\" \"),h.Ab(3),h.ic(\"ngIf\",\"FEPhone\"!=h.dc(64,26,\"FEPhone\")&&\"\"!=h.dc(65,28,\"FEPhone\")),h.Ab(7),h.kc(\"href\",\"mailto:\",h.dc(71,30,\"FEMail\"),\"\",h.xc),h.Ab(2),h.Fc(\" \",h.dc(73,32,\"FEMail\"),\" \"),h.Ab(7),h.Ec(h.dc(80,34,\"FEAddress\")),h.Ab(5),h.ic(\"ngForOf\",e.address.data),h.Ab(8),h.ic(\"ngForOf\",e.product.data))},directives:[s.f,n.l,r.n,r.b,r.i,r.l,n.k,s.d,fe.a,pt.a,pt.c,n.j,ke.a],pipes:[o.d,Ke.a],styles:['.images-detail[_ngcontent-%COMP%]{transition:.3s;max-width:100%;max-height:400px;position:relative;overflow:hidden}.images-detail[_ngcontent-%COMP%], .img-child[_ngcontent-%COMP%]{-o-object-fit:contain;object-fit:contain}.img-child[_ngcontent-%COMP%]{width:50px;height:50px;cursor:pointer;padding:2px}@media (max-width:615px){.card-title[_ngcontent-%COMP%]{font-size:1.75rem}}.slide[_ngcontent-%COMP%]{height:400px}.price-sale[_ngcontent-%COMP%]{font-size:24px}.price-default[_ngcontent-%COMP%]{text-decoration:line-through;font-size:.875rem}.input[_ngcontent-%COMP%]{width:30px;padding-left:7px}button[_ngcontent-%COMP%]{height:30px;width:30px;background-color:#fff;border:.5px solid #e4dddd}.input[_ngcontent-%COMP%]{padding-left:10px}.btn-cart[_ngcontent-%COMP%]{width:170px;height:40px}.detail-title[_ngcontent-%COMP%]{font-size:25px;background:#fff none repeat scroll 0 0;padding-right:20px;z-index:2;color:#cc3528;position:relative}.group-input[_ngcontent-%COMP%]{display:flex;align-items:center}.group-input[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:first-child{border-right:none;border-radius:4px 0 0 4px}.group-input[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{cursor:pointer;width:32px;border:1px solid #dee2e6;background-color:#fff}.group-input[_ngcontent-%COMP%]   button[_ngcontent-%COMP%], .group-input[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{height:30px;color:#242424;font-size:14px;text-align:center;outline:none;transition:border-color .15s ease-in-out 0s,box-shadow .15s ease-in-out 0s}.group-input[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:75px;border:1px solid #dee2e6}.group-input[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:last-child{border-radius:0 4px 4px 0;right:0;border-left:1px solid #dee2e6}.detail-title[_ngcontent-%COMP%]:after{background:#f3f3f3 none repeat scroll 0 0;content:\"\";height:2px;left:0;position:absolute;top:50%;width:100%;z-index:-1}.col-md-3[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:70px}.col-md-3[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]:hover{width:70px;cursor:pointer}.box-img[_ngcontent-%COMP%]{width:100%;-o-object-fit:cover;object-fit:cover;position:relative;background-color:#fff;height:300px;transition:all .3s linear}.input[_ngcontent-%COMP%]{padding-left:17px;text-align:left!important}.btn-outline-danger[_ngcontent-%COMP%]{border-color:#dc3545!important}.bg-primary[_ngcontent-%COMP%]{background-color:red!important}.bg-box[_ngcontent-%COMP%]{background-color:#ff8e00}.border-primary[_ngcontent-%COMP%]{border-color:#cc3528!important}.thumbnail[_ngcontent-%COMP%]{width:60px;height:50px;margin-right:20px;-o-object-fit:cover;object-fit:cover}.thumbnail[_ngcontent-%COMP%]:hover{cursor:pointer}.thumbnail-active[_ngcontent-%COMP%]{border:2px solid red}.venobox[_ngcontent-%COMP%]{position:absolute;top:34%;left:38%}']}),t}(),vi=i(\"HHYX\"),yi=[{path:\"\",component:Ze},{path:\":link\",component:Ze},{path:\":parent_link/:link\",component:bi}],mi=function(){function t(){}return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275mod=h.Kb({type:t}),t.\\u0275inj=h.Jb({imports:[[n.c,o.c,de.a,s.g.forChild(yi),a.b.forRoot(),c.c.forRoot(),r.f,pt.b,oe,r.p,pe,ht,p,fe.b,vi.a,ye.a,ve.a,me.a,ge.a,be.a,we.a,Oe.a]]}),t}()},yl3g:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"NwwV\"),o=function(t){return t},c=function(t){function e(e,i,n,r,s){t.call(this),this.initialState=e,this.condition=i,this.iterate=n,this.resultSelector=r,this.scheduler=s}return n(e,t),e.create=function(t,i,n,r,c){return 1==arguments.length?new e(t.initialState,t.condition,t.iterate,t.resultSelector||o,t.scheduler):void 0===r||s.isScheduler(r)?new e(t,i,n,o,r):new e(t,i,n,r,c)},e.prototype._subscribe=function(t){var i=this.initialState;if(this.scheduler)return this.scheduler.schedule(e.dispatch,0,{subscriber:t,iterate:this.iterate,condition:this.condition,resultSelector:this.resultSelector,state:i});for(var n=this,r=n.condition,s=n.resultSelector,o=n.iterate;;){if(r){var c=void 0;try{c=r(i)}catch(u){return void t.error(u)}if(!c){t.complete();break}}var a=void 0;try{a=s(i)}catch(u){return void t.error(u)}if(t.next(a),t.closed)break;try{i=o(i)}catch(u){return void t.error(u)}}},e.dispatch=function(t){var e=t.subscriber,i=t.condition;if(!e.closed){if(t.needIterate)try{t.state=t.iterate(t.state)}catch(s){return void e.error(s)}else t.needIterate=!0;if(i){var n=void 0;try{n=i(t.state)}catch(s){return void e.error(s)}if(!n)return void e.complete();if(e.closed)return}var r;try{r=t.resultSelector(t.state)}catch(s){return void e.error(s)}if(!e.closed&&(e.next(r),!e.closed))return this.schedule(t)}},e}(r.Observable);e.GenerateObservable=c},ypDg:function(t,e,i){\"use strict\";var n=i(\"Re0n\"),r=i(\"9BwH\");e.timeout=function(t,e){return void 0===e&&(e=n.async),r.timeout(t,e)(this)}},yz70:function(t,e,i){\"use strict\";e.empty={closed:!0,next:function(t){},error:function(t){throw t},complete:function(){}}},z1j8:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"RL+e\");n.Observable.prototype.find=r.find},zIAK:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"eeyt\");n.Observable.prototype.findIndex=r.findIndex},zKHA:function(t,e,i){\"use strict\";var n,r=i(\"AJP0\");function s(){try{return n.apply(this,arguments)}catch(t){return r.errorObject.e=t,r.errorObject}}e.tryCatch=function(t){return n=t,s}},zL8T:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.debounce=function(t){return function(e){return e.lift(new o(t))}};var o=function(){function t(t){this.durationSelector=t}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.durationSelector))},t}(),c=function(t){function e(e,i){t.call(this,e),this.durationSelector=i,this.hasValue=!1,this.durationSubscription=null}return n(e,t),e.prototype._next=function(t){try{var e=this.durationSelector.call(this,t);e&&this._tryNext(t,e)}catch(i){this.destination.error(i)}},e.prototype._complete=function(){this.emitValue(),this.destination.complete()},e.prototype._tryNext=function(t,e){var i=this.durationSubscription;this.value=t,this.hasValue=!0,i&&(i.unsubscribe(),this.remove(i)),(i=s.subscribeToResult(this,e)).closed||this.add(this.durationSubscription=i)},e.prototype.notifyNext=function(t,e,i,n,r){this.emitValue()},e.prototype.notifyComplete=function(){this.emitValue()},e.prototype.emitValue=function(){if(this.hasValue){var e=this.value,i=this.durationSubscription;i&&(this.durationSubscription=null,i.unsubscribe(),this.remove(i)),this.value=null,this.hasValue=!1,t.prototype._next.call(this,e)}},e}(r.OuterSubscriber)},zLeP:function(t,e,i){\"use strict\";var n=i(\"1DV/\");e.skip=function(t){return n.skip(t)(this)}},zMOc:function(t,e,i){\"use strict\";var n=i(\"Xrsd\");e.single=function(t){return n.single(t)(this)}},zSqD:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"6oB3\");n.Observable.concat=r.concat},zVww:function(t,e,i){\"use strict\";var n=i(\"+WiC\");e.concatMapTo=function(t,e){return n.concatMap(function(){return t},e)}},\"zZI/\":function(t,e,i){\"use strict\";var n=i(\"G2HO\");e.isNumeric=function(t){return!n.isArray(t)&&t-parseFloat(t)+1>=0}},zZax:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"wowj\");n.Observable.prototype.window=r.window},zbiA:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"hV2K\");n.Observable.prototype.auditTime=r.auditTime},zlBQ:function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"ks6M\");n.Observable.prototype.bufferToggle=r.bufferToggle},zobD:function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"9jZZ\"),s=i(\"Irel\");e.buffer=function(t){return function(e){return e.lift(new o(t))}};var o=function(){function t(t){this.closingNotifier=t}return t.prototype.call=function(t,e){return e.subscribe(new c(t,this.closingNotifier))},t}(),c=function(t){function e(e,i){t.call(this,e),this.buffer=[],this.add(s.subscribeToResult(this,i))}return n(e,t),e.prototype._next=function(t){this.buffer.push(t)},e.prototype.notifyNext=function(t,e,i,n,r){var s=this.buffer;this.buffer=[],this.destination.next(s)},e}(r.OuterSubscriber)},\"zrM/\":function(t,e,i){\"use strict\";var n=i(\"AZf1\"),r=i(\"5UB+\");n.Observable.prototype.windowToggle=r.windowToggle},\"zx+L\":function(t,e,i){\"use strict\";var n=this&&this.__extends||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);function n(){this.constructor=t}t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)},r=i(\"AZf1\"),s=i(\"Irel\"),o=i(\"9jZZ\"),c=function(t){function e(e,i,n){t.call(this),this.condition=e,this.thenSource=i,this.elseSource=n}return n(e,t),e.create=function(t,i,n){return new e(t,i,n)},e.prototype._subscribe=function(t){var e=this;return new a(t,e.condition,e.thenSource,e.elseSource)},e}(r.Observable);e.IfObservable=c;var a=function(t){function e(e,i,n,r){t.call(this,e),this.condition=i,this.thenSource=n,this.elseSource=r,this.tryIf()}return n(e,t),e.prototype.tryIf=function(){var t=this,e=t.condition,i=t.thenSource,n=t.elseSource;try{var r=e()?i:n;r?this.add(s.subscribeToResult(this,r)):this._complete()}catch(o){this._error(o)}},e}(o.OuterSubscriber)}}]);","name":"16.9e9f178874099cdf1916.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[16],{\n\n/***/ \"+1VR\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar mergeScan_1 = /*@__PURE__*/__webpack_require__(\"SQLu\");\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\n\n\nfunction mergeScan(accumulator, seed, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  return mergeScan_1.mergeScan(accumulator, seed, concurrent)(this);\n}\n\nexports.mergeScan = mergeScan;\n\n/***/ }),\n\n/***/ \"+2+e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nfunction symbolIteratorPonyfill(root) {\n  var Symbol = root.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (!Symbol.iterator) {\n      Symbol.iterator = Symbol('iterator polyfill');\n    }\n\n    return Symbol.iterator;\n  } else {\n    // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n    var Set_1 = root.Set;\n\n    if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n      return '@@iterator';\n    }\n\n    var Map_1 = root.Map; // required for compatability with es6-shim\n\n    if (Map_1) {\n      var keys = Object.getOwnPropertyNames(Map_1.prototype);\n\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i]; // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n\n        if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n          return key;\n        }\n      }\n    }\n\n    return '@@iterator';\n  }\n}\n\nexports.symbolIteratorPonyfill = symbolIteratorPonyfill;\nexports.iterator = /*@__PURE__*/symbolIteratorPonyfill(root_1.root);\n/**\n * @deprecated use iterator instead\n */\n\nexports.$$iterator = exports.iterator;\n\n/***/ }),\n\n/***/ \"+24W\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar switchMap_1 = /*@__PURE__*/__webpack_require__(\"VVja\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\n\n\nfunction switchMap(project, resultSelector) {\n  return switchMap_1.switchMap(project, resultSelector)(this);\n}\n\nexports.switchMap = switchMap;\n\n/***/ }),\n\n/***/ \"+PC9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar EmptyObservable_1 = /*@__PURE__*/__webpack_require__(\"36rE\");\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\n\n\nfunction repeat(count) {\n  if (count === void 0) {\n    count = -1;\n  }\n\n  return function (source) {\n    if (count === 0) {\n      return new EmptyObservable_1.EmptyObservable();\n    } else if (count < 0) {\n      return source.lift(new RepeatOperator(-1, source));\n    } else {\n      return source.lift(new RepeatOperator(count - 1, source));\n    }\n  };\n}\n\nexports.repeat = repeat;\n\nvar RepeatOperator = /*@__PURE__*/function () {\n  function RepeatOperator(count, source) {\n    this.count = count;\n    this.source = source;\n  }\n\n  RepeatOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n  };\n\n  return RepeatOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar RepeatSubscriber = function (_super) {\n  __extends(RepeatSubscriber, _super);\n\n  function RepeatSubscriber(destination, count, source) {\n    _super.call(this, destination);\n\n    this.count = count;\n    this.source = source;\n  }\n\n  RepeatSubscriber.prototype.complete = function () {\n    if (!this.isStopped) {\n      var _a = this,\n          source = _a.source,\n          count = _a.count;\n\n      if (count === 0) {\n        return _super.prototype.complete.call(this);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  };\n\n  return RepeatSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"+UM1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar RangeObservable = function (_super) {\n  __extends(RangeObservable, _super);\n\n  function RangeObservable(start, count, scheduler) {\n    _super.call(this);\n\n    this.start = start;\n    this._count = count;\n    this.scheduler = scheduler;\n  }\n  /**\n   * Creates an Observable that emits a sequence of numbers within a specified\n   * range.\n   *\n   * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n   *\n   * <img src=\"./img/range.png\" width=\"100%\">\n   *\n   * `range` operator emits a range of sequential integers, in order, where you\n   * select the `start` of the range and its `length`. By default, uses no\n   * IScheduler and just delivers the notifications synchronously, but may use\n   * an optional IScheduler to regulate those deliveries.\n   *\n   * @example <caption>Emits the numbers 1 to 10</caption>\n   * var numbers = Rx.Observable.range(1, 10);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @see {@link timer}\n   * @see {@link interval}\n   *\n   * @param {number} [start=0] The value of the first integer in the sequence.\n   * @param {number} [count=0] The number of sequential integers to generate.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the notifications.\n   * @return {Observable} An Observable of numbers that emits a finite range of\n   * sequential integers.\n   * @static true\n   * @name range\n   * @owner Observable\n   */\n\n\n  RangeObservable.create = function (start, count, scheduler) {\n    if (start === void 0) {\n      start = 0;\n    }\n\n    if (count === void 0) {\n      count = 0;\n    }\n\n    return new RangeObservable(start, count, scheduler);\n  };\n\n  RangeObservable.dispatch = function (state) {\n    var start = state.start,\n        index = state.index,\n        count = state.count,\n        subscriber = state.subscriber;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(start);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n    state.start = start + 1;\n    this.schedule(state);\n  };\n  /** @deprecated internal use only */\n\n\n  RangeObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n    var start = this.start;\n    var count = this._count;\n    var scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(RangeObservable.dispatch, 0, {\n        index: index,\n        count: count,\n        start: start,\n        subscriber: subscriber\n      });\n    } else {\n      do {\n        if (index++ >= count) {\n          subscriber.complete();\n          break;\n        }\n\n        subscriber.next(start++);\n\n        if (subscriber.closed) {\n          break;\n        }\n      } while (true);\n    }\n  };\n\n  return RangeObservable;\n}(Observable_1.Observable);\n\nexports.RangeObservable = RangeObservable;\n\n/***/ }),\n\n/***/ \"+Whv\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar UsingObservable_1 = /*@__PURE__*/__webpack_require__(\"JX5i\");\n\nexports.using = UsingObservable_1.UsingObservable.create;\n\n/***/ }),\n\n/***/ \"+WiC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar mergeMap_1 = /*@__PURE__*/__webpack_require__(\"lf2g\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\n\n\nfunction concatMap(project, resultSelector) {\n  return mergeMap_1.mergeMap(project, resultSelector, 1);\n}\n\nexports.concatMap = concatMap;\n\n/***/ }),\n\n/***/ \"+djB\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\n\n\nfunction windowWhen(closingSelector) {\n  return function windowWhenOperatorFunction(source) {\n    return source.lift(new WindowOperator(closingSelector));\n  };\n}\n\nexports.windowWhen = windowWhen;\n\nvar WindowOperator = /*@__PURE__*/function () {\n  function WindowOperator(closingSelector) {\n    this.closingSelector = closingSelector;\n  }\n\n  WindowOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n  };\n\n  return WindowOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar WindowSubscriber = function (_super) {\n  __extends(WindowSubscriber, _super);\n\n  function WindowSubscriber(destination, closingSelector) {\n    _super.call(this, destination);\n\n    this.destination = destination;\n    this.closingSelector = closingSelector;\n    this.openWindow();\n  }\n\n  WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.openWindow(innerSub);\n  };\n\n  WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n    this._error(error);\n  };\n\n  WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.openWindow(innerSub);\n  };\n\n  WindowSubscriber.prototype._next = function (value) {\n    this.window.next(value);\n  };\n\n  WindowSubscriber.prototype._error = function (err) {\n    this.window.error(err);\n    this.destination.error(err);\n    this.unsubscribeClosingNotification();\n  };\n\n  WindowSubscriber.prototype._complete = function () {\n    this.window.complete();\n    this.destination.complete();\n    this.unsubscribeClosingNotification();\n  };\n\n  WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n    if (this.closingNotification) {\n      this.closingNotification.unsubscribe();\n    }\n  };\n\n  WindowSubscriber.prototype.openWindow = function (innerSub) {\n    if (innerSub === void 0) {\n      innerSub = null;\n    }\n\n    if (innerSub) {\n      this.remove(innerSub);\n      innerSub.unsubscribe();\n    }\n\n    var prevWindow = this.window;\n\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n\n    var window = this.window = new Subject_1.Subject();\n    this.destination.next(window);\n    var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n\n    if (closingNotifier === errorObject_1.errorObject) {\n      var err = errorObject_1.errorObject.e;\n      this.destination.error(err);\n      this.window.error(err);\n    } else {\n      this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));\n    }\n  };\n\n  return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"+fDQ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar isArray_1 = /*@__PURE__*/__webpack_require__(\"G2HO\");\n\nvar isArrayLike_1 = /*@__PURE__*/__webpack_require__(\"foHw\");\n\nvar isPromise_1 = /*@__PURE__*/__webpack_require__(\"RGvf\");\n\nvar PromiseObservable_1 = /*@__PURE__*/__webpack_require__(\"r2oo\");\n\nvar IteratorObservable_1 = /*@__PURE__*/__webpack_require__(\"m+NU\");\n\nvar ArrayObservable_1 = /*@__PURE__*/__webpack_require__(\"rVFa\");\n\nvar ArrayLikeObservable_1 = /*@__PURE__*/__webpack_require__(\"04+N\");\n\nvar iterator_1 = /*@__PURE__*/__webpack_require__(\"+2+e\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar observeOn_1 = /*@__PURE__*/__webpack_require__(\"0zyO\");\n\nvar observable_1 = /*@__PURE__*/__webpack_require__(\"WU5C\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar FromObservable = function (_super) {\n  __extends(FromObservable, _super);\n\n  function FromObservable(ish, scheduler) {\n    _super.call(this, null);\n\n    this.ish = ish;\n    this.scheduler = scheduler;\n  }\n  /**\n   * Creates an Observable from an Array, an array-like object, a Promise, an\n   * iterable object, or an Observable-like object.\n   *\n   * <span class=\"informal\">Converts almost anything to an Observable.</span>\n   *\n   * <img src=\"./img/from.png\" width=\"100%\">\n   *\n   * Convert various other objects and data types into Observables. `from`\n   * converts a Promise or an array-like or an\n   * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n   * object into an Observable that emits the items in that promise or array or\n   * iterable. A String, in this context, is treated as an array of characters.\n   * Observable-like objects (contains a function named with the ES2015 Symbol\n   * for Observable) can also be converted through this operator.\n   *\n   * @example <caption>Converts an array to an Observable</caption>\n   * var array = [10, 20, 30];\n   * var result = Rx.Observable.from(array);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 10 20 30\n   *\n   * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n   * function* generateDoubles(seed) {\n   *   var i = seed;\n   *   while (true) {\n   *     yield i;\n   *     i = 2 * i; // double it\n   *   }\n   * }\n   *\n   * var iterator = generateDoubles(3);\n   * var result = Rx.Observable.from(iterator).take(10);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 3 6 12 24 48 96 192 384 768 1536\n   *\n   * @see {@link create}\n   * @see {@link fromEvent}\n   * @see {@link fromEventPattern}\n   * @see {@link fromPromise}\n   *\n   * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n   * Observable-like, an Array, an iterable or an array-like object to be\n   * converted.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * emissions of values.\n   * @return {Observable<T>} The Observable whose values are originally from the\n   * input object that was converted.\n   * @static true\n   * @name from\n   * @owner Observable\n   */\n\n\n  FromObservable.create = function (ish, scheduler) {\n    if (ish != null) {\n      if (typeof ish[observable_1.observable] === 'function') {\n        if (ish instanceof Observable_1.Observable && !scheduler) {\n          return ish;\n        }\n\n        return new FromObservable(ish, scheduler);\n      } else if (isArray_1.isArray(ish)) {\n        return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n      } else if (isPromise_1.isPromise(ish)) {\n        return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n      } else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {\n        return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n      } else if (isArrayLike_1.isArrayLike(ish)) {\n        return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n      }\n    }\n\n    throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n  };\n  /** @deprecated internal use only */\n\n\n  FromObservable.prototype._subscribe = function (subscriber) {\n    var ish = this.ish;\n    var scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      return ish[observable_1.observable]().subscribe(subscriber);\n    } else {\n      return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n    }\n  };\n\n  return FromObservable;\n}(Observable_1.Observable);\n\nexports.FromObservable = FromObservable;\n\n/***/ }),\n\n/***/ \"+t3k\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar first_1 = /*@__PURE__*/__webpack_require__(\"L/jt\");\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\n\n\nfunction first(predicate, resultSelector, defaultValue) {\n  return first_1.first(predicate, resultSelector, defaultValue)(this);\n}\n\nexports.first = first;\n\n/***/ }),\n\n/***/ \"/3m9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar combineAll_1 = /*@__PURE__*/__webpack_require__(\"OMR/\");\n/**\n * Converts a higher-order Observable into a first-order Observable by waiting\n * for the outer Observable to complete, then applying {@link combineLatest}.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by applying\n * {@link combineLatest} when the Observable-of-Observables completes.</span>\n *\n * <img src=\"./img/combineAll.png\" width=\"100%\">\n *\n * Takes an Observable of Observables, and collects all Observables from it.\n * Once the outer Observable completes, it subscribes to all collected\n * Observables and combines their values using the {@link combineLatest}\n * strategy, such that:\n * - Every time an inner Observable emits, the output Observable emits.\n * - When the returned observable emits, it emits all of the latest values by:\n *   - If a `project` function is provided, it is called with each recent value\n *     from each inner Observable in whatever order they arrived, and the result\n *     of the `project` function is what is emitted by the output Observable.\n *   - If there is no `project` function, an array of all of the most recent\n *     values is emitted by the output Observable.\n *\n * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev =>\n *   Rx.Observable.interval(Math.random()*2000).take(3)\n * ).take(2);\n * var result = higherOrder.combineAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n * @see {@link mergeAll}\n *\n * @param {function} [project] An optional function to map the most recent\n * values from each inner Observable into a new result. Takes each of the most\n * recent values from each collected inner Observable as arguments, in order.\n * @return {Observable} An Observable of projected results or arrays of recent\n * values.\n * @method combineAll\n * @owner Observable\n */\n\n\nfunction combineAll(project) {\n  return combineAll_1.combineAll(project)(this);\n}\n\nexports.combineAll = combineAll;\n\n/***/ }),\n\n/***/ \"/AUE\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar SubscriptionLoggable_1 = /*@__PURE__*/__webpack_require__(\"8t1O\");\n\nvar applyMixins_1 = /*@__PURE__*/__webpack_require__(\"QnAi\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar ColdObservable = function (_super) {\n  __extends(ColdObservable, _super);\n\n  function ColdObservable(messages, scheduler) {\n    _super.call(this, function (subscriber) {\n      var observable = this;\n      var index = observable.logSubscribedFrame();\n      subscriber.add(new Subscription_1.Subscription(function () {\n        observable.logUnsubscribedFrame(index);\n      }));\n      observable.scheduleMessages(subscriber);\n      return subscriber;\n    });\n\n    this.messages = messages;\n    this.subscriptions = [];\n    this.scheduler = scheduler;\n  }\n\n  ColdObservable.prototype.scheduleMessages = function (subscriber) {\n    var messagesLength = this.messages.length;\n\n    for (var i = 0; i < messagesLength; i++) {\n      var message = this.messages[i];\n      subscriber.add(this.scheduler.schedule(function (_a) {\n        var message = _a.message,\n            subscriber = _a.subscriber;\n        message.notification.observe(subscriber);\n      }, message.frame, {\n        message: message,\n        subscriber: subscriber\n      }));\n    }\n  };\n\n  return ColdObservable;\n}(Observable_1.Observable);\n\nexports.ColdObservable = ColdObservable;\n/*@__PURE__*/\n\napplyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n\n/***/ }),\n\n/***/ \"/Gz8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar bufferTime_1 = __webpack_require__(\"Vmj7\");\n\nObservable_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime; //# sourceMappingURL=bufferTime.js.map\n\n/***/ }),\n\n/***/ \"/QDG\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar mergeMapTo_1 = /*@__PURE__*/__webpack_require__(\"fEEN\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\n\n\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  return mergeMapTo_1.mergeMapTo(innerObservable, resultSelector, concurrent)(this);\n}\n\nexports.mergeMapTo = mergeMapTo;\n\n/***/ }),\n\n/***/ \"/WK6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n // CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\n\nvar __window = typeof window !== 'undefined' && window;\n\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;\n\nvar __global = typeof global !== 'undefined' && global;\n\nvar _root = __window || __global || __self;\n\nexports.root = _root; // Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n\n/*@__PURE__*/\n\n(function () {\n  if (!_root) {\n    throw new Error('RxJS could not find any global context (window, self, global)');\n  }\n})();\n\n/***/ }),\n\n/***/ \"/mOC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar MapPolyfill = /*@__PURE__*/function () {\n  function MapPolyfill() {\n    this.size = 0;\n    this._values = [];\n    this._keys = [];\n  }\n\n  MapPolyfill.prototype.get = function (key) {\n    var i = this._keys.indexOf(key);\n\n    return i === -1 ? undefined : this._values[i];\n  };\n\n  MapPolyfill.prototype.set = function (key, value) {\n    var i = this._keys.indexOf(key);\n\n    if (i === -1) {\n      this._keys.push(key);\n\n      this._values.push(value);\n\n      this.size++;\n    } else {\n      this._values[i] = value;\n    }\n\n    return this;\n  };\n\n  MapPolyfill.prototype.delete = function (key) {\n    var i = this._keys.indexOf(key);\n\n    if (i === -1) {\n      return false;\n    }\n\n    this._values.splice(i, 1);\n\n    this._keys.splice(i, 1);\n\n    this.size--;\n    return true;\n  };\n\n  MapPolyfill.prototype.clear = function () {\n    this._keys.length = 0;\n    this._values.length = 0;\n    this.size = 0;\n  };\n\n  MapPolyfill.prototype.forEach = function (cb, thisArg) {\n    for (var i = 0; i < this.size; i++) {\n      cb.call(thisArg, this._values[i], this._keys[i]);\n    }\n  };\n\n  return MapPolyfill;\n}();\n\nexports.MapPolyfill = MapPolyfill;\n\n/***/ }),\n\n/***/ \"/mgN\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar repeatWhen_1 = __webpack_require__(\"urEZ\");\n\nObservable_1.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen; //# sourceMappingURL=repeatWhen.js.map\n\n/***/ }),\n\n/***/ \"01WU\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar elementAt_1 = /*@__PURE__*/__webpack_require__(\"PxRv\");\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * <img src=\"./img/elementAt.png\" width=\"100%\">\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * @example <caption>Emit only the third click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.elementAt(2);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\n\n\nfunction elementAt(index, defaultValue) {\n  return elementAt_1.elementAt(index, defaultValue)(this);\n}\n\nexports.elementAt = elementAt;\n\n/***/ }),\n\n/***/ \"04+N\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar ScalarObservable_1 = /*@__PURE__*/__webpack_require__(\"8x9D\");\n\nvar EmptyObservable_1 = /*@__PURE__*/__webpack_require__(\"36rE\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar ArrayLikeObservable = function (_super) {\n  __extends(ArrayLikeObservable, _super);\n\n  function ArrayLikeObservable(arrayLike, scheduler) {\n    _super.call(this);\n\n    this.arrayLike = arrayLike;\n    this.scheduler = scheduler;\n\n    if (!scheduler && arrayLike.length === 1) {\n      this._isScalar = true;\n      this.value = arrayLike[0];\n    }\n  }\n\n  ArrayLikeObservable.create = function (arrayLike, scheduler) {\n    var length = arrayLike.length;\n\n    if (length === 0) {\n      return new EmptyObservable_1.EmptyObservable();\n    } else if (length === 1) {\n      return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n    } else {\n      return new ArrayLikeObservable(arrayLike, scheduler);\n    }\n  };\n\n  ArrayLikeObservable.dispatch = function (state) {\n    var arrayLike = state.arrayLike,\n        index = state.index,\n        length = state.length,\n        subscriber = state.subscriber;\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    if (index >= length) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(arrayLike[index]);\n    state.index = index + 1;\n    this.schedule(state);\n  };\n  /** @deprecated internal use only */\n\n\n  ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n\n    var _a = this,\n        arrayLike = _a.arrayLike,\n        scheduler = _a.scheduler;\n\n    var length = arrayLike.length;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n        arrayLike: arrayLike,\n        index: index,\n        length: length,\n        subscriber: subscriber\n      });\n    } else {\n      for (var i = 0; i < length && !subscriber.closed; i++) {\n        subscriber.next(arrayLike[i]);\n      }\n\n      subscriber.complete();\n    }\n  };\n\n  return ArrayLikeObservable;\n}(Observable_1.Observable);\n\nexports.ArrayLikeObservable = ArrayLikeObservable;\n\n/***/ }),\n\n/***/ \"07YY\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar generate_1 = __webpack_require__(\"qKmH\");\n\nObservable_1.Observable.generate = generate_1.generate; //# sourceMappingURL=generate.js.map\n\n/***/ }),\n\n/***/ \"0Iwa\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var result = clicks.window(interval)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\n\n\nfunction window(windowBoundaries) {\n  return function windowOperatorFunction(source) {\n    return source.lift(new WindowOperator(windowBoundaries));\n  };\n}\n\nexports.window = window;\n\nvar WindowOperator = /*@__PURE__*/function () {\n  function WindowOperator(windowBoundaries) {\n    this.windowBoundaries = windowBoundaries;\n  }\n\n  WindowOperator.prototype.call = function (subscriber, source) {\n    var windowSubscriber = new WindowSubscriber(subscriber);\n    var sourceSubscription = source.subscribe(windowSubscriber);\n\n    if (!sourceSubscription.closed) {\n      windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));\n    }\n\n    return sourceSubscription;\n  };\n\n  return WindowOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar WindowSubscriber = function (_super) {\n  __extends(WindowSubscriber, _super);\n\n  function WindowSubscriber(destination) {\n    _super.call(this, destination);\n\n    this.window = new Subject_1.Subject();\n    destination.next(this.window);\n  }\n\n  WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.openWindow();\n  };\n\n  WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n    this._error(error);\n  };\n\n  WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n    this._complete();\n  };\n\n  WindowSubscriber.prototype._next = function (value) {\n    this.window.next(value);\n  };\n\n  WindowSubscriber.prototype._error = function (err) {\n    this.window.error(err);\n    this.destination.error(err);\n  };\n\n  WindowSubscriber.prototype._complete = function () {\n    this.window.complete();\n    this.destination.complete();\n  };\n  /** @deprecated internal use only */\n\n\n  WindowSubscriber.prototype._unsubscribe = function () {\n    this.window = null;\n  };\n\n  WindowSubscriber.prototype.openWindow = function () {\n    var prevWindow = this.window;\n\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n\n    var destination = this.destination;\n    var newWindow = this.window = new Subject_1.Subject();\n    destination.next(newWindow);\n  };\n\n  return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"0Qin\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar ReplaySubject_1 = /*@__PURE__*/__webpack_require__(\"BjeI\");\n/**\n * @method shareReplay\n * @owner Observable\n */\n\n\nfunction shareReplay(bufferSize, windowTime, scheduler) {\n  return function (source) {\n    return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler));\n  };\n}\n\nexports.shareReplay = shareReplay;\n\nfunction shareReplayOperator(bufferSize, windowTime, scheduler) {\n  var subject;\n  var refCount = 0;\n  var subscription;\n  var hasError = false;\n  var isComplete = false;\n  return function shareReplayOperation(source) {\n    refCount++;\n\n    if (!subject || hasError) {\n      hasError = false;\n      subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n      subscription = source.subscribe({\n        next: function next(value) {\n          subject.next(value);\n        },\n        error: function error(err) {\n          hasError = true;\n          subject.error(err);\n        },\n        complete: function complete() {\n          isComplete = true;\n          subject.complete();\n        }\n      });\n    }\n\n    var innerSub = subject.subscribe(this);\n    return function () {\n      refCount--;\n      innerSub.unsubscribe();\n\n      if (subscription && refCount === 0 && isComplete) {\n        subscription.unsubscribe();\n      }\n    };\n  };\n}\n\n;\n\n/***/ }),\n\n/***/ \"0U/2\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar retryWhen_1 = __webpack_require__(\"Ontn\");\n\nObservable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen; //# sourceMappingURL=retryWhen.js.map\n\n/***/ }),\n\n/***/ \"0dxg\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar DeferObservable = function (_super) {\n  __extends(DeferObservable, _super);\n\n  function DeferObservable(observableFactory) {\n    _super.call(this);\n\n    this.observableFactory = observableFactory;\n  }\n  /**\n   * Creates an Observable that, on subscribe, calls an Observable factory to\n   * make an Observable for each new Observer.\n   *\n   * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n   * is subscribed.\n   * </span>\n   *\n   * <img src=\"./img/defer.png\" width=\"100%\">\n   *\n   * `defer` allows you to create the Observable only when the Observer\n   * subscribes, and create a fresh Observable for each Observer. It waits until\n   * an Observer subscribes to it, and then it generates an Observable,\n   * typically with an Observable factory function. It does this afresh for each\n   * subscriber, so although each subscriber may think it is subscribing to the\n   * same Observable, in fact each subscriber gets its own individual\n   * Observable.\n   *\n   * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n   * var clicksOrInterval = Rx.Observable.defer(function () {\n   *   if (Math.random() > 0.5) {\n   *     return Rx.Observable.fromEvent(document, 'click');\n   *   } else {\n   *     return Rx.Observable.interval(1000);\n   *   }\n   * });\n   * clicksOrInterval.subscribe(x => console.log(x));\n   *\n   * // Results in the following behavior:\n   * // If the result of Math.random() is greater than 0.5 it will listen\n   * // for clicks anywhere on the \"document\"; when document is clicked it\n   * // will log a MouseEvent object to the console. If the result is less\n   * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n   *\n   * @see {@link create}\n   *\n   * @param {function(): SubscribableOrPromise} observableFactory The Observable\n   * factory function to invoke for each Observer that subscribes to the output\n   * Observable. May also return a Promise, which will be converted on the fly\n   * to an Observable.\n   * @return {Observable} An Observable whose Observers' subscriptions trigger\n   * an invocation of the given Observable factory function.\n   * @static true\n   * @name defer\n   * @owner Observable\n   */\n\n\n  DeferObservable.create = function (observableFactory) {\n    return new DeferObservable(observableFactory);\n  };\n  /** @deprecated internal use only */\n\n\n  DeferObservable.prototype._subscribe = function (subscriber) {\n    return new DeferSubscriber(subscriber, this.observableFactory);\n  };\n\n  return DeferObservable;\n}(Observable_1.Observable);\n\nexports.DeferObservable = DeferObservable;\n\nvar DeferSubscriber = function (_super) {\n  __extends(DeferSubscriber, _super);\n\n  function DeferSubscriber(destination, factory) {\n    _super.call(this, destination);\n\n    this.factory = factory;\n    this.tryDefer();\n  }\n\n  DeferSubscriber.prototype.tryDefer = function () {\n    try {\n      this._callFactory();\n    } catch (err) {\n      this._error(err);\n    }\n  };\n\n  DeferSubscriber.prototype._callFactory = function () {\n    var result = this.factory();\n\n    if (result) {\n      this.add(subscribeToResult_1.subscribeToResult(this, result));\n    }\n  };\n\n  return DeferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"0j0j\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\n\n\nfunction repeatWhen(notifier) {\n  return function (source) {\n    return source.lift(new RepeatWhenOperator(notifier));\n  };\n}\n\nexports.repeatWhen = repeatWhen;\n\nvar RepeatWhenOperator = /*@__PURE__*/function () {\n  function RepeatWhenOperator(notifier) {\n    this.notifier = notifier;\n  }\n\n  RepeatWhenOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n  };\n\n  return RepeatWhenOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar RepeatWhenSubscriber = function (_super) {\n  __extends(RepeatWhenSubscriber, _super);\n\n  function RepeatWhenSubscriber(destination, notifier, source) {\n    _super.call(this, destination);\n\n    this.notifier = notifier;\n    this.source = source;\n    this.sourceIsBeingSubscribedTo = true;\n  }\n\n  RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.sourceIsBeingSubscribedTo = true;\n    this.source.subscribe(this);\n  };\n\n  RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n    if (this.sourceIsBeingSubscribedTo === false) {\n      return _super.prototype.complete.call(this);\n    }\n  };\n\n  RepeatWhenSubscriber.prototype.complete = function () {\n    this.sourceIsBeingSubscribedTo = false;\n\n    if (!this.isStopped) {\n      if (!this.retries) {\n        this.subscribeToRetries();\n      }\n\n      if (!this.retriesSubscription || this.retriesSubscription.closed) {\n        return _super.prototype.complete.call(this);\n      }\n\n      this._unsubscribeAndRecycle();\n\n      this.notifications.next();\n    }\n  };\n  /** @deprecated internal use only */\n\n\n  RepeatWhenSubscriber.prototype._unsubscribe = function () {\n    var _a = this,\n        notifications = _a.notifications,\n        retriesSubscription = _a.retriesSubscription;\n\n    if (notifications) {\n      notifications.unsubscribe();\n      this.notifications = null;\n    }\n\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = null;\n    }\n\n    this.retries = null;\n  };\n  /** @deprecated internal use only */\n\n\n  RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {\n    var _a = this,\n        notifications = _a.notifications,\n        retries = _a.retries,\n        retriesSubscription = _a.retriesSubscription;\n\n    this.notifications = null;\n    this.retries = null;\n    this.retriesSubscription = null;\n\n    _super.prototype._unsubscribeAndRecycle.call(this);\n\n    this.notifications = notifications;\n    this.retries = retries;\n    this.retriesSubscription = retriesSubscription;\n    return this;\n  };\n\n  RepeatWhenSubscriber.prototype.subscribeToRetries = function () {\n    this.notifications = new Subject_1.Subject();\n    var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);\n\n    if (retries === errorObject_1.errorObject) {\n      return _super.prototype.complete.call(this);\n    }\n\n    this.retries = retries;\n    this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n  };\n\n  return RepeatWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"0jD2\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar count_1 = /*@__PURE__*/__webpack_require__(\"iYe0\");\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var secondsBeforeClick = seconds.takeUntil(clicks);\n * var result = secondsBeforeClick.count();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n * var numbers = Rx.Observable.range(1, 7);\n * var result = numbers.count(i => i % 2 === 1);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 4\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\n\n\nfunction count(predicate) {\n  return count_1.count(predicate)(this);\n}\n\nexports.count = count;\n\n/***/ }),\n\n/***/ \"0p2S\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar mergeMap_1 = /*@__PURE__*/__webpack_require__(\"lf2g\");\n\nvar identity_1 = /*@__PURE__*/__webpack_require__(\"LAU0\");\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\n\n\nfunction mergeAll(concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  return mergeMap_1.mergeMap(identity_1.identity, null, concurrent);\n}\n\nexports.mergeAll = mergeAll;\n\n/***/ }),\n\n/***/ \"0zyO\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar Notification_1 = /*@__PURE__*/__webpack_require__(\"9x29\");\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\n\n\nfunction observeOn(scheduler, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n\n  return function observeOnOperatorFunction(source) {\n    return source.lift(new ObserveOnOperator(scheduler, delay));\n  };\n}\n\nexports.observeOn = observeOn;\n\nvar ObserveOnOperator = /*@__PURE__*/function () {\n  function ObserveOnOperator(scheduler, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    this.scheduler = scheduler;\n    this.delay = delay;\n  }\n\n  ObserveOnOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n  };\n\n  return ObserveOnOperator;\n}();\n\nexports.ObserveOnOperator = ObserveOnOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar ObserveOnSubscriber = function (_super) {\n  __extends(ObserveOnSubscriber, _super);\n\n  function ObserveOnSubscriber(destination, scheduler, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    _super.call(this, destination);\n\n    this.scheduler = scheduler;\n    this.delay = delay;\n  }\n\n  ObserveOnSubscriber.dispatch = function (arg) {\n    var notification = arg.notification,\n        destination = arg.destination;\n    notification.observe(destination);\n    this.unsubscribe();\n  };\n\n  ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n    this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n  };\n\n  ObserveOnSubscriber.prototype._next = function (value) {\n    this.scheduleMessage(Notification_1.Notification.createNext(value));\n  };\n\n  ObserveOnSubscriber.prototype._error = function (err) {\n    this.scheduleMessage(Notification_1.Notification.createError(err));\n  };\n\n  ObserveOnSubscriber.prototype._complete = function () {\n    this.scheduleMessage(Notification_1.Notification.createComplete());\n  };\n\n  return ObserveOnSubscriber;\n}(Subscriber_1.Subscriber);\n\nexports.ObserveOnSubscriber = ObserveOnSubscriber;\n\nvar ObserveOnMessage = /*@__PURE__*/function () {\n  function ObserveOnMessage(notification, destination) {\n    this.notification = notification;\n    this.destination = destination;\n  }\n\n  return ObserveOnMessage;\n}();\n\nexports.ObserveOnMessage = ObserveOnMessage;\n\n/***/ }),\n\n/***/ \"16yF\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\n\n\nfunction bufferCount(bufferSize, startBufferEvery) {\n  if (startBufferEvery === void 0) {\n    startBufferEvery = null;\n  }\n\n  return function bufferCountOperatorFunction(source) {\n    return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n  };\n}\n\nexports.bufferCount = bufferCount;\n\nvar BufferCountOperator = /*@__PURE__*/function () {\n  function BufferCountOperator(bufferSize, startBufferEvery) {\n    this.bufferSize = bufferSize;\n    this.startBufferEvery = startBufferEvery;\n\n    if (!startBufferEvery || bufferSize === startBufferEvery) {\n      this.subscriberClass = BufferCountSubscriber;\n    } else {\n      this.subscriberClass = BufferSkipCountSubscriber;\n    }\n  }\n\n  BufferCountOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n  };\n\n  return BufferCountOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar BufferCountSubscriber = function (_super) {\n  __extends(BufferCountSubscriber, _super);\n\n  function BufferCountSubscriber(destination, bufferSize) {\n    _super.call(this, destination);\n\n    this.bufferSize = bufferSize;\n    this.buffer = [];\n  }\n\n  BufferCountSubscriber.prototype._next = function (value) {\n    var buffer = this.buffer;\n    buffer.push(value);\n\n    if (buffer.length == this.bufferSize) {\n      this.destination.next(buffer);\n      this.buffer = [];\n    }\n  };\n\n  BufferCountSubscriber.prototype._complete = function () {\n    var buffer = this.buffer;\n\n    if (buffer.length > 0) {\n      this.destination.next(buffer);\n    }\n\n    _super.prototype._complete.call(this);\n  };\n\n  return BufferCountSubscriber;\n}(Subscriber_1.Subscriber);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar BufferSkipCountSubscriber = function (_super) {\n  __extends(BufferSkipCountSubscriber, _super);\n\n  function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n    _super.call(this, destination);\n\n    this.bufferSize = bufferSize;\n    this.startBufferEvery = startBufferEvery;\n    this.buffers = [];\n    this.count = 0;\n  }\n\n  BufferSkipCountSubscriber.prototype._next = function (value) {\n    var _a = this,\n        bufferSize = _a.bufferSize,\n        startBufferEvery = _a.startBufferEvery,\n        buffers = _a.buffers,\n        count = _a.count;\n\n    this.count++;\n\n    if (count % startBufferEvery === 0) {\n      buffers.push([]);\n    }\n\n    for (var i = buffers.length; i--;) {\n      var buffer = buffers[i];\n      buffer.push(value);\n\n      if (buffer.length === bufferSize) {\n        buffers.splice(i, 1);\n        this.destination.next(buffer);\n      }\n    }\n  };\n\n  BufferSkipCountSubscriber.prototype._complete = function () {\n    var _a = this,\n        buffers = _a.buffers,\n        destination = _a.destination;\n\n    while (buffers.length > 0) {\n      var buffer = buffers.shift();\n\n      if (buffer.length > 0) {\n        destination.next(buffer);\n      }\n    }\n\n    _super.prototype._complete.call(this);\n  };\n\n  return BufferSkipCountSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"1BBg\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar empty_1 = __webpack_require__(\"sYdX\");\n\nObservable_1.Observable.empty = empty_1.empty; //# sourceMappingURL=empty.js.map\n\n/***/ }),\n\n/***/ \"1DV/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\n\n\nfunction skip(count) {\n  return function (source) {\n    return source.lift(new SkipOperator(count));\n  };\n}\n\nexports.skip = skip;\n\nvar SkipOperator = /*@__PURE__*/function () {\n  function SkipOperator(total) {\n    this.total = total;\n  }\n\n  SkipOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SkipSubscriber(subscriber, this.total));\n  };\n\n  return SkipOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SkipSubscriber = function (_super) {\n  __extends(SkipSubscriber, _super);\n\n  function SkipSubscriber(destination, total) {\n    _super.call(this, destination);\n\n    this.total = total;\n    this.count = 0;\n  }\n\n  SkipSubscriber.prototype._next = function (x) {\n    if (++this.count > this.total) {\n      this.destination.next(x);\n    }\n  };\n\n  return SkipSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"1G/o\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar subscribeOn_1 = __webpack_require__(\"e7/H\");\n\nObservable_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn; //# sourceMappingURL=subscribeOn.js.map\n\n/***/ }),\n\n/***/ \"1jHa\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar merge_1 = __webpack_require__(\"gIzs\");\n\nObservable_1.Observable.prototype.merge = merge_1.merge; //# sourceMappingURL=merge.js.map\n\n/***/ }),\n\n/***/ \"1nIg\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar publishLast_1 = /*@__PURE__*/__webpack_require__(\"O/EN\");\n/**\n * @return {ConnectableObservable<T>}\n * @method publishLast\n * @owner Observable\n */\n\n\nfunction publishLast() {\n  //TODO(benlesh): correct type-flow through here.\n  return publishLast_1.publishLast()(this);\n}\n\nexports.publishLast = publishLast;\n\n/***/ }),\n\n/***/ \"1uGz\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar isFunction_1 = /*@__PURE__*/__webpack_require__(\"PFc+\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar Observer_1 = /*@__PURE__*/__webpack_require__(\"yz70\");\n\nvar rxSubscriber_1 = /*@__PURE__*/__webpack_require__(\"nkkL\");\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\n\n\nvar Subscriber = function (_super) {\n  __extends(Subscriber, _super);\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n\n\n  function Subscriber(destinationOrNext, error, complete) {\n    _super.call(this);\n\n    this.syncErrorValue = null;\n    this.syncErrorThrown = false;\n    this.syncErrorThrowable = false;\n    this.isStopped = false;\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = Observer_1.empty;\n        break;\n\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = Observer_1.empty;\n          break;\n        }\n\n        if (typeof destinationOrNext === 'object') {\n          // HACK(benlesh): To resolve an issue where Node users may have multiple\n          // copies of rxjs in their node_modules directory.\n          if (isTrustedSubscriber(destinationOrNext)) {\n            var trustedSubscriber = destinationOrNext[rxSubscriber_1.rxSubscriber]();\n            this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n            this.destination = trustedSubscriber;\n            trustedSubscriber.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber(this, destinationOrNext);\n          }\n\n          break;\n        }\n\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {\n    return this;\n  };\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n\n\n  Subscriber.create = function (next, error, complete) {\n    var subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  };\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n\n\n  Subscriber.prototype.next = function (value) {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  };\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n\n\n  Subscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._error(err);\n    }\n  };\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n\n\n  Subscriber.prototype.complete = function () {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._complete();\n    }\n  };\n\n  Subscriber.prototype.unsubscribe = function () {\n    if (this.closed) {\n      return;\n    }\n\n    this.isStopped = true;\n\n    _super.prototype.unsubscribe.call(this);\n  };\n\n  Subscriber.prototype._next = function (value) {\n    this.destination.next(value);\n  };\n\n  Subscriber.prototype._error = function (err) {\n    this.destination.error(err);\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._complete = function () {\n    this.destination.complete();\n    this.unsubscribe();\n  };\n  /** @deprecated internal use only */\n\n\n  Subscriber.prototype._unsubscribeAndRecycle = function () {\n    var _a = this,\n        _parent = _a._parent,\n        _parents = _a._parents;\n\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  };\n\n  return Subscriber;\n}(Subscription_1.Subscription);\n\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar SafeSubscriber = function (_super) {\n  __extends(SafeSubscriber, _super);\n\n  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n    _super.call(this);\n\n    this._parentSubscriber = _parentSubscriber;\n    var next;\n    var context = this;\n\n    if (isFunction_1.isFunction(observerOrNext)) {\n      next = observerOrNext;\n    } else if (observerOrNext) {\n      next = observerOrNext.next;\n      error = observerOrNext.error;\n      complete = observerOrNext.complete;\n\n      if (observerOrNext !== Observer_1.empty) {\n        context = Object.create(observerOrNext);\n\n        if (isFunction_1.isFunction(context.unsubscribe)) {\n          this.add(context.unsubscribe.bind(context));\n        }\n\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  SafeSubscriber.prototype.next = function (value) {\n    if (!this.isStopped && this._next) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parentSubscriber.syncErrorValue = err;\n        _parentSubscriber.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.complete = function () {\n    var _this = this;\n\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (this._complete) {\n        var wrappedComplete = function wrappedComplete() {\n          return _this._complete.call(_this._context);\n        };\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n\n    return false;\n  };\n  /** @deprecated internal use only */\n\n\n  SafeSubscriber.prototype._unsubscribe = function () {\n    var _parentSubscriber = this._parentSubscriber;\n    this._context = null;\n    this._parentSubscriber = null;\n\n    _parentSubscriber.unsubscribe();\n  };\n\n  return SafeSubscriber;\n}(Subscriber);\n\nfunction isTrustedSubscriber(obj) {\n  return obj instanceof Subscriber || 'syncErrorThrowable' in obj && obj[rxSubscriber_1.rxSubscriber];\n}\n\n/***/ }),\n\n/***/ \"1xzA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar distinctUntilChanged_1 = __webpack_require__(\"l9aY\");\n\nObservable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged; //# sourceMappingURL=distinctUntilChanged.js.map\n\n/***/ }),\n\n/***/ \"27EW\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar switchMapTo_1 = /*@__PURE__*/__webpack_require__(\"VthU\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\n\n\nfunction switchMapTo(innerObservable, resultSelector) {\n  return switchMapTo_1.switchMapTo(innerObservable, resultSelector)(this);\n}\n\nexports.switchMapTo = switchMapTo;\n\n/***/ }),\n\n/***/ \"2FQM\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar materialize_1 = __webpack_require__(\"8pZU\");\n\nObservable_1.Observable.prototype.materialize = materialize_1.materialize; //# sourceMappingURL=materialize.js.map\n\n/***/ }),\n\n/***/ \"2Go0\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar PairsObservable_1 = /*@__PURE__*/__webpack_require__(\"Zo/K\");\n\nexports.pairs = PairsObservable_1.PairsObservable.create;\n\n/***/ }),\n\n/***/ \"2HR8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar pairwise_1 = __webpack_require__(\"Al8V\");\n\nObservable_1.Observable.prototype.pairwise = pairwise_1.pairwise; //# sourceMappingURL=pairwise.js.map\n\n/***/ }),\n\n/***/ \"2Tbn\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/* tslint:enable:max-line-length */\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\n\n\nfunction defaultIfEmpty(defaultValue) {\n  if (defaultValue === void 0) {\n    defaultValue = null;\n  }\n\n  return function (source) {\n    return source.lift(new DefaultIfEmptyOperator(defaultValue));\n  };\n}\n\nexports.defaultIfEmpty = defaultIfEmpty;\n\nvar DefaultIfEmptyOperator = /*@__PURE__*/function () {\n  function DefaultIfEmptyOperator(defaultValue) {\n    this.defaultValue = defaultValue;\n  }\n\n  DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n  };\n\n  return DefaultIfEmptyOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar DefaultIfEmptySubscriber = function (_super) {\n  __extends(DefaultIfEmptySubscriber, _super);\n\n  function DefaultIfEmptySubscriber(destination, defaultValue) {\n    _super.call(this, destination);\n\n    this.defaultValue = defaultValue;\n    this.isEmpty = true;\n  }\n\n  DefaultIfEmptySubscriber.prototype._next = function (value) {\n    this.isEmpty = false;\n    this.destination.next(value);\n  };\n\n  DefaultIfEmptySubscriber.prototype._complete = function () {\n    if (this.isEmpty) {\n      this.destination.next(this.defaultValue);\n    }\n\n    this.destination.complete();\n  };\n\n  return DefaultIfEmptySubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"2Wg+\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/* tslint:enable:max-line-length */\n\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\n\n\nfunction withLatestFrom() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i - 0] = arguments[_i];\n  }\n\n  return function (source) {\n    var project;\n\n    if (typeof args[args.length - 1] === 'function') {\n      project = args.pop();\n    }\n\n    var observables = args;\n    return source.lift(new WithLatestFromOperator(observables, project));\n  };\n}\n\nexports.withLatestFrom = withLatestFrom;\n\nvar WithLatestFromOperator = /*@__PURE__*/function () {\n  function WithLatestFromOperator(observables, project) {\n    this.observables = observables;\n    this.project = project;\n  }\n\n  WithLatestFromOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n  };\n\n  return WithLatestFromOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar WithLatestFromSubscriber = function (_super) {\n  __extends(WithLatestFromSubscriber, _super);\n\n  function WithLatestFromSubscriber(destination, observables, project) {\n    _super.call(this, destination);\n\n    this.observables = observables;\n    this.project = project;\n    this.toRespond = [];\n    var len = observables.length;\n    this.values = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      this.toRespond.push(i);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var observable = observables[i];\n      this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n    }\n  }\n\n  WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.values[outerIndex] = innerValue;\n    var toRespond = this.toRespond;\n\n    if (toRespond.length > 0) {\n      var found = toRespond.indexOf(outerIndex);\n\n      if (found !== -1) {\n        toRespond.splice(found, 1);\n      }\n    }\n  };\n\n  WithLatestFromSubscriber.prototype.notifyComplete = function () {// noop\n  };\n\n  WithLatestFromSubscriber.prototype._next = function (value) {\n    if (this.toRespond.length === 0) {\n      var args = [value].concat(this.values);\n\n      if (this.project) {\n        this._tryProject(args);\n      } else {\n        this.destination.next(args);\n      }\n    }\n  };\n\n  WithLatestFromSubscriber.prototype._tryProject = function (args) {\n    var result;\n\n    try {\n      result = this.project.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"2fIB\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\n\n\nvar EmptyError = function (_super) {\n  __extends(EmptyError, _super);\n\n  function EmptyError() {\n    var err = _super.call(this, 'no elements in sequence');\n\n    this.name = err.name = 'EmptyError';\n    this.stack = err.stack;\n    this.message = err.message;\n  }\n\n  return EmptyError;\n}(Error);\n\nexports.EmptyError = EmptyError;\n\n/***/ }),\n\n/***/ \"2gSr\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nfunction assignImpl(target) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  var len = sources.length;\n\n  for (var i = 0; i < len; i++) {\n    var source = sources[i];\n\n    for (var k in source) {\n      if (source.hasOwnProperty(k)) {\n        target[k] = source[k];\n      }\n    }\n  }\n\n  return target;\n}\n\nexports.assignImpl = assignImpl;\n;\n\nfunction getAssign(root) {\n  return root.Object.assign || assignImpl;\n}\n\nexports.getAssign = getAssign;\nexports.assign = /*@__PURE__*/getAssign(root_1.root);\n\n/***/ }),\n\n/***/ \"2qLy\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar takeUntil_1 = /*@__PURE__*/__webpack_require__(\"MHPA\");\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\n\n\nfunction takeUntil(notifier) {\n  return takeUntil_1.takeUntil(notifier)(this);\n}\n\nexports.takeUntil = takeUntil;\n\n/***/ }),\n\n/***/ \"36rE\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar EmptyObservable = function (_super) {\n  __extends(EmptyObservable, _super);\n\n  function EmptyObservable(scheduler) {\n    _super.call(this);\n\n    this.scheduler = scheduler;\n  }\n  /**\n   * Creates an Observable that emits no items to the Observer and immediately\n   * emits a complete notification.\n   *\n   * <span class=\"informal\">Just emits 'complete', and nothing else.\n   * </span>\n   *\n   * <img src=\"./img/empty.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the complete notification. It can be used for composing with other\n   * Observables, such as in a {@link mergeMap}.\n   *\n   * @example <caption>Emit the number 7, then complete.</caption>\n   * var result = Rx.Observable.empty().startWith(7);\n   * result.subscribe(x => console.log(x));\n   *\n   * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n   * var interval = Rx.Observable.interval(1000);\n   * var result = interval.mergeMap(x =>\n   *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n   * );\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following to the console:\n   * // x is equal to the count on the interval eg(0,1,2,3,...)\n   * // x will occur every 1000ms\n   * // if x % 2 is equal to 1 print abc\n   * // if x % 2 is not equal to 1 nothing will be output\n   *\n   * @see {@link create}\n   * @see {@link never}\n   * @see {@link of}\n   * @see {@link throw}\n   *\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emission of the complete notification.\n   * @return {Observable} An \"empty\" Observable: emits only the complete\n   * notification.\n   * @static true\n   * @name empty\n   * @owner Observable\n   */\n\n\n  EmptyObservable.create = function (scheduler) {\n    return new EmptyObservable(scheduler);\n  };\n\n  EmptyObservable.dispatch = function (arg) {\n    var subscriber = arg.subscriber;\n    subscriber.complete();\n  };\n  /** @deprecated internal use only */\n\n\n  EmptyObservable.prototype._subscribe = function (subscriber) {\n    var scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(EmptyObservable.dispatch, 0, {\n        subscriber: subscriber\n      });\n    } else {\n      subscriber.complete();\n    }\n  };\n\n  return EmptyObservable;\n}(Observable_1.Observable);\n\nexports.EmptyObservable = EmptyObservable;\n\n/***/ }),\n\n/***/ \"3Ind\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\n\n\nfunction sequenceEqual(compareTo, comparor) {\n  return function (source) {\n    return source.lift(new SequenceEqualOperator(compareTo, comparor));\n  };\n}\n\nexports.sequenceEqual = sequenceEqual;\n\nvar SequenceEqualOperator = /*@__PURE__*/function () {\n  function SequenceEqualOperator(compareTo, comparor) {\n    this.compareTo = compareTo;\n    this.comparor = comparor;\n  }\n\n  SequenceEqualOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n  };\n\n  return SequenceEqualOperator;\n}();\n\nexports.SequenceEqualOperator = SequenceEqualOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar SequenceEqualSubscriber = function (_super) {\n  __extends(SequenceEqualSubscriber, _super);\n\n  function SequenceEqualSubscriber(destination, compareTo, comparor) {\n    _super.call(this, destination);\n\n    this.compareTo = compareTo;\n    this.comparor = comparor;\n    this._a = [];\n    this._b = [];\n    this._oneComplete = false;\n    this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n  }\n\n  SequenceEqualSubscriber.prototype._next = function (value) {\n    if (this._oneComplete && this._b.length === 0) {\n      this.emit(false);\n    } else {\n      this._a.push(value);\n\n      this.checkValues();\n    }\n  };\n\n  SequenceEqualSubscriber.prototype._complete = function () {\n    if (this._oneComplete) {\n      this.emit(this._a.length === 0 && this._b.length === 0);\n    } else {\n      this._oneComplete = true;\n    }\n  };\n\n  SequenceEqualSubscriber.prototype.checkValues = function () {\n    var _c = this,\n        _a = _c._a,\n        _b = _c._b,\n        comparor = _c.comparor;\n\n    while (_a.length > 0 && _b.length > 0) {\n      var a = _a.shift();\n\n      var b = _b.shift();\n\n      var areEqual = false;\n\n      if (comparor) {\n        areEqual = tryCatch_1.tryCatch(comparor)(a, b);\n\n        if (areEqual === errorObject_1.errorObject) {\n          this.destination.error(errorObject_1.errorObject.e);\n        }\n      } else {\n        areEqual = a === b;\n      }\n\n      if (!areEqual) {\n        this.emit(false);\n      }\n    }\n  };\n\n  SequenceEqualSubscriber.prototype.emit = function (value) {\n    var destination = this.destination;\n    destination.next(value);\n    destination.complete();\n  };\n\n  SequenceEqualSubscriber.prototype.nextB = function (value) {\n    if (this._oneComplete && this._a.length === 0) {\n      this.emit(false);\n    } else {\n      this._b.push(value);\n\n      this.checkValues();\n    }\n  };\n\n  return SequenceEqualSubscriber;\n}(Subscriber_1.Subscriber);\n\nexports.SequenceEqualSubscriber = SequenceEqualSubscriber;\n\nvar SequenceEqualCompareToSubscriber = function (_super) {\n  __extends(SequenceEqualCompareToSubscriber, _super);\n\n  function SequenceEqualCompareToSubscriber(destination, parent) {\n    _super.call(this, destination);\n\n    this.parent = parent;\n  }\n\n  SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n    this.parent.nextB(value);\n  };\n\n  SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n    this.parent.error(err);\n  };\n\n  SequenceEqualCompareToSubscriber.prototype._complete = function () {\n    this.parent._complete();\n  };\n\n  return SequenceEqualCompareToSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"3Tlz\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar DeferObservable_1 = /*@__PURE__*/__webpack_require__(\"0dxg\");\n\nexports.defer = DeferObservable_1.DeferObservable.create;\n\n/***/ }),\n\n/***/ \"3VCA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar refCount_1 = /*@__PURE__*/__webpack_require__(\"pk/4\");\n/**\n * @class ConnectableObservable<T>\n */\n\n\nvar ConnectableObservable = function (_super) {\n  __extends(ConnectableObservable, _super);\n\n  function ConnectableObservable(\n  /** @deprecated internal use only */\n  source,\n  /** @deprecated internal use only */\n  subjectFactory) {\n    _super.call(this);\n\n    this.source = source;\n    this.subjectFactory = subjectFactory;\n    /** @deprecated internal use only */\n\n    this._refCount = 0;\n    this._isComplete = false;\n  }\n  /** @deprecated internal use only */\n\n\n  ConnectableObservable.prototype._subscribe = function (subscriber) {\n    return this.getSubject().subscribe(subscriber);\n  };\n  /** @deprecated internal use only */\n\n\n  ConnectableObservable.prototype.getSubject = function () {\n    var subject = this._subject;\n\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n\n    return this._subject;\n  };\n\n  ConnectableObservable.prototype.connect = function () {\n    var connection = this._connection;\n\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription_1.Subscription();\n      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription_1.Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n\n    return connection;\n  };\n\n  ConnectableObservable.prototype.refCount = function () {\n    return refCount_1.refCount()(this);\n  };\n\n  return ConnectableObservable;\n}(Observable_1.Observable);\n\nexports.ConnectableObservable = ConnectableObservable;\nvar connectableProto = ConnectableObservable.prototype;\nexports.connectableObservableDescriptor = {\n  operator: {\n    value: null\n  },\n  _refCount: {\n    value: 0,\n    writable: true\n  },\n  _subject: {\n    value: null,\n    writable: true\n  },\n  _connection: {\n    value: null,\n    writable: true\n  },\n  _subscribe: {\n    value: connectableProto._subscribe\n  },\n  _isComplete: {\n    value: connectableProto._isComplete,\n    writable: true\n  },\n  getSubject: {\n    value: connectableProto.getSubject\n  },\n  connect: {\n    value: connectableProto.connect\n  },\n  refCount: {\n    value: connectableProto.refCount\n  }\n};\n\nvar ConnectableSubscriber = function (_super) {\n  __extends(ConnectableSubscriber, _super);\n\n  function ConnectableSubscriber(destination, connectable) {\n    _super.call(this, destination);\n\n    this.connectable = connectable;\n  }\n\n  ConnectableSubscriber.prototype._error = function (err) {\n    this._unsubscribe();\n\n    _super.prototype._error.call(this, err);\n  };\n\n  ConnectableSubscriber.prototype._complete = function () {\n    this.connectable._isComplete = true;\n\n    this._unsubscribe();\n\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n\n\n  ConnectableSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (connectable) {\n      this.connectable = null;\n      var connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  };\n\n  return ConnectableSubscriber;\n}(Subject_1.SubjectSubscriber);\n\nvar RefCountOperator = /*@__PURE__*/function () {\n  function RefCountOperator(connectable) {\n    this.connectable = connectable;\n  }\n\n  RefCountOperator.prototype.call = function (subscriber, source) {\n    var connectable = this.connectable;\n    connectable._refCount++;\n    var refCounter = new RefCountSubscriber(subscriber, connectable);\n    var subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n\n    return subscription;\n  };\n\n  return RefCountOperator;\n}();\n\nvar RefCountSubscriber = function (_super) {\n  __extends(RefCountSubscriber, _super);\n\n  function RefCountSubscriber(destination, connectable) {\n    _super.call(this, destination);\n\n    this.connectable = connectable;\n  }\n  /** @deprecated internal use only */\n\n\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    var refCount = connectable._refCount;\n\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    connectable._refCount = refCount - 1;\n\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    } ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n\n\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n\n  return RefCountSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"3W7U\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar takeWhile_1 = /*@__PURE__*/__webpack_require__(\"3jsl\");\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.takeWhile(ev => ev.clientX > 200);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\n\n\nfunction takeWhile(predicate) {\n  return takeWhile_1.takeWhile(predicate)(this);\n}\n\nexports.takeWhile = takeWhile;\n\n/***/ }),\n\n/***/ \"3WZS\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar isNumeric_1 = /*@__PURE__*/__webpack_require__(\"zZI/\");\n\nvar isScheduler_1 = /*@__PURE__*/__webpack_require__(\"NwwV\");\n\nfunction windowTime(windowTimeSpan) {\n  var scheduler = async_1.async;\n  var windowCreationInterval = null;\n  var maxWindowSize = Number.POSITIVE_INFINITY;\n\n  if (isScheduler_1.isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler_1.isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric_1.isNumeric(arguments[2])) {\n    maxWindowSize = arguments[2];\n  }\n\n  if (isScheduler_1.isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric_1.isNumeric(arguments[1])) {\n    windowCreationInterval = arguments[1];\n  }\n\n  return function windowTimeOperatorFunction(source) {\n    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\n\nexports.windowTime = windowTime;\n\nvar WindowTimeOperator = /*@__PURE__*/function () {\n  function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n  }\n\n  WindowTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n  };\n\n  return WindowTimeOperator;\n}();\n\nvar CountedSubject = function (_super) {\n  __extends(CountedSubject, _super);\n\n  function CountedSubject() {\n    _super.apply(this, arguments);\n\n    this._numberOfNextedValues = 0;\n  }\n\n  CountedSubject.prototype.next = function (value) {\n    this._numberOfNextedValues++;\n\n    _super.prototype.next.call(this, value);\n  };\n\n  Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n    get: function get() {\n      return this._numberOfNextedValues;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CountedSubject;\n}(Subject_1.Subject);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar WindowTimeSubscriber = function (_super) {\n  __extends(WindowTimeSubscriber, _super);\n\n  function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    _super.call(this, destination);\n\n    this.destination = destination;\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n    this.windows = [];\n    var window = this.openWindow();\n\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      var closeState = {\n        subscriber: this,\n        window: window,\n        context: null\n      };\n      var creationState = {\n        windowTimeSpan: windowTimeSpan,\n        windowCreationInterval: windowCreationInterval,\n        subscriber: this,\n        scheduler: scheduler\n      };\n      this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      var timeSpanOnlyState = {\n        subscriber: this,\n        window: window,\n        windowTimeSpan: windowTimeSpan\n      };\n      this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  WindowTimeSubscriber.prototype._next = function (value) {\n    var windows = this.windows;\n    var len = windows.length;\n\n    for (var i = 0; i < len; i++) {\n      var window_1 = windows[i];\n\n      if (!window_1.closed) {\n        window_1.next(value);\n\n        if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window_1);\n        }\n      }\n    }\n  };\n\n  WindowTimeSubscriber.prototype._error = function (err) {\n    var windows = this.windows;\n\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n\n    this.destination.error(err);\n  };\n\n  WindowTimeSubscriber.prototype._complete = function () {\n    var windows = this.windows;\n\n    while (windows.length > 0) {\n      var window_2 = windows.shift();\n\n      if (!window_2.closed) {\n        window_2.complete();\n      }\n    }\n\n    this.destination.complete();\n  };\n\n  WindowTimeSubscriber.prototype.openWindow = function () {\n    var window = new CountedSubject();\n    this.windows.push(window);\n    var destination = this.destination;\n    destination.next(window);\n    return window;\n  };\n\n  WindowTimeSubscriber.prototype.closeWindow = function (window) {\n    window.complete();\n    var windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  };\n\n  return WindowTimeSubscriber;\n}(Subscriber_1.Subscriber);\n\nfunction dispatchWindowTimeSpanOnly(state) {\n  var subscriber = state.subscriber,\n      windowTimeSpan = state.windowTimeSpan,\n      window = state.window;\n\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\nfunction dispatchWindowCreation(state) {\n  var windowTimeSpan = state.windowTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler,\n      windowCreationInterval = state.windowCreationInterval;\n  var window = subscriber.openWindow();\n  var action = this;\n  var context = {\n    action: action,\n    subscription: null\n  };\n  var timeSpanState = {\n    subscriber: subscriber,\n    window: window,\n    context: context\n  };\n  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose(state) {\n  var subscriber = state.subscriber,\n      window = state.window,\n      context = state.context;\n\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n\n  subscriber.closeWindow(window);\n}\n\n/***/ }),\n\n/***/ \"3hIw\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar ArgumentOutOfRangeError_1 = /*@__PURE__*/__webpack_require__(\"8kg7\");\n\nvar EmptyObservable_1 = /*@__PURE__*/__webpack_require__(\"36rE\");\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\n\n\nfunction take(count) {\n  return function (source) {\n    if (count === 0) {\n      return new EmptyObservable_1.EmptyObservable();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nexports.take = take;\n\nvar TakeOperator = /*@__PURE__*/function () {\n  function TakeOperator(total) {\n    this.total = total;\n\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();\n    }\n  }\n\n  TakeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  };\n\n  return TakeOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar TakeSubscriber = function (_super) {\n  __extends(TakeSubscriber, _super);\n\n  function TakeSubscriber(destination, total) {\n    _super.call(this, destination);\n\n    this.total = total;\n    this.count = 0;\n  }\n\n  TakeSubscriber.prototype._next = function (value) {\n    var total = this.total;\n    var count = ++this.count;\n\n    if (count <= total) {\n      this.destination.next(value);\n\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  };\n\n  return TakeSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"3jsl\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.takeWhile(ev => ev.clientX > 200);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\n\n\nfunction takeWhile(predicate) {\n  return function (source) {\n    return source.lift(new TakeWhileOperator(predicate));\n  };\n}\n\nexports.takeWhile = takeWhile;\n\nvar TakeWhileOperator = /*@__PURE__*/function () {\n  function TakeWhileOperator(predicate) {\n    this.predicate = predicate;\n  }\n\n  TakeWhileOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n  };\n\n  return TakeWhileOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar TakeWhileSubscriber = function (_super) {\n  __extends(TakeWhileSubscriber, _super);\n\n  function TakeWhileSubscriber(destination, predicate) {\n    _super.call(this, destination);\n\n    this.predicate = predicate;\n    this.index = 0;\n  }\n\n  TakeWhileSubscriber.prototype._next = function (value) {\n    var destination = this.destination;\n    var result;\n\n    try {\n      result = this.predicate(value, this.index++);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    this.nextOrComplete(value, result);\n  };\n\n  TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n    var destination = this.destination;\n\n    if (Boolean(predicateResult)) {\n      destination.next(value);\n    } else {\n      destination.complete();\n    }\n  };\n\n  return TakeWhileSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"3zH1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar AsyncSubject_1 = /*@__PURE__*/__webpack_require__(\"8G9e\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar BoundNodeCallbackObservable = function (_super) {\n  __extends(BoundNodeCallbackObservable, _super);\n\n  function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n    _super.call(this);\n\n    this.callbackFunc = callbackFunc;\n    this.selector = selector;\n    this.args = args;\n    this.context = context;\n    this.scheduler = scheduler;\n  }\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Converts a Node.js-style callback API to a function that returns an\n   * Observable.\n   *\n   * <span class=\"informal\">It's just like {@link bindCallback}, but the\n   * callback is expected to be of type `callback(error, result)`.</span>\n   *\n   * `bindNodeCallback` is not an operator because its input and output are not\n   * Observables. The input is a function `func` with some parameters, but the\n   * last parameter must be a callback function that `func` calls when it is\n   * done. The callback function is expected to follow Node.js conventions,\n   * where the first argument to the callback is an error object, signaling\n   * whether call was successful. If that object is passed to callback, it means\n   * something went wrong.\n   *\n   * The output of `bindNodeCallback` is a function that takes the same\n   * parameters as `func`, except the last one (the callback). When the output\n   * function is called with arguments, it will return an Observable.\n   * If `func` calls its callback with error parameter present, Observable will\n   * error with that value as well. If error parameter is not passed, Observable will emit\n   * second parameter. If there are more parameters (third and so on),\n   * Observable will emit an array with all arguments, except first error argument.\n   *\n   * Optionally `bindNodeCallback` accepts selector function, which allows you to\n   * make resulting Observable emit value computed by selector, instead of regular\n   * callback arguments. It works similarly to {@link bindCallback} selector, but\n   * Node.js-style error argument will never be passed to that function.\n   *\n   * Note that `func` will not be called at the same time output function is,\n   * but rather whenever resulting Observable is subscribed. By default call to\n   * `func` will happen synchronously after subscription, but that can be changed\n   * with proper {@link Scheduler} provided as optional third parameter. Scheduler\n   * can also control when values from callback will be emitted by Observable.\n   * To find out more, check out documentation for {@link bindCallback}, where\n   * Scheduler works exactly the same.\n   *\n   * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n   * of returned function, when it is called.\n   *\n   * After Observable emits value, it will complete immediately. This means\n   * even if `func` calls callback again, values from second and consecutive\n   * calls will never appear on the stream. If you need to handle functions\n   * that call callbacks multiple times, check out {@link fromEvent} or\n   * {@link fromEventPattern} instead.\n   *\n   * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n   * \"Node.js-style\" callbacks are just a convention, so if you write for\n   * browsers or any other environment and API you use implements that callback style,\n   * `bindNodeCallback` can be safely used on that API functions as well.\n   *\n   * Remember that Error object passed to callback does not have to be an instance\n   * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n   * Error parameter of callback function is interpreted as \"present\", when value\n   * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n   * string or boolean `true`. In all of these cases resulting Observable would error\n   * with that value. This means usually regular style callbacks will fail very often when\n   * `bindNodeCallback` is used. If your Observable errors much more often then you\n   * would expect, check if callback really is called in Node.js-style and, if not,\n   * switch to {@link bindCallback} instead.\n   *\n   * Note that even if error parameter is technically present in callback, but its value\n   * is falsy, it still won't appear in array emitted by Observable or in selector function.\n   *\n   *\n   * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>\n   * import * as fs from 'fs';\n   * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);\n   * var result = readFileAsObservable('./roadNames.txt', 'utf8');\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   *\n   * @example <caption>Use on function calling callback with multiple arguments</caption>\n   * someFunction((err, a, b) => {\n   *   console.log(err); // null\n   *   console.log(a); // 5\n   *   console.log(b); // \"some string\"\n   * });\n   * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n   * boundSomeFunction()\n   * .subscribe(value => {\n   *   console.log(value); // [5, \"some string\"]\n   * });\n   *\n   *\n   * @example <caption>Use with selector function</caption>\n   * someFunction((err, a, b) => {\n   *   console.log(err); // undefined\n   *   console.log(a); // \"abc\"\n   *   console.log(b); // \"DEF\"\n   * });\n   * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);\n   * boundSomeFunction()\n   * .subscribe(value => {\n   *   console.log(value); // \"abcDEF\"\n   * });\n   *\n   *\n   * @example <caption>Use on function calling callback in regular style</caption>\n   * someFunction(a => {\n   *   console.log(a); // 5\n   * });\n   * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n   * boundSomeFunction()\n   * .subscribe(\n   *   value => {}             // never gets called\n   *   err => console.log(err) // 5\n   *);\n   *\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   * @see {@link fromPromise}\n   *\n   * @param {function} func Function with a Node.js-style callback as the last parameter.\n   * @param {function} [selector] A function which takes the arguments from the\n   * callback and maps those to a value to emit on the output Observable.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * callbacks.\n   * @return {function(...params: *): Observable} A function which returns the\n   * Observable that delivers the same values the Node.js callback would\n   * deliver.\n   * @static true\n   * @name bindNodeCallback\n   * @owner Observable\n   */\n\n\n  BoundNodeCallbackObservable.create = function (func, selector, scheduler) {\n    if (selector === void 0) {\n      selector = undefined;\n    }\n\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n      }\n\n      return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);\n    };\n  };\n  /** @deprecated internal use only */\n\n\n  BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {\n    var callbackFunc = this.callbackFunc;\n    var args = this.args;\n    var scheduler = this.scheduler;\n    var subject = this.subject;\n\n    if (!scheduler) {\n      if (!subject) {\n        subject = this.subject = new AsyncSubject_1.AsyncSubject();\n\n        var handler = function handlerFn() {\n          var innerArgs = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            innerArgs[_i - 0] = arguments[_i];\n          }\n\n          var source = handlerFn.source;\n          var selector = source.selector,\n              subject = source.subject;\n          var err = innerArgs.shift();\n\n          if (err) {\n            subject.error(err);\n          } else if (selector) {\n            var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n\n            if (result_1 === errorObject_1.errorObject) {\n              subject.error(errorObject_1.errorObject.e);\n            } else {\n              subject.next(result_1);\n              subject.complete();\n            }\n          } else {\n            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n            subject.complete();\n          }\n        }; // use named function instance to avoid closure.\n\n\n        handler.source = this;\n        var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n\n        if (result === errorObject_1.errorObject) {\n          subject.error(errorObject_1.errorObject.e);\n        }\n      }\n\n      return subject.subscribe(subscriber);\n    } else {\n      return scheduler.schedule(dispatch, 0, {\n        source: this,\n        subscriber: subscriber,\n        context: this.context\n      });\n    }\n  };\n\n  return BoundNodeCallbackObservable;\n}(Observable_1.Observable);\n\nexports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;\n\nfunction dispatch(state) {\n  var self = this;\n  var source = state.source,\n      subscriber = state.subscriber,\n      context = state.context; // XXX: cast to `any` to access to the private field in `source`.\n\n  var _a = source,\n      callbackFunc = _a.callbackFunc,\n      args = _a.args,\n      scheduler = _a.scheduler;\n  var subject = source.subject;\n\n  if (!subject) {\n    subject = source.subject = new AsyncSubject_1.AsyncSubject();\n\n    var handler = function handlerFn() {\n      var innerArgs = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        innerArgs[_i - 0] = arguments[_i];\n      }\n\n      var source = handlerFn.source;\n      var selector = source.selector,\n          subject = source.subject;\n      var err = innerArgs.shift();\n\n      if (err) {\n        self.add(scheduler.schedule(dispatchError, 0, {\n          err: err,\n          subject: subject\n        }));\n      } else if (selector) {\n        var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n\n        if (result_2 === errorObject_1.errorObject) {\n          self.add(scheduler.schedule(dispatchError, 0, {\n            err: errorObject_1.errorObject.e,\n            subject: subject\n          }));\n        } else {\n          self.add(scheduler.schedule(dispatchNext, 0, {\n            value: result_2,\n            subject: subject\n          }));\n        }\n      } else {\n        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n        self.add(scheduler.schedule(dispatchNext, 0, {\n          value: value,\n          subject: subject\n        }));\n      }\n    }; // use named function to pass values in without closure\n\n\n    handler.source = source;\n    var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n\n    if (result === errorObject_1.errorObject) {\n      self.add(scheduler.schedule(dispatchError, 0, {\n        err: errorObject_1.errorObject.e,\n        subject: subject\n      }));\n    }\n  }\n\n  self.add(subject.subscribe(subscriber));\n}\n\nfunction dispatchNext(arg) {\n  var value = arg.value,\n      subject = arg.subject;\n  subject.next(value);\n  subject.complete();\n}\n\nfunction dispatchError(arg) {\n  var err = arg.err,\n      subject = arg.subject;\n  subject.error(err);\n}\n\n/***/ }),\n\n/***/ \"4BFK\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar skipWhile_1 = /*@__PURE__*/__webpack_require__(\"SX7S\");\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\n\n\nfunction skipWhile(predicate) {\n  return skipWhile_1.skipWhile(predicate)(this);\n}\n\nexports.skipWhile = skipWhile;\n\n/***/ }),\n\n/***/ \"4GoQ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delayWhen(event =>\n *   Rx.Observable.interval(Math.random() * 5000)\n * );\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\n\n\nfunction delayWhen(delayDurationSelector, subscriptionDelay) {\n  if (subscriptionDelay) {\n    return function (source) {\n      return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));\n    };\n  }\n\n  return function (source) {\n    return source.lift(new DelayWhenOperator(delayDurationSelector));\n  };\n}\n\nexports.delayWhen = delayWhen;\n\nvar DelayWhenOperator = /*@__PURE__*/function () {\n  function DelayWhenOperator(delayDurationSelector) {\n    this.delayDurationSelector = delayDurationSelector;\n  }\n\n  DelayWhenOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n  };\n\n  return DelayWhenOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar DelayWhenSubscriber = function (_super) {\n  __extends(DelayWhenSubscriber, _super);\n\n  function DelayWhenSubscriber(destination, delayDurationSelector) {\n    _super.call(this, destination);\n\n    this.delayDurationSelector = delayDurationSelector;\n    this.completed = false;\n    this.delayNotifierSubscriptions = [];\n    this.values = [];\n  }\n\n  DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.destination.next(outerValue);\n    this.removeSubscription(innerSub);\n    this.tryComplete();\n  };\n\n  DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n    this._error(error);\n  };\n\n  DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n    var value = this.removeSubscription(innerSub);\n\n    if (value) {\n      this.destination.next(value);\n    }\n\n    this.tryComplete();\n  };\n\n  DelayWhenSubscriber.prototype._next = function (value) {\n    try {\n      var delayNotifier = this.delayDurationSelector(value);\n\n      if (delayNotifier) {\n        this.tryDelay(delayNotifier, value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  };\n\n  DelayWhenSubscriber.prototype._complete = function () {\n    this.completed = true;\n    this.tryComplete();\n  };\n\n  DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n    subscription.unsubscribe();\n    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n    var value = null;\n\n    if (subscriptionIdx !== -1) {\n      value = this.values[subscriptionIdx];\n      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n      this.values.splice(subscriptionIdx, 1);\n    }\n\n    return value;\n  };\n\n  DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n    var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);\n\n    if (notifierSubscription && !notifierSubscription.closed) {\n      this.add(notifierSubscription);\n      this.delayNotifierSubscriptions.push(notifierSubscription);\n    }\n\n    this.values.push(value);\n  };\n\n  DelayWhenSubscriber.prototype.tryComplete = function () {\n    if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n      this.destination.complete();\n    }\n  };\n\n  return DelayWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SubscriptionDelayObservable = function (_super) {\n  __extends(SubscriptionDelayObservable, _super);\n\n  function SubscriptionDelayObservable(\n  /** @deprecated internal use only */\n  source, subscriptionDelay) {\n    _super.call(this);\n\n    this.source = source;\n    this.subscriptionDelay = subscriptionDelay;\n  }\n  /** @deprecated internal use only */\n\n\n  SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n  };\n\n  return SubscriptionDelayObservable;\n}(Observable_1.Observable);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SubscriptionDelaySubscriber = function (_super) {\n  __extends(SubscriptionDelaySubscriber, _super);\n\n  function SubscriptionDelaySubscriber(parent, source) {\n    _super.call(this);\n\n    this.parent = parent;\n    this.source = source;\n    this.sourceSubscribed = false;\n  }\n\n  SubscriptionDelaySubscriber.prototype._next = function (unused) {\n    this.subscribeToSource();\n  };\n\n  SubscriptionDelaySubscriber.prototype._error = function (err) {\n    this.unsubscribe();\n    this.parent.error(err);\n  };\n\n  SubscriptionDelaySubscriber.prototype._complete = function () {\n    this.subscribeToSource();\n  };\n\n  SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n    if (!this.sourceSubscribed) {\n      this.sourceSubscribed = true;\n      this.unsubscribe();\n      this.source.subscribe(this.parent);\n    }\n  };\n\n  return SubscriptionDelaySubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"4JC2\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar publishBehavior_1 = __webpack_require__(\"rPn0\");\n\nObservable_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior; //# sourceMappingURL=publishBehavior.js.map\n\n/***/ }),\n\n/***/ \"4WIM\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar ObjectUnsubscribedError_1 = /*@__PURE__*/__webpack_require__(\"PCq3\");\n\nvar SubjectSubscription_1 = /*@__PURE__*/__webpack_require__(\"NNAl\");\n\nvar rxSubscriber_1 = /*@__PURE__*/__webpack_require__(\"nkkL\");\n/**\n * @class SubjectSubscriber<T>\n */\n\n\nvar SubjectSubscriber = function (_super) {\n  __extends(SubjectSubscriber, _super);\n\n  function SubjectSubscriber(destination) {\n    _super.call(this, destination);\n\n    this.destination = destination;\n  }\n\n  return SubjectSubscriber;\n}(Subscriber_1.Subscriber);\n\nexports.SubjectSubscriber = SubjectSubscriber;\n/**\n * @class Subject<T>\n */\n\nvar Subject = function (_super) {\n  __extends(Subject, _super);\n\n  function Subject() {\n    _super.call(this);\n\n    this.observers = [];\n    this.closed = false;\n    this.isStopped = false;\n    this.hasError = false;\n    this.thrownError = null;\n  }\n\n  Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {\n    return new SubjectSubscriber(this);\n  };\n\n  Subject.prototype.lift = function (operator) {\n    var subject = new AnonymousSubject(this, this);\n    subject.operator = operator;\n    return subject;\n  };\n\n  Subject.prototype.next = function (value) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n    }\n\n    if (!this.isStopped) {\n      var observers = this.observers;\n      var len = observers.length;\n      var copy = observers.slice();\n\n      for (var i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  };\n\n  Subject.prototype.error = function (err) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n    }\n\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    var observers = this.observers;\n    var len = observers.length;\n    var copy = observers.slice();\n\n    for (var i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n\n    this.observers.length = 0;\n  };\n\n  Subject.prototype.complete = function () {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n    }\n\n    this.isStopped = true;\n    var observers = this.observers;\n    var len = observers.length;\n    var copy = observers.slice();\n\n    for (var i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n\n    this.observers.length = 0;\n  };\n\n  Subject.prototype.unsubscribe = function () {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  };\n\n  Subject.prototype._trySubscribe = function (subscriber) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n    } else {\n      return _super.prototype._trySubscribe.call(this, subscriber);\n    }\n  };\n  /** @deprecated internal use only */\n\n\n  Subject.prototype._subscribe = function (subscriber) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription_1.Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription_1.Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n    }\n  };\n\n  Subject.prototype.asObservable = function () {\n    var observable = new Observable_1.Observable();\n    observable.source = this;\n    return observable;\n  };\n\n  Subject.create = function (destination, source) {\n    return new AnonymousSubject(destination, source);\n  };\n\n  return Subject;\n}(Observable_1.Observable);\n\nexports.Subject = Subject;\n/**\n * @class AnonymousSubject<T>\n */\n\nvar AnonymousSubject = function (_super) {\n  __extends(AnonymousSubject, _super);\n\n  function AnonymousSubject(destination, source) {\n    _super.call(this);\n\n    this.destination = destination;\n    this.source = source;\n  }\n\n  AnonymousSubject.prototype.next = function (value) {\n    var destination = this.destination;\n\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  };\n\n  AnonymousSubject.prototype.error = function (err) {\n    var destination = this.destination;\n\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  };\n\n  AnonymousSubject.prototype.complete = function () {\n    var destination = this.destination;\n\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  };\n  /** @deprecated internal use only */\n\n\n  AnonymousSubject.prototype._subscribe = function (subscriber) {\n    var source = this.source;\n\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription_1.Subscription.EMPTY;\n    }\n  };\n\n  return AnonymousSubject;\n}(Subject);\n\nexports.AnonymousSubject = AnonymousSubject;\n\n/***/ }),\n\n/***/ \"4dTV\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar race_1 = /*@__PURE__*/__webpack_require__(\"UUzK\"); // NOTE: to support backwards compatability with 5.4.* and lower\n\n\nvar race_2 = /*@__PURE__*/__webpack_require__(\"6VCA\");\n\nexports.raceStatic = race_2.race;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\n\nfunction race() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return race_1.race.apply(void 0, observables)(this);\n}\n\nexports.race = race;\n\n/***/ }),\n\n/***/ \"4qOA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\n\n\nvar TimeoutError = function (_super) {\n  __extends(TimeoutError, _super);\n\n  function TimeoutError() {\n    var err = _super.call(this, 'Timeout has occurred');\n\n    this.name = err.name = 'TimeoutError';\n    this.stack = err.stack;\n    this.message = err.message;\n  }\n\n  return TimeoutError;\n}(Error);\n\nexports.TimeoutError = TimeoutError;\n\n/***/ }),\n\n/***/ \"5/1k\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar repeat_1 = __webpack_require__(\"Ui6c\");\n\nObservable_1.Observable.prototype.repeat = repeat_1.repeat; //# sourceMappingURL=repeat.js.map\n\n/***/ }),\n\n/***/ \"53d5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar delayWhen_1 = __webpack_require__(\"Az9W\");\n\nObservable_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen; //# sourceMappingURL=delayWhen.js.map\n\n/***/ }),\n\n/***/ \"5My3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar asap_1 = /*@__PURE__*/__webpack_require__(\"JB8t\");\n\nvar isNumeric_1 = /*@__PURE__*/__webpack_require__(\"zZI/\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar SubscribeOnObservable = function (_super) {\n  __extends(SubscribeOnObservable, _super);\n\n  function SubscribeOnObservable(source, delayTime, scheduler) {\n    if (delayTime === void 0) {\n      delayTime = 0;\n    }\n\n    if (scheduler === void 0) {\n      scheduler = asap_1.asap;\n    }\n\n    _super.call(this);\n\n    this.source = source;\n    this.delayTime = delayTime;\n    this.scheduler = scheduler;\n\n    if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {\n      this.delayTime = 0;\n    }\n\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n      this.scheduler = asap_1.asap;\n    }\n  }\n\n  SubscribeOnObservable.create = function (source, delay, scheduler) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (scheduler === void 0) {\n      scheduler = asap_1.asap;\n    }\n\n    return new SubscribeOnObservable(source, delay, scheduler);\n  };\n\n  SubscribeOnObservable.dispatch = function (arg) {\n    var source = arg.source,\n        subscriber = arg.subscriber;\n    return this.add(source.subscribe(subscriber));\n  };\n  /** @deprecated internal use only */\n\n\n  SubscribeOnObservable.prototype._subscribe = function (subscriber) {\n    var delay = this.delayTime;\n    var source = this.source;\n    var scheduler = this.scheduler;\n    return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {\n      source: source,\n      subscriber: subscriber\n    });\n  };\n\n  return SubscribeOnObservable;\n}(Observable_1.Observable);\n\nexports.SubscribeOnObservable = SubscribeOnObservable;\n\n/***/ }),\n\n/***/ \"5TWj\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar SubscriptionLog = /*@__PURE__*/function () {\n  function SubscriptionLog(subscribedFrame, unsubscribedFrame) {\n    if (unsubscribedFrame === void 0) {\n      unsubscribedFrame = Number.POSITIVE_INFINITY;\n    }\n\n    this.subscribedFrame = subscribedFrame;\n    this.unsubscribedFrame = unsubscribedFrame;\n  }\n\n  return SubscriptionLog;\n}();\n\nexports.SubscriptionLog = SubscriptionLog;\n\n/***/ }),\n\n/***/ \"5UB+\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar windowToggle_1 = /*@__PURE__*/__webpack_require__(\"8pnh\");\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\n\n\nfunction windowToggle(openings, closingSelector) {\n  return windowToggle_1.windowToggle(openings, closingSelector)(this);\n}\n\nexports.windowToggle = windowToggle;\n\n/***/ }),\n\n/***/ \"5aaB\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar reduce_1 = /*@__PURE__*/__webpack_require__(\"6fvh\");\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * <img src=\"./img/max.png\" width=\"100%\">\n *\n * @example <caption>Get the maximal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .max()\n *   .subscribe(x => console.log(x)); // -> 8\n *\n * @example <caption>Use a comparer function to get the maximal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * }\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\n\n\nfunction max(comparer) {\n  var max = typeof comparer === 'function' ? function (x, y) {\n    return comparer(x, y) > 0 ? x : y;\n  } : function (x, y) {\n    return x > y ? x : y;\n  };\n  return reduce_1.reduce(max);\n}\n\nexports.max = max;\n\n/***/ }),\n\n/***/ \"5sLA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar takeLast_1 = /*@__PURE__*/__webpack_require__(\"WO4J\");\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * <img src=\"./img/takeLast.png\" width=\"100%\">\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * @example <caption>Take the last 3 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 100);\n * var lastThree = many.takeLast(3);\n * lastThree.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\n\n\nfunction takeLast(count) {\n  return takeLast_1.takeLast(count)(this);\n}\n\nexports.takeLast = takeLast;\n\n/***/ }),\n\n/***/ \"6GWt\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar reduce_1 = /*@__PURE__*/__webpack_require__(\"6fvh\");\n/* tslint:enable:max-line-length */\n\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\n\n\nfunction reduce(accumulator, seed) {\n  // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n  if (arguments.length >= 2) {\n    return reduce_1.reduce(accumulator, seed)(this);\n  }\n\n  return reduce_1.reduce(accumulator)(this);\n}\n\nexports.reduce = reduce;\n\n/***/ }),\n\n/***/ \"6Tb1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar filter_1 = __webpack_require__(\"xQMj\");\n\nObservable_1.Observable.prototype.filter = filter_1.filter; //# sourceMappingURL=filter.js.map\n\n/***/ }),\n\n/***/ \"6VCA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar isArray_1 = /*@__PURE__*/__webpack_require__(\"G2HO\");\n\nvar ArrayObservable_1 = /*@__PURE__*/__webpack_require__(\"rVFa\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nfunction race() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  } // if the only argument is an array, it was most likely called with\n  // `race([obs1, obs2, ...])`\n\n\n  if (observables.length === 1) {\n    if (isArray_1.isArray(observables[0])) {\n      observables = observables[0];\n    } else {\n      return observables[0];\n    }\n  }\n\n  return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());\n}\n\nexports.race = race;\n\nvar RaceOperator = /*@__PURE__*/function () {\n  function RaceOperator() {}\n\n  RaceOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new RaceSubscriber(subscriber));\n  };\n\n  return RaceOperator;\n}();\n\nexports.RaceOperator = RaceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar RaceSubscriber = function (_super) {\n  __extends(RaceSubscriber, _super);\n\n  function RaceSubscriber(destination) {\n    _super.call(this, destination);\n\n    this.hasFirst = false;\n    this.observables = [];\n    this.subscriptions = [];\n  }\n\n  RaceSubscriber.prototype._next = function (observable) {\n    this.observables.push(observable);\n  };\n\n  RaceSubscriber.prototype._complete = function () {\n    var observables = this.observables;\n    var len = observables.length;\n\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      for (var i = 0; i < len && !this.hasFirst; i++) {\n        var observable = observables[i];\n        var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);\n\n        if (this.subscriptions) {\n          this.subscriptions.push(subscription);\n        }\n\n        this.add(subscription);\n      }\n\n      this.observables = null;\n    }\n  };\n\n  RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    if (!this.hasFirst) {\n      this.hasFirst = true;\n\n      for (var i = 0; i < this.subscriptions.length; i++) {\n        if (i !== outerIndex) {\n          var subscription = this.subscriptions[i];\n          subscription.unsubscribe();\n          this.remove(subscription);\n        }\n      }\n\n      this.subscriptions = null;\n    }\n\n    this.destination.next(innerValue);\n  };\n\n  return RaceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\nexports.RaceSubscriber = RaceSubscriber;\n\n/***/ }),\n\n/***/ \"6fvh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar scan_1 = /*@__PURE__*/__webpack_require__(\"n8Qg\");\n\nvar takeLast_1 = /*@__PURE__*/__webpack_require__(\"WO4J\");\n\nvar defaultIfEmpty_1 = /*@__PURE__*/__webpack_require__(\"2Tbn\");\n\nvar pipe_1 = /*@__PURE__*/__webpack_require__(\"GyLc\");\n/* tslint:enable:max-line-length */\n\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\n\n\nfunction reduce(accumulator, seed) {\n  // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n  if (arguments.length >= 2) {\n    return function reduceOperatorFunctionWithSeed(source) {\n      return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);\n    };\n  }\n\n  return function reduceOperatorFunction(source) {\n    return pipe_1.pipe(scan_1.scan(function (acc, value, index) {\n      return accumulator(acc, value, index + 1);\n    }), takeLast_1.takeLast(1))(source);\n  };\n}\n\nexports.reduce = reduce;\n\n/***/ }),\n\n/***/ \"6m09\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar groupBy_1 = __webpack_require__(\"xFrw\");\n\nObservable_1.Observable.prototype.groupBy = groupBy_1.groupBy; //# sourceMappingURL=groupBy.js.map\n\n/***/ }),\n\n/***/ \"6oB3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isScheduler_1 = /*@__PURE__*/__webpack_require__(\"NwwV\");\n\nvar of_1 = /*@__PURE__*/__webpack_require__(\"tHdp\");\n\nvar from_1 = /*@__PURE__*/__webpack_require__(\"9Kp9\");\n\nvar concatAll_1 = /*@__PURE__*/__webpack_require__(\"A0iX\");\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\n\n\nfunction concat() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  if (observables.length === 1 || observables.length === 2 && isScheduler_1.isScheduler(observables[1])) {\n    return from_1.from(observables[0]);\n  }\n\n  return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\n\nexports.concat = concat;\n\n/***/ }),\n\n/***/ \"78Oa\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar AjaxObservable_1 = /*@__PURE__*/__webpack_require__(\"oemf\");\n\nexports.ajax = AjaxObservable_1.AjaxObservable.create;\n\n/***/ }),\n\n/***/ \"7LGj\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * @example <caption>Every second, emit the most recent click at most once</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.sampleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\n\n\nfunction sampleTime(period, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return function (source) {\n    return source.lift(new SampleTimeOperator(period, scheduler));\n  };\n}\n\nexports.sampleTime = sampleTime;\n\nvar SampleTimeOperator = /*@__PURE__*/function () {\n  function SampleTimeOperator(period, scheduler) {\n    this.period = period;\n    this.scheduler = scheduler;\n  }\n\n  SampleTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n  };\n\n  return SampleTimeOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SampleTimeSubscriber = function (_super) {\n  __extends(SampleTimeSubscriber, _super);\n\n  function SampleTimeSubscriber(destination, period, scheduler) {\n    _super.call(this, destination);\n\n    this.period = period;\n    this.scheduler = scheduler;\n    this.hasValue = false;\n    this.add(scheduler.schedule(dispatchNotification, period, {\n      subscriber: this,\n      period: period\n    }));\n  }\n\n  SampleTimeSubscriber.prototype._next = function (value) {\n    this.lastValue = value;\n    this.hasValue = true;\n  };\n\n  SampleTimeSubscriber.prototype.notifyNext = function () {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.lastValue);\n    }\n  };\n\n  return SampleTimeSubscriber;\n}(Subscriber_1.Subscriber);\n\nfunction dispatchNotification(state) {\n  var subscriber = state.subscriber,\n      period = state.period;\n  subscriber.notifyNext();\n  this.schedule(state, period);\n}\n\n/***/ }),\n\n/***/ \"7Nkz\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar ArgumentOutOfRangeError_1 = /*@__PURE__*/__webpack_require__(\"8kg7\");\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\n\n\nfunction skipLast(count) {\n  return function (source) {\n    return source.lift(new SkipLastOperator(count));\n  };\n}\n\nexports.skipLast = skipLast;\n\nvar SkipLastOperator = /*@__PURE__*/function () {\n  function SkipLastOperator(_skipCount) {\n    this._skipCount = _skipCount;\n\n    if (this._skipCount < 0) {\n      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();\n    }\n  }\n\n  SkipLastOperator.prototype.call = function (subscriber, source) {\n    if (this._skipCount === 0) {\n      // If we don't want to skip any values then just subscribe\n      // to Subscriber without any further logic.\n      return source.subscribe(new Subscriber_1.Subscriber(subscriber));\n    } else {\n      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n    }\n  };\n\n  return SkipLastOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SkipLastSubscriber = function (_super) {\n  __extends(SkipLastSubscriber, _super);\n\n  function SkipLastSubscriber(destination, _skipCount) {\n    _super.call(this, destination);\n\n    this._skipCount = _skipCount;\n    this._count = 0;\n    this._ring = new Array(_skipCount);\n  }\n\n  SkipLastSubscriber.prototype._next = function (value) {\n    var skipCount = this._skipCount;\n    var count = this._count++;\n\n    if (count < skipCount) {\n      this._ring[count] = value;\n    } else {\n      var currentIndex = count % skipCount;\n      var ring = this._ring;\n      var oldValue = ring[currentIndex];\n      ring[currentIndex] = value;\n      this.destination.next(oldValue);\n    }\n  };\n\n  return SkipLastSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"7W5b\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar mergeMap_1 = /*@__PURE__*/__webpack_require__(\"lf2g\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\n\n\nfunction mergeMap(project, resultSelector, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);\n}\n\nexports.mergeMap = mergeMap;\n\n/***/ }),\n\n/***/ \"7bsd\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar map_1 = __webpack_require__(\"klBC\");\n\nObservable_1.Observable.prototype.map = map_1.map; //# sourceMappingURL=map.js.map\n\n/***/ }),\n\n/***/ \"7c4m\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\n\n\nfunction retry(count) {\n  if (count === void 0) {\n    count = -1;\n  }\n\n  return function (source) {\n    return source.lift(new RetryOperator(count, source));\n  };\n}\n\nexports.retry = retry;\n\nvar RetryOperator = /*@__PURE__*/function () {\n  function RetryOperator(count, source) {\n    this.count = count;\n    this.source = source;\n  }\n\n  RetryOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n  };\n\n  return RetryOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar RetrySubscriber = function (_super) {\n  __extends(RetrySubscriber, _super);\n\n  function RetrySubscriber(destination, count, source) {\n    _super.call(this, destination);\n\n    this.count = count;\n    this.source = source;\n  }\n\n  RetrySubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var _a = this,\n          source = _a.source,\n          count = _a.count;\n\n      if (count === 0) {\n        return _super.prototype.error.call(this, err);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  };\n\n  return RetrySubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"7f6I\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar BehaviorSubject_1 = /*@__PURE__*/__webpack_require__(\"Bx9r\");\n\nvar multicast_1 = /*@__PURE__*/__webpack_require__(\"cf1P\");\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\n\n\nfunction publishBehavior(value) {\n  return function (source) {\n    return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source);\n  };\n}\n\nexports.publishBehavior = publishBehavior;\n\n/***/ }),\n\n/***/ \"7lXC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isEmpty_1 = /*@__PURE__*/__webpack_require__(\"XNQH\");\n/**\n * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.\n *\n * <img src=\"./img/isEmpty.png\" width=\"100%\">\n *\n * @return {Observable} An Observable that emits a Boolean.\n * @method isEmpty\n * @owner Observable\n */\n\n\nfunction isEmpty() {\n  return isEmpty_1.isEmpty()(this);\n}\n\nexports.isEmpty = isEmpty;\n\n/***/ }),\n\n/***/ \"7qd/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar combineLatest_1 = __webpack_require__(\"Yjb7\");\n\nObservable_1.Observable.combineLatest = combineLatest_1.combineLatest; //# sourceMappingURL=combineLatest.js.map\n\n/***/ }),\n\n/***/ \"8FKM\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar sequenceEqual_1 = /*@__PURE__*/__webpack_require__(\"3Ind\");\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\n\n\nfunction sequenceEqual(compareTo, comparor) {\n  return sequenceEqual_1.sequenceEqual(compareTo, comparor)(this);\n}\n\nexports.sequenceEqual = sequenceEqual;\n\n/***/ }),\n\n/***/ \"8G9e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n/**\n * @class AsyncSubject<T>\n */\n\n\nvar AsyncSubject = function (_super) {\n  __extends(AsyncSubject, _super);\n\n  function AsyncSubject() {\n    _super.apply(this, arguments);\n\n    this.value = null;\n    this.hasNext = false;\n    this.hasCompleted = false;\n  }\n  /** @deprecated internal use only */\n\n\n  AsyncSubject.prototype._subscribe = function (subscriber) {\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription_1.Subscription.EMPTY;\n    } else if (this.hasCompleted && this.hasNext) {\n      subscriber.next(this.value);\n      subscriber.complete();\n      return Subscription_1.Subscription.EMPTY;\n    }\n\n    return _super.prototype._subscribe.call(this, subscriber);\n  };\n\n  AsyncSubject.prototype.next = function (value) {\n    if (!this.hasCompleted) {\n      this.value = value;\n      this.hasNext = true;\n    }\n  };\n\n  AsyncSubject.prototype.error = function (error) {\n    if (!this.hasCompleted) {\n      _super.prototype.error.call(this, error);\n    }\n  };\n\n  AsyncSubject.prototype.complete = function () {\n    this.hasCompleted = true;\n\n    if (this.hasNext) {\n      _super.prototype.next.call(this, this.value);\n    }\n\n    _super.prototype.complete.call(this);\n  };\n\n  return AsyncSubject;\n}(Subject_1.Subject);\n\nexports.AsyncSubject = AsyncSubject;\n\n/***/ }),\n\n/***/ \"8JYq\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\n\n\nvar Action = function (_super) {\n  __extends(Action, _super);\n\n  function Action(scheduler, work) {\n    _super.call(this);\n  }\n  /**\n   * Schedules this action on its parent Scheduler for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n\n\n  Action.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return this;\n  };\n\n  return Action;\n}(Subscription_1.Subscription);\n\nexports.Action = Action;\n\n/***/ }),\n\n/***/ \"8SF3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar first_1 = __webpack_require__(\"+t3k\");\n\nObservable_1.Observable.prototype.first = first_1.first; //# sourceMappingURL=first.js.map\n\n/***/ }),\n\n/***/ \"8kg7\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\n\n\nvar ArgumentOutOfRangeError = function (_super) {\n  __extends(ArgumentOutOfRangeError, _super);\n\n  function ArgumentOutOfRangeError() {\n    var err = _super.call(this, 'argument out of range');\n\n    this.name = err.name = 'ArgumentOutOfRangeError';\n    this.stack = err.stack;\n    this.message = err.message;\n  }\n\n  return ArgumentOutOfRangeError;\n}(Error);\n\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\n\n/***/ }),\n\n/***/ \"8pZU\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar materialize_1 = /*@__PURE__*/__webpack_require__(\"oGc9\");\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1, hasValue: false}\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\n\n\nfunction materialize() {\n  return materialize_1.materialize()(this);\n}\n\nexports.materialize = materialize;\n\n/***/ }),\n\n/***/ \"8pnh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\n\n\nfunction windowToggle(openings, closingSelector) {\n  return function (source) {\n    return source.lift(new WindowToggleOperator(openings, closingSelector));\n  };\n}\n\nexports.windowToggle = windowToggle;\n\nvar WindowToggleOperator = /*@__PURE__*/function () {\n  function WindowToggleOperator(openings, closingSelector) {\n    this.openings = openings;\n    this.closingSelector = closingSelector;\n  }\n\n  WindowToggleOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n  };\n\n  return WindowToggleOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar WindowToggleSubscriber = function (_super) {\n  __extends(WindowToggleSubscriber, _super);\n\n  function WindowToggleSubscriber(destination, openings, closingSelector) {\n    _super.call(this, destination);\n\n    this.openings = openings;\n    this.closingSelector = closingSelector;\n    this.contexts = [];\n    this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));\n  }\n\n  WindowToggleSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n\n    if (contexts) {\n      var len = contexts.length;\n\n      for (var i = 0; i < len; i++) {\n        contexts[i].window.next(value);\n      }\n    }\n  };\n\n  WindowToggleSubscriber.prototype._error = function (err) {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context = contexts[index];\n        context.window.error(err);\n        context.subscription.unsubscribe();\n      }\n    }\n\n    _super.prototype._error.call(this, err);\n  };\n\n  WindowToggleSubscriber.prototype._complete = function () {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context = contexts[index];\n        context.window.complete();\n        context.subscription.unsubscribe();\n      }\n    }\n\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n\n\n  WindowToggleSubscriber.prototype._unsubscribe = function () {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context = contexts[index];\n        context.window.unsubscribe();\n        context.subscription.unsubscribe();\n      }\n    }\n  };\n\n  WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    if (outerValue === this.openings) {\n      var closingSelector = this.closingSelector;\n      var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n\n      if (closingNotifier === errorObject_1.errorObject) {\n        return this.error(errorObject_1.errorObject.e);\n      } else {\n        var window_1 = new Subject_1.Subject();\n        var subscription = new Subscription_1.Subscription();\n        var context = {\n          window: window_1,\n          subscription: subscription\n        };\n        this.contexts.push(context);\n        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n\n        if (innerSubscription.closed) {\n          this.closeWindow(this.contexts.length - 1);\n        } else {\n          innerSubscription.context = context;\n          subscription.add(innerSubscription);\n        }\n\n        this.destination.next(window_1);\n      }\n    } else {\n      this.closeWindow(this.contexts.indexOf(outerValue));\n    }\n  };\n\n  WindowToggleSubscriber.prototype.notifyError = function (err) {\n    this.error(err);\n  };\n\n  WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n    if (inner !== this.openSubscription) {\n      this.closeWindow(this.contexts.indexOf(inner.context));\n    }\n  };\n\n  WindowToggleSubscriber.prototype.closeWindow = function (index) {\n    if (index === -1) {\n      return;\n    }\n\n    var contexts = this.contexts;\n    var context = contexts[index];\n    var window = context.window,\n        subscription = context.subscription;\n    contexts.splice(index, 1);\n    window.complete();\n    subscription.unsubscribe();\n  };\n\n  return WindowToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"8qff\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar AsyncAction_1 = /*@__PURE__*/__webpack_require__(\"g2Fv\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar QueueAction = function (_super) {\n  __extends(QueueAction, _super);\n\n  function QueueAction(scheduler, work) {\n    _super.call(this, scheduler, work);\n\n    this.scheduler = scheduler;\n    this.work = work;\n  }\n\n  QueueAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay > 0) {\n      return _super.prototype.schedule.call(this, state, delay);\n    }\n\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  };\n\n  QueueAction.prototype.execute = function (state, delay) {\n    return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);\n  };\n\n  QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    } // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n\n    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {\n      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n    } // Otherwise flush the scheduler starting with this action.\n\n\n    return scheduler.flush(this);\n  };\n\n  return QueueAction;\n}(AsyncAction_1.AsyncAction);\n\nexports.QueueAction = QueueAction;\n\n/***/ }),\n\n/***/ \"8rll\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar scan_1 = /*@__PURE__*/__webpack_require__(\"n8Qg\");\n/* tslint:enable:max-line-length */\n\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\n\n\nfunction scan(accumulator, seed) {\n  if (arguments.length >= 2) {\n    return scan_1.scan(accumulator, seed)(this);\n  }\n\n  return scan_1.scan(accumulator)(this);\n}\n\nexports.scan = scan;\n\n/***/ }),\n\n/***/ \"8t1O\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar SubscriptionLog_1 = /*@__PURE__*/__webpack_require__(\"5TWj\");\n\nvar SubscriptionLoggable = /*@__PURE__*/function () {\n  function SubscriptionLoggable() {\n    this.subscriptions = [];\n  }\n\n  SubscriptionLoggable.prototype.logSubscribedFrame = function () {\n    this.subscriptions.push(new SubscriptionLog_1.SubscriptionLog(this.scheduler.now()));\n    return this.subscriptions.length - 1;\n  };\n\n  SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {\n    var subscriptionLogs = this.subscriptions;\n    var oldSubscriptionLog = subscriptionLogs[index];\n    subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());\n  };\n\n  return SubscriptionLoggable;\n}();\n\nexports.SubscriptionLoggable = SubscriptionLoggable;\n\n/***/ }),\n\n/***/ \"8tnl\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar IfObservable_1 = /*@__PURE__*/__webpack_require__(\"zx+L\");\n\nexports._if = IfObservable_1.IfObservable.create;\n\n/***/ }),\n\n/***/ \"8x9D\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar ScalarObservable = function (_super) {\n  __extends(ScalarObservable, _super);\n\n  function ScalarObservable(value, scheduler) {\n    _super.call(this);\n\n    this.value = value;\n    this.scheduler = scheduler;\n    this._isScalar = true;\n\n    if (scheduler) {\n      this._isScalar = false;\n    }\n  }\n\n  ScalarObservable.create = function (value, scheduler) {\n    return new ScalarObservable(value, scheduler);\n  };\n\n  ScalarObservable.dispatch = function (state) {\n    var done = state.done,\n        value = state.value,\n        subscriber = state.subscriber;\n\n    if (done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(value);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.done = true;\n    this.schedule(state);\n  };\n  /** @deprecated internal use only */\n\n\n  ScalarObservable.prototype._subscribe = function (subscriber) {\n    var value = this.value;\n    var scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ScalarObservable.dispatch, 0, {\n        done: false,\n        value: value,\n        subscriber: subscriber\n      });\n    } else {\n      subscriber.next(value);\n\n      if (!subscriber.closed) {\n        subscriber.complete();\n      }\n    }\n  };\n\n  return ScalarObservable;\n}(Observable_1.Observable);\n\nexports.ScalarObservable = ScalarObservable;\n\n/***/ }),\n\n/***/ \"8ywx\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar pluck_1 = /*@__PURE__*/__webpack_require__(\"czP3\");\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\n\n\nfunction pluck() {\n  var properties = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    properties[_i - 0] = arguments[_i];\n  }\n\n  return pluck_1.pluck.apply(void 0, properties)(this);\n}\n\nexports.pluck = pluck;\n\n/***/ }),\n\n/***/ \"90cS\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar onErrorResumeNext_1 = __webpack_require__(\"At83\");\n\nObservable_1.Observable.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext; //# sourceMappingURL=onErrorResumeNext.js.map\n\n/***/ }),\n\n/***/ \"98qG\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar take_1 = __webpack_require__(\"GXS5\");\n\nObservable_1.Observable.prototype.take = take_1.take; //# sourceMappingURL=take.js.map\n\n/***/ }),\n\n/***/ \"9A9s\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar NeverObservable_1 = /*@__PURE__*/__webpack_require__(\"T3HJ\");\n\nexports.never = NeverObservable_1.NeverObservable.create;\n\n/***/ }),\n\n/***/ \"9BwH\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar isDate_1 = /*@__PURE__*/__webpack_require__(\"hut+\");\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar TimeoutError_1 = /*@__PURE__*/__webpack_require__(\"4qOA\");\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\n\n\nfunction timeout(due, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  var absoluteTimeout = isDate_1.isDate(due);\n  var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);\n  return function (source) {\n    return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError()));\n  };\n}\n\nexports.timeout = timeout;\n\nvar TimeoutOperator = /*@__PURE__*/function () {\n  function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n    this.waitFor = waitFor;\n    this.absoluteTimeout = absoluteTimeout;\n    this.scheduler = scheduler;\n    this.errorInstance = errorInstance;\n  }\n\n  TimeoutOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n  };\n\n  return TimeoutOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar TimeoutSubscriber = function (_super) {\n  __extends(TimeoutSubscriber, _super);\n\n  function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n    _super.call(this, destination);\n\n    this.absoluteTimeout = absoluteTimeout;\n    this.waitFor = waitFor;\n    this.scheduler = scheduler;\n    this.errorInstance = errorInstance;\n    this.action = null;\n    this.scheduleTimeout();\n  }\n\n  TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n    subscriber.error(subscriber.errorInstance);\n  };\n\n  TimeoutSubscriber.prototype.scheduleTimeout = function () {\n    var action = this.action;\n\n    if (action) {\n      // Recycle the action if we've already scheduled one. All the production\n      // Scheduler Actions mutate their state/delay time and return themeselves.\n      // VirtualActions are immutable, so they create and return a clone. In this\n      // case, we need to set the action reference to the most recent VirtualAction,\n      // to ensure that's the one we clone from next time.\n      this.action = action.schedule(this, this.waitFor);\n    } else {\n      this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n    }\n  };\n\n  TimeoutSubscriber.prototype._next = function (value) {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n\n    _super.prototype._next.call(this, value);\n  };\n  /** @deprecated internal use only */\n\n\n  TimeoutSubscriber.prototype._unsubscribe = function () {\n    this.action = null;\n    this.scheduler = null;\n    this.errorInstance = null;\n  };\n\n  return TimeoutSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"9Kp9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FromObservable_1 = /*@__PURE__*/__webpack_require__(\"+fDQ\");\n\nexports.from = FromObservable_1.FromObservable.create;\n\n/***/ }),\n\n/***/ \"9Zpy\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar sample_1 = /*@__PURE__*/__webpack_require__(\"WQoq\");\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\n\n\nfunction sample(notifier) {\n  return sample_1.sample(notifier)(this);\n}\n\nexports.sample = sample;\n\n/***/ }),\n\n/***/ \"9hG4\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar concat_1 = /*@__PURE__*/__webpack_require__(\"WC+f\");\n\nvar concat_2 = /*@__PURE__*/__webpack_require__(\"6oB3\");\n\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\n\nfunction concat() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return concat_1.concat.apply(void 0, observables)(this);\n}\n\nexports.concat = concat;\n\n/***/ }),\n\n/***/ \"9jZZ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar OuterSubscriber = function (_super) {\n  __extends(OuterSubscriber, _super);\n\n  function OuterSubscriber() {\n    _super.apply(this, arguments);\n  }\n\n  OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.destination.next(innerValue);\n  };\n\n  OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n    this.destination.error(error);\n  };\n\n  OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.destination.complete();\n  };\n\n  return OuterSubscriber;\n}(Subscriber_1.Subscriber);\n\nexports.OuterSubscriber = OuterSubscriber;\n\n/***/ }),\n\n/***/ \"9pdx\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar dematerialize_1 = /*@__PURE__*/__webpack_require__(\"mO1z\");\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\n\n\nfunction dematerialize() {\n  return dematerialize_1.dematerialize()(this);\n}\n\nexports.dematerialize = dematerialize;\n\n/***/ }),\n\n/***/ \"9x29\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\n\n\nvar Notification = /*@__PURE__*/function () {\n  function Notification(kind, value, error) {\n    this.kind = kind;\n    this.value = value;\n    this.error = error;\n    this.hasValue = kind === 'N';\n  }\n  /**\n   * Delivers to the given `observer` the value wrapped by this Notification.\n   * @param {Observer} observer\n   * @return\n   */\n\n\n  Notification.prototype.observe = function (observer) {\n    switch (this.kind) {\n      case 'N':\n        return observer.next && observer.next(this.value);\n\n      case 'E':\n        return observer.error && observer.error(this.error);\n\n      case 'C':\n        return observer.complete && observer.complete();\n    }\n  };\n  /**\n   * Given some {@link Observer} callbacks, deliver the value represented by the\n   * current Notification to the correctly corresponding callback.\n   * @param {function(value: T): void} next An Observer `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n\n\n  Notification.prototype.do = function (next, error, complete) {\n    var kind = this.kind;\n\n    switch (kind) {\n      case 'N':\n        return next && next(this.value);\n\n      case 'E':\n        return error && error(this.error);\n\n      case 'C':\n        return complete && complete();\n    }\n  };\n  /**\n   * Takes an Observer or its individual callback functions, and calls `observe`\n   * or `do` methods accordingly.\n   * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n   * the `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n\n\n  Notification.prototype.accept = function (nextOrObserver, error, complete) {\n    if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n      return this.observe(nextOrObserver);\n    } else {\n      return this.do(nextOrObserver, error, complete);\n    }\n  };\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   * @return {any}\n   */\n\n\n  Notification.prototype.toObservable = function () {\n    var kind = this.kind;\n\n    switch (kind) {\n      case 'N':\n        return Observable_1.Observable.of(this.value);\n\n      case 'E':\n        return Observable_1.Observable.throw(this.error);\n\n      case 'C':\n        return Observable_1.Observable.empty();\n    }\n\n    throw new Error('unexpected notification kind value');\n  };\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   */\n\n\n  Notification.createNext = function (value) {\n    if (typeof value !== 'undefined') {\n      return new Notification('N', value);\n    }\n\n    return Notification.undefinedValueNotification;\n  };\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   */\n\n\n  Notification.createError = function (err) {\n    return new Notification('E', undefined, err);\n  };\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   */\n\n\n  Notification.createComplete = function () {\n    return Notification.completeNotification;\n  };\n\n  Notification.completeNotification = new Notification('C');\n  Notification.undefinedValueNotification = new Notification('N', undefined);\n  return Notification;\n}();\n\nexports.Notification = Notification;\n\n/***/ }),\n\n/***/ \"A/ap\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // adapted from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n\nvar detectPassiveEvents = {\n  update: function update() {\n    if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {\n      var passive = false;\n      var options = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          passive = true;\n        }\n      }); // note: have to set and remove a no-op listener instead of null\n      // (which was used previously), becasue Edge v15 throws an error\n      // when providing a null callback.\n      // https://github.com/rafgraph/detect-passive-events/pull/3\n\n      var noop = function noop() {};\n\n      window.addEventListener('testPassiveEventSupport', noop, options);\n      window.removeEventListener('testPassiveEventSupport', noop, options);\n      detectPassiveEvents.hasSupport = passive;\n    }\n  }\n};\ndetectPassiveEvents.update();\nexports.default = detectPassiveEvents;\n\n/***/ }),\n\n/***/ \"A0iX\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar mergeAll_1 = /*@__PURE__*/__webpack_require__(\"0p2S\");\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\n\n\nfunction concatAll() {\n  return mergeAll_1.mergeAll(1);\n}\n\nexports.concatAll = concatAll;\n\n/***/ }),\n\n/***/ \"A17Z\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar combineAll_1 = __webpack_require__(\"/3m9\");\n\nObservable_1.Observable.prototype.combineAll = combineAll_1.combineAll; //# sourceMappingURL=combineAll.js.map\n\n/***/ }),\n\n/***/ \"A1NZ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar expand_1 = __webpack_require__(\"DIMi\");\n\nObservable_1.Observable.prototype.expand = expand_1.expand; //# sourceMappingURL=expand.js.map\n\n/***/ }),\n\n/***/ \"ABAE\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * <img src=\"./img/pairwise.png\" width=\"100%\">\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var pairs = clicks.pairwise();\n * var distance = pairs.map(pair => {\n *   var x0 = pair[0].clientX;\n *   var y0 = pair[0].clientY;\n *   var x1 = pair[1].clientX;\n *   var y1 = pair[1].clientY;\n *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n * });\n * distance.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\n\n\nfunction pairwise() {\n  return function (source) {\n    return source.lift(new PairwiseOperator());\n  };\n}\n\nexports.pairwise = pairwise;\n\nvar PairwiseOperator = /*@__PURE__*/function () {\n  function PairwiseOperator() {}\n\n  PairwiseOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new PairwiseSubscriber(subscriber));\n  };\n\n  return PairwiseOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar PairwiseSubscriber = function (_super) {\n  __extends(PairwiseSubscriber, _super);\n\n  function PairwiseSubscriber(destination) {\n    _super.call(this, destination);\n\n    this.hasPrev = false;\n  }\n\n  PairwiseSubscriber.prototype._next = function (value) {\n    if (this.hasPrev) {\n      this.destination.next([this.prev, value]);\n    } else {\n      this.hasPrev = true;\n    }\n\n    this.prev = value;\n  };\n\n  return PairwiseSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"AF4n\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar distinctUntilKeyChanged_1 = __webpack_require__(\"l6Ej\");\n\nObservable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged; //# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n/***/ }),\n\n/***/ \"AI1+\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar WebSocketSubject_1 = /*@__PURE__*/__webpack_require__(\"m8PH\");\n\nexports.webSocket = WebSocketSubject_1.WebSocketSubject.create;\n\n/***/ }),\n\n/***/ \"AJP0\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n // typeof any so that it we don't have to cast when comparing a result to the error object\n\nexports.errorObject = {\n  e: {}\n};\n\n/***/ }),\n\n/***/ \"AZf1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nvar toSubscriber_1 = /*@__PURE__*/__webpack_require__(\"wR93\");\n\nvar observable_1 = /*@__PURE__*/__webpack_require__(\"WU5C\");\n\nvar pipe_1 = /*@__PURE__*/__webpack_require__(\"GyLc\");\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\n\n\nvar Observable = /*@__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  function Observable(subscribe) {\n    this._isScalar = false;\n\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n\n\n  Observable.prototype.lift = function (operator) {\n    var observable = new Observable();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  };\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n   * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n   * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n   * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n   *\n   * @example <caption>Subscribe with an Observer</caption>\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Subscribe with functions</caption>\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Cancel a subscription</caption>\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   *\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n\n\n  Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n    var operator = this.operator;\n    var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (sink.syncErrorThrowable) {\n      sink.syncErrorThrowable = false;\n\n      if (sink.syncErrorThrown) {\n        throw sink.syncErrorValue;\n      }\n    }\n\n    return sink;\n  };\n\n  Observable.prototype._trySubscribe = function (sink) {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      sink.syncErrorThrown = true;\n      sink.syncErrorValue = err;\n      sink.error(err);\n    }\n  };\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n\n\n  Observable.prototype.forEach = function (next, PromiseCtor) {\n    var _this = this;\n\n    if (!PromiseCtor) {\n      if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n        PromiseCtor = root_1.root.Rx.config.Promise;\n      } else if (root_1.root.Promise) {\n        PromiseCtor = root_1.root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor(function (resolve, reject) {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      var subscription;\n      subscription = _this.subscribe(function (value) {\n        if (subscription) {\n          // if there is a subscription, then we can surmise\n          // the next handling is asynchronous. Any errors thrown\n          // need to be rejected explicitly and unsubscribe must be\n          // called manually\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscription.unsubscribe();\n          }\n        } else {\n          // if there is NO subscription, then we're getting a nexted\n          // value synchronously during subscription. We can just call it.\n          // If it errors, Observable's `subscribe` will ensure the\n          // unsubscription logic is called, then synchronously rethrow the error.\n          // After that, Promise will trap the error and send it\n          // down the rejection path.\n          next(value);\n        }\n      }, reject, resolve);\n    });\n  };\n  /** @deprecated internal use only */\n\n\n  Observable.prototype._subscribe = function (subscriber) {\n    return this.source.subscribe(subscriber);\n  };\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n\n\n  Observable.prototype[observable_1.observable] = function () {\n    return this;\n  };\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * @example\n   *\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   */\n\n\n  Observable.prototype.pipe = function () {\n    var operations = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      operations[_i - 0] = arguments[_i];\n    }\n\n    if (operations.length === 0) {\n      return this;\n    }\n\n    return pipe_1.pipeFromArray(operations)(this);\n  };\n  /* tslint:enable:max-line-length */\n\n\n  Observable.prototype.toPromise = function (PromiseCtor) {\n    var _this = this;\n\n    if (!PromiseCtor) {\n      if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n        PromiseCtor = root_1.root.Rx.config.Promise;\n      } else if (root_1.root.Promise) {\n        PromiseCtor = root_1.root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor(function (resolve, reject) {\n      var value;\n\n      _this.subscribe(function (x) {\n        return value = x;\n      }, function (err) {\n        return reject(err);\n      }, function () {\n        return resolve(value);\n      });\n    });\n  }; // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   */\n\n\n  Observable.create = function (subscribe) {\n    return new Observable(subscribe);\n  };\n\n  return Observable;\n}();\n\nexports.Observable = Observable;\n\n/***/ }),\n\n/***/ \"Al8V\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar pairwise_1 = /*@__PURE__*/__webpack_require__(\"ABAE\");\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * <img src=\"./img/pairwise.png\" width=\"100%\">\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var pairs = clicks.pairwise();\n * var distance = pairs.map(pair => {\n *   var x0 = pair[0].clientX;\n *   var y0 = pair[0].clientY;\n *   var x1 = pair[1].clientX;\n *   var y1 = pair[1].clientY;\n *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n * });\n * distance.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\n\n\nfunction pairwise() {\n  return pairwise_1.pairwise()(this);\n}\n\nexports.pairwise = pairwise;\n\n/***/ }),\n\n/***/ \"At83\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar onErrorResumeNext_1 = /*@__PURE__*/__webpack_require__(\"Rm1J\");\n\nexports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNextStatic;\n\n/***/ }),\n\n/***/ \"Az9W\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar delayWhen_1 = /*@__PURE__*/__webpack_require__(\"4GoQ\");\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delayWhen(event =>\n *   Rx.Observable.interval(Math.random() * 5000)\n * );\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\n\n\nfunction delayWhen(delayDurationSelector, subscriptionDelay) {\n  return delayWhen_1.delayWhen(delayDurationSelector, subscriptionDelay)(this);\n}\n\nexports.delayWhen = delayWhen;\n\n/***/ }),\n\n/***/ \"AzqM\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\n\n\nfunction debounceTime(dueTime, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return function (source) {\n    return source.lift(new DebounceTimeOperator(dueTime, scheduler));\n  };\n}\n\nexports.debounceTime = debounceTime;\n\nvar DebounceTimeOperator = /*@__PURE__*/function () {\n  function DebounceTimeOperator(dueTime, scheduler) {\n    this.dueTime = dueTime;\n    this.scheduler = scheduler;\n  }\n\n  DebounceTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n  };\n\n  return DebounceTimeOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar DebounceTimeSubscriber = function (_super) {\n  __extends(DebounceTimeSubscriber, _super);\n\n  function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n    _super.call(this, destination);\n\n    this.dueTime = dueTime;\n    this.scheduler = scheduler;\n    this.debouncedSubscription = null;\n    this.lastValue = null;\n    this.hasValue = false;\n  }\n\n  DebounceTimeSubscriber.prototype._next = function (value) {\n    this.clearDebounce();\n    this.lastValue = value;\n    this.hasValue = true;\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n  };\n\n  DebounceTimeSubscriber.prototype._complete = function () {\n    this.debouncedNext();\n    this.destination.complete();\n  };\n\n  DebounceTimeSubscriber.prototype.debouncedNext = function () {\n    this.clearDebounce();\n\n    if (this.hasValue) {\n      this.destination.next(this.lastValue);\n      this.lastValue = null;\n      this.hasValue = false;\n    }\n  };\n\n  DebounceTimeSubscriber.prototype.clearDebounce = function () {\n    var debouncedSubscription = this.debouncedSubscription;\n\n    if (debouncedSubscription !== null) {\n      this.remove(debouncedSubscription);\n      debouncedSubscription.unsubscribe();\n      this.debouncedSubscription = null;\n    }\n  };\n\n  return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber);\n\nfunction dispatchNext(subscriber) {\n  subscriber.debouncedNext();\n}\n\n/***/ }),\n\n/***/ \"BPHu\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar interval_1 = __webpack_require__(\"qQIA\");\n\nObservable_1.Observable.interval = interval_1.interval; //# sourceMappingURL=interval.js.map\n\n/***/ }),\n\n/***/ \"BQYW\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar publish_1 = __webpack_require__(\"IAWd\");\n\nObservable_1.Observable.prototype.publish = publish_1.publish; //# sourceMappingURL=publish.js.map\n\n/***/ }),\n\n/***/ \"BTim\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nfunction timeInterval(scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return function (source) {\n    return source.lift(new TimeIntervalOperator(scheduler));\n  };\n}\n\nexports.timeInterval = timeInterval;\n\nvar TimeInterval = /*@__PURE__*/function () {\n  function TimeInterval(value, interval) {\n    this.value = value;\n    this.interval = interval;\n  }\n\n  return TimeInterval;\n}();\n\nexports.TimeInterval = TimeInterval;\n;\n\nvar TimeIntervalOperator = /*@__PURE__*/function () {\n  function TimeIntervalOperator(scheduler) {\n    this.scheduler = scheduler;\n  }\n\n  TimeIntervalOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n  };\n\n  return TimeIntervalOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar TimeIntervalSubscriber = function (_super) {\n  __extends(TimeIntervalSubscriber, _super);\n\n  function TimeIntervalSubscriber(destination, scheduler) {\n    _super.call(this, destination);\n\n    this.scheduler = scheduler;\n    this.lastTime = 0;\n    this.lastTime = scheduler.now();\n  }\n\n  TimeIntervalSubscriber.prototype._next = function (value) {\n    var now = this.scheduler.now();\n    var span = now - this.lastTime;\n    this.lastTime = now;\n    this.destination.next(new TimeInterval(value, span));\n  };\n\n  return TimeIntervalSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"BWyk\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar delay_1 = /*@__PURE__*/__webpack_require__(\"QCIY\");\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\n\n\nfunction delay(delay, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return delay_1.delay(delay, scheduler)(this);\n}\n\nexports.delay = delay;\n\n/***/ }),\n\n/***/ \"BbYg\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar defer_1 = __webpack_require__(\"3Tlz\");\n\nObservable_1.Observable.defer = defer_1.defer; //# sourceMappingURL=defer.js.map\n\n/***/ }),\n\n/***/ \"Bgoh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar takeWhile_1 = __webpack_require__(\"3W7U\");\n\nObservable_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile; //# sourceMappingURL=takeWhile.js.map\n\n/***/ }),\n\n/***/ \"BjeI\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar queue_1 = /*@__PURE__*/__webpack_require__(\"VZMG\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar observeOn_1 = /*@__PURE__*/__webpack_require__(\"0zyO\");\n\nvar ObjectUnsubscribedError_1 = /*@__PURE__*/__webpack_require__(\"PCq3\");\n\nvar SubjectSubscription_1 = /*@__PURE__*/__webpack_require__(\"NNAl\");\n/**\n * @class ReplaySubject<T>\n */\n\n\nvar ReplaySubject = function (_super) {\n  __extends(ReplaySubject, _super);\n\n  function ReplaySubject(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) {\n      bufferSize = Number.POSITIVE_INFINITY;\n    }\n\n    if (windowTime === void 0) {\n      windowTime = Number.POSITIVE_INFINITY;\n    }\n\n    _super.call(this);\n\n    this.scheduler = scheduler;\n    this._events = [];\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n  }\n\n  ReplaySubject.prototype.next = function (value) {\n    var now = this._getNow();\n\n    this._events.push(new ReplayEvent(now, value));\n\n    this._trimBufferThenGetEvents();\n\n    _super.prototype.next.call(this, value);\n  };\n  /** @deprecated internal use only */\n\n\n  ReplaySubject.prototype._subscribe = function (subscriber) {\n    var _events = this._trimBufferThenGetEvents();\n\n    var scheduler = this.scheduler;\n    var subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscription = Subscription_1.Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscription = Subscription_1.Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n    }\n\n    var len = _events.length;\n\n    for (var i = 0; i < len && !subscriber.closed; i++) {\n      subscriber.next(_events[i].value);\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  };\n\n  ReplaySubject.prototype._getNow = function () {\n    return (this.scheduler || queue_1.queue).now();\n  };\n\n  ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n    var now = this._getNow();\n\n    var _bufferSize = this._bufferSize;\n    var _windowTime = this._windowTime;\n    var _events = this._events;\n    var eventsCount = _events.length;\n    var spliceCount = 0; // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n\n    while (spliceCount < eventsCount) {\n      if (now - _events[spliceCount].time < _windowTime) {\n        break;\n      }\n\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  };\n\n  return ReplaySubject;\n}(Subject_1.Subject);\n\nexports.ReplaySubject = ReplaySubject;\n\nvar ReplayEvent = /*@__PURE__*/function () {\n  function ReplayEvent(time, value) {\n    this.time = time;\n    this.value = value;\n  }\n\n  return ReplayEvent;\n}();\n\n/***/ }),\n\n/***/ \"BnoD\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar throttle_1 = /*@__PURE__*/__webpack_require__(\"o6MN\");\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\n\n\nfunction throttleTime(duration, scheduler, config) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  if (config === void 0) {\n    config = throttle_1.defaultThrottleConfig;\n  }\n\n  return function (source) {\n    return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n  };\n}\n\nexports.throttleTime = throttleTime;\n\nvar ThrottleTimeOperator = /*@__PURE__*/function () {\n  function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n    this.duration = duration;\n    this.scheduler = scheduler;\n    this.leading = leading;\n    this.trailing = trailing;\n  }\n\n  ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n  };\n\n  return ThrottleTimeOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar ThrottleTimeSubscriber = function (_super) {\n  __extends(ThrottleTimeSubscriber, _super);\n\n  function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n    _super.call(this, destination);\n\n    this.duration = duration;\n    this.scheduler = scheduler;\n    this.leading = leading;\n    this.trailing = trailing;\n    this._hasTrailingValue = false;\n    this._trailingValue = null;\n  }\n\n  ThrottleTimeSubscriber.prototype._next = function (value) {\n    if (this.throttled) {\n      if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    } else {\n      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, {\n        subscriber: this\n      }));\n\n      if (this.leading) {\n        this.destination.next(value);\n      }\n    }\n  };\n\n  ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n    var throttled = this.throttled;\n\n    if (throttled) {\n      if (this.trailing && this._hasTrailingValue) {\n        this.destination.next(this._trailingValue);\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n      }\n\n      throttled.unsubscribe();\n      this.remove(throttled);\n      this.throttled = null;\n    }\n  };\n\n  return ThrottleTimeSubscriber;\n}(Subscriber_1.Subscriber);\n\nfunction dispatchNext(arg) {\n  var subscriber = arg.subscriber;\n  subscriber.clearThrottle();\n}\n\n/***/ }),\n\n/***/ \"BoXX\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar AnimationFrameAction_1 = /*@__PURE__*/__webpack_require__(\"WesY\");\n\nvar AnimationFrameScheduler_1 = /*@__PURE__*/__webpack_require__(\"loW1\");\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * @example <caption>Schedule div height animation</caption>\n * const div = document.querySelector('.some-div');\n *\n * Rx.Scheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see .some-div element growing in height\n *\n *\n * @static true\n * @name animationFrame\n * @owner Scheduler\n */\n\n\nexports.animationFrame = /*@__PURE__*/new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);\n\n/***/ }),\n\n/***/ \"Bx9r\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar ObjectUnsubscribedError_1 = /*@__PURE__*/__webpack_require__(\"PCq3\");\n/**\n * @class BehaviorSubject<T>\n */\n\n\nvar BehaviorSubject = function (_super) {\n  __extends(BehaviorSubject, _super);\n\n  function BehaviorSubject(_value) {\n    _super.call(this);\n\n    this._value = _value;\n  }\n\n  Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n    get: function get() {\n      return this.getValue();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @deprecated internal use only */\n\n  BehaviorSubject.prototype._subscribe = function (subscriber) {\n    var subscription = _super.prototype._subscribe.call(this, subscriber);\n\n    if (subscription && !subscription.closed) {\n      subscriber.next(this._value);\n    }\n\n    return subscription;\n  };\n\n  BehaviorSubject.prototype.getValue = function () {\n    if (this.hasError) {\n      throw this.thrownError;\n    } else if (this.closed) {\n      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n    } else {\n      return this._value;\n    }\n  };\n\n  BehaviorSubject.prototype.next = function (value) {\n    _super.prototype.next.call(this, this._value = value);\n  };\n\n  return BehaviorSubject;\n}(Subject_1.Subject);\n\nexports.BehaviorSubject = BehaviorSubject;\n\n/***/ }),\n\n/***/ \"C8RJ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\n\n\nfunction retryWhen(notifier) {\n  return function (source) {\n    return source.lift(new RetryWhenOperator(notifier, source));\n  };\n}\n\nexports.retryWhen = retryWhen;\n\nvar RetryWhenOperator = /*@__PURE__*/function () {\n  function RetryWhenOperator(notifier, source) {\n    this.notifier = notifier;\n    this.source = source;\n  }\n\n  RetryWhenOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n  };\n\n  return RetryWhenOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar RetryWhenSubscriber = function (_super) {\n  __extends(RetryWhenSubscriber, _super);\n\n  function RetryWhenSubscriber(destination, notifier, source) {\n    _super.call(this, destination);\n\n    this.notifier = notifier;\n    this.source = source;\n  }\n\n  RetryWhenSubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var errors = this.errors;\n      var retries = this.retries;\n      var retriesSubscription = this.retriesSubscription;\n\n      if (!retries) {\n        errors = new Subject_1.Subject();\n        retries = tryCatch_1.tryCatch(this.notifier)(errors);\n\n        if (retries === errorObject_1.errorObject) {\n          return _super.prototype.error.call(this, errorObject_1.errorObject.e);\n        }\n\n        retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n      } else {\n        this.errors = null;\n        this.retriesSubscription = null;\n      }\n\n      this._unsubscribeAndRecycle();\n\n      this.errors = errors;\n      this.retries = retries;\n      this.retriesSubscription = retriesSubscription;\n      errors.next(err);\n    }\n  };\n  /** @deprecated internal use only */\n\n\n  RetryWhenSubscriber.prototype._unsubscribe = function () {\n    var _a = this,\n        errors = _a.errors,\n        retriesSubscription = _a.retriesSubscription;\n\n    if (errors) {\n      errors.unsubscribe();\n      this.errors = null;\n    }\n\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = null;\n    }\n\n    this.retries = null;\n  };\n\n  RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var _a = this,\n        errors = _a.errors,\n        retries = _a.retries,\n        retriesSubscription = _a.retriesSubscription;\n\n    this.errors = null;\n    this.retries = null;\n    this.retriesSubscription = null;\n\n    this._unsubscribeAndRecycle();\n\n    this.errors = errors;\n    this.retries = retries;\n    this.retriesSubscription = retriesSubscription;\n    this.source.subscribe(this);\n  };\n\n  return RetryWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"CxhQ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\n\n\nfunction catchError(selector) {\n  return function catchErrorOperatorFunction(source) {\n    var operator = new CatchOperator(selector);\n    var caught = source.lift(operator);\n    return operator.caught = caught;\n  };\n}\n\nexports.catchError = catchError;\n\nvar CatchOperator = /*@__PURE__*/function () {\n  function CatchOperator(selector) {\n    this.selector = selector;\n  }\n\n  CatchOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n  };\n\n  return CatchOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar CatchSubscriber = function (_super) {\n  __extends(CatchSubscriber, _super);\n\n  function CatchSubscriber(destination, selector, caught) {\n    _super.call(this, destination);\n\n    this.selector = selector;\n    this.caught = caught;\n  } // NOTE: overriding `error` instead of `_error` because we don't want\n  // to have this flag this subscriber as `isStopped`. We can mimic the\n  // behavior of the RetrySubscriber (from the `retry` operator), where\n  // we unsubscribe from our source chain, reset our Subscriber flags,\n  // then subscribe to the selector result.\n\n\n  CatchSubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var result = void 0;\n\n      try {\n        result = this.selector(err, this.caught);\n      } catch (err2) {\n        _super.prototype.error.call(this, err2);\n\n        return;\n      }\n\n      this._unsubscribeAndRecycle();\n\n      this.add(subscribeToResult_1.subscribeToResult(this, result));\n    }\n  };\n\n  return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"D2MY\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar InnerSubscriber = function (_super) {\n  __extends(InnerSubscriber, _super);\n\n  function InnerSubscriber(parent, outerValue, outerIndex) {\n    _super.call(this);\n\n    this.parent = parent;\n    this.outerValue = outerValue;\n    this.outerIndex = outerIndex;\n    this.index = 0;\n  }\n\n  InnerSubscriber.prototype._next = function (value) {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  };\n\n  InnerSubscriber.prototype._error = function (error) {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  };\n\n  InnerSubscriber.prototype._complete = function () {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  };\n\n  return InnerSubscriber;\n}(Subscriber_1.Subscriber);\n\nexports.InnerSubscriber = InnerSubscriber;\n\n/***/ }),\n\n/***/ \"D4pF\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar debounceTime_1 = /*@__PURE__*/__webpack_require__(\"AzqM\");\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\n\n\nfunction debounceTime(dueTime, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return debounceTime_1.debounceTime(dueTime, scheduler)(this);\n}\n\nexports.debounceTime = debounceTime;\n\n/***/ }),\n\n/***/ \"D9at\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar concatAll_1 = __webpack_require__(\"un7O\");\n\nObservable_1.Observable.prototype.concatAll = concatAll_1.concatAll; //# sourceMappingURL=concatAll.js.map\n\n/***/ }),\n\n/***/ \"DAeC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar concat_1 = __webpack_require__(\"9hG4\");\n\nObservable_1.Observable.prototype.concat = concat_1.concat; //# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ \"DFxj\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar ArrayObservable_1 = /*@__PURE__*/__webpack_require__(\"rVFa\");\n\nvar ScalarObservable_1 = /*@__PURE__*/__webpack_require__(\"8x9D\");\n\nvar EmptyObservable_1 = /*@__PURE__*/__webpack_require__(\"36rE\");\n\nvar concat_1 = /*@__PURE__*/__webpack_require__(\"6oB3\");\n\nvar isScheduler_1 = /*@__PURE__*/__webpack_require__(\"NwwV\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\n\n\nfunction startWith() {\n  var array = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    array[_i - 0] = arguments[_i];\n  }\n\n  return function (source) {\n    var scheduler = array[array.length - 1];\n\n    if (isScheduler_1.isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    var len = array.length;\n\n    if (len === 1) {\n      return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);\n    } else if (len > 1) {\n      return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);\n    } else {\n      return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);\n    }\n  };\n}\n\nexports.startWith = startWith;\n\n/***/ }),\n\n/***/ \"DIMi\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar expand_1 = /*@__PURE__*/__webpack_require__(\"we3k\");\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\n\n\nfunction expand(project, concurrent, scheduler) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  if (scheduler === void 0) {\n    scheduler = undefined;\n  }\n\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n  return expand_1.expand(project, concurrent, scheduler)(this);\n}\n\nexports.expand = expand;\n\n/***/ }),\n\n/***/ \"DKXc\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\n\n\nfunction find(predicate, thisArg) {\n  if (typeof predicate !== 'function') {\n    throw new TypeError('predicate is not a function');\n  }\n\n  return function (source) {\n    return source.lift(new FindValueOperator(predicate, source, false, thisArg));\n  };\n}\n\nexports.find = find;\n\nvar FindValueOperator = /*@__PURE__*/function () {\n  function FindValueOperator(predicate, source, yieldIndex, thisArg) {\n    this.predicate = predicate;\n    this.source = source;\n    this.yieldIndex = yieldIndex;\n    this.thisArg = thisArg;\n  }\n\n  FindValueOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n  };\n\n  return FindValueOperator;\n}();\n\nexports.FindValueOperator = FindValueOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar FindValueSubscriber = function (_super) {\n  __extends(FindValueSubscriber, _super);\n\n  function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n    _super.call(this, destination);\n\n    this.predicate = predicate;\n    this.source = source;\n    this.yieldIndex = yieldIndex;\n    this.thisArg = thisArg;\n    this.index = 0;\n  }\n\n  FindValueSubscriber.prototype.notifyComplete = function (value) {\n    var destination = this.destination;\n    destination.next(value);\n    destination.complete();\n  };\n\n  FindValueSubscriber.prototype._next = function (value) {\n    var _a = this,\n        predicate = _a.predicate,\n        thisArg = _a.thisArg;\n\n    var index = this.index++;\n\n    try {\n      var result = predicate.call(thisArg || this, value, index, this.source);\n\n      if (result) {\n        this.notifyComplete(this.yieldIndex ? index : value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  };\n\n  FindValueSubscriber.prototype._complete = function () {\n    this.notifyComplete(this.yieldIndex ? -1 : undefined);\n  };\n\n  return FindValueSubscriber;\n}(Subscriber_1.Subscriber);\n\nexports.FindValueSubscriber = FindValueSubscriber;\n\n/***/ }),\n\n/***/ \"DbqF\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar share_1 = __webpack_require__(\"LVa5\");\n\nObservable_1.Observable.prototype.share = share_1.share; //# sourceMappingURL=share.js.map\n\n/***/ }),\n\n/***/ \"DsW9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar fromPromise_1 = __webpack_require__(\"xxrh\");\n\nObservable_1.Observable.fromPromise = fromPromise_1.fromPromise; //# sourceMappingURL=fromPromise.js.map\n\n/***/ }),\n\n/***/ \"DxGp\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar SubscribeOnObservable_1 = /*@__PURE__*/__webpack_require__(\"5My3\");\n/**\n * Asynchronously subscribes Observers to this Observable on the specified IScheduler.\n *\n * <img src=\"./img/subscribeOn.png\" width=\"100%\">\n *\n * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.\n * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.\n .\n * @method subscribeOn\n * @owner Observable\n */\n\n\nfunction subscribeOn(scheduler, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n\n  return function subscribeOnOperatorFunction(source) {\n    return source.lift(new SubscribeOnOperator(scheduler, delay));\n  };\n}\n\nexports.subscribeOn = subscribeOn;\n\nvar SubscribeOnOperator = /*@__PURE__*/function () {\n  function SubscribeOnOperator(scheduler, delay) {\n    this.scheduler = scheduler;\n    this.delay = delay;\n  }\n\n  SubscribeOnOperator.prototype.call = function (subscriber, source) {\n    return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);\n  };\n\n  return SubscribeOnOperator;\n}();\n\n/***/ }),\n\n/***/ \"ER9c\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n *  Observable.of(1, 2, 3, 4, 5, 6)\n *     .every(x => x < 5)\n *     .subscribe(x => console.log(x)); // -> false\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\n\n\nfunction every(predicate, thisArg) {\n  return function (source) {\n    return source.lift(new EveryOperator(predicate, thisArg, source));\n  };\n}\n\nexports.every = every;\n\nvar EveryOperator = /*@__PURE__*/function () {\n  function EveryOperator(predicate, thisArg, source) {\n    this.predicate = predicate;\n    this.thisArg = thisArg;\n    this.source = source;\n  }\n\n  EveryOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n  };\n\n  return EveryOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar EverySubscriber = function (_super) {\n  __extends(EverySubscriber, _super);\n\n  function EverySubscriber(destination, predicate, thisArg, source) {\n    _super.call(this, destination);\n\n    this.predicate = predicate;\n    this.thisArg = thisArg;\n    this.source = source;\n    this.index = 0;\n    this.thisArg = thisArg || this;\n  }\n\n  EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n    this.destination.next(everyValueMatch);\n    this.destination.complete();\n  };\n\n  EverySubscriber.prototype._next = function (value) {\n    var result = false;\n\n    try {\n      result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (!result) {\n      this.notifyComplete(false);\n    }\n  };\n\n  EverySubscriber.prototype._complete = function () {\n    this.notifyComplete(true);\n  };\n\n  return EverySubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"EeVn\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar fromEvent_1 = __webpack_require__(\"V9wX\");\n\nObservable_1.Observable.fromEvent = fromEvent_1.fromEvent; //# sourceMappingURL=fromEvent.js.map\n\n/***/ }),\n\n/***/ \"Etjs\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar zip_1 = /*@__PURE__*/__webpack_require__(\"oQYR\");\n\nexports.zip = zip_1.zipStatic;\n\n/***/ }),\n\n/***/ \"FBtj\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar zip_1 = /*@__PURE__*/__webpack_require__(\"oQYR\");\n\nfunction zipAll(project) {\n  return function (source) {\n    return source.lift(new zip_1.ZipOperator(project));\n  };\n}\n\nexports.zipAll = zipAll;\n\n/***/ }),\n\n/***/ \"FEB/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar distinct_1 = /*@__PURE__*/__webpack_require__(\"nQov\");\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .distinct()\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n *\n * @example <caption>An example using a keySelector function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     .distinct((p: Person) => p.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n *\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\n\n\nfunction distinct(keySelector, flushes) {\n  return distinct_1.distinct(keySelector, flushes)(this);\n}\n\nexports.distinct = distinct;\n\n/***/ }),\n\n/***/ \"FXL7\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Scheduler_1 = /*@__PURE__*/__webpack_require__(\"ZCeS\");\n\nvar AsyncScheduler = function (_super) {\n  __extends(AsyncScheduler, _super);\n\n  function AsyncScheduler() {\n    _super.apply(this, arguments);\n\n    this.actions = [];\n    /**\n     * A flag to indicate whether the Scheduler is currently executing a batch of\n     * queued actions.\n     * @type {boolean}\n     */\n\n    this.active = false;\n    /**\n     * An internal ID used to track the latest asynchronous task such as those\n     * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n     * others.\n     * @type {any}\n     */\n\n    this.scheduled = undefined;\n  }\n\n  AsyncScheduler.prototype.flush = function (action) {\n    var actions = this.actions;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    var error;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  return AsyncScheduler;\n}(Scheduler_1.Scheduler);\n\nexports.AsyncScheduler = AsyncScheduler;\n\n/***/ }),\n\n/***/ \"FYEZ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar switchMap_1 = __webpack_require__(\"+24W\");\n\nObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap; //# sourceMappingURL=switchMap.js.map\n\n/***/ }),\n\n/***/ \"Fgpt\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar timeInterval_1 = __webpack_require__(\"suOF\");\n\nObservable_1.Observable.prototype.timeInterval = timeInterval_1.timeInterval; //# sourceMappingURL=timeInterval.js.map\n\n/***/ }),\n\n/***/ \"G2HO\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.isArray = Array.isArray || function (x) {\n  return x && typeof x.length === 'number';\n};\n\n/***/ }),\n\n/***/ \"G7wb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar multicast_1 = __webpack_require__(\"c/6p\");\n\nObservable_1.Observable.prototype.multicast = multicast_1.multicast; //# sourceMappingURL=multicast.js.map\n\n/***/ }),\n\n/***/ \"GCyh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar let_1 = __webpack_require__(\"QM1w\");\n\nObservable_1.Observable.prototype.let = let_1.letProto;\nObservable_1.Observable.prototype.letBind = let_1.letProto; //# sourceMappingURL=let.js.map\n\n/***/ }),\n\n/***/ \"GEfX\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\n\n\nfunction exhaustMap(project, resultSelector) {\n  return function (source) {\n    return source.lift(new SwitchFirstMapOperator(project, resultSelector));\n  };\n}\n\nexports.exhaustMap = exhaustMap;\n\nvar SwitchFirstMapOperator = /*@__PURE__*/function () {\n  function SwitchFirstMapOperator(project, resultSelector) {\n    this.project = project;\n    this.resultSelector = resultSelector;\n  }\n\n  SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n  };\n\n  return SwitchFirstMapOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SwitchFirstMapSubscriber = function (_super) {\n  __extends(SwitchFirstMapSubscriber, _super);\n\n  function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n    _super.call(this, destination);\n\n    this.project = project;\n    this.resultSelector = resultSelector;\n    this.hasSubscription = false;\n    this.hasCompleted = false;\n    this.index = 0;\n  }\n\n  SwitchFirstMapSubscriber.prototype._next = function (value) {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n    var index = this.index++;\n    var destination = this.destination;\n\n    try {\n      var result = this.project(value, index);\n      this.hasSubscription = true;\n      this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    } catch (err) {\n      destination.error(err);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    if (resultSelector) {\n      this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    try {\n      var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n      destination.next(result);\n    } catch (err) {\n      destination.error(err);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n    this.destination.error(err);\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.hasSubscription = false;\n\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"GHBr\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar ErrorObservable_1 = /*@__PURE__*/__webpack_require__(\"i45a\");\n\nexports._throw = ErrorObservable_1.ErrorObservable.create;\n\n/***/ }),\n\n/***/ \"GJlw\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar zip_1 = __webpack_require__(\"skK3\");\n\nObservable_1.Observable.prototype.zip = zip_1.zipProto; //# sourceMappingURL=zip.js.map\n\n/***/ }),\n\n/***/ \"GXS5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar take_1 = /*@__PURE__*/__webpack_require__(\"3hIw\");\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\n\n\nfunction take(count) {\n  return take_1.take(count)(this);\n}\n\nexports.take = take;\n\n/***/ }),\n\n/***/ \"GyLc\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar noop_1 = /*@__PURE__*/__webpack_require__(\"gRDe\");\n/* tslint:enable:max-line-length */\n\n\nfunction pipe() {\n  var fns = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    fns[_i - 0] = arguments[_i];\n  }\n\n  return pipeFromArray(fns);\n}\n\nexports.pipe = pipe;\n/* @internal */\n\nfunction pipeFromArray(fns) {\n  if (!fns) {\n    return noop_1.noop;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input) {\n    return fns.reduce(function (prev, fn) {\n      return fn(prev);\n    }, input);\n  };\n}\n\nexports.pipeFromArray = pipeFromArray;\n\n/***/ }),\n\n/***/ \"H0zL\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n * var result = higherOrder.exhaust();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\n\n\nfunction exhaust() {\n  return function (source) {\n    return source.lift(new SwitchFirstOperator());\n  };\n}\n\nexports.exhaust = exhaust;\n\nvar SwitchFirstOperator = /*@__PURE__*/function () {\n  function SwitchFirstOperator() {}\n\n  SwitchFirstOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SwitchFirstSubscriber(subscriber));\n  };\n\n  return SwitchFirstOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SwitchFirstSubscriber = function (_super) {\n  __extends(SwitchFirstSubscriber, _super);\n\n  function SwitchFirstSubscriber(destination) {\n    _super.call(this, destination);\n\n    this.hasCompleted = false;\n    this.hasSubscription = false;\n  }\n\n  SwitchFirstSubscriber.prototype._next = function (value) {\n    if (!this.hasSubscription) {\n      this.hasSubscription = true;\n      this.add(subscribeToResult_1.subscribeToResult(this, value));\n    }\n  };\n\n  SwitchFirstSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  };\n\n  SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.hasSubscription = false;\n\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return SwitchFirstSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"HH2i\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar skipWhile_1 = __webpack_require__(\"4BFK\");\n\nObservable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile; //# sourceMappingURL=skipWhile.js.map\n\n/***/ }),\n\n/***/ \"HTvz\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar sample_1 = __webpack_require__(\"9Zpy\");\n\nObservable_1.Observable.prototype.sample = sample_1.sample; //# sourceMappingURL=sample.js.map\n\n/***/ }),\n\n/***/ \"Hbpk\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\nSome credit for this helper goes to http://github.com/YuzuJS/setImmediate\n*/\n\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nvar ImmediateDefinition = /*@__PURE__*/function () {\n  function ImmediateDefinition(root) {\n    this.root = root;\n\n    if (root.setImmediate && typeof root.setImmediate === 'function') {\n      this.setImmediate = root.setImmediate.bind(root);\n      this.clearImmediate = root.clearImmediate.bind(root);\n    } else {\n      this.nextHandle = 1;\n      this.tasksByHandle = {};\n      this.currentlyRunningATask = false; // Don't get fooled by e.g. browserify environments.\n\n      if (this.canUseProcessNextTick()) {\n        // For Node.js before 0.9\n        this.setImmediate = this.createProcessNextTickSetImmediate();\n      } else if (this.canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        this.setImmediate = this.createPostMessageSetImmediate();\n      } else if (this.canUseMessageChannel()) {\n        // For web workers, where supported\n        this.setImmediate = this.createMessageChannelSetImmediate();\n      } else if (this.canUseReadyStateChange()) {\n        // For IE 68\n        this.setImmediate = this.createReadyStateChangeSetImmediate();\n      } else {\n        // For older browsers\n        this.setImmediate = this.createSetTimeoutSetImmediate();\n      }\n\n      var ci = function clearImmediate(handle) {\n        delete clearImmediate.instance.tasksByHandle[handle];\n      };\n\n      ci.instance = this;\n      this.clearImmediate = ci;\n    }\n  }\n\n  ImmediateDefinition.prototype.identify = function (o) {\n    return this.root.Object.prototype.toString.call(o);\n  };\n\n  ImmediateDefinition.prototype.canUseProcessNextTick = function () {\n    return this.identify(this.root.process) === '[object process]';\n  };\n\n  ImmediateDefinition.prototype.canUseMessageChannel = function () {\n    return Boolean(this.root.MessageChannel);\n  };\n\n  ImmediateDefinition.prototype.canUseReadyStateChange = function () {\n    var document = this.root.document;\n    return Boolean(document && 'onreadystatechange' in document.createElement('script'));\n  };\n\n  ImmediateDefinition.prototype.canUsePostMessage = function () {\n    var root = this.root; // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n    // where `root.postMessage` means something completely different and can't be used for this purpose.\n\n    if (root.postMessage && !root.importScripts) {\n      var postMessageIsAsynchronous_1 = true;\n      var oldOnMessage = root.onmessage;\n\n      root.onmessage = function () {\n        postMessageIsAsynchronous_1 = false;\n      };\n\n      root.postMessage('', '*');\n      root.onmessage = oldOnMessage;\n      return postMessageIsAsynchronous_1;\n    }\n\n    return false;\n  }; // This function accepts the same arguments as setImmediate, but\n  // returns a function that requires no arguments.\n\n\n  ImmediateDefinition.prototype.partiallyApplied = function (handler) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var fn = function result() {\n      var _a = result,\n          handler = _a.handler,\n          args = _a.args;\n\n      if (typeof handler === 'function') {\n        handler.apply(undefined, args);\n      } else {\n        new Function('' + handler)();\n      }\n    };\n\n    fn.handler = handler;\n    fn.args = args;\n    return fn;\n  };\n\n  ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {\n    this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);\n    return this.nextHandle++;\n  };\n\n  ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {\n    var fn = function setImmediate() {\n      var instance = setImmediate.instance;\n      var handle = instance.addFromSetImmediateArguments(arguments);\n      instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));\n      return handle;\n    };\n\n    fn.instance = this;\n    return fn;\n  };\n\n  ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {\n    // Installs an event handler on `global` for the `message` event: see\n    // * https://developer.mozilla.org/en/DOM/window.postMessage\n    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n    var root = this.root;\n    var messagePrefix = 'setImmediate$' + root.Math.random() + '$';\n\n    var onGlobalMessage = function globalMessageHandler(event) {\n      var instance = globalMessageHandler.instance;\n\n      if (event.source === root && typeof event.data === 'string' && event.data.indexOf(messagePrefix) === 0) {\n        instance.runIfPresent(+event.data.slice(messagePrefix.length));\n      }\n    };\n\n    onGlobalMessage.instance = this;\n    root.addEventListener('message', onGlobalMessage, false);\n\n    var fn = function setImmediate() {\n      var _a = setImmediate,\n          messagePrefix = _a.messagePrefix,\n          instance = _a.instance;\n      var handle = instance.addFromSetImmediateArguments(arguments);\n      instance.root.postMessage(messagePrefix + handle, '*');\n      return handle;\n    };\n\n    fn.instance = this;\n    fn.messagePrefix = messagePrefix;\n    return fn;\n  };\n\n  ImmediateDefinition.prototype.runIfPresent = function (handle) {\n    // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'\n    // So if we're currently running a task, we'll need to delay this invocation.\n    if (this.currentlyRunningATask) {\n      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n      // 'too much recursion' error.\n      this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);\n    } else {\n      var task = this.tasksByHandle[handle];\n\n      if (task) {\n        this.currentlyRunningATask = true;\n\n        try {\n          task();\n        } finally {\n          this.clearImmediate(handle);\n          this.currentlyRunningATask = false;\n        }\n      }\n    }\n  };\n\n  ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {\n    var _this = this;\n\n    var channel = new this.root.MessageChannel();\n\n    channel.port1.onmessage = function (event) {\n      var handle = event.data;\n\n      _this.runIfPresent(handle);\n    };\n\n    var fn = function setImmediate() {\n      var _a = setImmediate,\n          channel = _a.channel,\n          instance = _a.instance;\n      var handle = instance.addFromSetImmediateArguments(arguments);\n      channel.port2.postMessage(handle);\n      return handle;\n    };\n\n    fn.channel = channel;\n    fn.instance = this;\n    return fn;\n  };\n\n  ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {\n    var fn = function setImmediate() {\n      var instance = setImmediate.instance;\n      var root = instance.root;\n      var doc = root.document;\n      var html = doc.documentElement;\n      var handle = instance.addFromSetImmediateArguments(arguments); // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\n      var script = doc.createElement('script');\n\n      script.onreadystatechange = function () {\n        instance.runIfPresent(handle);\n        script.onreadystatechange = null;\n        html.removeChild(script);\n        script = null;\n      };\n\n      html.appendChild(script);\n      return handle;\n    };\n\n    fn.instance = this;\n    return fn;\n  };\n\n  ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {\n    var fn = function setImmediate() {\n      var instance = setImmediate.instance;\n      var handle = instance.addFromSetImmediateArguments(arguments);\n      instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);\n      return handle;\n    };\n\n    fn.instance = this;\n    return fn;\n  };\n\n  return ImmediateDefinition;\n}();\n\nexports.ImmediateDefinition = ImmediateDefinition;\nexports.Immediate = /*@__PURE__*/new ImmediateDefinition(root_1.root);\n\n/***/ }),\n\n/***/ \"Ht43\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar race_1 = __webpack_require__(\"4dTV\");\n\nObservable_1.Observable.prototype.race = race_1.race; //# sourceMappingURL=race.js.map\n\n/***/ }),\n\n/***/ \"I+lI\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar windowCount_1 = /*@__PURE__*/__webpack_require__(\"ast0\");\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\n\n\nfunction windowCount(windowSize, startWindowEvery) {\n  if (startWindowEvery === void 0) {\n    startWindowEvery = 0;\n  }\n\n  return windowCount_1.windowCount(windowSize, startWindowEvery)(this);\n}\n\nexports.windowCount = windowCount;\n\n/***/ }),\n\n/***/ \"IAWd\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar publish_1 = /*@__PURE__*/__webpack_require__(\"gcf/\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\n\n\nfunction publish(selector) {\n  return publish_1.publish(selector)(this);\n}\n\nexports.publish = publish;\n\n/***/ }),\n\n/***/ \"IEzG\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar withLatestFrom_1 = /*@__PURE__*/__webpack_require__(\"2Wg+\");\n/* tslint:enable:max-line-length */\n\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\n\n\nfunction withLatestFrom() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i - 0] = arguments[_i];\n  }\n\n  return withLatestFrom_1.withLatestFrom.apply(void 0, args)(this);\n}\n\nexports.withLatestFrom = withLatestFrom;\n\n/***/ }),\n\n/***/ \"IYeR\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar count_1 = __webpack_require__(\"0jD2\");\n\nObservable_1.Observable.prototype.count = count_1.count; //# sourceMappingURL=count.js.map\n\n/***/ }),\n\n/***/ \"Irel\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nvar isArrayLike_1 = /*@__PURE__*/__webpack_require__(\"foHw\");\n\nvar isPromise_1 = /*@__PURE__*/__webpack_require__(\"RGvf\");\n\nvar isObject_1 = /*@__PURE__*/__webpack_require__(\"pYXR\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar iterator_1 = /*@__PURE__*/__webpack_require__(\"+2+e\");\n\nvar InnerSubscriber_1 = /*@__PURE__*/__webpack_require__(\"D2MY\");\n\nvar observable_1 = /*@__PURE__*/__webpack_require__(\"WU5C\");\n\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n  var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable_1.Observable) {\n    if (result._isScalar) {\n      destination.next(result.value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike_1.isArrayLike(result)) {\n    for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise_1.isPromise(result)) {\n    result.then(function (value) {\n      if (!destination.closed) {\n        destination.next(value);\n        destination.complete();\n      }\n    }, function (err) {\n      return destination.error(err);\n    }).then(null, function (err) {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root_1.root.setTimeout(function () {\n        throw err;\n      });\n    });\n    return destination;\n  } else if (result && typeof result[iterator_1.iterator] === 'function') {\n    var iterator = result[iterator_1.iterator]();\n\n    do {\n      var item = iterator.next();\n\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n\n      destination.next(item.value);\n\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[observable_1.observable] === 'function') {\n    var obs = result[observable_1.observable]();\n\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n    var msg = \"You provided \" + value + \" where a stream was expected.\" + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n\n  return null;\n}\n\nexports.subscribeToResult = subscribeToResult;\n\n/***/ }),\n\n/***/ \"IwEe\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar finalize_1 = /*@__PURE__*/__webpack_require__(\"q9sB\");\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\n\n\nfunction _finally(callback) {\n  return finalize_1.finalize(callback)(this);\n}\n\nexports._finally = _finally;\n\n/***/ }),\n\n/***/ \"J//a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar observeOn_1 = __webpack_require__(\"QCDQ\");\n\nObservable_1.Observable.prototype.observeOn = observeOn_1.observeOn; //# sourceMappingURL=observeOn.js.map\n\n/***/ }),\n\n/***/ \"J9JT\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar AsyncAction_1 = /*@__PURE__*/__webpack_require__(\"g2Fv\");\n\nvar AsyncScheduler_1 = /*@__PURE__*/__webpack_require__(\"FXL7\");\n\nvar VirtualTimeScheduler = function (_super) {\n  __extends(VirtualTimeScheduler, _super);\n\n  function VirtualTimeScheduler(SchedulerAction, maxFrames) {\n    var _this = this;\n\n    if (SchedulerAction === void 0) {\n      SchedulerAction = VirtualAction;\n    }\n\n    if (maxFrames === void 0) {\n      maxFrames = Number.POSITIVE_INFINITY;\n    }\n\n    _super.call(this, SchedulerAction, function () {\n      return _this.frame;\n    });\n\n    this.maxFrames = maxFrames;\n    this.frame = 0;\n    this.index = -1;\n  }\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   * @return {void}\n   */\n\n\n  VirtualTimeScheduler.prototype.flush = function () {\n    var _a = this,\n        actions = _a.actions,\n        maxFrames = _a.maxFrames;\n\n    var error, action;\n\n    while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    }\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  VirtualTimeScheduler.frameTimeFactor = 10;\n  return VirtualTimeScheduler;\n}(AsyncScheduler_1.AsyncScheduler);\n\nexports.VirtualTimeScheduler = VirtualTimeScheduler;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar VirtualAction = function (_super) {\n  __extends(VirtualAction, _super);\n\n  function VirtualAction(scheduler, work, index) {\n    if (index === void 0) {\n      index = scheduler.index += 1;\n    }\n\n    _super.call(this, scheduler, work);\n\n    this.scheduler = scheduler;\n    this.work = work;\n    this.index = index;\n    this.active = true;\n    this.index = scheduler.index = index;\n  }\n\n  VirtualAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (!this.id) {\n      return _super.prototype.schedule.call(this, state, delay);\n    }\n\n    this.active = false; // If an action is rescheduled, we save allocations by mutating its state,\n    // pushing it to the end of the scheduler queue, and recycling the action.\n    // But since the VirtualTimeScheduler is used for testing, VirtualActions\n    // must be immutable so they can be inspected later.\n\n    var action = new VirtualAction(this.scheduler, this.work);\n    this.add(action);\n    return action.schedule(state, delay);\n  };\n\n  VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    this.delay = scheduler.frame + delay;\n    var actions = scheduler.actions;\n    actions.push(this);\n    actions.sort(VirtualAction.sortActions);\n    return true;\n  };\n\n  VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return undefined;\n  };\n\n  VirtualAction.prototype._execute = function (state, delay) {\n    if (this.active === true) {\n      return _super.prototype._execute.call(this, state, delay);\n    }\n  };\n\n  VirtualAction.sortActions = function (a, b) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  };\n\n  return VirtualAction;\n}(AsyncAction_1.AsyncAction);\n\nexports.VirtualAction = VirtualAction;\n\n/***/ }),\n\n/***/ \"JB8t\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar AsapAction_1 = /*@__PURE__*/__webpack_require__(\"bIKf\");\n\nvar AsapScheduler_1 = /*@__PURE__*/__webpack_require__(\"q+iv\");\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * @example <caption>Compare async and asap scheduler</caption>\n *\n * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...\n * Rx.Scheduler.asap.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n *\n * @static true\n * @name asap\n * @owner Scheduler\n */\n\n\nexports.asap = /*@__PURE__*/new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);\n\n/***/ }),\n\n/***/ \"JLRC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar mergeMapTo_1 = __webpack_require__(\"/QDG\");\n\nObservable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;\nObservable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo; //# sourceMappingURL=mergeMapTo.js.map\n\n/***/ }),\n\n/***/ \"JLi8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar ForkJoinObservable_1 = /*@__PURE__*/__webpack_require__(\"od+f\");\n\nexports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;\n\n/***/ }),\n\n/***/ \"JWmB\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar pairs_1 = __webpack_require__(\"2Go0\");\n\nObservable_1.Observable.pairs = pairs_1.pairs; //# sourceMappingURL=pairs.js.map\n\n/***/ }),\n\n/***/ \"JX5i\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar UsingObservable = function (_super) {\n  __extends(UsingObservable, _super);\n\n  function UsingObservable(resourceFactory, observableFactory) {\n    _super.call(this);\n\n    this.resourceFactory = resourceFactory;\n    this.observableFactory = observableFactory;\n  }\n\n  UsingObservable.create = function (resourceFactory, observableFactory) {\n    return new UsingObservable(resourceFactory, observableFactory);\n  };\n  /** @deprecated internal use only */\n\n\n  UsingObservable.prototype._subscribe = function (subscriber) {\n    var _a = this,\n        resourceFactory = _a.resourceFactory,\n        observableFactory = _a.observableFactory;\n\n    var resource;\n\n    try {\n      resource = resourceFactory();\n      return new UsingSubscriber(subscriber, resource, observableFactory);\n    } catch (err) {\n      subscriber.error(err);\n    }\n  };\n\n  return UsingObservable;\n}(Observable_1.Observable);\n\nexports.UsingObservable = UsingObservable;\n\nvar UsingSubscriber = function (_super) {\n  __extends(UsingSubscriber, _super);\n\n  function UsingSubscriber(destination, resource, observableFactory) {\n    _super.call(this, destination);\n\n    this.resource = resource;\n    this.observableFactory = observableFactory;\n    destination.add(resource);\n    this.tryUse();\n  }\n\n  UsingSubscriber.prototype.tryUse = function () {\n    try {\n      var source = this.observableFactory.call(this, this.resource);\n\n      if (source) {\n        this.add(subscribeToResult_1.subscribeToResult(this, source));\n      }\n    } catch (err) {\n      this._error(err);\n    }\n  };\n\n  return UsingSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"Jmzy\":\n/***/ (function(module, exports) {\n\n// HACK: does nothing, because `toPromise` now lives on the `Observable` itself.\n// leaving this module here to prevent breakage.\n//# sourceMappingURL=toPromise.js.map\n\n/***/ }),\n\n/***/ \"Jvmm\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar isEmpty_1 = __webpack_require__(\"7lXC\");\n\nObservable_1.Observable.prototype.isEmpty = isEmpty_1.isEmpty; //# sourceMappingURL=isEmpty.js.map\n\n/***/ }),\n\n/***/ \"K4Q0\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar ignoreElements_1 = __webpack_require__(\"KXV8\");\n\nObservable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements; //# sourceMappingURL=ignoreElements.js.map\n\n/***/ }),\n\n/***/ \"KC+j\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar concatMap_1 = /*@__PURE__*/__webpack_require__(\"+WiC\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\n\n\nfunction concatMap(project, resultSelector) {\n  return concatMap_1.concatMap(project, resultSelector)(this);\n}\n\nexports.concatMap = concatMap;\n\n/***/ }),\n\n/***/ \"KHtr\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar ajax_1 = __webpack_require__(\"78Oa\");\n\nObservable_1.Observable.ajax = ajax_1.ajax; //# sourceMappingURL=ajax.js.map\n\n/***/ }),\n\n/***/ \"KXV8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar ignoreElements_1 = /*@__PURE__*/__webpack_require__(\"Tb5M\");\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\n\n\nfunction ignoreElements() {\n  return ignoreElements_1.ignoreElements()(this);\n}\n\nexports.ignoreElements = ignoreElements;\n;\n\n/***/ }),\n\n/***/ \"Kc9Z\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar reduce_1 = /*@__PURE__*/__webpack_require__(\"6fvh\");\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * <img src=\"./img/min.png\" width=\"100%\">\n *\n * @example <caption>Get the minimal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .min()\n *   .subscribe(x => console.log(x)); // -> 2\n *\n * @example <caption>Use a comparer function to get the minimal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * }\n *\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\n\n\nfunction min(comparer) {\n  var min = typeof comparer === 'function' ? function (x, y) {\n    return comparer(x, y) < 0 ? x : y;\n  } : function (x, y) {\n    return x < y ? x : y;\n  };\n  return reduce_1.reduce(min);\n}\n\nexports.min = min;\n\n/***/ }),\n\n/***/ \"Kqb3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\n\n\nfunction tap(nextOrObserver, error, complete) {\n  return function tapOperatorFunction(source) {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nexports.tap = tap;\n\nvar DoOperator = /*@__PURE__*/function () {\n  function DoOperator(nextOrObserver, error, complete) {\n    this.nextOrObserver = nextOrObserver;\n    this.error = error;\n    this.complete = complete;\n  }\n\n  DoOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  };\n\n  return DoOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar DoSubscriber = function (_super) {\n  __extends(DoSubscriber, _super);\n\n  function DoSubscriber(destination, nextOrObserver, error, complete) {\n    _super.call(this, destination);\n\n    var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n    safeSubscriber.syncErrorThrowable = true;\n    this.add(safeSubscriber);\n    this.safeSubscriber = safeSubscriber;\n  }\n\n  DoSubscriber.prototype._next = function (value) {\n    var safeSubscriber = this.safeSubscriber;\n    safeSubscriber.next(value);\n\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.next(value);\n    }\n  };\n\n  DoSubscriber.prototype._error = function (err) {\n    var safeSubscriber = this.safeSubscriber;\n    safeSubscriber.error(err);\n\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.error(err);\n    }\n  };\n\n  DoSubscriber.prototype._complete = function () {\n    var safeSubscriber = this.safeSubscriber;\n    safeSubscriber.complete();\n\n    if (safeSubscriber.syncErrorThrown) {\n      this.destination.error(safeSubscriber.syncErrorValue);\n    } else {\n      this.destination.complete();\n    }\n  };\n\n  return DoSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"Kwcu\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar retry_1 = /*@__PURE__*/__webpack_require__(\"7c4m\");\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\n\n\nfunction retry(count) {\n  if (count === void 0) {\n    count = -1;\n  }\n\n  return retry_1.retry(count)(this);\n}\n\nexports.retry = retry;\n\n/***/ }),\n\n/***/ \"L/jt\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar EmptyError_1 = /*@__PURE__*/__webpack_require__(\"2fIB\");\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\n\n\nfunction first(predicate, resultSelector, defaultValue) {\n  return function (source) {\n    return source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source));\n  };\n}\n\nexports.first = first;\n\nvar FirstOperator = /*@__PURE__*/function () {\n  function FirstOperator(predicate, resultSelector, defaultValue, source) {\n    this.predicate = predicate;\n    this.resultSelector = resultSelector;\n    this.defaultValue = defaultValue;\n    this.source = source;\n  }\n\n  FirstOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n  };\n\n  return FirstOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar FirstSubscriber = function (_super) {\n  __extends(FirstSubscriber, _super);\n\n  function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n    _super.call(this, destination);\n\n    this.predicate = predicate;\n    this.resultSelector = resultSelector;\n    this.defaultValue = defaultValue;\n    this.source = source;\n    this.index = 0;\n    this.hasCompleted = false;\n    this._emitted = false;\n  }\n\n  FirstSubscriber.prototype._next = function (value) {\n    var index = this.index++;\n\n    if (this.predicate) {\n      this._tryPredicate(value, index);\n    } else {\n      this._emit(value, index);\n    }\n  };\n\n  FirstSubscriber.prototype._tryPredicate = function (value, index) {\n    var result;\n\n    try {\n      result = this.predicate(value, index, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this._emit(value, index);\n    }\n  };\n\n  FirstSubscriber.prototype._emit = function (value, index) {\n    if (this.resultSelector) {\n      this._tryResultSelector(value, index);\n\n      return;\n    }\n\n    this._emitFinal(value);\n  };\n\n  FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n    var result;\n\n    try {\n      result = this.resultSelector(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this._emitFinal(result);\n  };\n\n  FirstSubscriber.prototype._emitFinal = function (value) {\n    var destination = this.destination;\n\n    if (!this._emitted) {\n      this._emitted = true;\n      destination.next(value);\n      destination.complete();\n      this.hasCompleted = true;\n    }\n  };\n\n  FirstSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n\n    if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n      destination.next(this.defaultValue);\n      destination.complete();\n    } else if (!this.hasCompleted) {\n      destination.error(new EmptyError_1.EmptyError());\n    }\n  };\n\n  return FirstSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"LAU0\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction identity(x) {\n  return x;\n}\n\nexports.identity = identity;\n\n/***/ }),\n\n/***/ \"LLa1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar buffer_1 = /*@__PURE__*/__webpack_require__(\"zobD\");\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\n\n\nfunction buffer(closingNotifier) {\n  return buffer_1.buffer(closingNotifier)(this);\n}\n\nexports.buffer = buffer;\n\n/***/ }),\n\n/***/ \"LVa5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar share_1 = /*@__PURE__*/__webpack_require__(\"X/dC\");\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n *\n * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.\n * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.\n * Observable.of(\"test\").publish().refCount() will not re-emit \"test\" on new subscriptions, Observable.of(\"test\").share() will\n * re-emit \"test\" to new subscriptions.\n *\n * <img src=\"./img/share.png\" width=\"100%\">\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\n\n\nfunction share() {\n  return share_1.share()(this);\n}\n\nexports.share = share;\n;\n\n/***/ }),\n\n/***/ \"LWF9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nvar MapPolyfill_1 = /*@__PURE__*/__webpack_require__(\"/mOC\");\n\nexports.Map = root_1.root.Map || /*@__PURE__*/function () {\n  return MapPolyfill_1.MapPolyfill;\n}();\n\n/***/ }),\n\n/***/ \"Lhs8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar tap_1 = /*@__PURE__*/__webpack_require__(\"Kqb3\");\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\n\n\nfunction _do(nextOrObserver, error, complete) {\n  return tap_1.tap(nextOrObserver, error, complete)(this);\n}\n\nexports._do = _do;\n\n/***/ }),\n\n/***/ \"Lj2B\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar switchAll_1 = /*@__PURE__*/__webpack_require__(\"hY8S\");\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * subscribing to only the most recently emitted of those inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * previous inner Observable once a new one appears.</span>\n *\n * <img src=\"./img/switch.png\" width=\"100%\">\n *\n * `switch` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable subscribes to the inner Observable and\n * begins emitting the items emitted by that. So far, it behaves\n * like {@link mergeAll}. However, when a new inner Observable is emitted,\n * `switch` unsubscribes from the earlier-emitted inner Observable and\n * subscribes to the new inner Observable and begins emitting items from it. It\n * continues to behave like this for subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * // Each click event is mapped to an Observable that ticks every second\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var switched = higherOrder.switch();\n * // The outcome is that `switched` is essentially a timer that restarts\n * // on every click. The interval Observables from older clicks do not merge\n * // with the current interval Observable.\n * switched.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link zipAll}\n *\n * @return {Observable<T>} An Observable that emits the items emitted by the\n * Observable most recently emitted by the source Observable.\n * @method switch\n * @name switch\n * @owner Observable\n */\n\n\nfunction _switch() {\n  return switchAll_1.switchAll()(this);\n}\n\nexports._switch = _switch;\n\n/***/ }),\n\n/***/ \"LqmK\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar merge_1 = /*@__PURE__*/__webpack_require__(\"MdjT\");\n\nvar merge_2 = /*@__PURE__*/__webpack_require__(\"MdjT\");\n\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\n\nfunction merge() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return function (source) {\n    return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables)));\n  };\n}\n\nexports.merge = merge;\n\n/***/ }),\n\n/***/ \"M1gx\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar throttleTime_1 = __webpack_require__(\"X7Im\");\n\nObservable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime; //# sourceMappingURL=throttleTime.js.map\n\n/***/ }),\n\n/***/ \"M6BU\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar reduce_1 = /*@__PURE__*/__webpack_require__(\"6fvh\");\n\nfunction toArrayReducer(arr, item, index) {\n  if (index === 0) {\n    return [item];\n  }\n\n  arr.push(item);\n  return arr;\n}\n\nfunction toArray() {\n  return reduce_1.reduce(toArrayReducer, []);\n}\n\nexports.toArray = toArray;\n\n/***/ }),\n\n/***/ \"MB5B\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar partition_1 = __webpack_require__(\"wEqr\");\n\nObservable_1.Observable.prototype.partition = partition_1.partition; //# sourceMappingURL=partition.js.map\n\n/***/ }),\n\n/***/ \"MHPA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value or a complete notification, the output Observable stops\n * mirroring the source Observable and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\n\n\nfunction takeUntil(notifier) {\n  return function (source) {\n    return source.lift(new TakeUntilOperator(notifier));\n  };\n}\n\nexports.takeUntil = takeUntil;\n\nvar TakeUntilOperator = /*@__PURE__*/function () {\n  function TakeUntilOperator(notifier) {\n    this.notifier = notifier;\n  }\n\n  TakeUntilOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));\n  };\n\n  return TakeUntilOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar TakeUntilSubscriber = function (_super) {\n  __extends(TakeUntilSubscriber, _super);\n\n  function TakeUntilSubscriber(destination, notifier) {\n    _super.call(this, destination);\n\n    this.notifier = notifier;\n    this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n  }\n\n  TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.complete();\n  };\n\n  TakeUntilSubscriber.prototype.notifyComplete = function () {// noop\n  };\n\n  return TakeUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"MdjT\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar ArrayObservable_1 = /*@__PURE__*/__webpack_require__(\"rVFa\");\n\nvar isScheduler_1 = /*@__PURE__*/__webpack_require__(\"NwwV\");\n\nvar mergeAll_1 = /*@__PURE__*/__webpack_require__(\"0p2S\");\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits it's max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits it's max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\n\n\nfunction merge() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  var concurrent = Number.POSITIVE_INFINITY;\n  var scheduler = null;\n  var last = observables[observables.length - 1];\n\n  if (isScheduler_1.isScheduler(last)) {\n    scheduler = observables.pop();\n\n    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n      concurrent = observables.pop();\n    }\n  } else if (typeof last === 'number') {\n    concurrent = observables.pop();\n  }\n\n  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {\n    return observables[0];\n  }\n\n  return mergeAll_1.mergeAll(concurrent)(new ArrayObservable_1.ArrayObservable(observables, scheduler));\n}\n\nexports.merge = merge;\n\n/***/ }),\n\n/***/ \"Mnf/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar isNumeric_1 = /*@__PURE__*/__webpack_require__(\"zZI/\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar IntervalObservable = function (_super) {\n  __extends(IntervalObservable, _super);\n\n  function IntervalObservable(period, scheduler) {\n    if (period === void 0) {\n      period = 0;\n    }\n\n    if (scheduler === void 0) {\n      scheduler = async_1.async;\n    }\n\n    _super.call(this);\n\n    this.period = period;\n    this.scheduler = scheduler;\n\n    if (!isNumeric_1.isNumeric(period) || period < 0) {\n      this.period = 0;\n    }\n\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n      this.scheduler = async_1.async;\n    }\n  }\n  /**\n   * Creates an Observable that emits sequential numbers every specified\n   * interval of time, on a specified IScheduler.\n   *\n   * <span class=\"informal\">Emits incremental numbers periodically in time.\n   * </span>\n   *\n   * <img src=\"./img/interval.png\" width=\"100%\">\n   *\n   * `interval` returns an Observable that emits an infinite sequence of\n   * ascending integers, with a constant interval of time of your choosing\n   * between those emissions. The first emission is not sent immediately, but\n   * only after the first period has passed. By default, this operator uses the\n   * `async` IScheduler to provide a notion of time, but you may pass any\n   * IScheduler to it.\n   *\n   * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\n   * var numbers = Rx.Observable.interval(1000);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @see {@link timer}\n   * @see {@link delay}\n   *\n   * @param {number} [period=0] The interval size in milliseconds (by default)\n   * or the time unit determined by the scheduler's clock.\n   * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n   * the emission of values, and providing a notion of \"time\".\n   * @return {Observable} An Observable that emits a sequential number each time\n   * interval.\n   * @static true\n   * @name interval\n   * @owner Observable\n   */\n\n\n  IntervalObservable.create = function (period, scheduler) {\n    if (period === void 0) {\n      period = 0;\n    }\n\n    if (scheduler === void 0) {\n      scheduler = async_1.async;\n    }\n\n    return new IntervalObservable(period, scheduler);\n  };\n\n  IntervalObservable.dispatch = function (state) {\n    var index = state.index,\n        subscriber = state.subscriber,\n        period = state.period;\n    subscriber.next(index);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index += 1;\n    this.schedule(state, period);\n  };\n  /** @deprecated internal use only */\n\n\n  IntervalObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n    var period = this.period;\n    var scheduler = this.scheduler;\n    subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {\n      index: index,\n      subscriber: subscriber,\n      period: period\n    }));\n  };\n\n  return IntervalObservable;\n}(Observable_1.Observable);\n\nexports.IntervalObservable = IntervalObservable;\n\n/***/ }),\n\n/***/ \"N6Zr\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\n\n\nfunction bufferWhen(closingSelector) {\n  return function (source) {\n    return source.lift(new BufferWhenOperator(closingSelector));\n  };\n}\n\nexports.bufferWhen = bufferWhen;\n\nvar BufferWhenOperator = /*@__PURE__*/function () {\n  function BufferWhenOperator(closingSelector) {\n    this.closingSelector = closingSelector;\n  }\n\n  BufferWhenOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n  };\n\n  return BufferWhenOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar BufferWhenSubscriber = function (_super) {\n  __extends(BufferWhenSubscriber, _super);\n\n  function BufferWhenSubscriber(destination, closingSelector) {\n    _super.call(this, destination);\n\n    this.closingSelector = closingSelector;\n    this.subscribing = false;\n    this.openBuffer();\n  }\n\n  BufferWhenSubscriber.prototype._next = function (value) {\n    this.buffer.push(value);\n  };\n\n  BufferWhenSubscriber.prototype._complete = function () {\n    var buffer = this.buffer;\n\n    if (buffer) {\n      this.destination.next(buffer);\n    }\n\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n\n\n  BufferWhenSubscriber.prototype._unsubscribe = function () {\n    this.buffer = null;\n    this.subscribing = false;\n  };\n\n  BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.openBuffer();\n  };\n\n  BufferWhenSubscriber.prototype.notifyComplete = function () {\n    if (this.subscribing) {\n      this.complete();\n    } else {\n      this.openBuffer();\n    }\n  };\n\n  BufferWhenSubscriber.prototype.openBuffer = function () {\n    var closingSubscription = this.closingSubscription;\n\n    if (closingSubscription) {\n      this.remove(closingSubscription);\n      closingSubscription.unsubscribe();\n    }\n\n    var buffer = this.buffer;\n\n    if (this.buffer) {\n      this.destination.next(buffer);\n    }\n\n    this.buffer = [];\n    var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n\n    if (closingNotifier === errorObject_1.errorObject) {\n      this.error(errorObject_1.errorObject.e);\n    } else {\n      closingSubscription = new Subscription_1.Subscription();\n      this.closingSubscription = closingSubscription;\n      this.add(closingSubscription);\n      this.subscribing = true;\n      closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n      this.subscribing = false;\n    }\n  };\n\n  return BufferWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"NNAl\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SubjectSubscription = function (_super) {\n  __extends(SubjectSubscription, _super);\n\n  function SubjectSubscription(subject, subscriber) {\n    _super.call(this);\n\n    this.subject = subject;\n    this.subscriber = subscriber;\n    this.closed = false;\n  }\n\n  SubjectSubscription.prototype.unsubscribe = function () {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    var subject = this.subject;\n    var observers = subject.observers;\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    var subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  };\n\n  return SubjectSubscription;\n}(Subscription_1.Subscription);\n\nexports.SubjectSubscription = SubjectSubscription;\n\n/***/ }),\n\n/***/ \"NeaI\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar throttle_1 = /*@__PURE__*/__webpack_require__(\"o6MN\");\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/throttle.png\" width=\"100%\">\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttle(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\n\n\nfunction throttle(durationSelector, config) {\n  if (config === void 0) {\n    config = throttle_1.defaultThrottleConfig;\n  }\n\n  return throttle_1.throttle(durationSelector, config)(this);\n}\n\nexports.throttle = throttle;\n\n/***/ }),\n\n/***/ \"NwwV\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction isScheduler(value) {\n  return value && typeof value.schedule === 'function';\n}\n\nexports.isScheduler = isScheduler;\n\n/***/ }),\n\n/***/ \"O/EN\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar AsyncSubject_1 = /*@__PURE__*/__webpack_require__(\"8G9e\");\n\nvar multicast_1 = /*@__PURE__*/__webpack_require__(\"cf1P\");\n\nfunction publishLast() {\n  return function (source) {\n    return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source);\n  };\n}\n\nexports.publishLast = publishLast;\n\n/***/ }),\n\n/***/ \"OMR/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar combineLatest_1 = /*@__PURE__*/__webpack_require__(\"SWOv\");\n\nfunction combineAll(project) {\n  return function (source) {\n    return source.lift(new combineLatest_1.CombineLatestOperator(project));\n  };\n}\n\nexports.combineAll = combineAll;\n\n/***/ }),\n\n/***/ \"OVX6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar every_1 = /*@__PURE__*/__webpack_require__(\"ER9c\");\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n *  Observable.of(1, 2, 3, 4, 5, 6)\n *     .every(x => x < 5)\n *     .subscribe(x => console.log(x)); // -> false\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\n\n\nfunction every(predicate, thisArg) {\n  return every_1.every(predicate, thisArg)(this);\n}\n\nexports.every = every;\n\n/***/ }),\n\n/***/ \"OmKy\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bufferWhen_1 = /*@__PURE__*/__webpack_require__(\"N6Zr\");\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\n\n\nfunction bufferWhen(closingSelector) {\n  return bufferWhen_1.bufferWhen(closingSelector)(this);\n}\n\nexports.bufferWhen = bufferWhen;\n\n/***/ }),\n\n/***/ \"Ontn\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar retryWhen_1 = /*@__PURE__*/__webpack_require__(\"C8RJ\");\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\n\n\nfunction retryWhen(notifier) {\n  return retryWhen_1.retryWhen(notifier)(this);\n}\n\nexports.retryWhen = retryWhen;\n\n/***/ }),\n\n/***/ \"OtNS\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar mapTo_1 = __webpack_require__(\"YJDk\");\n\nObservable_1.Observable.prototype.mapTo = mapTo_1.mapTo; //# sourceMappingURL=mapTo.js.map\n\n/***/ }),\n\n/***/ \"PCq3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\n\n\nvar ObjectUnsubscribedError = function (_super) {\n  __extends(ObjectUnsubscribedError, _super);\n\n  function ObjectUnsubscribedError() {\n    var err = _super.call(this, 'object unsubscribed');\n\n    this.name = err.name = 'ObjectUnsubscribedError';\n    this.stack = err.stack;\n    this.message = err.message;\n  }\n\n  return ObjectUnsubscribedError;\n}(Error);\n\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n\n/***/ }),\n\n/***/ \"PFc+\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nexports.isFunction = isFunction;\n\n/***/ }),\n\n/***/ \"Pg5x\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar elementAt_1 = __webpack_require__(\"01WU\");\n\nObservable_1.Observable.prototype.elementAt = elementAt_1.elementAt; //# sourceMappingURL=elementAt.js.map\n\n/***/ }),\n\n/***/ \"PqiM\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar skipUntil_1 = /*@__PURE__*/__webpack_require__(\"WgKs\");\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\n\n\nfunction skipUntil(notifier) {\n  return skipUntil_1.skipUntil(notifier)(this);\n}\n\nexports.skipUntil = skipUntil;\n\n/***/ }),\n\n/***/ \"PxRv\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar ArgumentOutOfRangeError_1 = /*@__PURE__*/__webpack_require__(\"8kg7\");\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * <img src=\"./img/elementAt.png\" width=\"100%\">\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * @example <caption>Emit only the third click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.elementAt(2);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\n\n\nfunction elementAt(index, defaultValue) {\n  return function (source) {\n    return source.lift(new ElementAtOperator(index, defaultValue));\n  };\n}\n\nexports.elementAt = elementAt;\n\nvar ElementAtOperator = /*@__PURE__*/function () {\n  function ElementAtOperator(index, defaultValue) {\n    this.index = index;\n    this.defaultValue = defaultValue;\n\n    if (index < 0) {\n      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();\n    }\n  }\n\n  ElementAtOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));\n  };\n\n  return ElementAtOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar ElementAtSubscriber = function (_super) {\n  __extends(ElementAtSubscriber, _super);\n\n  function ElementAtSubscriber(destination, index, defaultValue) {\n    _super.call(this, destination);\n\n    this.index = index;\n    this.defaultValue = defaultValue;\n  }\n\n  ElementAtSubscriber.prototype._next = function (x) {\n    if (this.index-- === 0) {\n      this.destination.next(x);\n      this.destination.complete();\n    }\n  };\n\n  ElementAtSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n\n    if (this.index >= 0) {\n      if (typeof this.defaultValue !== 'undefined') {\n        destination.next(this.defaultValue);\n      } else {\n        destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError());\n      }\n    }\n\n    destination.complete();\n  };\n\n  return ElementAtSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"Q0aF\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar max_1 = __webpack_require__(\"uJFK\");\n\nObservable_1.Observable.prototype.max = max_1.max; //# sourceMappingURL=max.js.map\n\n/***/ }),\n\n/***/ \"Q6nm\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar Map_1 = /*@__PURE__*/__webpack_require__(\"LWF9\");\n\nvar FastMap_1 = /*@__PURE__*/__webpack_require__(\"Sbdl\");\n/* tslint:enable:max-line-length */\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\n\n\nfunction groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n  return function (source) {\n    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n  };\n}\n\nexports.groupBy = groupBy;\n\nvar GroupByOperator = /*@__PURE__*/function () {\n  function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n    this.keySelector = keySelector;\n    this.elementSelector = elementSelector;\n    this.durationSelector = durationSelector;\n    this.subjectSelector = subjectSelector;\n  }\n\n  GroupByOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n  };\n\n  return GroupByOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar GroupBySubscriber = function (_super) {\n  __extends(GroupBySubscriber, _super);\n\n  function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n    _super.call(this, destination);\n\n    this.keySelector = keySelector;\n    this.elementSelector = elementSelector;\n    this.durationSelector = durationSelector;\n    this.subjectSelector = subjectSelector;\n    this.groups = null;\n    this.attemptedToUnsubscribe = false;\n    this.count = 0;\n  }\n\n  GroupBySubscriber.prototype._next = function (value) {\n    var key;\n\n    try {\n      key = this.keySelector(value);\n    } catch (err) {\n      this.error(err);\n      return;\n    }\n\n    this._group(value, key);\n  };\n\n  GroupBySubscriber.prototype._group = function (value, key) {\n    var groups = this.groups;\n\n    if (!groups) {\n      groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();\n    }\n\n    var group = groups.get(key);\n    var element;\n\n    if (this.elementSelector) {\n      try {\n        element = this.elementSelector(value);\n      } catch (err) {\n        this.error(err);\n      }\n    } else {\n      element = value;\n    }\n\n    if (!group) {\n      group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();\n      groups.set(key, group);\n      var groupedObservable = new GroupedObservable(key, group, this);\n      this.destination.next(groupedObservable);\n\n      if (this.durationSelector) {\n        var duration = void 0;\n\n        try {\n          duration = this.durationSelector(new GroupedObservable(key, group));\n        } catch (err) {\n          this.error(err);\n          return;\n        }\n\n        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n      }\n    }\n\n    if (!group.closed) {\n      group.next(element);\n    }\n  };\n\n  GroupBySubscriber.prototype._error = function (err) {\n    var groups = this.groups;\n\n    if (groups) {\n      groups.forEach(function (group, key) {\n        group.error(err);\n      });\n      groups.clear();\n    }\n\n    this.destination.error(err);\n  };\n\n  GroupBySubscriber.prototype._complete = function () {\n    var groups = this.groups;\n\n    if (groups) {\n      groups.forEach(function (group, key) {\n        group.complete();\n      });\n      groups.clear();\n    }\n\n    this.destination.complete();\n  };\n\n  GroupBySubscriber.prototype.removeGroup = function (key) {\n    this.groups.delete(key);\n  };\n\n  GroupBySubscriber.prototype.unsubscribe = function () {\n    if (!this.closed) {\n      this.attemptedToUnsubscribe = true;\n\n      if (this.count === 0) {\n        _super.prototype.unsubscribe.call(this);\n      }\n    }\n  };\n\n  return GroupBySubscriber;\n}(Subscriber_1.Subscriber);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar GroupDurationSubscriber = function (_super) {\n  __extends(GroupDurationSubscriber, _super);\n\n  function GroupDurationSubscriber(key, group, parent) {\n    _super.call(this, group);\n\n    this.key = key;\n    this.group = group;\n    this.parent = parent;\n  }\n\n  GroupDurationSubscriber.prototype._next = function (value) {\n    this.complete();\n  };\n  /** @deprecated internal use only */\n\n\n  GroupDurationSubscriber.prototype._unsubscribe = function () {\n    var _a = this,\n        parent = _a.parent,\n        key = _a.key;\n\n    this.key = this.parent = null;\n\n    if (parent) {\n      parent.removeGroup(key);\n    }\n  };\n\n  return GroupDurationSubscriber;\n}(Subscriber_1.Subscriber);\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\n\n\nvar GroupedObservable = function (_super) {\n  __extends(GroupedObservable, _super);\n\n  function GroupedObservable(key, groupSubject, refCountSubscription) {\n    _super.call(this);\n\n    this.key = key;\n    this.groupSubject = groupSubject;\n    this.refCountSubscription = refCountSubscription;\n  }\n  /** @deprecated internal use only */\n\n\n  GroupedObservable.prototype._subscribe = function (subscriber) {\n    var subscription = new Subscription_1.Subscription();\n\n    var _a = this,\n        refCountSubscription = _a.refCountSubscription,\n        groupSubject = _a.groupSubject;\n\n    if (refCountSubscription && !refCountSubscription.closed) {\n      subscription.add(new InnerRefCountSubscription(refCountSubscription));\n    }\n\n    subscription.add(groupSubject.subscribe(subscriber));\n    return subscription;\n  };\n\n  return GroupedObservable;\n}(Observable_1.Observable);\n\nexports.GroupedObservable = GroupedObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar InnerRefCountSubscription = function (_super) {\n  __extends(InnerRefCountSubscription, _super);\n\n  function InnerRefCountSubscription(parent) {\n    _super.call(this);\n\n    this.parent = parent;\n    parent.count++;\n  }\n\n  InnerRefCountSubscription.prototype.unsubscribe = function () {\n    var parent = this.parent;\n\n    if (!parent.closed && !this.closed) {\n      _super.prototype.unsubscribe.call(this);\n\n      parent.count -= 1;\n\n      if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n        parent.unsubscribe();\n      }\n    }\n  };\n\n  return InnerRefCountSubscription;\n}(Subscription_1.Subscription);\n\n/***/ }),\n\n/***/ \"QCDQ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar observeOn_1 = /*@__PURE__*/__webpack_require__(\"0zyO\");\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\n\n\nfunction observeOn(scheduler, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n\n  return observeOn_1.observeOn(scheduler, delay)(this);\n}\n\nexports.observeOn = observeOn;\n\n/***/ }),\n\n/***/ \"QCIY\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar isDate_1 = /*@__PURE__*/__webpack_require__(\"hut+\");\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar Notification_1 = /*@__PURE__*/__webpack_require__(\"9x29\");\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\n\n\nfunction delay(delay, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  var absoluteDelay = isDate_1.isDate(delay);\n  var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);\n  return function (source) {\n    return source.lift(new DelayOperator(delayFor, scheduler));\n  };\n}\n\nexports.delay = delay;\n\nvar DelayOperator = /*@__PURE__*/function () {\n  function DelayOperator(delay, scheduler) {\n    this.delay = delay;\n    this.scheduler = scheduler;\n  }\n\n  DelayOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n  };\n\n  return DelayOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar DelaySubscriber = function (_super) {\n  __extends(DelaySubscriber, _super);\n\n  function DelaySubscriber(destination, delay, scheduler) {\n    _super.call(this, destination);\n\n    this.delay = delay;\n    this.scheduler = scheduler;\n    this.queue = [];\n    this.active = false;\n    this.errored = false;\n  }\n\n  DelaySubscriber.dispatch = function (state) {\n    var source = state.source;\n    var queue = source.queue;\n    var scheduler = state.scheduler;\n    var destination = state.destination;\n\n    while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n\n    if (queue.length > 0) {\n      var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay_1);\n    } else {\n      this.unsubscribe();\n      source.active = false;\n    }\n  };\n\n  DelaySubscriber.prototype._schedule = function (scheduler) {\n    this.active = true;\n    this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n      source: this,\n      destination: this.destination,\n      scheduler: scheduler\n    }));\n  };\n\n  DelaySubscriber.prototype.scheduleNotification = function (notification) {\n    if (this.errored === true) {\n      return;\n    }\n\n    var scheduler = this.scheduler;\n    var message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  };\n\n  DelaySubscriber.prototype._next = function (value) {\n    this.scheduleNotification(Notification_1.Notification.createNext(value));\n  };\n\n  DelaySubscriber.prototype._error = function (err) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n  };\n\n  DelaySubscriber.prototype._complete = function () {\n    this.scheduleNotification(Notification_1.Notification.createComplete());\n  };\n\n  return DelaySubscriber;\n}(Subscriber_1.Subscriber);\n\nvar DelayMessage = /*@__PURE__*/function () {\n  function DelayMessage(time, notification) {\n    this.time = time;\n    this.notification = notification;\n  }\n\n  return DelayMessage;\n}();\n\n/***/ }),\n\n/***/ \"QM1w\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @param func\n * @return {Observable<R>}\n * @method let\n * @owner Observable\n */\n\nfunction letProto(func) {\n  return func(this);\n}\n\nexports.letProto = letProto;\n\n/***/ }),\n\n/***/ \"QY9E\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar bufferCount_1 = __webpack_require__(\"nxYh\");\n\nObservable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount; //# sourceMappingURL=bufferCount.js.map\n\n/***/ }),\n\n/***/ \"QnAi\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction applyMixins(derivedCtor, baseCtors) {\n  for (var i = 0, len = baseCtors.length; i < len; i++) {\n    var baseCtor = baseCtors[i];\n    var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);\n\n    for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {\n      var name_1 = propertyKeys[j];\n      derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];\n    }\n  }\n}\n\nexports.applyMixins = applyMixins;\n\n/***/ }),\n\n/***/ \"RGvf\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction isPromise(value) {\n  return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\n\nexports.isPromise = isPromise;\n\n/***/ }),\n\n/***/ \"RIQZ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar timeout_1 = __webpack_require__(\"ypDg\");\n\nObservable_1.Observable.prototype.timeout = timeout_1.timeout; //# sourceMappingURL=timeout.js.map\n\n/***/ }),\n\n/***/ \"RL+e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar find_1 = /*@__PURE__*/__webpack_require__(\"DKXc\");\n/* tslint:enable:max-line-length */\n\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\n\n\nfunction find(predicate, thisArg) {\n  return find_1.find(predicate, thisArg)(this);\n}\n\nexports.find = find;\n\n/***/ }),\n\n/***/ \"RM7s\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar startWith_1 = /*@__PURE__*/__webpack_require__(\"DFxj\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\n\n\nfunction startWith() {\n  var array = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    array[_i - 0] = arguments[_i];\n  }\n\n  return startWith_1.startWith.apply(void 0, array)(this);\n}\n\nexports.startWith = startWith;\n\n/***/ }),\n\n/***/ \"RYdh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar skip_1 = __webpack_require__(\"zLeP\");\n\nObservable_1.Observable.prototype.skip = skip_1.skip; //# sourceMappingURL=skip.js.map\n\n/***/ }),\n\n/***/ \"Re0n\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar AsyncAction_1 = /*@__PURE__*/__webpack_require__(\"g2Fv\");\n\nvar AsyncScheduler_1 = /*@__PURE__*/__webpack_require__(\"FXL7\");\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\n\n\nexports.async = /*@__PURE__*/new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n\n/***/ }),\n\n/***/ \"RkF3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar combineLatest_1 = /*@__PURE__*/__webpack_require__(\"SWOv\");\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\n\n\nfunction combineLatest() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return combineLatest_1.combineLatest.apply(void 0, observables)(this);\n}\n\nexports.combineLatest = combineLatest;\n\n/***/ }),\n\n/***/ \"Rm1J\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar FromObservable_1 = /*@__PURE__*/__webpack_require__(\"+fDQ\");\n\nvar isArray_1 = /*@__PURE__*/__webpack_require__(\"G2HO\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n *\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * Rx.Observable.of(1, 2, 3, 0)\n *   .map(x => {\n *       if (x === 0) { throw Error(); }\n         return 10 / x;\n *   })\n *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n *   .subscribe(\n *     val => console.log(val),\n *     err => console.log(err),          // Will never be called.\n *     () => console.log('that\\'s it!')\n *   );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\n\n\nfunction onErrorResumeNext() {\n  var nextSources = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    nextSources[_i - 0] = arguments[_i];\n  }\n\n  if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n    nextSources = nextSources[0];\n  }\n\n  return function (source) {\n    return source.lift(new OnErrorResumeNextOperator(nextSources));\n  };\n}\n\nexports.onErrorResumeNext = onErrorResumeNext;\n/* tslint:enable:max-line-length */\n\nfunction onErrorResumeNextStatic() {\n  var nextSources = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    nextSources[_i - 0] = arguments[_i];\n  }\n\n  var source = null;\n\n  if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n    nextSources = nextSources[0];\n  }\n\n  source = nextSources.shift();\n  return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));\n}\n\nexports.onErrorResumeNextStatic = onErrorResumeNextStatic;\n\nvar OnErrorResumeNextOperator = /*@__PURE__*/function () {\n  function OnErrorResumeNextOperator(nextSources) {\n    this.nextSources = nextSources;\n  }\n\n  OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n  };\n\n  return OnErrorResumeNextOperator;\n}();\n\nvar OnErrorResumeNextSubscriber = function (_super) {\n  __extends(OnErrorResumeNextSubscriber, _super);\n\n  function OnErrorResumeNextSubscriber(destination, nextSources) {\n    _super.call(this, destination);\n\n    this.destination = destination;\n    this.nextSources = nextSources;\n  }\n\n  OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n    this.subscribeToNextSource();\n  };\n\n  OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.subscribeToNextSource();\n  };\n\n  OnErrorResumeNextSubscriber.prototype._error = function (err) {\n    this.subscribeToNextSource();\n  };\n\n  OnErrorResumeNextSubscriber.prototype._complete = function () {\n    this.subscribeToNextSource();\n  };\n\n  OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n    var next = this.nextSources.shift();\n\n    if (next) {\n      this.add(subscribeToResult_1.subscribeToResult(this, next));\n    } else {\n      this.destination.complete();\n    }\n  };\n\n  return OnErrorResumeNextSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"S26M\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar catchError_1 = /*@__PURE__*/__webpack_require__(\"CxhQ\");\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @name catch\n * @owner Observable\n */\n\n\nfunction _catch(selector) {\n  return catchError_1.catchError(selector)(this);\n}\n\nexports._catch = _catch;\n\n/***/ }),\n\n/***/ \"SQLu\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\n\n\nfunction mergeScan(accumulator, seed, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  return function (source) {\n    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));\n  };\n}\n\nexports.mergeScan = mergeScan;\n\nvar MergeScanOperator = /*@__PURE__*/function () {\n  function MergeScanOperator(accumulator, seed, concurrent) {\n    this.accumulator = accumulator;\n    this.seed = seed;\n    this.concurrent = concurrent;\n  }\n\n  MergeScanOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n  };\n\n  return MergeScanOperator;\n}();\n\nexports.MergeScanOperator = MergeScanOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar MergeScanSubscriber = function (_super) {\n  __extends(MergeScanSubscriber, _super);\n\n  function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n    _super.call(this, destination);\n\n    this.accumulator = accumulator;\n    this.acc = acc;\n    this.concurrent = concurrent;\n    this.hasValue = false;\n    this.hasCompleted = false;\n    this.buffer = [];\n    this.active = 0;\n    this.index = 0;\n  }\n\n  MergeScanSubscriber.prototype._next = function (value) {\n    if (this.active < this.concurrent) {\n      var index = this.index++;\n      var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);\n      var destination = this.destination;\n\n      if (ish === errorObject_1.errorObject) {\n        destination.error(errorObject_1.errorObject.e);\n      } else {\n        this.active++;\n\n        this._innerSub(ish, value, index);\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  };\n\n  MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n    this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n  };\n\n  MergeScanSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (this.active === 0 && this.buffer.length === 0) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n\n      this.destination.complete();\n    }\n  };\n\n  MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var destination = this.destination;\n    this.acc = innerValue;\n    this.hasValue = true;\n    destination.next(innerValue);\n  };\n\n  MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n    var buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n\n      this.destination.complete();\n    }\n  };\n\n  return MergeScanSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\nexports.MergeScanSubscriber = MergeScanSubscriber;\n\n/***/ }),\n\n/***/ \"SWOv\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar ArrayObservable_1 = /*@__PURE__*/__webpack_require__(\"rVFa\");\n\nvar isArray_1 = /*@__PURE__*/__webpack_require__(\"G2HO\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nvar none = {};\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\n\nfunction combineLatest() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  var project = null;\n\n  if (typeof observables[observables.length - 1] === 'function') {\n    project = observables.pop();\n  } // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n\n\n  if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n    observables = observables[0].slice();\n  }\n\n  return function (source) {\n    return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project));\n  };\n}\n\nexports.combineLatest = combineLatest;\n\nvar CombineLatestOperator = /*@__PURE__*/function () {\n  function CombineLatestOperator(project) {\n    this.project = project;\n  }\n\n  CombineLatestOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n  };\n\n  return CombineLatestOperator;\n}();\n\nexports.CombineLatestOperator = CombineLatestOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar CombineLatestSubscriber = function (_super) {\n  __extends(CombineLatestSubscriber, _super);\n\n  function CombineLatestSubscriber(destination, project) {\n    _super.call(this, destination);\n\n    this.project = project;\n    this.active = 0;\n    this.values = [];\n    this.observables = [];\n  }\n\n  CombineLatestSubscriber.prototype._next = function (observable) {\n    this.values.push(none);\n    this.observables.push(observable);\n  };\n\n  CombineLatestSubscriber.prototype._complete = function () {\n    var observables = this.observables;\n    var len = observables.length;\n\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n\n      for (var i = 0; i < len; i++) {\n        var observable = observables[i];\n        this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n      }\n    }\n  };\n\n  CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete();\n    }\n  };\n\n  CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var values = this.values;\n    var oldVal = values[outerIndex];\n    var toRespond = !this.toRespond ? 0 : oldVal === none ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n\n    if (toRespond === 0) {\n      if (this.project) {\n        this._tryProject(values);\n      } else {\n        this.destination.next(values.slice());\n      }\n    }\n  };\n\n  CombineLatestSubscriber.prototype._tryProject = function (values) {\n    var result;\n\n    try {\n      result = this.project.apply(this, values);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return CombineLatestSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\nexports.CombineLatestSubscriber = CombineLatestSubscriber;\n\n/***/ }),\n\n/***/ \"SX7S\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\n\n\nfunction skipWhile(predicate) {\n  return function (source) {\n    return source.lift(new SkipWhileOperator(predicate));\n  };\n}\n\nexports.skipWhile = skipWhile;\n\nvar SkipWhileOperator = /*@__PURE__*/function () {\n  function SkipWhileOperator(predicate) {\n    this.predicate = predicate;\n  }\n\n  SkipWhileOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n  };\n\n  return SkipWhileOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SkipWhileSubscriber = function (_super) {\n  __extends(SkipWhileSubscriber, _super);\n\n  function SkipWhileSubscriber(destination, predicate) {\n    _super.call(this, destination);\n\n    this.predicate = predicate;\n    this.skipping = true;\n    this.index = 0;\n  }\n\n  SkipWhileSubscriber.prototype._next = function (value) {\n    var destination = this.destination;\n\n    if (this.skipping) {\n      this.tryCallPredicate(value);\n    }\n\n    if (!this.skipping) {\n      destination.next(value);\n    }\n  };\n\n  SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n    try {\n      var result = this.predicate(value, this.index++);\n      this.skipping = Boolean(result);\n    } catch (err) {\n      this.destination.error(err);\n    }\n  };\n\n  return SkipWhileSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"Sbdl\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FastMap = /*@__PURE__*/function () {\n  function FastMap() {\n    this.values = {};\n  }\n\n  FastMap.prototype.delete = function (key) {\n    this.values[key] = null;\n    return true;\n  };\n\n  FastMap.prototype.set = function (key, value) {\n    this.values[key] = value;\n    return this;\n  };\n\n  FastMap.prototype.get = function (key) {\n    return this.values[key];\n  };\n\n  FastMap.prototype.forEach = function (cb, thisArg) {\n    var values = this.values;\n\n    for (var key in values) {\n      if (values.hasOwnProperty(key) && values[key] !== null) {\n        cb.call(thisArg, values[key], key);\n      }\n    }\n  };\n\n  FastMap.prototype.clear = function () {\n    this.values = {};\n  };\n\n  return FastMap;\n}();\n\nexports.FastMap = FastMap;\n\n/***/ }),\n\n/***/ \"Sevg\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar zip_1 = __webpack_require__(\"Etjs\");\n\nObservable_1.Observable.zip = zip_1.zip; //# sourceMappingURL=zip.js.map\n\n/***/ }),\n\n/***/ \"SfWB\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar webSocket_1 = __webpack_require__(\"AI1+\");\n\nObservable_1.Observable.webSocket = webSocket_1.webSocket; //# sourceMappingURL=webSocket.js.map\n\n/***/ }),\n\n/***/ \"T3D5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar bindCallback_1 = __webpack_require__(\"r9ib\");\n\nObservable_1.Observable.bindCallback = bindCallback_1.bindCallback; //# sourceMappingURL=bindCallback.js.map\n\n/***/ }),\n\n/***/ \"T3HJ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar noop_1 = /*@__PURE__*/__webpack_require__(\"gRDe\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar NeverObservable = function (_super) {\n  __extends(NeverObservable, _super);\n\n  function NeverObservable() {\n    _super.call(this);\n  }\n  /**\n   * Creates an Observable that emits no items to the Observer.\n   *\n   * <span class=\"informal\">An Observable that never emits anything.</span>\n   *\n   * <img src=\"./img/never.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that emits\n   * neither values nor errors nor the completion notification. It can be used\n   * for testing purposes or for composing with other Observables. Please note\n   * that by never emitting a complete notification, this Observable keeps the\n   * subscription from being disposed automatically. Subscriptions need to be\n   * manually disposed.\n   *\n   * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>\n   * function info() {\n   *   console.log('Will not be called');\n   * }\n   * var result = Rx.Observable.never().startWith(7);\n   * result.subscribe(x => console.log(x), info, info);\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link of}\n   * @see {@link throw}\n   *\n   * @return {Observable} A \"never\" Observable: never emits anything.\n   * @static true\n   * @name never\n   * @owner Observable\n   */\n\n\n  NeverObservable.create = function () {\n    return new NeverObservable();\n  };\n  /** @deprecated internal use only */\n\n\n  NeverObservable.prototype._subscribe = function (subscriber) {\n    noop_1.noop();\n  };\n\n  return NeverObservable;\n}(Observable_1.Observable);\n\nexports.NeverObservable = NeverObservable;\n\n/***/ }),\n\n/***/ \"Tb5M\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar noop_1 = /*@__PURE__*/__webpack_require__(\"gRDe\");\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\n\n\nfunction ignoreElements() {\n  return function ignoreElementsOperatorFunction(source) {\n    return source.lift(new IgnoreElementsOperator());\n  };\n}\n\nexports.ignoreElements = ignoreElements;\n\nvar IgnoreElementsOperator = /*@__PURE__*/function () {\n  function IgnoreElementsOperator() {}\n\n  IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n  };\n\n  return IgnoreElementsOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar IgnoreElementsSubscriber = function (_super) {\n  __extends(IgnoreElementsSubscriber, _super);\n\n  function IgnoreElementsSubscriber() {\n    _super.apply(this, arguments);\n  }\n\n  IgnoreElementsSubscriber.prototype._next = function (unused) {\n    noop_1.noop();\n  };\n\n  return IgnoreElementsSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"TiRI\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar SubscriptionLoggable_1 = /*@__PURE__*/__webpack_require__(\"8t1O\");\n\nvar applyMixins_1 = /*@__PURE__*/__webpack_require__(\"QnAi\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar HotObservable = function (_super) {\n  __extends(HotObservable, _super);\n\n  function HotObservable(messages, scheduler) {\n    _super.call(this);\n\n    this.messages = messages;\n    this.subscriptions = [];\n    this.scheduler = scheduler;\n  }\n  /** @deprecated internal use only */\n\n\n  HotObservable.prototype._subscribe = function (subscriber) {\n    var subject = this;\n    var index = subject.logSubscribedFrame();\n    subscriber.add(new Subscription_1.Subscription(function () {\n      subject.logUnsubscribedFrame(index);\n    }));\n    return _super.prototype._subscribe.call(this, subscriber);\n  };\n\n  HotObservable.prototype.setup = function () {\n    var subject = this;\n    var messagesLength = subject.messages.length;\n    /* tslint:disable:no-var-keyword */\n\n    for (var i = 0; i < messagesLength; i++) {\n      (function () {\n        var message = subject.messages[i];\n        /* tslint:enable */\n\n        subject.scheduler.schedule(function () {\n          message.notification.observe(subject);\n        }, message.frame);\n      })();\n    }\n  };\n\n  return HotObservable;\n}(Subject_1.Subject);\n\nexports.HotObservable = HotObservable;\n/*@__PURE__*/\n\napplyMixins_1.applyMixins(HotObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n\n/***/ }),\n\n/***/ \"TzlO\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar debounce_1 = /*@__PURE__*/__webpack_require__(\"zL8T\");\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\n\n\nfunction debounce(durationSelector) {\n  return debounce_1.debounce(durationSelector)(this);\n}\n\nexports.debounce = debounce;\n\n/***/ }),\n\n/***/ \"UCNy\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar takeUntil_1 = __webpack_require__(\"2qLy\");\n\nObservable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil; //# sourceMappingURL=takeUntil.js.map\n\n/***/ }),\n\n/***/ \"UGt1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar skipLast_1 = __webpack_require__(\"h8ds\");\n\nObservable_1.Observable.prototype.skipLast = skipLast_1.skipLast; //# sourceMappingURL=skipLast.js.map\n\n/***/ }),\n\n/***/ \"UUzK\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isArray_1 = /*@__PURE__*/__webpack_require__(\"G2HO\");\n\nvar race_1 = /*@__PURE__*/__webpack_require__(\"6VCA\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\n\n\nfunction race() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return function raceOperatorFunction(source) {\n    // if the only argument is an array, it was most likely called with\n    // `pair([obs1, obs2, ...])`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n      observables = observables[0];\n    }\n\n    return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));\n  };\n}\n\nexports.race = race;\n\n/***/ }),\n\n/***/ \"Ui6c\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar repeat_1 = /*@__PURE__*/__webpack_require__(\"+PC9\");\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\n\n\nfunction repeat(count) {\n  if (count === void 0) {\n    count = -1;\n  }\n\n  return repeat_1.repeat(count)(this);\n}\n\nexports.repeat = repeat;\n\n/***/ }),\n\n/***/ \"UqH8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar TimerObservable_1 = /*@__PURE__*/__webpack_require__(\"YKi8\");\n\nexports.timer = TimerObservable_1.TimerObservable.create;\n\n/***/ }),\n\n/***/ \"V9wX\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FromEventObservable_1 = /*@__PURE__*/__webpack_require__(\"fQTG\");\n\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n\n/***/ }),\n\n/***/ \"VIOb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar exhaust_1 = __webpack_require__(\"onQ2\");\n\nObservable_1.Observable.prototype.exhaust = exhaust_1.exhaust; //# sourceMappingURL=exhaust.js.map\n\n/***/ }),\n\n/***/ \"VLEn\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar startWith_1 = __webpack_require__(\"RM7s\");\n\nObservable_1.Observable.prototype.startWith = startWith_1.startWith; //# sourceMappingURL=startWith.js.map\n\n/***/ }),\n\n/***/ \"VVja\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\n\n\nfunction switchMap(project, resultSelector) {\n  return function switchMapOperatorFunction(source) {\n    return source.lift(new SwitchMapOperator(project, resultSelector));\n  };\n}\n\nexports.switchMap = switchMap;\n\nvar SwitchMapOperator = /*@__PURE__*/function () {\n  function SwitchMapOperator(project, resultSelector) {\n    this.project = project;\n    this.resultSelector = resultSelector;\n  }\n\n  SwitchMapOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n  };\n\n  return SwitchMapOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SwitchMapSubscriber = function (_super) {\n  __extends(SwitchMapSubscriber, _super);\n\n  function SwitchMapSubscriber(destination, project, resultSelector) {\n    _super.call(this, destination);\n\n    this.project = project;\n    this.resultSelector = resultSelector;\n    this.index = 0;\n  }\n\n  SwitchMapSubscriber.prototype._next = function (value) {\n    var result;\n    var index = this.index++;\n\n    try {\n      result = this.project(value, index);\n    } catch (error) {\n      this.destination.error(error);\n      return;\n    }\n\n    this._innerSub(result, value, index);\n  };\n\n  SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n    var innerSubscription = this.innerSubscription;\n\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n\n    this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n  };\n\n  SwitchMapSubscriber.prototype._complete = function () {\n    var innerSubscription = this.innerSubscription;\n\n    if (!innerSubscription || innerSubscription.closed) {\n      _super.prototype._complete.call(this);\n    }\n  };\n  /** @deprecated internal use only */\n\n\n  SwitchMapSubscriber.prototype._unsubscribe = function () {\n    this.innerSubscription = null;\n  };\n\n  SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.innerSubscription = null;\n\n    if (this.isStopped) {\n      _super.prototype._complete.call(this);\n    }\n  };\n\n  SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    if (this.resultSelector) {\n      this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      this.destination.next(innerValue);\n    }\n  };\n\n  SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n    var result;\n\n    try {\n      result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"VZMG\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar QueueAction_1 = /*@__PURE__*/__webpack_require__(\"8qff\");\n\nvar QueueScheduler_1 = /*@__PURE__*/__webpack_require__(\"X46/\");\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * @examples <caption>Schedule recursively first, then do something</caption>\n *\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n *\n *\n * @example <caption>Reschedule itself recursively</caption>\n *\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n *\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\n\n\nexports.queue = /*@__PURE__*/new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n\n/***/ }),\n\n/***/ \"Vmj7\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar isScheduler_1 = /*@__PURE__*/__webpack_require__(\"NwwV\");\n\nvar bufferTime_1 = /*@__PURE__*/__webpack_require__(\"wELj\");\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\n\n\nfunction bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async_1.async;\n\n  if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  var bufferCreationInterval = null;\n\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return bufferTime_1.bufferTime(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler)(this);\n}\n\nexports.bufferTime = bufferTime;\n\n/***/ }),\n\n/***/ \"Vo3M\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar dematerialize_1 = __webpack_require__(\"9pdx\");\n\nObservable_1.Observable.prototype.dematerialize = dematerialize_1.dematerialize; //# sourceMappingURL=dematerialize.js.map\n\n/***/ }),\n\n/***/ \"Vrlg\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar switchMapTo_1 = __webpack_require__(\"27EW\");\n\nObservable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo; //# sourceMappingURL=switchMapTo.js.map\n\n/***/ }),\n\n/***/ \"VthU\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\n\n\nfunction switchMapTo(innerObservable, resultSelector) {\n  return function (source) {\n    return source.lift(new SwitchMapToOperator(innerObservable, resultSelector));\n  };\n}\n\nexports.switchMapTo = switchMapTo;\n\nvar SwitchMapToOperator = /*@__PURE__*/function () {\n  function SwitchMapToOperator(observable, resultSelector) {\n    this.observable = observable;\n    this.resultSelector = resultSelector;\n  }\n\n  SwitchMapToOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n  };\n\n  return SwitchMapToOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SwitchMapToSubscriber = function (_super) {\n  __extends(SwitchMapToSubscriber, _super);\n\n  function SwitchMapToSubscriber(destination, inner, resultSelector) {\n    _super.call(this, destination);\n\n    this.inner = inner;\n    this.resultSelector = resultSelector;\n    this.index = 0;\n  }\n\n  SwitchMapToSubscriber.prototype._next = function (value) {\n    var innerSubscription = this.innerSubscription;\n\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n\n    this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n  };\n\n  SwitchMapToSubscriber.prototype._complete = function () {\n    var innerSubscription = this.innerSubscription;\n\n    if (!innerSubscription || innerSubscription.closed) {\n      _super.prototype._complete.call(this);\n    }\n  };\n  /** @deprecated internal use only */\n\n\n  SwitchMapToSubscriber.prototype._unsubscribe = function () {\n    this.innerSubscription = null;\n  };\n\n  SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.innerSubscription = null;\n\n    if (this.isStopped) {\n      _super.prototype._complete.call(this);\n    }\n  };\n\n  SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    if (resultSelector) {\n      this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  };\n\n  SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    var result;\n\n    try {\n      result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    destination.next(result);\n  };\n\n  return SwitchMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"WC+f\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar concat_1 = /*@__PURE__*/__webpack_require__(\"6oB3\");\n\nvar concat_2 = /*@__PURE__*/__webpack_require__(\"6oB3\");\n\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\n\nfunction concat() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return function (source) {\n    return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables)));\n  };\n}\n\nexports.concat = concat;\n\n/***/ }),\n\n/***/ \"WO4J\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar ArgumentOutOfRangeError_1 = /*@__PURE__*/__webpack_require__(\"8kg7\");\n\nvar EmptyObservable_1 = /*@__PURE__*/__webpack_require__(\"36rE\");\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * <img src=\"./img/takeLast.png\" width=\"100%\">\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * @example <caption>Take the last 3 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 100);\n * var lastThree = many.takeLast(3);\n * lastThree.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\n\n\nfunction takeLast(count) {\n  return function takeLastOperatorFunction(source) {\n    if (count === 0) {\n      return new EmptyObservable_1.EmptyObservable();\n    } else {\n      return source.lift(new TakeLastOperator(count));\n    }\n  };\n}\n\nexports.takeLast = takeLast;\n\nvar TakeLastOperator = /*@__PURE__*/function () {\n  function TakeLastOperator(total) {\n    this.total = total;\n\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();\n    }\n  }\n\n  TakeLastOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n  };\n\n  return TakeLastOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar TakeLastSubscriber = function (_super) {\n  __extends(TakeLastSubscriber, _super);\n\n  function TakeLastSubscriber(destination, total) {\n    _super.call(this, destination);\n\n    this.total = total;\n    this.ring = new Array();\n    this.count = 0;\n  }\n\n  TakeLastSubscriber.prototype._next = function (value) {\n    var ring = this.ring;\n    var total = this.total;\n    var count = this.count++;\n\n    if (ring.length < total) {\n      ring.push(value);\n    } else {\n      var index = count % total;\n      ring[index] = value;\n    }\n  };\n\n  TakeLastSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n    var count = this.count;\n\n    if (count > 0) {\n      var total = this.count >= this.total ? this.total : this.count;\n      var ring = this.ring;\n\n      for (var i = 0; i < total; i++) {\n        var idx = count++ % total;\n        destination.next(ring[idx]);\n      }\n    }\n\n    destination.complete();\n  };\n\n  return TakeLastSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"WQoq\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\n\n\nfunction sample(notifier) {\n  return function (source) {\n    return source.lift(new SampleOperator(notifier));\n  };\n}\n\nexports.sample = sample;\n\nvar SampleOperator = /*@__PURE__*/function () {\n  function SampleOperator(notifier) {\n    this.notifier = notifier;\n  }\n\n  SampleOperator.prototype.call = function (subscriber, source) {\n    var sampleSubscriber = new SampleSubscriber(subscriber);\n    var subscription = source.subscribe(sampleSubscriber);\n    subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));\n    return subscription;\n  };\n\n  return SampleOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SampleSubscriber = function (_super) {\n  __extends(SampleSubscriber, _super);\n\n  function SampleSubscriber() {\n    _super.apply(this, arguments);\n\n    this.hasValue = false;\n  }\n\n  SampleSubscriber.prototype._next = function (value) {\n    this.value = value;\n    this.hasValue = true;\n  };\n\n  SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.emitValue();\n  };\n\n  SampleSubscriber.prototype.notifyComplete = function () {\n    this.emitValue();\n  };\n\n  SampleSubscriber.prototype.emitValue = function () {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.value);\n    }\n  };\n\n  return SampleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"WU5C\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nfunction getSymbolObservable(context) {\n  var $$observable;\n  var Symbol = context.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n      $$observable = Symbol.observable;\n    } else {\n      $$observable = Symbol('observable');\n      Symbol.observable = $$observable;\n    }\n  } else {\n    $$observable = '@@observable';\n  }\n\n  return $$observable;\n}\n\nexports.getSymbolObservable = getSymbolObservable;\nexports.observable = /*@__PURE__*/getSymbolObservable(root_1.root);\n/**\n * @deprecated use observable instead\n */\n\nexports.$$observable = exports.observable;\n\n/***/ }),\n\n/***/ \"WesY\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar AsyncAction_1 = /*@__PURE__*/__webpack_require__(\"g2Fv\");\n\nvar AnimationFrame_1 = /*@__PURE__*/__webpack_require__(\"Zn6/\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar AnimationFrameAction = function (_super) {\n  __extends(AnimationFrameAction, _super);\n\n  function AnimationFrameAction(scheduler, work) {\n    _super.call(this, scheduler, work);\n\n    this.scheduler = scheduler;\n    this.work = work;\n  }\n\n  AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    } // If delay is greater than 0, request as an async action.\n\n\n    if (delay !== null && delay > 0) {\n      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n    } // Push the action to the end of the scheduler queue.\n\n\n    scheduler.actions.push(this); // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n\n    return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));\n  };\n\n  AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    } // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n\n    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {\n      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n    } // If the scheduler queue is empty, cancel the requested animation frame and\n    // set the scheduled flag to undefined so the next AnimationFrameAction will\n    // request its own.\n\n\n    if (scheduler.actions.length === 0) {\n      AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);\n      scheduler.scheduled = undefined;\n    } // Return undefined so the action knows to request a new async id if it's rescheduled.\n\n\n    return undefined;\n  };\n\n  return AnimationFrameAction;\n}(AsyncAction_1.AsyncAction);\n\nexports.AnimationFrameAction = AnimationFrameAction;\n\n/***/ }),\n\n/***/ \"WgKs\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\n\n\nfunction skipUntil(notifier) {\n  return function (source) {\n    return source.lift(new SkipUntilOperator(notifier));\n  };\n}\n\nexports.skipUntil = skipUntil;\n\nvar SkipUntilOperator = /*@__PURE__*/function () {\n  function SkipUntilOperator(notifier) {\n    this.notifier = notifier;\n  }\n\n  SkipUntilOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n  };\n\n  return SkipUntilOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SkipUntilSubscriber = function (_super) {\n  __extends(SkipUntilSubscriber, _super);\n\n  function SkipUntilSubscriber(destination, notifier) {\n    _super.call(this, destination);\n\n    this.hasValue = false;\n    this.isInnerStopped = false;\n    this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n  }\n\n  SkipUntilSubscriber.prototype._next = function (value) {\n    if (this.hasValue) {\n      _super.prototype._next.call(this, value);\n    }\n  };\n\n  SkipUntilSubscriber.prototype._complete = function () {\n    if (this.isInnerStopped) {\n      _super.prototype._complete.call(this);\n    } else {\n      this.unsubscribe();\n    }\n  };\n\n  SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.hasValue = true;\n  };\n\n  SkipUntilSubscriber.prototype.notifyComplete = function () {\n    this.isInnerStopped = true;\n\n    if (this.isStopped) {\n      _super.prototype._complete.call(this);\n    }\n  };\n\n  return SkipUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"Wv9J\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar single_1 = __webpack_require__(\"zMOc\");\n\nObservable_1.Observable.prototype.single = single_1.single; //# sourceMappingURL=single.js.map\n\n/***/ }),\n\n/***/ \"X/dC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar multicast_1 = /*@__PURE__*/__webpack_require__(\"cf1P\");\n\nvar refCount_1 = /*@__PURE__*/__webpack_require__(\"pk/4\");\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nfunction shareSubjectFactory() {\n  return new Subject_1.Subject();\n}\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for .multicast(() => new Subject()).refCount().\n *\n * <img src=\"./img/share.png\" width=\"100%\">\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\n\n\nfunction share() {\n  return function (source) {\n    return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source));\n  };\n}\n\nexports.share = share;\n;\n\n/***/ }),\n\n/***/ \"X46/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar AsyncScheduler_1 = /*@__PURE__*/__webpack_require__(\"FXL7\");\n\nvar QueueScheduler = function (_super) {\n  __extends(QueueScheduler, _super);\n\n  function QueueScheduler() {\n    _super.apply(this, arguments);\n  }\n\n  return QueueScheduler;\n}(AsyncScheduler_1.AsyncScheduler);\n\nexports.QueueScheduler = QueueScheduler;\n\n/***/ }),\n\n/***/ \"X7Im\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar throttle_1 = /*@__PURE__*/__webpack_require__(\"o6MN\");\n\nvar throttleTime_1 = /*@__PURE__*/__webpack_require__(\"BnoD\");\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\n\n\nfunction throttleTime(duration, scheduler, config) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  if (config === void 0) {\n    config = throttle_1.defaultThrottleConfig;\n  }\n\n  return throttleTime_1.throttleTime(duration, scheduler, config)(this);\n}\n\nexports.throttleTime = throttleTime;\n\n/***/ }),\n\n/***/ \"XMAI\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar windowCount_1 = __webpack_require__(\"I+lI\");\n\nObservable_1.Observable.prototype.windowCount = windowCount_1.windowCount; //# sourceMappingURL=windowCount.js.map\n\n/***/ }),\n\n/***/ \"XNQH\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nfunction isEmpty() {\n  return function (source) {\n    return source.lift(new IsEmptyOperator());\n  };\n}\n\nexports.isEmpty = isEmpty;\n\nvar IsEmptyOperator = /*@__PURE__*/function () {\n  function IsEmptyOperator() {}\n\n  IsEmptyOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new IsEmptySubscriber(observer));\n  };\n\n  return IsEmptyOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar IsEmptySubscriber = function (_super) {\n  __extends(IsEmptySubscriber, _super);\n\n  function IsEmptySubscriber(destination) {\n    _super.call(this, destination);\n  }\n\n  IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n    var destination = this.destination;\n    destination.next(isEmpty);\n    destination.complete();\n  };\n\n  IsEmptySubscriber.prototype._next = function (value) {\n    this.notifyComplete(false);\n  };\n\n  IsEmptySubscriber.prototype._complete = function () {\n    this.notifyComplete(true);\n  };\n\n  return IsEmptySubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"Xn12\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar merge_1 = __webpack_require__(\"MdjT\");\n\nObservable_1.Observable.merge = merge_1.merge; //# sourceMappingURL=merge.js.map\n\n/***/ }),\n\n/***/ \"Xrsd\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar EmptyError_1 = /*@__PURE__*/__webpack_require__(\"2fIB\");\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate.\n .\n * @method single\n * @owner Observable\n */\n\n\nfunction single(predicate) {\n  return function (source) {\n    return source.lift(new SingleOperator(predicate, source));\n  };\n}\n\nexports.single = single;\n\nvar SingleOperator = /*@__PURE__*/function () {\n  function SingleOperator(predicate, source) {\n    this.predicate = predicate;\n    this.source = source;\n  }\n\n  SingleOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n  };\n\n  return SingleOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SingleSubscriber = function (_super) {\n  __extends(SingleSubscriber, _super);\n\n  function SingleSubscriber(destination, predicate, source) {\n    _super.call(this, destination);\n\n    this.predicate = predicate;\n    this.source = source;\n    this.seenValue = false;\n    this.index = 0;\n  }\n\n  SingleSubscriber.prototype.applySingleValue = function (value) {\n    if (this.seenValue) {\n      this.destination.error('Sequence contains more than one element');\n    } else {\n      this.seenValue = true;\n      this.singleValue = value;\n    }\n  };\n\n  SingleSubscriber.prototype._next = function (value) {\n    var index = this.index++;\n\n    if (this.predicate) {\n      this.tryNext(value, index);\n    } else {\n      this.applySingleValue(value);\n    }\n  };\n\n  SingleSubscriber.prototype.tryNext = function (value, index) {\n    try {\n      if (this.predicate(value, index, this.source)) {\n        this.applySingleValue(value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  };\n\n  SingleSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n\n    if (this.index > 0) {\n      destination.next(this.seenValue ? this.singleValue : undefined);\n      destination.complete();\n    } else {\n      destination.error(new EmptyError_1.EmptyError());\n    }\n  };\n\n  return SingleSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"XzFz\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar zipAll_1 = __webpack_require__(\"fTxW\");\n\nObservable_1.Observable.prototype.zipAll = zipAll_1.zipAll; //# sourceMappingURL=zipAll.js.map\n\n/***/ }),\n\n/***/ \"Y4yW\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar audit_1 = __webpack_require__(\"d+Tj\");\n\nObservable_1.Observable.prototype.audit = audit_1.audit; //# sourceMappingURL=audit.js.map\n\n/***/ }),\n\n/***/ \"YJDk\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar mapTo_1 = /*@__PURE__*/__webpack_require__(\"saxw\");\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\n\n\nfunction mapTo(value) {\n  return mapTo_1.mapTo(value)(this);\n}\n\nexports.mapTo = mapTo;\n\n/***/ }),\n\n/***/ \"YKi8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar isNumeric_1 = /*@__PURE__*/__webpack_require__(\"zZI/\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar isScheduler_1 = /*@__PURE__*/__webpack_require__(\"NwwV\");\n\nvar isDate_1 = /*@__PURE__*/__webpack_require__(\"hut+\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar TimerObservable = function (_super) {\n  __extends(TimerObservable, _super);\n\n  function TimerObservable(dueTime, period, scheduler) {\n    if (dueTime === void 0) {\n      dueTime = 0;\n    }\n\n    _super.call(this);\n\n    this.period = -1;\n    this.dueTime = 0;\n\n    if (isNumeric_1.isNumeric(period)) {\n      this.period = Number(period) < 1 && 1 || Number(period);\n    } else if (isScheduler_1.isScheduler(period)) {\n      scheduler = period;\n    }\n\n    if (!isScheduler_1.isScheduler(scheduler)) {\n      scheduler = async_1.async;\n    }\n\n    this.scheduler = scheduler;\n    this.dueTime = isDate_1.isDate(dueTime) ? +dueTime - this.scheduler.now() : dueTime;\n  }\n  /**\n   * Creates an Observable that starts emitting after an `initialDelay` and\n   * emits ever increasing numbers after each `period` of time thereafter.\n   *\n   * <span class=\"informal\">Its like {@link interval}, but you can specify when\n   * should the emissions start.</span>\n   *\n   * <img src=\"./img/timer.png\" width=\"100%\">\n   *\n   * `timer` returns an Observable that emits an infinite sequence of ascending\n   * integers, with a constant interval of time, `period` of your choosing\n   * between those emissions. The first emission happens after the specified\n   * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n   * operator uses the `async` IScheduler to provide a notion of time, but you\n   * may pass any IScheduler to it. If `period` is not specified, the output\n   * Observable emits only one value, `0`. Otherwise, it emits an infinite\n   * sequence.\n   *\n   * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n   * var numbers = Rx.Observable.timer(3000, 1000);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @example <caption>Emits one number after five seconds</caption>\n   * var numbers = Rx.Observable.timer(5000);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @see {@link interval}\n   * @see {@link delay}\n   *\n   * @param {number|Date} initialDelay The initial delay time to wait before\n   * emitting the first value of `0`.\n   * @param {number} [period] The period of time between emissions of the\n   * subsequent numbers.\n   * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n   * the emission of values, and providing a notion of \"time\".\n   * @return {Observable} An Observable that emits a `0` after the\n   * `initialDelay` and ever increasing numbers after each `period` of time\n   * thereafter.\n   * @static true\n   * @name timer\n   * @owner Observable\n   */\n\n\n  TimerObservable.create = function (initialDelay, period, scheduler) {\n    if (initialDelay === void 0) {\n      initialDelay = 0;\n    }\n\n    return new TimerObservable(initialDelay, period, scheduler);\n  };\n\n  TimerObservable.dispatch = function (state) {\n    var index = state.index,\n        period = state.period,\n        subscriber = state.subscriber;\n    var action = this;\n    subscriber.next(index);\n\n    if (subscriber.closed) {\n      return;\n    } else if (period === -1) {\n      return subscriber.complete();\n    }\n\n    state.index = index + 1;\n    action.schedule(state, period);\n  };\n  /** @deprecated internal use only */\n\n\n  TimerObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n\n    var _a = this,\n        period = _a.period,\n        dueTime = _a.dueTime,\n        scheduler = _a.scheduler;\n\n    return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n      index: index,\n      period: period,\n      subscriber: subscriber\n    });\n  };\n\n  return TimerObservable;\n}(Observable_1.Observable);\n\nexports.TimerObservable = TimerObservable;\n\n/***/ }),\n\n/***/ \"Yjb7\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isScheduler_1 = /*@__PURE__*/__webpack_require__(\"NwwV\");\n\nvar isArray_1 = /*@__PURE__*/__webpack_require__(\"G2HO\");\n\nvar ArrayObservable_1 = /*@__PURE__*/__webpack_require__(\"rVFa\");\n\nvar combineLatest_1 = /*@__PURE__*/__webpack_require__(\"SWOv\");\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from all the Observables passed as\n * arguments. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to operator,\n * returned Observable will always emit an array of `n` values, in order\n * corresponding to order of passed Observables (value from the first Observable\n * on the first place and so on).\n *\n * Static version of `combineLatest` accepts either an array of Observables\n * or each Observable can be put directly as an argument. Note that array of\n * Observables is good choice, if you don't know beforehand how many Observables\n * you will combine. Passing empty array will result in Observable that\n * completes immediately.\n *\n * To ensure output array has always the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all that values but last\n * will be lost. On the other hand, is some Observable does not emit value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will be now impossible to include value from\n * completed Observable in resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * `combineLatest` accepts as optional parameter `project` function, which takes\n * as arguments all values that would normally be emitted by resulting Observable.\n * `project` can return any kind of value, which will be then emitted by Observable\n * instead of default array. Note that `project` does not take as argument that array\n * of values, but values themselves. That means default `project` can be imagined\n * as function that takes all its arguments and puts them into an array.\n *\n *\n * @example <caption>Combine two timer Observables</caption>\n * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n *\n *\n * @example <caption>Combine an array of Observables</caption>\n * const observables = [1, 5, 10].map(\n *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds\n * );\n * const combined = Rx.Observable.combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n *\n *\n * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\n * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\n * More than one input Observables may be given as arguments\n * or an array of Observables may be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @static true\n * @name combineLatest\n * @owner Observable\n */\n\n\nfunction combineLatest() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  var project = null;\n  var scheduler = null;\n\n  if (isScheduler_1.isScheduler(observables[observables.length - 1])) {\n    scheduler = observables.pop();\n  }\n\n  if (typeof observables[observables.length - 1] === 'function') {\n    project = observables.pop();\n  } // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n\n\n  if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n    observables = observables[0];\n  }\n\n  return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));\n}\n\nexports.combineLatest = combineLatest;\n\n/***/ }),\n\n/***/ \"Z57B\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar map_1 = /*@__PURE__*/__webpack_require__(\"aK2G\");\n/**\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\n\n\nfunction timestamp(scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return map_1.map(function (value) {\n    return new Timestamp(value, scheduler.now());\n  }); // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));\n}\n\nexports.timestamp = timestamp;\n\nvar Timestamp = /*@__PURE__*/function () {\n  function Timestamp(value, timestamp) {\n    this.value = value;\n    this.timestamp = timestamp;\n  }\n\n  return Timestamp;\n}();\n\nexports.Timestamp = Timestamp;\n;\n\n/***/ }),\n\n/***/ \"ZCeS\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\n\nvar Scheduler = /*@__PURE__*/function () {\n  function Scheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    this.SchedulerAction = SchedulerAction;\n    this.now = now;\n  }\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n\n\n  Scheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return new this.SchedulerAction(this, work).schedule(state, delay);\n  };\n\n  Scheduler.now = Date.now ? Date.now : function () {\n    return +new Date();\n  };\n  return Scheduler;\n}();\n\nexports.Scheduler = Scheduler;\n\n/***/ }),\n\n/***/ \"ZTY5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar toArray_1 = /*@__PURE__*/__webpack_require__(\"M6BU\");\n/**\n * Collects all source emissions and emits them as an array when the source completes.\n *\n * <span class=\"informal\">Get all values inside an array when the source completes</span>\n *\n * <img src=\"./img/toArray.png\" width=\"100%\">\n *\n * `toArray` will wait until the source Observable completes\n * before emitting the array containing all emissions.\n * When the source Observable errors no array will be emitted.\n *\n * @example <caption>Create array from input</caption>\n * const input = Rx.Observable.interval(100).take(4);\n *\n * input.toArray()\n *   .subscribe(arr => console.log(arr)); // [0,1,2,3]\n *\n * @see {@link buffer}\n *\n * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}\n * @method toArray\n * @owner Observable\n */\n\n\nfunction toArray() {\n  return toArray_1.toArray()(this);\n}\n\nexports.toArray = toArray;\n\n/***/ }),\n\n/***/ \"ZXB4\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\n\n\nfunction filter(predicate, thisArg) {\n  return function filterOperatorFunction(source) {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nexports.filter = filter;\n\nvar FilterOperator = /*@__PURE__*/function () {\n  function FilterOperator(predicate, thisArg) {\n    this.predicate = predicate;\n    this.thisArg = thisArg;\n  }\n\n  FilterOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  };\n\n  return FilterOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar FilterSubscriber = function (_super) {\n  __extends(FilterSubscriber, _super);\n\n  function FilterSubscriber(destination, predicate, thisArg) {\n    _super.call(this, destination);\n\n    this.predicate = predicate;\n    this.thisArg = thisArg;\n    this.count = 0;\n  } // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n\n\n  FilterSubscriber.prototype._next = function (value) {\n    var result;\n\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.destination.next(value);\n    }\n  };\n\n  return FilterSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"Zn6/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nvar RequestAnimationFrameDefinition = /*@__PURE__*/function () {\n  function RequestAnimationFrameDefinition(root) {\n    if (root.requestAnimationFrame) {\n      this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);\n      this.requestAnimationFrame = root.requestAnimationFrame.bind(root);\n    } else if (root.mozRequestAnimationFrame) {\n      this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);\n      this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);\n    } else if (root.webkitRequestAnimationFrame) {\n      this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);\n      this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);\n    } else if (root.msRequestAnimationFrame) {\n      this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);\n      this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);\n    } else if (root.oRequestAnimationFrame) {\n      this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);\n      this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);\n    } else {\n      this.cancelAnimationFrame = root.clearTimeout.bind(root);\n\n      this.requestAnimationFrame = function (cb) {\n        return root.setTimeout(cb, 1000 / 60);\n      };\n    }\n  }\n\n  return RequestAnimationFrameDefinition;\n}();\n\nexports.RequestAnimationFrameDefinition = RequestAnimationFrameDefinition;\nexports.AnimationFrame = /*@__PURE__*/new RequestAnimationFrameDefinition(root_1.root);\n\n/***/ }),\n\n/***/ \"ZnfZ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar Notification_1 = /*@__PURE__*/__webpack_require__(\"9x29\");\n\nvar ColdObservable_1 = /*@__PURE__*/__webpack_require__(\"/AUE\");\n\nvar HotObservable_1 = /*@__PURE__*/__webpack_require__(\"TiRI\");\n\nvar SubscriptionLog_1 = /*@__PURE__*/__webpack_require__(\"5TWj\");\n\nvar VirtualTimeScheduler_1 = /*@__PURE__*/__webpack_require__(\"J9JT\");\n\nvar defaultMaxFrame = 750;\n\nvar TestScheduler = function (_super) {\n  __extends(TestScheduler, _super);\n\n  function TestScheduler(assertDeepEqual) {\n    _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);\n\n    this.assertDeepEqual = assertDeepEqual;\n    this.hotObservables = [];\n    this.coldObservables = [];\n    this.flushTests = [];\n  }\n\n  TestScheduler.prototype.createTime = function (marbles) {\n    var indexOf = marbles.indexOf('|');\n\n    if (indexOf === -1) {\n      throw new Error('marble diagram for time should have a completion marker \"|\"');\n    }\n\n    return indexOf * TestScheduler.frameTimeFactor;\n  };\n\n  TestScheduler.prototype.createColdObservable = function (marbles, values, error) {\n    if (marbles.indexOf('^') !== -1) {\n      throw new Error('cold observable cannot have subscription offset \"^\"');\n    }\n\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('cold observable cannot have unsubscription marker \"!\"');\n    }\n\n    var messages = TestScheduler.parseMarbles(marbles, values, error);\n    var cold = new ColdObservable_1.ColdObservable(messages, this);\n    this.coldObservables.push(cold);\n    return cold;\n  };\n\n  TestScheduler.prototype.createHotObservable = function (marbles, values, error) {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('hot observable cannot have unsubscription marker \"!\"');\n    }\n\n    var messages = TestScheduler.parseMarbles(marbles, values, error);\n    var subject = new HotObservable_1.HotObservable(messages, this);\n    this.hotObservables.push(subject);\n    return subject;\n  };\n\n  TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {\n    var _this = this;\n\n    var messages = [];\n    observable.subscribe(function (value) {\n      messages.push({\n        frame: _this.frame - outerFrame,\n        notification: Notification_1.Notification.createNext(value)\n      });\n    }, function (err) {\n      messages.push({\n        frame: _this.frame - outerFrame,\n        notification: Notification_1.Notification.createError(err)\n      });\n    }, function () {\n      messages.push({\n        frame: _this.frame - outerFrame,\n        notification: Notification_1.Notification.createComplete()\n      });\n    });\n    return messages;\n  };\n\n  TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {\n    var _this = this;\n\n    if (unsubscriptionMarbles === void 0) {\n      unsubscriptionMarbles = null;\n    }\n\n    var actual = [];\n    var flushTest = {\n      actual: actual,\n      ready: false\n    };\n    var unsubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;\n    var subscription;\n    this.schedule(function () {\n      subscription = observable.subscribe(function (x) {\n        var value = x; // Support Observable-of-Observables\n\n        if (x instanceof Observable_1.Observable) {\n          value = _this.materializeInnerObservable(value, _this.frame);\n        }\n\n        actual.push({\n          frame: _this.frame,\n          notification: Notification_1.Notification.createNext(value)\n        });\n      }, function (err) {\n        actual.push({\n          frame: _this.frame,\n          notification: Notification_1.Notification.createError(err)\n        });\n      }, function () {\n        actual.push({\n          frame: _this.frame,\n          notification: Notification_1.Notification.createComplete()\n        });\n      });\n    }, 0);\n\n    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n      this.schedule(function () {\n        return subscription.unsubscribe();\n      }, unsubscriptionFrame);\n    }\n\n    this.flushTests.push(flushTest);\n    return {\n      toBe: function toBe(marbles, values, errorValue) {\n        flushTest.ready = true;\n        flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);\n      }\n    };\n  };\n\n  TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {\n    var flushTest = {\n      actual: actualSubscriptionLogs,\n      ready: false\n    };\n    this.flushTests.push(flushTest);\n    return {\n      toBe: function toBe(marbles) {\n        var marblesArray = typeof marbles === 'string' ? [marbles] : marbles;\n        flushTest.ready = true;\n        flushTest.expected = marblesArray.map(function (marbles) {\n          return TestScheduler.parseMarblesAsSubscriptions(marbles);\n        });\n      }\n    };\n  };\n\n  TestScheduler.prototype.flush = function () {\n    var hotObservables = this.hotObservables;\n\n    while (hotObservables.length > 0) {\n      hotObservables.shift().setup();\n    }\n\n    _super.prototype.flush.call(this);\n\n    var readyFlushTests = this.flushTests.filter(function (test) {\n      return test.ready;\n    });\n\n    while (readyFlushTests.length > 0) {\n      var test = readyFlushTests.shift();\n      this.assertDeepEqual(test.actual, test.expected);\n    }\n  };\n\n  TestScheduler.parseMarblesAsSubscriptions = function (marbles) {\n    if (typeof marbles !== 'string') {\n      return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);\n    }\n\n    var len = marbles.length;\n    var groupStart = -1;\n    var subscriptionFrame = Number.POSITIVE_INFINITY;\n    var unsubscriptionFrame = Number.POSITIVE_INFINITY;\n\n    for (var i = 0; i < len; i++) {\n      var frame = i * this.frameTimeFactor;\n      var c = marbles[i];\n\n      switch (c) {\n        case '-':\n        case ' ':\n          break;\n\n        case '(':\n          groupStart = frame;\n          break;\n\n        case ')':\n          groupStart = -1;\n          break;\n\n        case '^':\n          if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n          }\n\n          subscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n\n        case '!':\n          if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n          }\n\n          unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n\n        default:\n          throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' + 'subscription marble diagram. Found instead \\'' + c + '\\'.');\n      }\n    }\n\n    if (unsubscriptionFrame < 0) {\n      return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);\n    } else {\n      return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n    }\n  };\n\n  TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {\n    if (materializeInnerObservables === void 0) {\n      materializeInnerObservables = false;\n    }\n\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker \"!\"');\n    }\n\n    var len = marbles.length;\n    var testMessages = [];\n    var subIndex = marbles.indexOf('^');\n    var frameOffset = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;\n    var getValue = typeof values !== 'object' ? function (x) {\n      return x;\n    } : function (x) {\n      // Support Observable-of-Observables\n      if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {\n        return values[x].messages;\n      }\n\n      return values[x];\n    };\n    var groupStart = -1;\n\n    for (var i = 0; i < len; i++) {\n      var frame = i * this.frameTimeFactor + frameOffset;\n      var notification = void 0;\n      var c = marbles[i];\n\n      switch (c) {\n        case '-':\n        case ' ':\n          break;\n\n        case '(':\n          groupStart = frame;\n          break;\n\n        case ')':\n          groupStart = -1;\n          break;\n\n        case '|':\n          notification = Notification_1.Notification.createComplete();\n          break;\n\n        case '^':\n          break;\n\n        case '#':\n          notification = Notification_1.Notification.createError(errorValue || 'error');\n          break;\n\n        default:\n          notification = Notification_1.Notification.createNext(getValue(c));\n          break;\n      }\n\n      if (notification) {\n        testMessages.push({\n          frame: groupStart > -1 ? groupStart : frame,\n          notification: notification\n        });\n      }\n    }\n\n    return testMessages;\n  };\n\n  return TestScheduler;\n}(VirtualTimeScheduler_1.VirtualTimeScheduler);\n\nexports.TestScheduler = TestScheduler;\n\n/***/ }),\n\n/***/ \"Zo/K\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nfunction dispatch(state) {\n  var obj = state.obj,\n      keys = state.keys,\n      length = state.length,\n      index = state.index,\n      subscriber = state.subscriber;\n\n  if (index === length) {\n    subscriber.complete();\n    return;\n  }\n\n  var key = keys[index];\n  subscriber.next([key, obj[key]]);\n  state.index = index + 1;\n  this.schedule(state);\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar PairsObservable = function (_super) {\n  __extends(PairsObservable, _super);\n\n  function PairsObservable(obj, scheduler) {\n    _super.call(this);\n\n    this.obj = obj;\n    this.scheduler = scheduler;\n    this.keys = Object.keys(obj);\n  }\n  /**\n   * Convert an object into an observable sequence of [key, value] pairs\n   * using an optional IScheduler to enumerate the object.\n   *\n   * @example <caption>Converts a javascript object to an Observable</caption>\n   * var obj = {\n   *   foo: 42,\n   *   bar: 56,\n   *   baz: 78\n   * };\n   *\n   * var source = Rx.Observable.pairs(obj);\n   *\n   * var subscription = source.subscribe(\n   *   function (x) {\n   *     console.log('Next: %s', x);\n   *   },\n   *   function (err) {\n   *     console.log('Error: %s', err);\n   *   },\n   *   function () {\n   *     console.log('Completed');\n   *   });\n   *\n   * @param {Object} obj The object to inspect and turn into an\n   * Observable sequence.\n   * @param {Scheduler} [scheduler] An optional IScheduler to run the\n   * enumeration of the input sequence on.\n   * @returns {(Observable<Array<string | T>>)} An observable sequence of\n   * [key, value] pairs from the object.\n   */\n\n\n  PairsObservable.create = function (obj, scheduler) {\n    return new PairsObservable(obj, scheduler);\n  };\n  /** @deprecated internal use only */\n\n\n  PairsObservable.prototype._subscribe = function (subscriber) {\n    var _a = this,\n        keys = _a.keys,\n        scheduler = _a.scheduler;\n\n    var length = keys.length;\n\n    if (scheduler) {\n      return scheduler.schedule(dispatch, 0, {\n        obj: this.obj,\n        keys: keys,\n        length: length,\n        index: 0,\n        subscriber: subscriber\n      });\n    } else {\n      for (var idx = 0; idx < length; idx++) {\n        var key = keys[idx];\n        subscriber.next([key, this.obj[key]]);\n      }\n\n      subscriber.complete();\n    }\n  };\n\n  return PairsObservable;\n}(Observable_1.Observable);\n\nexports.PairsObservable = PairsObservable;\n\n/***/ }),\n\n/***/ \"ZzdT\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar bufferWhen_1 = __webpack_require__(\"OmKy\");\n\nObservable_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen; //# sourceMappingURL=bufferWhen.js.map\n\n/***/ }),\n\n/***/ \"aK2G\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\n\n\nfunction map(project, thisArg) {\n  return function mapOperation(source) {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexports.map = map;\n\nvar MapOperator = /*@__PURE__*/function () {\n  function MapOperator(project, thisArg) {\n    this.project = project;\n    this.thisArg = thisArg;\n  }\n\n  MapOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  };\n\n  return MapOperator;\n}();\n\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar MapSubscriber = function (_super) {\n  __extends(MapSubscriber, _super);\n\n  function MapSubscriber(destination, project, thisArg) {\n    _super.call(this, destination);\n\n    this.project = project;\n    this.count = 0;\n    this.thisArg = thisArg || this;\n  } // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n\n\n  MapSubscriber.prototype._next = function (value) {\n    var result;\n\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return MapSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"aUw6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar throw_1 = __webpack_require__(\"GHBr\");\n\nObservable_1.Observable.throw = throw_1._throw; //# sourceMappingURL=throw.js.map\n\n/***/ }),\n\n/***/ \"aea6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar sampleTime_1 = /*@__PURE__*/__webpack_require__(\"7LGj\");\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * @example <caption>Every second, emit the most recent click at most once</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.sampleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\n\n\nfunction sampleTime(period, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return sampleTime_1.sampleTime(period, scheduler)(this);\n}\n\nexports.sampleTime = sampleTime;\n\n/***/ }),\n\n/***/ \"agdi\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar timeoutWith_1 = /*@__PURE__*/__webpack_require__(\"uj+q\");\n/* tslint:enable:max-line-length */\n\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * @example <caption>Add fallback observable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const minutes = Rx.Observable.interval(60 * 1000);\n *\n * seconds.timeoutWith(900, minutes)\n *     .subscribe(\n *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                      // since first value of `seconds` will not arrive fast enough.\n *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n *                                 // but here will never be called.\n *     );\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\n\n\nfunction timeoutWith(due, withObservable, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return timeoutWith_1.timeoutWith(due, withObservable, scheduler)(this);\n}\n\nexports.timeoutWith = timeoutWith;\n\n/***/ }),\n\n/***/ \"ast0\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\n\n\nfunction windowCount(windowSize, startWindowEvery) {\n  if (startWindowEvery === void 0) {\n    startWindowEvery = 0;\n  }\n\n  return function windowCountOperatorFunction(source) {\n    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n  };\n}\n\nexports.windowCount = windowCount;\n\nvar WindowCountOperator = /*@__PURE__*/function () {\n  function WindowCountOperator(windowSize, startWindowEvery) {\n    this.windowSize = windowSize;\n    this.startWindowEvery = startWindowEvery;\n  }\n\n  WindowCountOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n  };\n\n  return WindowCountOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar WindowCountSubscriber = function (_super) {\n  __extends(WindowCountSubscriber, _super);\n\n  function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n    _super.call(this, destination);\n\n    this.destination = destination;\n    this.windowSize = windowSize;\n    this.startWindowEvery = startWindowEvery;\n    this.windows = [new Subject_1.Subject()];\n    this.count = 0;\n    destination.next(this.windows[0]);\n  }\n\n  WindowCountSubscriber.prototype._next = function (value) {\n    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;\n    var destination = this.destination;\n    var windowSize = this.windowSize;\n    var windows = this.windows;\n    var len = windows.length;\n\n    for (var i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n\n    var c = this.count - windowSize + 1;\n\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      var window_1 = new Subject_1.Subject();\n      windows.push(window_1);\n      destination.next(window_1);\n    }\n  };\n\n  WindowCountSubscriber.prototype._error = function (err) {\n    var windows = this.windows;\n\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n\n    this.destination.error(err);\n  };\n\n  WindowCountSubscriber.prototype._complete = function () {\n    var windows = this.windows;\n\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n\n    this.destination.complete();\n  };\n  /** @deprecated internal use only */\n\n\n  WindowCountSubscriber.prototype._unsubscribe = function () {\n    this.count = 0;\n    this.windows = null;\n  };\n\n  return WindowCountSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"b4nC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar timestamp_1 = __webpack_require__(\"uH8Z\");\n\nObservable_1.Observable.prototype.timestamp = timestamp_1.timestamp; //# sourceMappingURL=timestamp.js.map\n\n/***/ }),\n\n/***/ \"bIKf\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Immediate_1 = /*@__PURE__*/__webpack_require__(\"Hbpk\");\n\nvar AsyncAction_1 = /*@__PURE__*/__webpack_require__(\"g2Fv\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar AsapAction = function (_super) {\n  __extends(AsapAction, _super);\n\n  function AsapAction(scheduler, work) {\n    _super.call(this, scheduler, work);\n\n    this.scheduler = scheduler;\n    this.work = work;\n  }\n\n  AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    } // If delay is greater than 0, request as an async action.\n\n\n    if (delay !== null && delay > 0) {\n      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n    } // Push the action to the end of the scheduler queue.\n\n\n    scheduler.actions.push(this); // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n\n    return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n  };\n\n  AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    } // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n\n    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {\n      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n    } // If the scheduler queue is empty, cancel the requested microtask and\n    // set the scheduled flag to undefined so the next AsapAction will schedule\n    // its own.\n\n\n    if (scheduler.actions.length === 0) {\n      Immediate_1.Immediate.clearImmediate(id);\n      scheduler.scheduled = undefined;\n    } // Return undefined so the action knows to request a new async id if it's rescheduled.\n\n\n    return undefined;\n  };\n\n  return AsapAction;\n}(AsyncAction_1.AsyncAction);\n\nexports.AsapAction = AsapAction;\n\n/***/ }),\n\n/***/ \"bZxC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar mergeMap_1 = __webpack_require__(\"7W5b\");\n\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap; //# sourceMappingURL=mergeMap.js.map\n\n/***/ }),\n\n/***/ \"bq7C\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction not(pred, thisArg) {\n  function notPred() {\n    return !notPred.pred.apply(notPred.thisArg, arguments);\n  }\n\n  notPred.pred = pred;\n  notPred.thisArg = thisArg;\n  return notPred;\n}\n\nexports.not = not;\n\n/***/ }),\n\n/***/ \"c/6p\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar multicast_1 = /*@__PURE__*/__webpack_require__(\"cf1P\");\n/* tslint:enable:max-line-length */\n\n/**\n * Allows source Observable to be subscribed only once with a Subject of choice,\n * while still sharing its values between multiple subscribers.\n *\n * <span class=\"informal\">Subscribe to Observable once, but send its values to multiple subscribers.</span>\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * `multicast` is an operator that works in two modes.\n *\n * In the first mode you provide a single argument to it, which can be either an initialized Subject or a Subject\n * factory. As a result you will get a special kind of an Observable - a {@link ConnectableObservable}. It can be\n * subscribed multiple times, just as regular Observable, but it won't subscribe to the source Observable at that\n * moment. It will do it only if you call its `connect` method. This means you can essentially control by hand, when\n * source Observable will be actually subscribed. What is more, ConnectableObservable will share this one subscription\n * between all of its subscribers. This means that, for example, `ajax` Observable will only send a request once,\n * even though usually it would send a request per every subscriber. Since it sends a request at the moment of\n * subscription, here request would be sent when the `connect` method of a ConnectableObservable is called.\n *\n * The most common pattern of using ConnectableObservable is calling `connect` when the first consumer subscribes,\n * keeping the subscription alive while several consumers come and go and finally unsubscribing from the source\n * Observable, when the last consumer unsubscribes. To not implement that logic over and over again,\n * ConnectableObservable has a special operator, `refCount`. When called, it returns an Observable, which will count\n * the number of consumers subscribed to it and keep ConnectableObservable connected as long as there is at least\n * one consumer. So if you don't actually need to decide yourself when to connect and disconnect a\n * ConnectableObservable, use `refCount`.\n *\n * The second mode is invoked by calling `multicast` with an additional, second argument - selector function.\n * This function accepts an Observable - which basically mirrors the source Observable - and returns Observable\n * as well, which should be the input stream modified by any operators you want. Note that in this\n * mode you cannot provide initialized Subject as a first argument - it has to be a Subject factory. If\n * you provide selector function, `multicast` returns just a regular Observable, instead of ConnectableObservable.\n * Thus, as usual, each subscription to this stream triggers subscription to the source Observable. However,\n * if inside the selector function you subscribe to the input Observable multiple times, actual source stream\n * will be subscribed only once. So if you have a chain of operators that use some Observable many times,\n * but you want to subscribe to that Observable only once, this is the mode you would use.\n *\n * Subject provided as a first parameter of `multicast` is used as a proxy for the single subscription to the\n * source Observable. It means that all values from the source stream go through that Subject. Thus, if a Subject\n * has some special properties, Observable returned by `multicast` will have them as well. If you want to use\n * `multicast` with a Subject that is one of the ones included in RxJS by default - {@link Subject},\n * {@link AsyncSubject}, {@link BehaviorSubject}, or {@link ReplaySubject} - simply use {@link publish},\n * {@link publishLast}, {@link publishBehavior} or {@link publishReplay} respectively. These are actually\n * just wrappers around `multicast`, with a specific Subject hardcoded inside.\n *\n * Also, if you use {@link publish} or {@link publishReplay} with a ConnectableObservables `refCount` operator,\n * you can simply use {@link share} and {@link shareReplay} respectively, which chain these two.\n *\n * @example <caption>Use ConnectableObservable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const connectableSeconds = seconds.multicast(new Subject());\n *\n * connectableSeconds.subscribe(value => console.log('first: ' + value));\n * connectableSeconds.subscribe(value => console.log('second: ' + value));\n *\n * // At this point still nothing happens, even though we subscribed twice.\n *\n * connectableSeconds.connect();\n *\n * // From now on `seconds` are being logged to the console,\n * // twice per every second. `seconds` Observable was however only subscribed once,\n * // so under the hood Observable.interval had only one clock started.\n *\n * @example <caption>Use selector</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds\n *     .multicast(\n *         () => new Subject(),\n *         seconds => seconds.zip(seconds) // Usually zip would subscribe to `seconds` twice.\n *                                         // Because we are inside selector, `seconds` is subscribed once,\n *     )                                   // thus starting only one clock used internally by Observable.interval.\n *     .subscribe();\n *\n * @see {@link publish}\n * @see {@link publishLast}\n * @see {@link publishBehavior}\n * @see {@link publishReplay}\n * @see {@link share}\n * @see {@link shareReplay}\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate Subject through\n * which the source sequence's elements will be multicast to the selector function input Observable or\n * ConnectableObservable returned by the operator.\n * @param {Function} [selector] - Optional selector function that can use the input stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the input source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable<T>|ConnectableObservable<T>} An Observable that emits the results of invoking the selector\n * on the source stream or a special {@link ConnectableObservable}, if selector was not provided.\n *\n * @method multicast\n * @owner Observable\n */\n\n\nfunction multicast(subjectOrSubjectFactory, selector) {\n  return multicast_1.multicast(subjectOrSubjectFactory, selector)(this);\n}\n\nexports.multicast = multicast;\n\n/***/ }),\n\n/***/ \"c4YM\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar distinctUntilChanged_1 = /*@__PURE__*/__webpack_require__(\"rgOj\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>An example comparing the name of persons</caption>\n *\n *  interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilKeyChanged('name')\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @example <caption>An example comparing the first letters of the name</caption>\n *\n * interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo1'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo2'},\n *     { age: 6, name: 'Foo3'})\n *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\n\n\nfunction distinctUntilKeyChanged(key, compare) {\n  return distinctUntilChanged_1.distinctUntilChanged(function (x, y) {\n    return compare ? compare(x[key], y[key]) : x[key] === y[key];\n  });\n}\n\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n\n/***/ }),\n\n/***/ \"cIDA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FromEventPatternObservable_1 = /*@__PURE__*/__webpack_require__(\"fImS\");\n\nexports.fromEventPattern = FromEventPatternObservable_1.FromEventPatternObservable.create;\n\n/***/ }),\n\n/***/ \"cP0Y\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar windowTime_1 = __webpack_require__(\"svOU\");\n\nObservable_1.Observable.prototype.windowTime = windowTime_1.windowTime; //# sourceMappingURL=windowTime.js.map\n\n/***/ }),\n\n/***/ \"cUCP\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar audit_1 = /*@__PURE__*/__webpack_require__(\"mdQD\");\n\nvar timer_1 = /*@__PURE__*/__webpack_require__(\"UqH8\");\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\n\n\nfunction auditTime(duration, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return audit_1.audit(function () {\n    return timer_1.timer(duration, scheduler);\n  });\n}\n\nexports.auditTime = auditTime;\n\n/***/ }),\n\n/***/ \"cWud\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar windowWhen_1 = /*@__PURE__*/__webpack_require__(\"+djB\");\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\n\n\nfunction windowWhen(closingSelector) {\n  return windowWhen_1.windowWhen(closingSelector)(this);\n}\n\nexports.windowWhen = windowWhen;\n\n/***/ }),\n\n/***/ \"cdxN\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar switch_1 = __webpack_require__(\"Lj2B\");\n\nObservable_1.Observable.prototype.switch = switch_1._switch;\nObservable_1.Observable.prototype._switch = switch_1._switch; //# sourceMappingURL=switch.js.map\n\n/***/ }),\n\n/***/ \"cf1P\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar ConnectableObservable_1 = /*@__PURE__*/__webpack_require__(\"3VCA\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\n\n\nfunction multicast(subjectOrSubjectFactory, selector) {\n  return function multicastOperatorFunction(source) {\n    var subjectFactory;\n\n    if (typeof subjectOrSubjectFactory === 'function') {\n      subjectFactory = subjectOrSubjectFactory;\n    } else {\n      subjectFactory = function subjectFactory() {\n        return subjectOrSubjectFactory;\n      };\n    }\n\n    if (typeof selector === 'function') {\n      return source.lift(new MulticastOperator(subjectFactory, selector));\n    }\n\n    var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);\n    connectable.source = source;\n    connectable.subjectFactory = subjectFactory;\n    return connectable;\n  };\n}\n\nexports.multicast = multicast;\n\nvar MulticastOperator = /*@__PURE__*/function () {\n  function MulticastOperator(subjectFactory, selector) {\n    this.subjectFactory = subjectFactory;\n    this.selector = selector;\n  }\n\n  MulticastOperator.prototype.call = function (subscriber, source) {\n    var selector = this.selector;\n    var subject = this.subjectFactory();\n    var subscription = selector(subject).subscribe(subscriber);\n    subscription.add(source.subscribe(subject));\n    return subscription;\n  };\n\n  return MulticastOperator;\n}();\n\nexports.MulticastOperator = MulticastOperator;\n\n/***/ }),\n\n/***/ \"codN\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar BoundNodeCallbackObservable_1 = /*@__PURE__*/__webpack_require__(\"3zH1\");\n\nexports.bindNodeCallback = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;\n\n/***/ }),\n\n/***/ \"czP3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar map_1 = /*@__PURE__*/__webpack_require__(\"aK2G\");\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\n\n\nfunction pluck() {\n  var properties = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    properties[_i - 0] = arguments[_i];\n  }\n\n  var length = properties.length;\n\n  if (length === 0) {\n    throw new Error('list of properties cannot be empty.');\n  }\n\n  return function (source) {\n    return map_1.map(plucker(properties, length))(source);\n  };\n}\n\nexports.pluck = pluck;\n\nfunction plucker(props, length) {\n  var mapper = function mapper(x) {\n    var currentProp = x;\n\n    for (var i = 0; i < length; i++) {\n      var p = currentProp[props[i]];\n\n      if (typeof p !== 'undefined') {\n        currentProp = p;\n      } else {\n        return undefined;\n      }\n    }\n\n    return currentProp;\n  };\n\n  return mapper;\n}\n\n/***/ }),\n\n/***/ \"d+Tj\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar audit_1 = /*@__PURE__*/__webpack_require__(\"mdQD\");\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\n\n\nfunction audit(durationSelector) {\n  return audit_1.audit(durationSelector)(this);\n}\n\nexports.audit = audit;\n\n/***/ }),\n\n/***/ \"dAHb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar exhaustMap_1 = __webpack_require__(\"hw8L\");\n\nObservable_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap; //# sourceMappingURL=exhaustMap.js.map\n\n/***/ }),\n\n/***/ \"dxsx\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar publishReplay_1 = __webpack_require__(\"qJ4/\");\n\nObservable_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay; //# sourceMappingURL=publishReplay.js.map\n\n/***/ }),\n\n/***/ \"e7/H\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar subscribeOn_1 = /*@__PURE__*/__webpack_require__(\"DxGp\");\n/**\n * Asynchronously subscribes Observers to this Observable on the specified IScheduler.\n *\n * <img src=\"./img/subscribeOn.png\" width=\"100%\">\n *\n * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.\n * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.\n .\n * @method subscribeOn\n * @owner Observable\n */\n\n\nfunction subscribeOn(scheduler, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n\n  return subscribeOn_1.subscribeOn(scheduler, delay)(this);\n}\n\nexports.subscribeOn = subscribeOn;\n\n/***/ }),\n\n/***/ \"e7R1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar mergeAll_1 = /*@__PURE__*/__webpack_require__(\"0p2S\");\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\n\n\nfunction mergeAll(concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  return mergeAll_1.mergeAll(concurrent)(this);\n}\n\nexports.mergeAll = mergeAll;\n\n/***/ }),\n\n/***/ \"eBTF\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nfunction minimalSetImpl() {\n  // THIS IS NOT a full impl of Set, this is just the minimum\n  // bits of functionality we need for this library.\n  return function () {\n    function MinimalSet() {\n      this._values = [];\n    }\n\n    MinimalSet.prototype.add = function (value) {\n      if (!this.has(value)) {\n        this._values.push(value);\n      }\n    };\n\n    MinimalSet.prototype.has = function (value) {\n      return this._values.indexOf(value) !== -1;\n    };\n\n    Object.defineProperty(MinimalSet.prototype, \"size\", {\n      get: function get() {\n        return this._values.length;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    MinimalSet.prototype.clear = function () {\n      this._values.length = 0;\n    };\n\n    return MinimalSet;\n  }();\n}\n\nexports.minimalSetImpl = minimalSetImpl;\nexports.Set = root_1.root.Set || /*@__PURE__*/minimalSetImpl();\n\n/***/ }),\n\n/***/ \"eeyt\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar findIndex_1 = /*@__PURE__*/__webpack_require__(\"qN2p\");\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * <img src=\"./img/findIndex.png\" width=\"100%\">\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\n\n\nfunction findIndex(predicate, thisArg) {\n  return findIndex_1.findIndex(predicate, thisArg)(this);\n}\n\nexports.findIndex = findIndex;\n\n/***/ }),\n\n/***/ \"f0q5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar audit_1 = /*@__PURE__*/__webpack_require__(\"mdQD\");\n\nexports.audit = audit_1.audit;\n\nvar auditTime_1 = /*@__PURE__*/__webpack_require__(\"cUCP\");\n\nexports.auditTime = auditTime_1.auditTime;\n\nvar buffer_1 = /*@__PURE__*/__webpack_require__(\"zobD\");\n\nexports.buffer = buffer_1.buffer;\n\nvar bufferCount_1 = /*@__PURE__*/__webpack_require__(\"16yF\");\n\nexports.bufferCount = bufferCount_1.bufferCount;\n\nvar bufferTime_1 = /*@__PURE__*/__webpack_require__(\"wELj\");\n\nexports.bufferTime = bufferTime_1.bufferTime;\n\nvar bufferToggle_1 = /*@__PURE__*/__webpack_require__(\"re5B\");\n\nexports.bufferToggle = bufferToggle_1.bufferToggle;\n\nvar bufferWhen_1 = /*@__PURE__*/__webpack_require__(\"N6Zr\");\n\nexports.bufferWhen = bufferWhen_1.bufferWhen;\n\nvar catchError_1 = /*@__PURE__*/__webpack_require__(\"CxhQ\");\n\nexports.catchError = catchError_1.catchError;\n\nvar combineAll_1 = /*@__PURE__*/__webpack_require__(\"OMR/\");\n\nexports.combineAll = combineAll_1.combineAll;\n\nvar combineLatest_1 = /*@__PURE__*/__webpack_require__(\"SWOv\");\n\nexports.combineLatest = combineLatest_1.combineLatest;\n\nvar concat_1 = /*@__PURE__*/__webpack_require__(\"WC+f\");\n\nexports.concat = concat_1.concat;\n\nvar concatAll_1 = /*@__PURE__*/__webpack_require__(\"A0iX\");\n\nexports.concatAll = concatAll_1.concatAll;\n\nvar concatMap_1 = /*@__PURE__*/__webpack_require__(\"+WiC\");\n\nexports.concatMap = concatMap_1.concatMap;\n\nvar concatMapTo_1 = /*@__PURE__*/__webpack_require__(\"zVww\");\n\nexports.concatMapTo = concatMapTo_1.concatMapTo;\n\nvar count_1 = /*@__PURE__*/__webpack_require__(\"iYe0\");\n\nexports.count = count_1.count;\n\nvar debounce_1 = /*@__PURE__*/__webpack_require__(\"zL8T\");\n\nexports.debounce = debounce_1.debounce;\n\nvar debounceTime_1 = /*@__PURE__*/__webpack_require__(\"AzqM\");\n\nexports.debounceTime = debounceTime_1.debounceTime;\n\nvar defaultIfEmpty_1 = /*@__PURE__*/__webpack_require__(\"2Tbn\");\n\nexports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\n\nvar delay_1 = /*@__PURE__*/__webpack_require__(\"QCIY\");\n\nexports.delay = delay_1.delay;\n\nvar delayWhen_1 = /*@__PURE__*/__webpack_require__(\"4GoQ\");\n\nexports.delayWhen = delayWhen_1.delayWhen;\n\nvar dematerialize_1 = /*@__PURE__*/__webpack_require__(\"mO1z\");\n\nexports.dematerialize = dematerialize_1.dematerialize;\n\nvar distinct_1 = /*@__PURE__*/__webpack_require__(\"nQov\");\n\nexports.distinct = distinct_1.distinct;\n\nvar distinctUntilChanged_1 = /*@__PURE__*/__webpack_require__(\"rgOj\");\n\nexports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\n\nvar distinctUntilKeyChanged_1 = /*@__PURE__*/__webpack_require__(\"c4YM\");\n\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\n\nvar elementAt_1 = /*@__PURE__*/__webpack_require__(\"PxRv\");\n\nexports.elementAt = elementAt_1.elementAt;\n\nvar every_1 = /*@__PURE__*/__webpack_require__(\"ER9c\");\n\nexports.every = every_1.every;\n\nvar exhaust_1 = /*@__PURE__*/__webpack_require__(\"H0zL\");\n\nexports.exhaust = exhaust_1.exhaust;\n\nvar exhaustMap_1 = /*@__PURE__*/__webpack_require__(\"GEfX\");\n\nexports.exhaustMap = exhaustMap_1.exhaustMap;\n\nvar expand_1 = /*@__PURE__*/__webpack_require__(\"we3k\");\n\nexports.expand = expand_1.expand;\n\nvar filter_1 = /*@__PURE__*/__webpack_require__(\"ZXB4\");\n\nexports.filter = filter_1.filter;\n\nvar finalize_1 = /*@__PURE__*/__webpack_require__(\"q9sB\");\n\nexports.finalize = finalize_1.finalize;\n\nvar find_1 = /*@__PURE__*/__webpack_require__(\"DKXc\");\n\nexports.find = find_1.find;\n\nvar findIndex_1 = /*@__PURE__*/__webpack_require__(\"qN2p\");\n\nexports.findIndex = findIndex_1.findIndex;\n\nvar first_1 = /*@__PURE__*/__webpack_require__(\"L/jt\");\n\nexports.first = first_1.first;\n\nvar groupBy_1 = /*@__PURE__*/__webpack_require__(\"Q6nm\");\n\nexports.groupBy = groupBy_1.groupBy;\n\nvar ignoreElements_1 = /*@__PURE__*/__webpack_require__(\"Tb5M\");\n\nexports.ignoreElements = ignoreElements_1.ignoreElements;\n\nvar isEmpty_1 = /*@__PURE__*/__webpack_require__(\"XNQH\");\n\nexports.isEmpty = isEmpty_1.isEmpty;\n\nvar last_1 = /*@__PURE__*/__webpack_require__(\"ffiR\");\n\nexports.last = last_1.last;\n\nvar map_1 = /*@__PURE__*/__webpack_require__(\"aK2G\");\n\nexports.map = map_1.map;\n\nvar mapTo_1 = /*@__PURE__*/__webpack_require__(\"saxw\");\n\nexports.mapTo = mapTo_1.mapTo;\n\nvar materialize_1 = /*@__PURE__*/__webpack_require__(\"oGc9\");\n\nexports.materialize = materialize_1.materialize;\n\nvar max_1 = /*@__PURE__*/__webpack_require__(\"5aaB\");\n\nexports.max = max_1.max;\n\nvar merge_1 = /*@__PURE__*/__webpack_require__(\"LqmK\");\n\nexports.merge = merge_1.merge;\n\nvar mergeAll_1 = /*@__PURE__*/__webpack_require__(\"0p2S\");\n\nexports.mergeAll = mergeAll_1.mergeAll;\n\nvar mergeMap_1 = /*@__PURE__*/__webpack_require__(\"lf2g\");\n\nexports.mergeMap = mergeMap_1.mergeMap;\n\nvar mergeMap_2 = /*@__PURE__*/__webpack_require__(\"lf2g\");\n\nexports.flatMap = mergeMap_2.mergeMap;\n\nvar mergeMapTo_1 = /*@__PURE__*/__webpack_require__(\"fEEN\");\n\nexports.mergeMapTo = mergeMapTo_1.mergeMapTo;\n\nvar mergeScan_1 = /*@__PURE__*/__webpack_require__(\"SQLu\");\n\nexports.mergeScan = mergeScan_1.mergeScan;\n\nvar min_1 = /*@__PURE__*/__webpack_require__(\"Kc9Z\");\n\nexports.min = min_1.min;\n\nvar multicast_1 = /*@__PURE__*/__webpack_require__(\"cf1P\");\n\nexports.multicast = multicast_1.multicast;\n\nvar observeOn_1 = /*@__PURE__*/__webpack_require__(\"0zyO\");\n\nexports.observeOn = observeOn_1.observeOn;\n\nvar onErrorResumeNext_1 = /*@__PURE__*/__webpack_require__(\"Rm1J\");\n\nexports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n\nvar pairwise_1 = /*@__PURE__*/__webpack_require__(\"ABAE\");\n\nexports.pairwise = pairwise_1.pairwise;\n\nvar partition_1 = /*@__PURE__*/__webpack_require__(\"gSfb\");\n\nexports.partition = partition_1.partition;\n\nvar pluck_1 = /*@__PURE__*/__webpack_require__(\"czP3\");\n\nexports.pluck = pluck_1.pluck;\n\nvar publish_1 = /*@__PURE__*/__webpack_require__(\"gcf/\");\n\nexports.publish = publish_1.publish;\n\nvar publishBehavior_1 = /*@__PURE__*/__webpack_require__(\"7f6I\");\n\nexports.publishBehavior = publishBehavior_1.publishBehavior;\n\nvar publishLast_1 = /*@__PURE__*/__webpack_require__(\"O/EN\");\n\nexports.publishLast = publishLast_1.publishLast;\n\nvar publishReplay_1 = /*@__PURE__*/__webpack_require__(\"f947\");\n\nexports.publishReplay = publishReplay_1.publishReplay;\n\nvar race_1 = /*@__PURE__*/__webpack_require__(\"UUzK\");\n\nexports.race = race_1.race;\n\nvar reduce_1 = /*@__PURE__*/__webpack_require__(\"6fvh\");\n\nexports.reduce = reduce_1.reduce;\n\nvar repeat_1 = /*@__PURE__*/__webpack_require__(\"+PC9\");\n\nexports.repeat = repeat_1.repeat;\n\nvar repeatWhen_1 = /*@__PURE__*/__webpack_require__(\"0j0j\");\n\nexports.repeatWhen = repeatWhen_1.repeatWhen;\n\nvar retry_1 = /*@__PURE__*/__webpack_require__(\"7c4m\");\n\nexports.retry = retry_1.retry;\n\nvar retryWhen_1 = /*@__PURE__*/__webpack_require__(\"C8RJ\");\n\nexports.retryWhen = retryWhen_1.retryWhen;\n\nvar refCount_1 = /*@__PURE__*/__webpack_require__(\"pk/4\");\n\nexports.refCount = refCount_1.refCount;\n\nvar sample_1 = /*@__PURE__*/__webpack_require__(\"WQoq\");\n\nexports.sample = sample_1.sample;\n\nvar sampleTime_1 = /*@__PURE__*/__webpack_require__(\"7LGj\");\n\nexports.sampleTime = sampleTime_1.sampleTime;\n\nvar scan_1 = /*@__PURE__*/__webpack_require__(\"n8Qg\");\n\nexports.scan = scan_1.scan;\n\nvar sequenceEqual_1 = /*@__PURE__*/__webpack_require__(\"3Ind\");\n\nexports.sequenceEqual = sequenceEqual_1.sequenceEqual;\n\nvar share_1 = /*@__PURE__*/__webpack_require__(\"X/dC\");\n\nexports.share = share_1.share;\n\nvar shareReplay_1 = /*@__PURE__*/__webpack_require__(\"0Qin\");\n\nexports.shareReplay = shareReplay_1.shareReplay;\n\nvar single_1 = /*@__PURE__*/__webpack_require__(\"Xrsd\");\n\nexports.single = single_1.single;\n\nvar skip_1 = /*@__PURE__*/__webpack_require__(\"1DV/\");\n\nexports.skip = skip_1.skip;\n\nvar skipLast_1 = /*@__PURE__*/__webpack_require__(\"7Nkz\");\n\nexports.skipLast = skipLast_1.skipLast;\n\nvar skipUntil_1 = /*@__PURE__*/__webpack_require__(\"WgKs\");\n\nexports.skipUntil = skipUntil_1.skipUntil;\n\nvar skipWhile_1 = /*@__PURE__*/__webpack_require__(\"SX7S\");\n\nexports.skipWhile = skipWhile_1.skipWhile;\n\nvar startWith_1 = /*@__PURE__*/__webpack_require__(\"DFxj\");\n\nexports.startWith = startWith_1.startWith;\n/**\n * TODO(https://github.com/ReactiveX/rxjs/issues/2900): Add back subscribeOn once it can be\n * treeshaken. Currently if this export is added back, it\n * forces apps to bring in asap scheduler along with\n * Immediate, root, and other supporting code.\n */\n// export { subscribeOn } from './operators/subscribeOn';\n\nvar switchAll_1 = /*@__PURE__*/__webpack_require__(\"hY8S\");\n\nexports.switchAll = switchAll_1.switchAll;\n\nvar switchMap_1 = /*@__PURE__*/__webpack_require__(\"VVja\");\n\nexports.switchMap = switchMap_1.switchMap;\n\nvar switchMapTo_1 = /*@__PURE__*/__webpack_require__(\"VthU\");\n\nexports.switchMapTo = switchMapTo_1.switchMapTo;\n\nvar take_1 = /*@__PURE__*/__webpack_require__(\"3hIw\");\n\nexports.take = take_1.take;\n\nvar takeLast_1 = /*@__PURE__*/__webpack_require__(\"WO4J\");\n\nexports.takeLast = takeLast_1.takeLast;\n\nvar takeUntil_1 = /*@__PURE__*/__webpack_require__(\"MHPA\");\n\nexports.takeUntil = takeUntil_1.takeUntil;\n\nvar takeWhile_1 = /*@__PURE__*/__webpack_require__(\"3jsl\");\n\nexports.takeWhile = takeWhile_1.takeWhile;\n\nvar tap_1 = /*@__PURE__*/__webpack_require__(\"Kqb3\");\n\nexports.tap = tap_1.tap;\n\nvar throttle_1 = /*@__PURE__*/__webpack_require__(\"o6MN\");\n\nexports.throttle = throttle_1.throttle;\n\nvar throttleTime_1 = /*@__PURE__*/__webpack_require__(\"BnoD\");\n\nexports.throttleTime = throttleTime_1.throttleTime;\n\nvar timeInterval_1 = /*@__PURE__*/__webpack_require__(\"BTim\");\n\nexports.timeInterval = timeInterval_1.timeInterval;\n\nvar timeout_1 = /*@__PURE__*/__webpack_require__(\"9BwH\");\n\nexports.timeout = timeout_1.timeout;\n\nvar timeoutWith_1 = /*@__PURE__*/__webpack_require__(\"uj+q\");\n\nexports.timeoutWith = timeoutWith_1.timeoutWith;\n\nvar timestamp_1 = /*@__PURE__*/__webpack_require__(\"Z57B\");\n\nexports.timestamp = timestamp_1.timestamp;\n\nvar toArray_1 = /*@__PURE__*/__webpack_require__(\"M6BU\");\n\nexports.toArray = toArray_1.toArray;\n\nvar window_1 = /*@__PURE__*/__webpack_require__(\"0Iwa\");\n\nexports.window = window_1.window;\n\nvar windowCount_1 = /*@__PURE__*/__webpack_require__(\"ast0\");\n\nexports.windowCount = windowCount_1.windowCount;\n\nvar windowTime_1 = /*@__PURE__*/__webpack_require__(\"3WZS\");\n\nexports.windowTime = windowTime_1.windowTime;\n\nvar windowToggle_1 = /*@__PURE__*/__webpack_require__(\"8pnh\");\n\nexports.windowToggle = windowToggle_1.windowToggle;\n\nvar windowWhen_1 = /*@__PURE__*/__webpack_require__(\"+djB\");\n\nexports.windowWhen = windowWhen_1.windowWhen;\n\nvar withLatestFrom_1 = /*@__PURE__*/__webpack_require__(\"2Wg+\");\n\nexports.withLatestFrom = withLatestFrom_1.withLatestFrom;\n\nvar zip_1 = /*@__PURE__*/__webpack_require__(\"oQYR\");\n\nexports.zip = zip_1.zip;\n\nvar zipAll_1 = /*@__PURE__*/__webpack_require__(\"FBtj\");\n\nexports.zipAll = zipAll_1.zipAll;\n\n/***/ }),\n\n/***/ \"f947\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar ReplaySubject_1 = /*@__PURE__*/__webpack_require__(\"BjeI\");\n\nvar multicast_1 = /*@__PURE__*/__webpack_require__(\"cf1P\");\n/* tslint:enable:max-line-length */\n\n\nfunction publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n    scheduler = selectorOrScheduler;\n  }\n\n  var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n  var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n  return function (source) {\n    return multicast_1.multicast(function () {\n      return subject;\n    }, selector)(source);\n  };\n}\n\nexports.publishReplay = publishReplay;\n\n/***/ }),\n\n/***/ \"fEEN\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\n\n\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n    resultSelector = null;\n  }\n\n  return function (source) {\n    return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));\n  };\n}\n\nexports.mergeMapTo = mergeMapTo; // TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\n\nvar MergeMapToOperator = /*@__PURE__*/function () {\n  function MergeMapToOperator(ish, resultSelector, concurrent) {\n    if (concurrent === void 0) {\n      concurrent = Number.POSITIVE_INFINITY;\n    }\n\n    this.ish = ish;\n    this.resultSelector = resultSelector;\n    this.concurrent = concurrent;\n  }\n\n  MergeMapToOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n  };\n\n  return MergeMapToOperator;\n}();\n\nexports.MergeMapToOperator = MergeMapToOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar MergeMapToSubscriber = function (_super) {\n  __extends(MergeMapToSubscriber, _super);\n\n  function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {\n    if (concurrent === void 0) {\n      concurrent = Number.POSITIVE_INFINITY;\n    }\n\n    _super.call(this, destination);\n\n    this.ish = ish;\n    this.resultSelector = resultSelector;\n    this.concurrent = concurrent;\n    this.hasCompleted = false;\n    this.buffer = [];\n    this.active = 0;\n    this.index = 0;\n  }\n\n  MergeMapToSubscriber.prototype._next = function (value) {\n    if (this.active < this.concurrent) {\n      var resultSelector = this.resultSelector;\n      var index = this.index++;\n      var ish = this.ish;\n      var destination = this.destination;\n      this.active++;\n\n      this._innerSub(ish, destination, resultSelector, value, index);\n    } else {\n      this.buffer.push(value);\n    }\n  };\n\n  MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {\n    this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n  };\n\n  MergeMapToSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  };\n\n  MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    if (resultSelector) {\n      this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  };\n\n  MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    var result;\n\n    try {\n      result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    destination.next(result);\n  };\n\n  MergeMapToSubscriber.prototype.notifyError = function (err) {\n    this.destination.error(err);\n  };\n\n  MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n    var buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return MergeMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\nexports.MergeMapToSubscriber = MergeMapToSubscriber;\n\n/***/ }),\n\n/***/ \"fImS\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar isFunction_1 = /*@__PURE__*/__webpack_require__(\"PFc+\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar FromEventPatternObservable = function (_super) {\n  __extends(FromEventPatternObservable, _super);\n\n  function FromEventPatternObservable(addHandler, removeHandler, selector) {\n    _super.call(this);\n\n    this.addHandler = addHandler;\n    this.removeHandler = removeHandler;\n    this.selector = selector;\n  }\n  /**\n   * Creates an Observable from an API based on addHandler/removeHandler\n   * functions.\n   *\n   * <span class=\"informal\">Converts any addHandler/removeHandler API to an\n   * Observable.</span>\n   *\n   * <img src=\"./img/fromEventPattern.png\" width=\"100%\">\n   *\n   * Creates an Observable by using the `addHandler` and `removeHandler`\n   * functions to add and remove the handlers, with an optional selector\n   * function to project the event arguments to a result. The `addHandler` is\n   * called when the output Observable is subscribed, and `removeHandler` is\n   * called when the Subscription is unsubscribed.\n   *\n   * @example <caption>Emits clicks happening on the DOM document</caption>\n   * function addClickHandler(handler) {\n   *   document.addEventListener('click', handler);\n   * }\n   *\n   * function removeClickHandler(handler) {\n   *   document.removeEventListener('click', handler);\n   * }\n   *\n   * var clicks = Rx.Observable.fromEventPattern(\n   *   addClickHandler,\n   *   removeClickHandler\n   * );\n   * clicks.subscribe(x => console.log(x));\n   *\n   * @see {@link from}\n   * @see {@link fromEvent}\n   *\n   * @param {function(handler: Function): any} addHandler A function that takes\n   * a `handler` function as argument and attaches it somehow to the actual\n   * source of events.\n   * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that\n   * takes a `handler` function as argument and removes it in case it was\n   * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,\n   * removeHandler function will forward it.\n   * @param {function(...args: any): T} [selector] An optional function to\n   * post-process results. It takes the arguments from the event handler and\n   * should return a single value.\n   * @return {Observable<T>}\n   * @static true\n   * @name fromEventPattern\n   * @owner Observable\n   */\n\n\n  FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {\n    return new FromEventPatternObservable(addHandler, removeHandler, selector);\n  };\n  /** @deprecated internal use only */\n\n\n  FromEventPatternObservable.prototype._subscribe = function (subscriber) {\n    var _this = this;\n\n    var removeHandler = this.removeHandler;\n    var handler = !!this.selector ? function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n      }\n\n      _this._callSelector(subscriber, args);\n    } : function (e) {\n      subscriber.next(e);\n    };\n\n    var retValue = this._callAddHandler(handler, subscriber);\n\n    if (!isFunction_1.isFunction(removeHandler)) {\n      return;\n    }\n\n    subscriber.add(new Subscription_1.Subscription(function () {\n      //TODO: determine whether or not to forward to error handler\n      removeHandler(handler, retValue);\n    }));\n  };\n\n  FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {\n    try {\n      var result = this.selector.apply(this, args);\n      subscriber.next(result);\n    } catch (e) {\n      subscriber.error(e);\n    }\n  };\n\n  FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {\n    try {\n      return this.addHandler(handler) || null;\n    } catch (e) {\n      errorSubscriber.error(e);\n    }\n  };\n\n  return FromEventPatternObservable;\n}(Observable_1.Observable);\n\nexports.FromEventPatternObservable = FromEventPatternObservable;\n\n/***/ }),\n\n/***/ \"fQTG\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar isFunction_1 = /*@__PURE__*/__webpack_require__(\"PFc+\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar toString = Object.prototype.toString;\n\nfunction isNodeStyleEventEmitter(sourceObj) {\n  return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\n\nfunction isJQueryStyleEventEmitter(sourceObj) {\n  return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\n\nfunction isNodeList(sourceObj) {\n  return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\n\nfunction isHTMLCollection(sourceObj) {\n  return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\n\nfunction isEventTarget(sourceObj) {\n  return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar FromEventObservable = function (_super) {\n  __extends(FromEventObservable, _super);\n\n  function FromEventObservable(sourceObj, eventName, selector, options) {\n    _super.call(this);\n\n    this.sourceObj = sourceObj;\n    this.eventName = eventName;\n    this.selector = selector;\n    this.options = options;\n  }\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Creates an Observable that emits events of a specific type coming from the\n   * given event target.\n   *\n   * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n   * EventEmitter events or others.</span>\n   *\n   * <img src=\"./img/fromEvent.png\" width=\"100%\">\n   *\n   * `fromEvent` accepts as a first argument event target, which is an object with methods\n   * for registering event handler functions. As a second argument it takes string that indicates\n   * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n   * which are described in detail below. If your event target does not match any of the ones listed,\n   * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n   * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n   * handler functions have different names, but they all accept a string describing event type\n   * and function itself, which will be called whenever said event happens.\n   *\n   * Every time resulting Observable is subscribed, event handler function will be registered\n   * to event target on given event type. When that event fires, value\n   * passed as a first argument to registered function will be emitted by output Observable.\n   * When Observable is unsubscribed, function will be unregistered from event target.\n   *\n   * Note that if event target calls registered function with more than one argument, second\n   * and following arguments will not appear in resulting stream. In order to get access to them,\n   * you can pass to `fromEvent` optional project function, which will be called with all arguments\n   * passed to event handler. Output Observable will then emit value returned by project function,\n   * instead of the usual value.\n   *\n   * Remember that event targets listed below are checked via duck typing. It means that\n   * no matter what kind of object you have and no matter what environment you work in,\n   * you can safely use `fromEvent` on that object if it exposes described methods (provided\n   * of course they behave as was described above). So for example if Node.js library exposes\n   * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n   * a good choice.\n   *\n   * If the API you use is more callback then event handler oriented (subscribed\n   * callback function fires only once and thus there is no need to manually\n   * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n   * instead.\n   *\n   * `fromEvent` supports following types of event targets:\n   *\n   * **DOM EventTarget**\n   *\n   * This is an object with `addEventListener` and `removeEventListener` methods.\n   *\n   * In the browser, `addEventListener` accepts - apart from event type string and event\n   * handler function arguments - optional third parameter, which is either an object or boolean,\n   * both used for additional configuration how and when passed function will be called. When\n   * `fromEvent` is used with event target of that type, you can provide this values\n   * as third parameter as well.\n   *\n   * **Node.js EventEmitter**\n   *\n   * An object with `addListener` and `removeListener` methods.\n   *\n   * **JQuery-style event target**\n   *\n   * An object with `on` and `off` methods\n   *\n   * **DOM NodeList**\n   *\n   * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n   *\n   * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n   * it contains and install event handler function in every of them. When returned Observable\n   * is unsubscribed, function will be removed from all Nodes.\n   *\n   * **DOM HtmlCollection**\n   *\n   * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n   * installed and removed in each of elements.\n   *\n   *\n   * @example <caption>Emits clicks happening on the DOM document</caption>\n   * var clicks = Rx.Observable.fromEvent(document, 'click');\n   * clicks.subscribe(x => console.log(x));\n   *\n   * // Results in:\n   * // MouseEvent object logged to console every time a click\n   * // occurs on the document.\n   *\n   *\n   * @example <caption>Use addEventListener with capture option</caption>\n   * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n   *                                                                          // which will be passed to addEventListener\n   * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n   *\n   * clicksInDocument.subscribe(() => console.log('document'));\n   * clicksInDiv.subscribe(() => console.log('div'));\n   *\n   * // By default events bubble UP in DOM tree, so normally\n   * // when we would click on div in document\n   * // \"div\" would be logged first and then \"document\".\n   * // Since we specified optional `capture` option, document\n   * // will catch event when it goes DOWN DOM tree, so console\n   * // will log \"document\" and then \"div\".\n   *\n   * @see {@link bindCallback}\n   * @see {@link bindNodeCallback}\n   * @see {@link fromEventPattern}\n   *\n   * @param {EventTargetLike} target The DOM EventTarget, Node.js\n   * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n   * @param {string} eventName The event name of interest, being emitted by the\n   * `target`.\n   * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n   * @param {SelectorMethodSignature<T>} [selector] An optional function to\n   * post-process results. It takes the arguments from the event handler and\n   * should return a single value.\n   * @return {Observable<T>}\n   * @static true\n   * @name fromEvent\n   * @owner Observable\n   */\n\n\n  FromEventObservable.create = function (target, eventName, options, selector) {\n    if (isFunction_1.isFunction(options)) {\n      selector = options;\n      options = undefined;\n    }\n\n    return new FromEventObservable(target, eventName, selector, options);\n  };\n\n  FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n    var unsubscribe;\n\n    if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n      for (var i = 0, len = sourceObj.length; i < len; i++) {\n        FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n      }\n    } else if (isEventTarget(sourceObj)) {\n      var source_1 = sourceObj;\n      sourceObj.addEventListener(eventName, handler, options);\n\n      unsubscribe = function unsubscribe() {\n        return source_1.removeEventListener(eventName, handler, options);\n      };\n    } else if (isJQueryStyleEventEmitter(sourceObj)) {\n      var source_2 = sourceObj;\n      sourceObj.on(eventName, handler);\n\n      unsubscribe = function unsubscribe() {\n        return source_2.off(eventName, handler);\n      };\n    } else if (isNodeStyleEventEmitter(sourceObj)) {\n      var source_3 = sourceObj;\n      sourceObj.addListener(eventName, handler);\n\n      unsubscribe = function unsubscribe() {\n        return source_3.removeListener(eventName, handler);\n      };\n    } else {\n      throw new TypeError('Invalid event target');\n    }\n\n    subscriber.add(new Subscription_1.Subscription(unsubscribe));\n  };\n  /** @deprecated internal use only */\n\n\n  FromEventObservable.prototype._subscribe = function (subscriber) {\n    var sourceObj = this.sourceObj;\n    var eventName = this.eventName;\n    var options = this.options;\n    var selector = this.selector;\n    var handler = selector ? function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n      }\n\n      var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n\n      if (result === errorObject_1.errorObject) {\n        subscriber.error(errorObject_1.errorObject.e);\n      } else {\n        subscriber.next(result);\n      }\n    } : function (e) {\n      return subscriber.next(e);\n    };\n    FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n  };\n\n  return FromEventObservable;\n}(Observable_1.Observable);\n\nexports.FromEventObservable = FromEventObservable;\n\n/***/ }),\n\n/***/ \"fTxW\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar zipAll_1 = /*@__PURE__*/__webpack_require__(\"FBtj\");\n/**\n * @param project\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method zipAll\n * @owner Observable\n */\n\n\nfunction zipAll(project) {\n  return zipAll_1.zipAll(project)(this);\n}\n\nexports.zipAll = zipAll;\n\n/***/ }),\n\n/***/ \"ffiR\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar EmptyError_1 = /*@__PURE__*/__webpack_require__(\"2fIB\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - The condition any source emitted item has to satisfy.\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\n\n\nfunction last(predicate, resultSelector, defaultValue) {\n  return function (source) {\n    return source.lift(new LastOperator(predicate, resultSelector, defaultValue, source));\n  };\n}\n\nexports.last = last;\n\nvar LastOperator = /*@__PURE__*/function () {\n  function LastOperator(predicate, resultSelector, defaultValue, source) {\n    this.predicate = predicate;\n    this.resultSelector = resultSelector;\n    this.defaultValue = defaultValue;\n    this.source = source;\n  }\n\n  LastOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n  };\n\n  return LastOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar LastSubscriber = function (_super) {\n  __extends(LastSubscriber, _super);\n\n  function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n    _super.call(this, destination);\n\n    this.predicate = predicate;\n    this.resultSelector = resultSelector;\n    this.defaultValue = defaultValue;\n    this.source = source;\n    this.hasValue = false;\n    this.index = 0;\n\n    if (typeof defaultValue !== 'undefined') {\n      this.lastValue = defaultValue;\n      this.hasValue = true;\n    }\n  }\n\n  LastSubscriber.prototype._next = function (value) {\n    var index = this.index++;\n\n    if (this.predicate) {\n      this._tryPredicate(value, index);\n    } else {\n      if (this.resultSelector) {\n        this._tryResultSelector(value, index);\n\n        return;\n      }\n\n      this.lastValue = value;\n      this.hasValue = true;\n    }\n  };\n\n  LastSubscriber.prototype._tryPredicate = function (value, index) {\n    var result;\n\n    try {\n      result = this.predicate(value, index, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      if (this.resultSelector) {\n        this._tryResultSelector(value, index);\n\n        return;\n      }\n\n      this.lastValue = value;\n      this.hasValue = true;\n    }\n  };\n\n  LastSubscriber.prototype._tryResultSelector = function (value, index) {\n    var result;\n\n    try {\n      result = this.resultSelector(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.lastValue = result;\n    this.hasValue = true;\n  };\n\n  LastSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n\n    if (this.hasValue) {\n      destination.next(this.lastValue);\n      destination.complete();\n    } else {\n      destination.error(new EmptyError_1.EmptyError());\n    }\n  };\n\n  return LastSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"fmye\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar last_1 = /*@__PURE__*/__webpack_require__(\"ffiR\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - The condition any source emitted item has to satisfy.\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\n\n\nfunction last(predicate, resultSelector, defaultValue) {\n  return last_1.last(predicate, resultSelector, defaultValue)(this);\n}\n\nexports.last = last;\n\n/***/ }),\n\n/***/ \"foHw\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.isArrayLike = function (x) {\n  return x && typeof x.length === 'number';\n};\n\n/***/ }),\n\n/***/ \"g1x8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar fromEventPattern_1 = __webpack_require__(\"cIDA\");\n\nObservable_1.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern; //# sourceMappingURL=fromEventPattern.js.map\n\n/***/ }),\n\n/***/ \"g2Fv\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nvar Action_1 = /*@__PURE__*/__webpack_require__(\"8JYq\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar AsyncAction = function (_super) {\n  __extends(AsyncAction, _super);\n\n  function AsyncAction(scheduler, work) {\n    _super.call(this, scheduler, work);\n\n    this.scheduler = scheduler;\n    this.pending = false;\n    this.work = work;\n  }\n\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (this.closed) {\n      return this;\n    } // Always replace the current state with the new state.\n\n\n    this.state = state; // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n\n    this.pending = true;\n    var id = this.id;\n    var scheduler = this.scheduler; //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.delay = delay; // If this action has already an async Id, don't request a new one.\n\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n\n  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n\n  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    } // If this action is rescheduled with the same delay time, don't clear the interval id.\n\n\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    } // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n\n\n    return root_1.root.clearInterval(id) && undefined || undefined;\n  };\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n\n\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n\n    var error = this._execute(state, delay);\n\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n\n  AsyncAction.prototype._execute = function (state, delay) {\n    var errored = false;\n    var errorValue = undefined;\n\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n  /** @deprecated internal use only */\n\n\n  AsyncAction.prototype._unsubscribe = function () {\n    var id = this.id;\n    var scheduler = this.scheduler;\n    var actions = scheduler.actions;\n    var index = actions.indexOf(this);\n    this.work = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  };\n\n  return AsyncAction;\n}(Action_1.Action);\n\nexports.AsyncAction = AsyncAction;\n\n/***/ }),\n\n/***/ \"gIzs\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar merge_1 = /*@__PURE__*/__webpack_require__(\"LqmK\");\n\nvar merge_2 = /*@__PURE__*/__webpack_require__(\"MdjT\");\n\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\n\nfunction merge() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return merge_1.merge.apply(void 0, observables)(this);\n}\n\nexports.merge = merge;\n\n/***/ }),\n\n/***/ \"gRDe\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/* tslint:disable:no-empty */\n\nfunction noop() {}\n\nexports.noop = noop;\n\n/***/ }),\n\n/***/ \"gSfb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar not_1 = /*@__PURE__*/__webpack_require__(\"bq7C\");\n\nvar filter_1 = /*@__PURE__*/__webpack_require__(\"ZXB4\");\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * <img src=\"./img/partition.png\" width=\"100%\">\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n * var clicksOnDivs = parts[0];\n * var clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n */\n\n\nfunction partition(predicate, thisArg) {\n  return function (source) {\n    return [filter_1.filter(predicate, thisArg)(source), filter_1.filter(not_1.not(predicate, thisArg))(source)];\n  };\n}\n\nexports.partition = partition;\n\n/***/ }),\n\n/***/ \"gcf/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar multicast_1 = /*@__PURE__*/__webpack_require__(\"cf1P\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\n\n\nfunction publish(selector) {\n  return selector ? multicast_1.multicast(function () {\n    return new Subject_1.Subject();\n  }, selector) : multicast_1.multicast(new Subject_1.Subject());\n}\n\nexports.publish = publish;\n\n/***/ }),\n\n/***/ \"gugg\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar shareReplay_1 = __webpack_require__(\"rOew\");\n\nObservable_1.Observable.prototype.shareReplay = shareReplay_1.shareReplay; //# sourceMappingURL=shareReplay.js.map\n\n/***/ }),\n\n/***/ \"h8ds\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar skipLast_1 = /*@__PURE__*/__webpack_require__(\"7Nkz\");\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\n\n\nfunction skipLast(count) {\n  return skipLast_1.skipLast(count)(this);\n}\n\nexports.skipLast = skipLast;\n\n/***/ }),\n\n/***/ \"hV2K\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar auditTime_1 = /*@__PURE__*/__webpack_require__(\"cUCP\");\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\n\n\nfunction auditTime(duration, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return auditTime_1.auditTime(duration, scheduler)(this);\n}\n\nexports.auditTime = auditTime;\n\n/***/ }),\n\n/***/ \"hY8S\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar switchMap_1 = /*@__PURE__*/__webpack_require__(\"VVja\");\n\nvar identity_1 = /*@__PURE__*/__webpack_require__(\"LAU0\");\n\nfunction switchAll() {\n  return switchMap_1.switchMap(identity_1.identity);\n}\n\nexports.switchAll = switchAll;\n\n/***/ }),\n\n/***/ \"hgYf\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar delay_1 = __webpack_require__(\"BWyk\");\n\nObservable_1.Observable.prototype.delay = delay_1.delay; //# sourceMappingURL=delay.js.map\n\n/***/ }),\n\n/***/ \"hut+\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction isDate(value) {\n  return value instanceof Date && !isNaN(+value);\n}\n\nexports.isDate = isDate;\n\n/***/ }),\n\n/***/ \"hw8L\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar exhaustMap_1 = /*@__PURE__*/__webpack_require__(\"GEfX\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\n\n\nfunction exhaustMap(project, resultSelector) {\n  return exhaustMap_1.exhaustMap(project, resultSelector)(this);\n}\n\nexports.exhaustMap = exhaustMap;\n\n/***/ }),\n\n/***/ \"i45a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar ErrorObservable = function (_super) {\n  __extends(ErrorObservable, _super);\n\n  function ErrorObservable(error, scheduler) {\n    _super.call(this);\n\n    this.error = error;\n    this.scheduler = scheduler;\n  }\n  /**\n   * Creates an Observable that emits no items to the Observer and immediately\n   * emits an error notification.\n   *\n   * <span class=\"informal\">Just emits 'error', and nothing else.\n   * </span>\n   *\n   * <img src=\"./img/throw.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the error notification. It can be used for composing with other\n   * Observables, such as in a {@link mergeMap}.\n   *\n   * @example <caption>Emit the number 7, then emit an error.</caption>\n   * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>\n   * var interval = Rx.Observable.interval(1000);\n   * var result = interval.mergeMap(x =>\n   *   x === 13 ?\n   *     Rx.Observable.throw('Thirteens are bad') :\n   *     Rx.Observable.of('a', 'b', 'c')\n   * );\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link of}\n   *\n   * @param {any} error The particular Error to pass to the error notification.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emission of the error notification.\n   * @return {Observable} An error Observable: emits only the error notification\n   * using the given error argument.\n   * @static true\n   * @name throw\n   * @owner Observable\n   */\n\n\n  ErrorObservable.create = function (error, scheduler) {\n    return new ErrorObservable(error, scheduler);\n  };\n\n  ErrorObservable.dispatch = function (arg) {\n    var error = arg.error,\n        subscriber = arg.subscriber;\n    subscriber.error(error);\n  };\n  /** @deprecated internal use only */\n\n\n  ErrorObservable.prototype._subscribe = function (subscriber) {\n    var error = this.error;\n    var scheduler = this.scheduler;\n    subscriber.syncErrorThrowable = true;\n\n    if (scheduler) {\n      return scheduler.schedule(ErrorObservable.dispatch, 0, {\n        error: error,\n        subscriber: subscriber\n      });\n    } else {\n      subscriber.error(error);\n    }\n  };\n\n  return ErrorObservable;\n}(Observable_1.Observable);\n\nexports.ErrorObservable = ErrorObservable;\n\n/***/ }),\n\n/***/ \"iYe0\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var secondsBeforeClick = seconds.takeUntil(clicks);\n * var result = secondsBeforeClick.count();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n * var numbers = Rx.Observable.range(1, 7);\n * var result = numbers.count(i => i % 2 === 1);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 4\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\n\n\nfunction count(predicate) {\n  return function (source) {\n    return source.lift(new CountOperator(predicate, source));\n  };\n}\n\nexports.count = count;\n\nvar CountOperator = /*@__PURE__*/function () {\n  function CountOperator(predicate, source) {\n    this.predicate = predicate;\n    this.source = source;\n  }\n\n  CountOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n  };\n\n  return CountOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar CountSubscriber = function (_super) {\n  __extends(CountSubscriber, _super);\n\n  function CountSubscriber(destination, predicate, source) {\n    _super.call(this, destination);\n\n    this.predicate = predicate;\n    this.source = source;\n    this.count = 0;\n    this.index = 0;\n  }\n\n  CountSubscriber.prototype._next = function (value) {\n    if (this.predicate) {\n      this._tryPredicate(value);\n    } else {\n      this.count++;\n    }\n  };\n\n  CountSubscriber.prototype._tryPredicate = function (value) {\n    var result;\n\n    try {\n      result = this.predicate(value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.count++;\n    }\n  };\n\n  CountSubscriber.prototype._complete = function () {\n    this.destination.next(this.count);\n    this.destination.complete();\n  };\n\n  return CountSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"iaCc\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar RangeObservable_1 = /*@__PURE__*/__webpack_require__(\"+UM1\");\n\nexports.range = RangeObservable_1.RangeObservable.create;\n\n/***/ }),\n\n/***/ \"jNrO\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar sampleTime_1 = __webpack_require__(\"aea6\");\n\nObservable_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime; //# sourceMappingURL=sampleTime.js.map\n\n/***/ }),\n\n/***/ \"jRt/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar min_1 = /*@__PURE__*/__webpack_require__(\"Kc9Z\");\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * <img src=\"./img/min.png\" width=\"100%\">\n *\n * @example <caption>Get the minimal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .min()\n *   .subscribe(x => console.log(x)); // -> 2\n *\n * @example <caption>Use a comparer function to get the minimal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * }\n *\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\n\n\nfunction min(comparer) {\n  return min_1.min(comparer)(this);\n}\n\nexports.min = min;\n\n/***/ }),\n\n/***/ \"jc2T\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar pluck_1 = __webpack_require__(\"8ywx\");\n\nObservable_1.Observable.prototype.pluck = pluck_1.pluck; //# sourceMappingURL=pluck.js.map\n\n/***/ }),\n\n/***/ \"klBC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar map_1 = /*@__PURE__*/__webpack_require__(\"aK2G\");\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\n\n\nfunction map(project, thisArg) {\n  return map_1.map(project, thisArg)(this);\n}\n\nexports.map = map;\n\n/***/ }),\n\n/***/ \"ks6M\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bufferToggle_1 = /*@__PURE__*/__webpack_require__(\"re5B\");\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\n\n\nfunction bufferToggle(openings, closingSelector) {\n  return bufferToggle_1.bufferToggle(openings, closingSelector)(this);\n}\n\nexports.bufferToggle = bufferToggle;\n\n/***/ }),\n\n/***/ \"kwlx\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\n\n\nvar UnsubscriptionError = function (_super) {\n  __extends(UnsubscriptionError, _super);\n\n  function UnsubscriptionError(errors) {\n    _super.call(this);\n\n    this.errors = errors;\n    var err = Error.call(this, errors ? errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) {\n      return i + 1 + \") \" + err.toString();\n    }).join('\\n  ') : '');\n    this.name = err.name = 'UnsubscriptionError';\n    this.stack = err.stack;\n    this.message = err.message;\n  }\n\n  return UnsubscriptionError;\n}(Error);\n\nexports.UnsubscriptionError = UnsubscriptionError;\n\n/***/ }),\n\n/***/ \"l/bX\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar timeoutWith_1 = __webpack_require__(\"agdi\");\n\nObservable_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith; //# sourceMappingURL=timeoutWith.js.map\n\n/***/ }),\n\n/***/ \"l1g9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar takeLast_1 = __webpack_require__(\"5sLA\");\n\nObservable_1.Observable.prototype.takeLast = takeLast_1.takeLast; //# sourceMappingURL=takeLast.js.map\n\n/***/ }),\n\n/***/ \"l6Ej\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar distinctUntilKeyChanged_1 = /*@__PURE__*/__webpack_require__(\"c4YM\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>An example comparing the name of persons</caption>\n *\n *  interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilKeyChanged('name')\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @example <caption>An example comparing the first letters of the name</caption>\n *\n * interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo1'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo2'},\n *     { age: 6, name: 'Foo3'})\n *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\n\n\nfunction distinctUntilKeyChanged(key, compare) {\n  return distinctUntilKeyChanged_1.distinctUntilKeyChanged(key, compare)(this);\n}\n\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n\n/***/ }),\n\n/***/ \"l9aY\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar distinctUntilChanged_1 = /*@__PURE__*/__webpack_require__(\"rgOj\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\n\n\nfunction distinctUntilChanged(compare, keySelector) {\n  return distinctUntilChanged_1.distinctUntilChanged(compare, keySelector)(this);\n}\n\nexports.distinctUntilChanged = distinctUntilChanged;\n\n/***/ }),\n\n/***/ \"lBaL\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar combineLatest_1 = __webpack_require__(\"RkF3\");\n\nObservable_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest; //# sourceMappingURL=combineLatest.js.map\n\n/***/ }),\n\n/***/ \"lCqY\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar catch_1 = __webpack_require__(\"S26M\");\n\nObservable_1.Observable.prototype.catch = catch_1._catch;\nObservable_1.Observable.prototype._catch = catch_1._catch; //# sourceMappingURL=catch.js.map\n\n/***/ }),\n\n/***/ \"laXh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar mergeScan_1 = __webpack_require__(\"+1VR\");\n\nObservable_1.Observable.prototype.mergeScan = mergeScan_1.mergeScan; //# sourceMappingURL=mergeScan.js.map\n\n/***/ }),\n\n/***/ \"lf2g\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\n\n\nfunction mergeMap(project, resultSelector, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  return function mergeMapOperatorFunction(source) {\n    if (typeof resultSelector === 'number') {\n      concurrent = resultSelector;\n      resultSelector = null;\n    }\n\n    return source.lift(new MergeMapOperator(project, resultSelector, concurrent));\n  };\n}\n\nexports.mergeMap = mergeMap;\n\nvar MergeMapOperator = /*@__PURE__*/function () {\n  function MergeMapOperator(project, resultSelector, concurrent) {\n    if (concurrent === void 0) {\n      concurrent = Number.POSITIVE_INFINITY;\n    }\n\n    this.project = project;\n    this.resultSelector = resultSelector;\n    this.concurrent = concurrent;\n  }\n\n  MergeMapOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n  };\n\n  return MergeMapOperator;\n}();\n\nexports.MergeMapOperator = MergeMapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar MergeMapSubscriber = function (_super) {\n  __extends(MergeMapSubscriber, _super);\n\n  function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n    if (concurrent === void 0) {\n      concurrent = Number.POSITIVE_INFINITY;\n    }\n\n    _super.call(this, destination);\n\n    this.project = project;\n    this.resultSelector = resultSelector;\n    this.concurrent = concurrent;\n    this.hasCompleted = false;\n    this.buffer = [];\n    this.active = 0;\n    this.index = 0;\n  }\n\n  MergeMapSubscriber.prototype._next = function (value) {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  };\n\n  MergeMapSubscriber.prototype._tryNext = function (value) {\n    var result;\n    var index = this.index++;\n\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.active++;\n\n    this._innerSub(result, value, index);\n  };\n\n  MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n    this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n  };\n\n  MergeMapSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  };\n\n  MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    if (this.resultSelector) {\n      this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      this.destination.next(innerValue);\n    }\n  };\n\n  MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n    var result;\n\n    try {\n      result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n    var buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return MergeMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\nexports.MergeMapSubscriber = MergeMapSubscriber;\n\n/***/ }),\n\n/***/ \"loW1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar AsyncScheduler_1 = /*@__PURE__*/__webpack_require__(\"FXL7\");\n\nvar AnimationFrameScheduler = function (_super) {\n  __extends(AnimationFrameScheduler, _super);\n\n  function AnimationFrameScheduler() {\n    _super.apply(this, arguments);\n  }\n\n  AnimationFrameScheduler.prototype.flush = function (action) {\n    this.active = true;\n    this.scheduled = undefined;\n    var actions = this.actions;\n    var error;\n    var index = -1;\n    var count = actions.length;\n    action = action || actions.shift();\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (++index < count && (action = actions.shift()));\n\n    this.active = false;\n\n    if (error) {\n      while (++index < count && (action = actions.shift())) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  return AnimationFrameScheduler;\n}(AsyncScheduler_1.AsyncScheduler);\n\nexports.AnimationFrameScheduler = AnimationFrameScheduler;\n\n/***/ }),\n\n/***/ \"m+NU\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar iterator_1 = /*@__PURE__*/__webpack_require__(\"+2+e\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar IteratorObservable = function (_super) {\n  __extends(IteratorObservable, _super);\n\n  function IteratorObservable(iterator, scheduler) {\n    _super.call(this);\n\n    this.scheduler = scheduler;\n\n    if (iterator == null) {\n      throw new Error('iterator cannot be null.');\n    }\n\n    this.iterator = getIterator(iterator);\n  }\n\n  IteratorObservable.create = function (iterator, scheduler) {\n    return new IteratorObservable(iterator, scheduler);\n  };\n\n  IteratorObservable.dispatch = function (state) {\n    var index = state.index,\n        hasError = state.hasError,\n        iterator = state.iterator,\n        subscriber = state.subscriber;\n\n    if (hasError) {\n      subscriber.error(state.error);\n      return;\n    }\n\n    var result = iterator.next();\n\n    if (result.done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(result.value);\n    state.index = index + 1;\n\n    if (subscriber.closed) {\n      if (typeof iterator.return === 'function') {\n        iterator.return();\n      }\n\n      return;\n    }\n\n    this.schedule(state);\n  };\n  /** @deprecated internal use only */\n\n\n  IteratorObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n\n    var _a = this,\n        iterator = _a.iterator,\n        scheduler = _a.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(IteratorObservable.dispatch, 0, {\n        index: index,\n        iterator: iterator,\n        subscriber: subscriber\n      });\n    } else {\n      do {\n        var result = iterator.next();\n\n        if (result.done) {\n          subscriber.complete();\n          break;\n        } else {\n          subscriber.next(result.value);\n        }\n\n        if (subscriber.closed) {\n          if (typeof iterator.return === 'function') {\n            iterator.return();\n          }\n\n          break;\n        }\n      } while (true);\n    }\n  };\n\n  return IteratorObservable;\n}(Observable_1.Observable);\n\nexports.IteratorObservable = IteratorObservable;\n\nvar StringIterator = /*@__PURE__*/function () {\n  function StringIterator(str, idx, len) {\n    if (idx === void 0) {\n      idx = 0;\n    }\n\n    if (len === void 0) {\n      len = str.length;\n    }\n\n    this.str = str;\n    this.idx = idx;\n    this.len = len;\n  }\n\n  StringIterator.prototype[iterator_1.iterator] = function () {\n    return this;\n  };\n\n  StringIterator.prototype.next = function () {\n    return this.idx < this.len ? {\n      done: false,\n      value: this.str.charAt(this.idx++)\n    } : {\n      done: true,\n      value: undefined\n    };\n  };\n\n  return StringIterator;\n}();\n\nvar ArrayIterator = /*@__PURE__*/function () {\n  function ArrayIterator(arr, idx, len) {\n    if (idx === void 0) {\n      idx = 0;\n    }\n\n    if (len === void 0) {\n      len = toLength(arr);\n    }\n\n    this.arr = arr;\n    this.idx = idx;\n    this.len = len;\n  }\n\n  ArrayIterator.prototype[iterator_1.iterator] = function () {\n    return this;\n  };\n\n  ArrayIterator.prototype.next = function () {\n    return this.idx < this.len ? {\n      done: false,\n      value: this.arr[this.idx++]\n    } : {\n      done: true,\n      value: undefined\n    };\n  };\n\n  return ArrayIterator;\n}();\n\nfunction getIterator(obj) {\n  var i = obj[iterator_1.iterator];\n\n  if (!i && typeof obj === 'string') {\n    return new StringIterator(obj);\n  }\n\n  if (!i && obj.length !== undefined) {\n    return new ArrayIterator(obj);\n  }\n\n  if (!i) {\n    throw new TypeError('object is not iterable');\n  }\n\n  return obj[iterator_1.iterator]();\n}\n\nvar maxSafeInteger = /*@__PURE__*/Math.pow(2, 53) - 1;\n\nfunction toLength(o) {\n  var len = +o.length;\n\n  if (isNaN(len)) {\n    return 0;\n  }\n\n  if (len === 0 || !numberIsFinite(len)) {\n    return len;\n  }\n\n  len = sign(len) * Math.floor(Math.abs(len));\n\n  if (len <= 0) {\n    return 0;\n  }\n\n  if (len > maxSafeInteger) {\n    return maxSafeInteger;\n  }\n\n  return len;\n}\n\nfunction numberIsFinite(value) {\n  return typeof value === 'number' && root_1.root.isFinite(value);\n}\n\nfunction sign(value) {\n  var valueAsNumber = +value;\n\n  if (valueAsNumber === 0) {\n    return valueAsNumber;\n  }\n\n  if (isNaN(valueAsNumber)) {\n    return valueAsNumber;\n  }\n\n  return valueAsNumber < 0 ? -1 : 1;\n}\n\n/***/ }),\n\n/***/ \"m8PH\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nvar ReplaySubject_1 = /*@__PURE__*/__webpack_require__(\"BjeI\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar assign_1 = /*@__PURE__*/__webpack_require__(\"2gSr\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar WebSocketSubject = function (_super) {\n  __extends(WebSocketSubject, _super);\n\n  function WebSocketSubject(urlConfigOrSource, destination) {\n    if (urlConfigOrSource instanceof Observable_1.Observable) {\n      _super.call(this, destination, urlConfigOrSource);\n    } else {\n      _super.call(this);\n\n      this.WebSocketCtor = root_1.root.WebSocket;\n      this._output = new Subject_1.Subject();\n\n      if (typeof urlConfigOrSource === 'string') {\n        this.url = urlConfigOrSource;\n      } else {\n        // WARNING: config object could override important members here.\n        assign_1.assign(this, urlConfigOrSource);\n      }\n\n      if (!this.WebSocketCtor) {\n        throw new Error('no WebSocket constructor can be found');\n      }\n\n      this.destination = new ReplaySubject_1.ReplaySubject();\n    }\n  }\n\n  WebSocketSubject.prototype.resultSelector = function (e) {\n    return JSON.parse(e.data);\n  };\n  /**\n   * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n   *\n   * @example <caption>Wraps browser WebSocket</caption>\n   *\n   * let socket$ = Observable.webSocket('ws://localhost:8081');\n   *\n   * socket$.subscribe(\n   *    (msg) => console.log('message received: ' + msg),\n   *    (err) => console.log(err),\n   *    () => console.log('complete')\n   *  );\n   *\n   * socket$.next(JSON.stringify({ op: 'hello' }));\n   *\n   * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>\n   *\n   * import { w3cwebsocket } from 'websocket';\n   *\n   * let socket$ = Observable.webSocket({\n   *   url: 'ws://localhost:8081',\n   *   WebSocketCtor: w3cwebsocket\n   * });\n   *\n   * socket$.subscribe(\n   *    (msg) => console.log('message received: ' + msg),\n   *    (err) => console.log(err),\n   *    () => console.log('complete')\n   *  );\n   *\n   * socket$.next(JSON.stringify({ op: 'hello' }));\n   *\n   * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object\n   * @return {WebSocketSubject}\n   * @static true\n   * @name webSocket\n   * @owner Observable\n   */\n\n\n  WebSocketSubject.create = function (urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n  };\n\n  WebSocketSubject.prototype.lift = function (operator) {\n    var sock = new WebSocketSubject(this, this.destination);\n    sock.operator = operator;\n    return sock;\n  };\n\n  WebSocketSubject.prototype._resetState = function () {\n    this.socket = null;\n\n    if (!this.source) {\n      this.destination = new ReplaySubject_1.ReplaySubject();\n    }\n\n    this._output = new Subject_1.Subject();\n  }; // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures\n\n\n  WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n    var self = this;\n    return new Observable_1.Observable(function (observer) {\n      var result = tryCatch_1.tryCatch(subMsg)();\n\n      if (result === errorObject_1.errorObject) {\n        observer.error(errorObject_1.errorObject.e);\n      } else {\n        self.next(result);\n      }\n\n      var subscription = self.subscribe(function (x) {\n        var result = tryCatch_1.tryCatch(messageFilter)(x);\n\n        if (result === errorObject_1.errorObject) {\n          observer.error(errorObject_1.errorObject.e);\n        } else if (result) {\n          observer.next(x);\n        }\n      }, function (err) {\n        return observer.error(err);\n      }, function () {\n        return observer.complete();\n      });\n      return function () {\n        var result = tryCatch_1.tryCatch(unsubMsg)();\n\n        if (result === errorObject_1.errorObject) {\n          observer.error(errorObject_1.errorObject.e);\n        } else {\n          self.next(result);\n        }\n\n        subscription.unsubscribe();\n      };\n    });\n  };\n\n  WebSocketSubject.prototype._connectSocket = function () {\n    var _this = this;\n\n    var WebSocketCtor = this.WebSocketCtor;\n    var observer = this._output;\n    var socket = null;\n\n    try {\n      socket = this.protocol ? new WebSocketCtor(this.url, this.protocol) : new WebSocketCtor(this.url);\n      this.socket = socket;\n\n      if (this.binaryType) {\n        this.socket.binaryType = this.binaryType;\n      }\n    } catch (e) {\n      observer.error(e);\n      return;\n    }\n\n    var subscription = new Subscription_1.Subscription(function () {\n      _this.socket = null;\n\n      if (socket && socket.readyState === 1) {\n        socket.close();\n      }\n    });\n\n    socket.onopen = function (e) {\n      var openObserver = _this.openObserver;\n\n      if (openObserver) {\n        openObserver.next(e);\n      }\n\n      var queue = _this.destination;\n      _this.destination = Subscriber_1.Subscriber.create(function (x) {\n        return socket.readyState === 1 && socket.send(x);\n      }, function (e) {\n        var closingObserver = _this.closingObserver;\n\n        if (closingObserver) {\n          closingObserver.next(undefined);\n        }\n\n        if (e && e.code) {\n          socket.close(e.code, e.reason);\n        } else {\n          observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' + 'and an optional reason: { code: number, reason: string }'));\n        }\n\n        _this._resetState();\n      }, function () {\n        var closingObserver = _this.closingObserver;\n\n        if (closingObserver) {\n          closingObserver.next(undefined);\n        }\n\n        socket.close();\n\n        _this._resetState();\n      });\n\n      if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {\n        subscription.add(queue.subscribe(_this.destination));\n      }\n    };\n\n    socket.onerror = function (e) {\n      _this._resetState();\n\n      observer.error(e);\n    };\n\n    socket.onclose = function (e) {\n      _this._resetState();\n\n      var closeObserver = _this.closeObserver;\n\n      if (closeObserver) {\n        closeObserver.next(e);\n      }\n\n      if (e.wasClean) {\n        observer.complete();\n      } else {\n        observer.error(e);\n      }\n    };\n\n    socket.onmessage = function (e) {\n      var result = tryCatch_1.tryCatch(_this.resultSelector)(e);\n\n      if (result === errorObject_1.errorObject) {\n        observer.error(errorObject_1.errorObject.e);\n      } else {\n        observer.next(result);\n      }\n    };\n  };\n  /** @deprecated internal use only */\n\n\n  WebSocketSubject.prototype._subscribe = function (subscriber) {\n    var _this = this;\n\n    var source = this.source;\n\n    if (source) {\n      return source.subscribe(subscriber);\n    }\n\n    if (!this.socket) {\n      this._connectSocket();\n    }\n\n    var subscription = new Subscription_1.Subscription();\n    subscription.add(this._output.subscribe(subscriber));\n    subscription.add(function () {\n      var socket = _this.socket;\n\n      if (_this._output.observers.length === 0) {\n        if (socket && socket.readyState === 1) {\n          socket.close();\n        }\n\n        _this._resetState();\n      }\n    });\n    return subscription;\n  };\n\n  WebSocketSubject.prototype.unsubscribe = function () {\n    var _a = this,\n        source = _a.source,\n        socket = _a.socket;\n\n    if (socket && socket.readyState === 1) {\n      socket.close();\n\n      this._resetState();\n    }\n\n    _super.prototype.unsubscribe.call(this);\n\n    if (!source) {\n      this.destination = new ReplaySubject_1.ReplaySubject();\n    }\n  };\n\n  return WebSocketSubject;\n}(Subject_1.AnonymousSubject);\n\nexports.WebSocketSubject = WebSocketSubject;\n\n/***/ }),\n\n/***/ \"mO1z\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\n\n\nfunction dematerialize() {\n  return function dematerializeOperatorFunction(source) {\n    return source.lift(new DeMaterializeOperator());\n  };\n}\n\nexports.dematerialize = dematerialize;\n\nvar DeMaterializeOperator = /*@__PURE__*/function () {\n  function DeMaterializeOperator() {}\n\n  DeMaterializeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DeMaterializeSubscriber(subscriber));\n  };\n\n  return DeMaterializeOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar DeMaterializeSubscriber = function (_super) {\n  __extends(DeMaterializeSubscriber, _super);\n\n  function DeMaterializeSubscriber(destination) {\n    _super.call(this, destination);\n  }\n\n  DeMaterializeSubscriber.prototype._next = function (value) {\n    value.observe(this.destination);\n  };\n\n  return DeMaterializeSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"mSFr\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar retry_1 = __webpack_require__(\"Kwcu\");\n\nObservable_1.Observable.prototype.retry = retry_1.retry; //# sourceMappingURL=retry.js.map\n\n/***/ }),\n\n/***/ \"mXuN\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar skipUntil_1 = __webpack_require__(\"PqiM\");\n\nObservable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil; //# sourceMappingURL=skipUntil.js.map\n\n/***/ }),\n\n/***/ \"mdQD\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\n\n\nfunction audit(durationSelector) {\n  return function auditOperatorFunction(source) {\n    return source.lift(new AuditOperator(durationSelector));\n  };\n}\n\nexports.audit = audit;\n\nvar AuditOperator = /*@__PURE__*/function () {\n  function AuditOperator(durationSelector) {\n    this.durationSelector = durationSelector;\n  }\n\n  AuditOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n  };\n\n  return AuditOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar AuditSubscriber = function (_super) {\n  __extends(AuditSubscriber, _super);\n\n  function AuditSubscriber(destination, durationSelector) {\n    _super.call(this, destination);\n\n    this.durationSelector = durationSelector;\n    this.hasValue = false;\n  }\n\n  AuditSubscriber.prototype._next = function (value) {\n    this.value = value;\n    this.hasValue = true;\n\n    if (!this.throttled) {\n      var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n\n      if (duration === errorObject_1.errorObject) {\n        this.destination.error(errorObject_1.errorObject.e);\n      } else {\n        var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n\n        if (innerSubscription.closed) {\n          this.clearThrottle();\n        } else {\n          this.add(this.throttled = innerSubscription);\n        }\n      }\n    }\n  };\n\n  AuditSubscriber.prototype.clearThrottle = function () {\n    var _a = this,\n        value = _a.value,\n        hasValue = _a.hasValue,\n        throttled = _a.throttled;\n\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = null;\n      throttled.unsubscribe();\n    }\n\n    if (hasValue) {\n      this.value = null;\n      this.hasValue = false;\n      this.destination.next(value);\n    }\n  };\n\n  AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n    this.clearThrottle();\n  };\n\n  AuditSubscriber.prototype.notifyComplete = function () {\n    this.clearThrottle();\n  };\n\n  return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"mz1d\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar concatMapTo_1 = __webpack_require__(\"qnn9\");\n\nObservable_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo; //# sourceMappingURL=concatMapTo.js.map\n\n/***/ }),\n\n/***/ \"n8Qg\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/* tslint:enable:max-line-length */\n\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\n\n\nfunction scan(accumulator, seed) {\n  var hasSeed = false; // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n\n  if (arguments.length >= 2) {\n    hasSeed = true;\n  }\n\n  return function scanOperatorFunction(source) {\n    return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n  };\n}\n\nexports.scan = scan;\n\nvar ScanOperator = /*@__PURE__*/function () {\n  function ScanOperator(accumulator, seed, hasSeed) {\n    if (hasSeed === void 0) {\n      hasSeed = false;\n    }\n\n    this.accumulator = accumulator;\n    this.seed = seed;\n    this.hasSeed = hasSeed;\n  }\n\n  ScanOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n  };\n\n  return ScanOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar ScanSubscriber = function (_super) {\n  __extends(ScanSubscriber, _super);\n\n  function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n    _super.call(this, destination);\n\n    this.accumulator = accumulator;\n    this._seed = _seed;\n    this.hasSeed = hasSeed;\n    this.index = 0;\n  }\n\n  Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n    get: function get() {\n      return this._seed;\n    },\n    set: function set(value) {\n      this.hasSeed = true;\n      this._seed = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ScanSubscriber.prototype._next = function (value) {\n    if (!this.hasSeed) {\n      this.seed = value;\n      this.destination.next(value);\n    } else {\n      return this._tryNext(value);\n    }\n  };\n\n  ScanSubscriber.prototype._tryNext = function (value) {\n    var index = this.index++;\n    var result;\n\n    try {\n      result = this.accumulator(this.seed, value, index);\n    } catch (err) {\n      this.destination.error(err);\n    }\n\n    this.seed = result;\n    this.destination.next(result);\n  };\n\n  return ScanSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"nD5C\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar reduce_1 = __webpack_require__(\"6GWt\");\n\nObservable_1.Observable.prototype.reduce = reduce_1.reduce; //# sourceMappingURL=reduce.js.map\n\n/***/ }),\n\n/***/ \"nQov\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nvar Set_1 = /*@__PURE__*/__webpack_require__(\"eBTF\");\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .distinct()\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n *\n * @example <caption>An example using a keySelector function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     .distinct((p: Person) => p.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n *\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\n\n\nfunction distinct(keySelector, flushes) {\n  return function (source) {\n    return source.lift(new DistinctOperator(keySelector, flushes));\n  };\n}\n\nexports.distinct = distinct;\n\nvar DistinctOperator = /*@__PURE__*/function () {\n  function DistinctOperator(keySelector, flushes) {\n    this.keySelector = keySelector;\n    this.flushes = flushes;\n  }\n\n  DistinctOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n  };\n\n  return DistinctOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar DistinctSubscriber = function (_super) {\n  __extends(DistinctSubscriber, _super);\n\n  function DistinctSubscriber(destination, keySelector, flushes) {\n    _super.call(this, destination);\n\n    this.keySelector = keySelector;\n    this.values = new Set_1.Set();\n\n    if (flushes) {\n      this.add(subscribeToResult_1.subscribeToResult(this, flushes));\n    }\n  }\n\n  DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.values.clear();\n  };\n\n  DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n    this._error(error);\n  };\n\n  DistinctSubscriber.prototype._next = function (value) {\n    if (this.keySelector) {\n      this._useKeySelector(value);\n    } else {\n      this._finalizeNext(value, value);\n    }\n  };\n\n  DistinctSubscriber.prototype._useKeySelector = function (value) {\n    var key;\n    var destination = this.destination;\n\n    try {\n      key = this.keySelector(value);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    this._finalizeNext(key, value);\n  };\n\n  DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n    var values = this.values;\n\n    if (!values.has(key)) {\n      values.add(key);\n      this.destination.next(value);\n    }\n  };\n\n  return DistinctSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\nexports.DistinctSubscriber = DistinctSubscriber;\n\n/***/ }),\n\n/***/ \"nXmG\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar onErrorResumeNext_1 = __webpack_require__(\"onNu\");\n\nObservable_1.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext; //# sourceMappingURL=onErrorResumeNext.js.map\n\n/***/ }),\n\n/***/ \"nfiU\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar concatMap_1 = __webpack_require__(\"KC+j\");\n\nObservable_1.Observable.prototype.concatMap = concatMap_1.concatMap; //# sourceMappingURL=concatMap.js.map\n\n/***/ }),\n\n/***/ \"nkkL\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nvar Symbol = root_1.root.Symbol;\nexports.rxSubscriber = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? /*@__PURE__*/Symbol.for('rxSubscriber') : '@@rxSubscriber';\n/**\n * @deprecated use rxSubscriber instead\n */\n\nexports.$$rxSubscriber = exports.rxSubscriber;\n\n/***/ }),\n\n/***/ \"nxYh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bufferCount_1 = /*@__PURE__*/__webpack_require__(\"16yF\");\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\n\n\nfunction bufferCount(bufferSize, startBufferEvery) {\n  if (startBufferEvery === void 0) {\n    startBufferEvery = null;\n  }\n\n  return bufferCount_1.bufferCount(bufferSize, startBufferEvery)(this);\n}\n\nexports.bufferCount = bufferCount;\n\n/***/ }),\n\n/***/ \"o/sf\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar never_1 = __webpack_require__(\"9A9s\");\n\nObservable_1.Observable.never = never_1.never; //# sourceMappingURL=never.js.map\n\n/***/ }),\n\n/***/ \"o6MN\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nexports.defaultThrottleConfig = {\n  leading: true,\n  trailing: false\n};\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/throttle.png\" width=\"100%\">\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttle(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\n\nfunction throttle(durationSelector, config) {\n  if (config === void 0) {\n    config = exports.defaultThrottleConfig;\n  }\n\n  return function (source) {\n    return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing));\n  };\n}\n\nexports.throttle = throttle;\n\nvar ThrottleOperator = /*@__PURE__*/function () {\n  function ThrottleOperator(durationSelector, leading, trailing) {\n    this.durationSelector = durationSelector;\n    this.leading = leading;\n    this.trailing = trailing;\n  }\n\n  ThrottleOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));\n  };\n\n  return ThrottleOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar ThrottleSubscriber = function (_super) {\n  __extends(ThrottleSubscriber, _super);\n\n  function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {\n    _super.call(this, destination);\n\n    this.destination = destination;\n    this.durationSelector = durationSelector;\n    this._leading = _leading;\n    this._trailing = _trailing;\n    this._hasTrailingValue = false;\n  }\n\n  ThrottleSubscriber.prototype._next = function (value) {\n    if (this.throttled) {\n      if (this._trailing) {\n        this._hasTrailingValue = true;\n        this._trailingValue = value;\n      }\n    } else {\n      var duration = this.tryDurationSelector(value);\n\n      if (duration) {\n        this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));\n      }\n\n      if (this._leading) {\n        this.destination.next(value);\n\n        if (this._trailing) {\n          this._hasTrailingValue = true;\n          this._trailingValue = value;\n        }\n      }\n    }\n  };\n\n  ThrottleSubscriber.prototype.tryDurationSelector = function (value) {\n    try {\n      return this.durationSelector(value);\n    } catch (err) {\n      this.destination.error(err);\n      return null;\n    }\n  };\n  /** @deprecated internal use only */\n\n\n  ThrottleSubscriber.prototype._unsubscribe = function () {\n    var _a = this,\n        throttled = _a.throttled,\n        _trailingValue = _a._trailingValue,\n        _hasTrailingValue = _a._hasTrailingValue,\n        _trailing = _a._trailing;\n\n    this._trailingValue = null;\n    this._hasTrailingValue = false;\n\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = null;\n      throttled.unsubscribe();\n    }\n  };\n\n  ThrottleSubscriber.prototype._sendTrailing = function () {\n    var _a = this,\n        destination = _a.destination,\n        throttled = _a.throttled,\n        _trailing = _a._trailing,\n        _trailingValue = _a._trailingValue,\n        _hasTrailingValue = _a._hasTrailingValue;\n\n    if (throttled && _trailing && _hasTrailingValue) {\n      destination.next(_trailingValue);\n      this._trailingValue = null;\n      this._hasTrailingValue = false;\n    }\n  };\n\n  ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this._sendTrailing();\n\n    this._unsubscribe();\n  };\n\n  ThrottleSubscriber.prototype.notifyComplete = function () {\n    this._sendTrailing();\n\n    this._unsubscribe();\n  };\n\n  return ThrottleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"oGc9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar Notification_1 = /*@__PURE__*/__webpack_require__(\"9x29\");\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1, hasValue: false}\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\n\n\nfunction materialize() {\n  return function materializeOperatorFunction(source) {\n    return source.lift(new MaterializeOperator());\n  };\n}\n\nexports.materialize = materialize;\n\nvar MaterializeOperator = /*@__PURE__*/function () {\n  function MaterializeOperator() {}\n\n  MaterializeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new MaterializeSubscriber(subscriber));\n  };\n\n  return MaterializeOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar MaterializeSubscriber = function (_super) {\n  __extends(MaterializeSubscriber, _super);\n\n  function MaterializeSubscriber(destination) {\n    _super.call(this, destination);\n  }\n\n  MaterializeSubscriber.prototype._next = function (value) {\n    this.destination.next(Notification_1.Notification.createNext(value));\n  };\n\n  MaterializeSubscriber.prototype._error = function (err) {\n    var destination = this.destination;\n    destination.next(Notification_1.Notification.createError(err));\n    destination.complete();\n  };\n\n  MaterializeSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n    destination.next(Notification_1.Notification.createComplete());\n    destination.complete();\n  };\n\n  return MaterializeSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"oQYR\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar ArrayObservable_1 = /*@__PURE__*/__webpack_require__(\"rVFa\");\n\nvar isArray_1 = /*@__PURE__*/__webpack_require__(\"G2HO\");\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nvar iterator_1 = /*@__PURE__*/__webpack_require__(\"+2+e\");\n/* tslint:enable:max-line-length */\n\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\n\n\nfunction zip() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return function zipOperatorFunction(source) {\n    return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));\n  };\n}\n\nexports.zip = zip;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\n\nfunction zipStatic() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  var project = observables[observables.length - 1];\n\n  if (typeof project === 'function') {\n    observables.pop();\n  }\n\n  return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n}\n\nexports.zipStatic = zipStatic;\n\nvar ZipOperator = /*@__PURE__*/function () {\n  function ZipOperator(project) {\n    this.project = project;\n  }\n\n  ZipOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ZipSubscriber(subscriber, this.project));\n  };\n\n  return ZipOperator;\n}();\n\nexports.ZipOperator = ZipOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar ZipSubscriber = function (_super) {\n  __extends(ZipSubscriber, _super);\n\n  function ZipSubscriber(destination, project, values) {\n    if (values === void 0) {\n      values = Object.create(null);\n    }\n\n    _super.call(this, destination);\n\n    this.iterators = [];\n    this.active = 0;\n    this.project = typeof project === 'function' ? project : null;\n    this.values = values;\n  }\n\n  ZipSubscriber.prototype._next = function (value) {\n    var iterators = this.iterators;\n\n    if (isArray_1.isArray(value)) {\n      iterators.push(new StaticArrayIterator(value));\n    } else if (typeof value[iterator_1.iterator] === 'function') {\n      iterators.push(new StaticIterator(value[iterator_1.iterator]()));\n    } else {\n      iterators.push(new ZipBufferIterator(this.destination, this, value));\n    }\n  };\n\n  ZipSubscriber.prototype._complete = function () {\n    var iterators = this.iterators;\n    var len = iterators.length;\n\n    if (len === 0) {\n      this.destination.complete();\n      return;\n    }\n\n    this.active = len;\n\n    for (var i = 0; i < len; i++) {\n      var iterator = iterators[i];\n\n      if (iterator.stillUnsubscribed) {\n        this.add(iterator.subscribe(iterator, i));\n      } else {\n        this.active--; // not an observable\n      }\n    }\n  };\n\n  ZipSubscriber.prototype.notifyInactive = function () {\n    this.active--;\n\n    if (this.active === 0) {\n      this.destination.complete();\n    }\n  };\n\n  ZipSubscriber.prototype.checkIterators = function () {\n    var iterators = this.iterators;\n    var len = iterators.length;\n    var destination = this.destination; // abort if not all of them have values\n\n    for (var i = 0; i < len; i++) {\n      var iterator = iterators[i];\n\n      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n        return;\n      }\n    }\n\n    var shouldComplete = false;\n    var args = [];\n\n    for (var i = 0; i < len; i++) {\n      var iterator = iterators[i];\n      var result = iterator.next(); // check to see if it's completed now that you've gotten\n      // the next value.\n\n      if (iterator.hasCompleted()) {\n        shouldComplete = true;\n      }\n\n      if (result.done) {\n        destination.complete();\n        return;\n      }\n\n      args.push(result.value);\n    }\n\n    if (this.project) {\n      this._tryProject(args);\n    } else {\n      destination.next(args);\n    }\n\n    if (shouldComplete) {\n      destination.complete();\n    }\n  };\n\n  ZipSubscriber.prototype._tryProject = function (args) {\n    var result;\n\n    try {\n      result = this.project.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return ZipSubscriber;\n}(Subscriber_1.Subscriber);\n\nexports.ZipSubscriber = ZipSubscriber;\n\nvar StaticIterator = /*@__PURE__*/function () {\n  function StaticIterator(iterator) {\n    this.iterator = iterator;\n    this.nextResult = iterator.next();\n  }\n\n  StaticIterator.prototype.hasValue = function () {\n    return true;\n  };\n\n  StaticIterator.prototype.next = function () {\n    var result = this.nextResult;\n    this.nextResult = this.iterator.next();\n    return result;\n  };\n\n  StaticIterator.prototype.hasCompleted = function () {\n    var nextResult = this.nextResult;\n    return nextResult && nextResult.done;\n  };\n\n  return StaticIterator;\n}();\n\nvar StaticArrayIterator = /*@__PURE__*/function () {\n  function StaticArrayIterator(array) {\n    this.array = array;\n    this.index = 0;\n    this.length = 0;\n    this.length = array.length;\n  }\n\n  StaticArrayIterator.prototype[iterator_1.iterator] = function () {\n    return this;\n  };\n\n  StaticArrayIterator.prototype.next = function (value) {\n    var i = this.index++;\n    var array = this.array;\n    return i < this.length ? {\n      value: array[i],\n      done: false\n    } : {\n      value: null,\n      done: true\n    };\n  };\n\n  StaticArrayIterator.prototype.hasValue = function () {\n    return this.array.length > this.index;\n  };\n\n  StaticArrayIterator.prototype.hasCompleted = function () {\n    return this.array.length === this.index;\n  };\n\n  return StaticArrayIterator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar ZipBufferIterator = function (_super) {\n  __extends(ZipBufferIterator, _super);\n\n  function ZipBufferIterator(destination, parent, observable) {\n    _super.call(this, destination);\n\n    this.parent = parent;\n    this.observable = observable;\n    this.stillUnsubscribed = true;\n    this.buffer = [];\n    this.isComplete = false;\n  }\n\n  ZipBufferIterator.prototype[iterator_1.iterator] = function () {\n    return this;\n  }; // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n  //    this is legit because `next()` will never be called by a subscription in this case.\n\n\n  ZipBufferIterator.prototype.next = function () {\n    var buffer = this.buffer;\n\n    if (buffer.length === 0 && this.isComplete) {\n      return {\n        value: null,\n        done: true\n      };\n    } else {\n      return {\n        value: buffer.shift(),\n        done: false\n      };\n    }\n  };\n\n  ZipBufferIterator.prototype.hasValue = function () {\n    return this.buffer.length > 0;\n  };\n\n  ZipBufferIterator.prototype.hasCompleted = function () {\n    return this.buffer.length === 0 && this.isComplete;\n  };\n\n  ZipBufferIterator.prototype.notifyComplete = function () {\n    if (this.buffer.length > 0) {\n      this.isComplete = true;\n      this.parent.notifyInactive();\n    } else {\n      this.destination.complete();\n    }\n  };\n\n  ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.buffer.push(innerValue);\n    this.parent.checkIterators();\n  };\n\n  ZipBufferIterator.prototype.subscribe = function (value, index) {\n    return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n  };\n\n  return ZipBufferIterator;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"od+f\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar EmptyObservable_1 = /*@__PURE__*/__webpack_require__(\"36rE\");\n\nvar isArray_1 = /*@__PURE__*/__webpack_require__(\"G2HO\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar ForkJoinObservable = function (_super) {\n  __extends(ForkJoinObservable, _super);\n\n  function ForkJoinObservable(sources, resultSelector) {\n    _super.call(this);\n\n    this.sources = sources;\n    this.resultSelector = resultSelector;\n  }\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Joins last values emitted by passed Observables.\n   *\n   * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n   *\n   * <img src=\"./img/forkJoin.png\" width=\"100%\">\n   *\n   * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n   * or directly as arguments. If no input Observables are provided, resulting stream will complete\n   * immediately.\n   *\n   * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n   * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n   * array will have `n` values, where first value is the last thing emitted by the first Observable,\n   * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n   * not emit more than once and it will complete after that. If you need to emit combined values not only\n   * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n   * or {@link zip} instead.\n   *\n   * In order for resulting array to have the same length as the number of input Observables, whenever any of\n   * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n   * and it will not emit anything either, even if it already has some last values from other Observables.\n   * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n   * unless at any point some other Observable completes without emitting value, which brings us back to\n   * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n   * have to emit something at least once and complete.\n   *\n   * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n   * will be immediately unsubscribed.\n   *\n   * Optionally `forkJoin` accepts project function, that will be called with values which normally\n   * would land in emitted array. Whatever is returned by project function, will appear in output\n   * Observable instead. This means that default project can be thought of as a function that takes\n   * all its arguments and puts them into an array. Note that project function will be called only\n   * when output Observable is supposed to emit a result.\n   *\n   * @example <caption>Use forkJoin with operator emitting immediately</caption>\n   * const observable = Rx.Observable.forkJoin(\n   *   Rx.Observable.of(1, 2, 3, 4),\n   *   Rx.Observable.of(5, 6, 7, 8)\n   * );\n   * observable.subscribe(\n   *   value => console.log(value),\n   *   err => {},\n   *   () => console.log('This is how it ends!')\n   * );\n   *\n   * // Logs:\n   * // [4, 8]\n   * // \"This is how it ends!\"\n   *\n   *\n   * @example <caption>Use forkJoin with operator emitting after some time</caption>\n   * const observable = Rx.Observable.forkJoin(\n   *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n   *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\n   * );\n   * observable.subscribe(\n   *   value => console.log(value),\n   *   err => {},\n   *   () => console.log('This is how it ends!')\n   * );\n   *\n   * // Logs:\n   * // [2, 3] after 3 seconds\n   * // \"This is how it ends!\" immediately after\n   *\n   *\n   * @example <caption>Use forkJoin with project function</caption>\n   * const observable = Rx.Observable.forkJoin(\n   *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n   *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n   *   (n, m) => n + m\n   * );\n   * observable.subscribe(\n   *   value => console.log(value),\n   *   err => {},\n   *   () => console.log('This is how it ends!')\n   * );\n   *\n   * // Logs:\n   * // 5 after 3 seconds\n   * // \"This is how it ends!\" immediately after\n   *\n   * @see {@link combineLatest}\n   * @see {@link zip}\n   *\n   * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\n   * passed directly to the operator.\n   * @param {function} [project] Function that takes values emitted by input Observables and returns value\n   * that will appear in resulting Observable instead of default array.\n   * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n   * or value from project function.\n   * @static true\n   * @name forkJoin\n   * @owner Observable\n   */\n\n\n  ForkJoinObservable.create = function () {\n    var sources = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      sources[_i - 0] = arguments[_i];\n    }\n\n    if (sources === null || arguments.length === 0) {\n      return new EmptyObservable_1.EmptyObservable();\n    }\n\n    var resultSelector = null;\n\n    if (typeof sources[sources.length - 1] === 'function') {\n      resultSelector = sources.pop();\n    } // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n\n\n    if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n      sources = sources[0];\n    }\n\n    if (sources.length === 0) {\n      return new EmptyObservable_1.EmptyObservable();\n    }\n\n    return new ForkJoinObservable(sources, resultSelector);\n  };\n  /** @deprecated internal use only */\n\n\n  ForkJoinObservable.prototype._subscribe = function (subscriber) {\n    return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n  };\n\n  return ForkJoinObservable;\n}(Observable_1.Observable);\n\nexports.ForkJoinObservable = ForkJoinObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar ForkJoinSubscriber = function (_super) {\n  __extends(ForkJoinSubscriber, _super);\n\n  function ForkJoinSubscriber(destination, sources, resultSelector) {\n    _super.call(this, destination);\n\n    this.sources = sources;\n    this.resultSelector = resultSelector;\n    this.completed = 0;\n    this.haveValues = 0;\n    var len = sources.length;\n    this.total = len;\n    this.values = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      var source = sources[i];\n      var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);\n\n      if (innerSubscription) {\n        innerSubscription.outerIndex = i;\n        this.add(innerSubscription);\n      }\n    }\n  }\n\n  ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.values[outerIndex] = innerValue;\n\n    if (!innerSub._hasValue) {\n      innerSub._hasValue = true;\n      this.haveValues++;\n    }\n  };\n\n  ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n    var destination = this.destination;\n\n    var _a = this,\n        haveValues = _a.haveValues,\n        resultSelector = _a.resultSelector,\n        values = _a.values;\n\n    var len = values.length;\n\n    if (!innerSub._hasValue) {\n      destination.complete();\n      return;\n    }\n\n    this.completed++;\n\n    if (this.completed !== len) {\n      return;\n    }\n\n    if (haveValues === len) {\n      var value = resultSelector ? resultSelector.apply(this, values) : values;\n      destination.next(value);\n    }\n\n    destination.complete();\n  };\n\n  return ForkJoinSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"oemf\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar map_1 = /*@__PURE__*/__webpack_require__(\"aK2G\");\n\nfunction getCORSRequest() {\n  if (root_1.root.XMLHttpRequest) {\n    return new root_1.root.XMLHttpRequest();\n  } else if (!!root_1.root.XDomainRequest) {\n    return new root_1.root.XDomainRequest();\n  } else {\n    throw new Error('CORS is not supported by your browser');\n  }\n}\n\nfunction getXMLHttpRequest() {\n  if (root_1.root.XMLHttpRequest) {\n    return new root_1.root.XMLHttpRequest();\n  } else {\n    var progId = void 0;\n\n    try {\n      var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n\n      for (var i = 0; i < 3; i++) {\n        try {\n          progId = progIds[i];\n\n          if (new root_1.root.ActiveXObject(progId)) {\n            break;\n          }\n        } catch (e) {}\n      }\n\n      return new root_1.root.ActiveXObject(progId);\n    } catch (e) {\n      throw new Error('XMLHttpRequest is not supported by your browser');\n    }\n  }\n}\n\nfunction ajaxGet(url, headers) {\n  if (headers === void 0) {\n    headers = null;\n  }\n\n  return new AjaxObservable({\n    method: 'GET',\n    url: url,\n    headers: headers\n  });\n}\n\nexports.ajaxGet = ajaxGet;\n;\n\nfunction ajaxPost(url, body, headers) {\n  return new AjaxObservable({\n    method: 'POST',\n    url: url,\n    body: body,\n    headers: headers\n  });\n}\n\nexports.ajaxPost = ajaxPost;\n;\n\nfunction ajaxDelete(url, headers) {\n  return new AjaxObservable({\n    method: 'DELETE',\n    url: url,\n    headers: headers\n  });\n}\n\nexports.ajaxDelete = ajaxDelete;\n;\n\nfunction ajaxPut(url, body, headers) {\n  return new AjaxObservable({\n    method: 'PUT',\n    url: url,\n    body: body,\n    headers: headers\n  });\n}\n\nexports.ajaxPut = ajaxPut;\n;\n\nfunction ajaxPatch(url, body, headers) {\n  return new AjaxObservable({\n    method: 'PATCH',\n    url: url,\n    body: body,\n    headers: headers\n  });\n}\n\nexports.ajaxPatch = ajaxPatch;\n;\nvar mapResponse = /*@__PURE__*/map_1.map(function (x, index) {\n  return x.response;\n});\n\nfunction ajaxGetJSON(url, headers) {\n  return mapResponse(new AjaxObservable({\n    method: 'GET',\n    url: url,\n    responseType: 'json',\n    headers: headers\n  }));\n}\n\nexports.ajaxGetJSON = ajaxGetJSON;\n;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\nvar AjaxObservable = function (_super) {\n  __extends(AjaxObservable, _super);\n\n  function AjaxObservable(urlOrRequest) {\n    _super.call(this);\n\n    var request = {\n      async: true,\n      createXHR: function createXHR() {\n        return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();\n      },\n      crossDomain: false,\n      withCredentials: false,\n      headers: {},\n      method: 'GET',\n      responseType: 'json',\n      timeout: 0\n    };\n\n    if (typeof urlOrRequest === 'string') {\n      request.url = urlOrRequest;\n    } else {\n      for (var prop in urlOrRequest) {\n        if (urlOrRequest.hasOwnProperty(prop)) {\n          request[prop] = urlOrRequest[prop];\n        }\n      }\n    }\n\n    this.request = request;\n  }\n  /** @deprecated internal use only */\n\n\n  AjaxObservable.prototype._subscribe = function (subscriber) {\n    return new AjaxSubscriber(subscriber, this.request);\n  };\n  /**\n   * Creates an observable for an Ajax request with either a request object with\n   * url, headers, etc or a string for a URL.\n   *\n   * @example\n   * source = Rx.Observable.ajax('/products');\n   * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });\n   *\n   * @param {string|Object} request Can be one of the following:\n   *   A string of the URL to make the Ajax call.\n   *   An object with the following properties\n   *   - url: URL of the request\n   *   - body: The body of the request\n   *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE\n   *   - async: Whether the request is async\n   *   - headers: Optional headers\n   *   - crossDomain: true if a cross domain request, else false\n   *   - createXHR: a function to override if you need to use an alternate\n   *   XMLHttpRequest implementation.\n   *   - resultSelector: a function to use to alter the output value type of\n   *   the Observable. Gets {@link AjaxResponse} as an argument.\n   * @return {Observable} An observable sequence containing the XMLHttpRequest.\n   * @static true\n   * @name ajax\n   * @owner Observable\n  */\n\n\n  AjaxObservable.create = function () {\n    var create = function create(urlOrRequest) {\n      return new AjaxObservable(urlOrRequest);\n    };\n\n    create.get = ajaxGet;\n    create.post = ajaxPost;\n    create.delete = ajaxDelete;\n    create.put = ajaxPut;\n    create.patch = ajaxPatch;\n    create.getJSON = ajaxGetJSON;\n    return create;\n  }();\n\n  return AjaxObservable;\n}(Observable_1.Observable);\n\nexports.AjaxObservable = AjaxObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar AjaxSubscriber = function (_super) {\n  __extends(AjaxSubscriber, _super);\n\n  function AjaxSubscriber(destination, request) {\n    _super.call(this, destination);\n\n    this.request = request;\n    this.done = false;\n    var headers = request.headers = request.headers || {}; // force CORS if requested\n\n    if (!request.crossDomain && !headers['X-Requested-With']) {\n      headers['X-Requested-With'] = 'XMLHttpRequest';\n    } // ensure content type is set\n\n\n    if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {\n      headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n    } // properly serialize body\n\n\n    request.body = this.serializeBody(request.body, request.headers['Content-Type']);\n    this.send();\n  }\n\n  AjaxSubscriber.prototype.next = function (e) {\n    this.done = true;\n\n    var _a = this,\n        xhr = _a.xhr,\n        request = _a.request,\n        destination = _a.destination;\n\n    var response = new AjaxResponse(e, xhr, request);\n    destination.next(response);\n  };\n\n  AjaxSubscriber.prototype.send = function () {\n    var _a = this,\n        request = _a.request,\n        _b = _a.request,\n        user = _b.user,\n        method = _b.method,\n        url = _b.url,\n        async = _b.async,\n        password = _b.password,\n        headers = _b.headers,\n        body = _b.body;\n\n    var createXHR = request.createXHR;\n    var xhr = tryCatch_1.tryCatch(createXHR).call(request);\n\n    if (xhr === errorObject_1.errorObject) {\n      this.error(errorObject_1.errorObject.e);\n    } else {\n      this.xhr = xhr; // set up the events before open XHR\n      // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\n      // You need to add the event listeners before calling open() on the request.\n      // Otherwise the progress events will not fire.\n\n      this.setupEvents(xhr, request); // open XHR\n\n      var result = void 0;\n\n      if (user) {\n        result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);\n      } else {\n        result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);\n      }\n\n      if (result === errorObject_1.errorObject) {\n        this.error(errorObject_1.errorObject.e);\n        return null;\n      } // timeout, responseType and withCredentials can be set once the XHR is open\n\n\n      if (async) {\n        xhr.timeout = request.timeout;\n        xhr.responseType = request.responseType;\n      }\n\n      if ('withCredentials' in xhr) {\n        xhr.withCredentials = !!request.withCredentials;\n      } // set headers\n\n\n      this.setHeaders(xhr, headers); // finally send the request\n\n      result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);\n\n      if (result === errorObject_1.errorObject) {\n        this.error(errorObject_1.errorObject.e);\n        return null;\n      }\n    }\n\n    return xhr;\n  };\n\n  AjaxSubscriber.prototype.serializeBody = function (body, contentType) {\n    if (!body || typeof body === 'string') {\n      return body;\n    } else if (root_1.root.FormData && body instanceof root_1.root.FormData) {\n      return body;\n    }\n\n    if (contentType) {\n      var splitIndex = contentType.indexOf(';');\n\n      if (splitIndex !== -1) {\n        contentType = contentType.substring(0, splitIndex);\n      }\n    }\n\n    switch (contentType) {\n      case 'application/x-www-form-urlencoded':\n        return Object.keys(body).map(function (key) {\n          return encodeURIComponent(key) + \"=\" + encodeURIComponent(body[key]);\n        }).join('&');\n\n      case 'application/json':\n        return JSON.stringify(body);\n\n      default:\n        return body;\n    }\n  };\n\n  AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {\n    for (var key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  };\n\n  AjaxSubscriber.prototype.setupEvents = function (xhr, request) {\n    var progressSubscriber = request.progressSubscriber;\n\n    function xhrTimeout(e) {\n      var _a = xhrTimeout,\n          subscriber = _a.subscriber,\n          progressSubscriber = _a.progressSubscriber,\n          request = _a.request;\n\n      if (progressSubscriber) {\n        progressSubscriber.error(e);\n      }\n\n      subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.\n    }\n\n    ;\n    xhr.ontimeout = xhrTimeout;\n    xhrTimeout.request = request;\n    xhrTimeout.subscriber = this;\n    xhrTimeout.progressSubscriber = progressSubscriber;\n\n    if (xhr.upload && 'withCredentials' in xhr) {\n      if (progressSubscriber) {\n        var _xhrProgress_;\n\n        _xhrProgress_ = function xhrProgress_1(e) {\n          var progressSubscriber = _xhrProgress_.progressSubscriber;\n          progressSubscriber.next(e);\n        };\n\n        if (root_1.root.XDomainRequest) {\n          xhr.onprogress = _xhrProgress_;\n        } else {\n          xhr.upload.onprogress = _xhrProgress_;\n        }\n\n        _xhrProgress_.progressSubscriber = progressSubscriber;\n      }\n\n      var _xhrError_;\n\n      _xhrError_ = function xhrError_1(e) {\n        var _a = _xhrError_,\n            progressSubscriber = _a.progressSubscriber,\n            subscriber = _a.subscriber,\n            request = _a.request;\n\n        if (progressSubscriber) {\n          progressSubscriber.error(e);\n        }\n\n        subscriber.error(new AjaxError('ajax error', this, request));\n      };\n\n      xhr.onerror = _xhrError_;\n      _xhrError_.request = request;\n      _xhrError_.subscriber = this;\n      _xhrError_.progressSubscriber = progressSubscriber;\n    }\n\n    function xhrReadyStateChange(e) {\n      var _a = xhrReadyStateChange,\n          subscriber = _a.subscriber,\n          progressSubscriber = _a.progressSubscriber,\n          request = _a.request;\n\n      if (this.readyState === 4) {\n        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n        var status_1 = this.status === 1223 ? 204 : this.status;\n        var response = this.responseType === 'text' ? this.response || this.responseText : this.response; // fix status code when it is 0 (0 status is undocumented).\n        // Occurs when accessing file resources or on Android 4.1 stock browser\n        // while retrieving files from application cache.\n\n        if (status_1 === 0) {\n          status_1 = response ? 200 : 0;\n        }\n\n        if (200 <= status_1 && status_1 < 300) {\n          if (progressSubscriber) {\n            progressSubscriber.complete();\n          }\n\n          subscriber.next(e);\n          subscriber.complete();\n        } else {\n          if (progressSubscriber) {\n            progressSubscriber.error(e);\n          }\n\n          subscriber.error(new AjaxError('ajax error ' + status_1, this, request));\n        }\n      }\n    }\n\n    ;\n    xhr.onreadystatechange = xhrReadyStateChange;\n    xhrReadyStateChange.subscriber = this;\n    xhrReadyStateChange.progressSubscriber = progressSubscriber;\n    xhrReadyStateChange.request = request;\n  };\n\n  AjaxSubscriber.prototype.unsubscribe = function () {\n    var _a = this,\n        done = _a.done,\n        xhr = _a.xhr;\n\n    if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {\n      xhr.abort();\n    }\n\n    _super.prototype.unsubscribe.call(this);\n  };\n\n  return AjaxSubscriber;\n}(Subscriber_1.Subscriber);\n\nexports.AjaxSubscriber = AjaxSubscriber;\n/**\n * A normalized AJAX response.\n *\n * @see {@link ajax}\n *\n * @class AjaxResponse\n */\n\nvar AjaxResponse = /*@__PURE__*/function () {\n  function AjaxResponse(originalEvent, xhr, request) {\n    this.originalEvent = originalEvent;\n    this.xhr = xhr;\n    this.request = request;\n    this.status = xhr.status;\n    this.responseType = xhr.responseType || request.responseType;\n    this.response = parseXhrResponse(this.responseType, xhr);\n  }\n\n  return AjaxResponse;\n}();\n\nexports.AjaxResponse = AjaxResponse;\n/**\n * A normalized AJAX error.\n *\n * @see {@link ajax}\n *\n * @class AjaxError\n */\n\nvar AjaxError = function (_super) {\n  __extends(AjaxError, _super);\n\n  function AjaxError(message, xhr, request) {\n    _super.call(this, message);\n\n    this.message = message;\n    this.xhr = xhr;\n    this.request = request;\n    this.status = xhr.status;\n    this.responseType = xhr.responseType || request.responseType;\n    this.response = parseXhrResponse(this.responseType, xhr);\n  }\n\n  return AjaxError;\n}(Error);\n\nexports.AjaxError = AjaxError;\n\nfunction parseXhrResponse(responseType, xhr) {\n  switch (responseType) {\n    case 'json':\n      if ('response' in xhr) {\n        //IE does not support json as responseType, parse it internally\n        return xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n      } else {\n        // HACK(benlesh): TypeScript shennanigans\n        // tslint:disable-next-line:no-any latest TS seems to think xhr is \"never\" here.\n        return JSON.parse(xhr.responseText || 'null');\n      }\n\n    case 'xml':\n      return xhr.responseXML;\n\n    case 'text':\n    default:\n      // HACK(benlesh): TypeScript shennanigans\n      // tslint:disable-next-line:no-any latest TS seems to think xhr is \"never\" here.\n      return 'response' in xhr ? xhr.response : xhr.responseText;\n  }\n}\n/**\n * @see {@link ajax}\n *\n * @class AjaxTimeoutError\n */\n\n\nvar AjaxTimeoutError = function (_super) {\n  __extends(AjaxTimeoutError, _super);\n\n  function AjaxTimeoutError(xhr, request) {\n    _super.call(this, 'ajax timeout', xhr, request);\n  }\n\n  return AjaxTimeoutError;\n}(AjaxError);\n\nexports.AjaxTimeoutError = AjaxTimeoutError;\n\n/***/ }),\n\n/***/ \"onNu\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar onErrorResumeNext_1 = /*@__PURE__*/__webpack_require__(\"Rm1J\");\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n *\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * Rx.Observable.of(1, 2, 3, 0)\n *   .map(x => {\n *       if (x === 0) { throw Error(); }\n         return 10 / x;\n *   })\n *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n *   .subscribe(\n *     val => console.log(val),\n *     err => console.log(err),          // Will never be called.\n *     () => console.log('that\\'s it!')\n *   );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\n\n\nfunction onErrorResumeNext() {\n  var nextSources = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    nextSources[_i - 0] = arguments[_i];\n  }\n\n  return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, nextSources)(this);\n}\n\nexports.onErrorResumeNext = onErrorResumeNext;\n\n/***/ }),\n\n/***/ \"onQ2\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar exhaust_1 = /*@__PURE__*/__webpack_require__(\"H0zL\");\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n * var result = higherOrder.exhaust();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\n\n\nfunction exhaust() {\n  return exhaust_1.exhaust()(this);\n}\n\nexports.exhaust = exhaust;\n\n/***/ }),\n\n/***/ \"oonV\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar using_1 = __webpack_require__(\"+Whv\");\n\nObservable_1.Observable.using = using_1.using; //# sourceMappingURL=using.js.map\n\n/***/ }),\n\n/***/ \"pNQw\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar timer_1 = __webpack_require__(\"UqH8\");\n\nObservable_1.Observable.timer = timer_1.timer; //# sourceMappingURL=timer.js.map\n\n/***/ }),\n\n/***/ \"pYXR\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction isObject(x) {\n  return x != null && typeof x === 'object';\n}\n\nexports.isObject = isObject;\n\n/***/ }),\n\n/***/ \"pZ8H\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaultIfEmpty_1 = /*@__PURE__*/__webpack_require__(\"2Tbn\");\n/* tslint:enable:max-line-length */\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\n\n\nfunction defaultIfEmpty(defaultValue) {\n  if (defaultValue === void 0) {\n    defaultValue = null;\n  }\n\n  return defaultIfEmpty_1.defaultIfEmpty(defaultValue)(this);\n}\n\nexports.defaultIfEmpty = defaultIfEmpty;\n\n/***/ }),\n\n/***/ \"pi/U\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar debounceTime_1 = __webpack_require__(\"D4pF\");\n\nObservable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime; //# sourceMappingURL=debounceTime.js.map\n\n/***/ }),\n\n/***/ \"pk/4\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nfunction refCount() {\n  return function refCountOperatorFunction(source) {\n    return source.lift(new RefCountOperator(source));\n  };\n}\n\nexports.refCount = refCount;\n\nvar RefCountOperator = /*@__PURE__*/function () {\n  function RefCountOperator(connectable) {\n    this.connectable = connectable;\n  }\n\n  RefCountOperator.prototype.call = function (subscriber, source) {\n    var connectable = this.connectable;\n    connectable._refCount++;\n    var refCounter = new RefCountSubscriber(subscriber, connectable);\n    var subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n\n    return subscription;\n  };\n\n  return RefCountOperator;\n}();\n\nvar RefCountSubscriber = function (_super) {\n  __extends(RefCountSubscriber, _super);\n\n  function RefCountSubscriber(destination, connectable) {\n    _super.call(this, destination);\n\n    this.connectable = connectable;\n  }\n  /** @deprecated internal use only */\n\n\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    var refCount = connectable._refCount;\n\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    connectable._refCount = refCount - 1;\n\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    } ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n\n\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n\n  return RefCountSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"puri\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar publishLast_1 = __webpack_require__(\"1nIg\");\n\nObservable_1.Observable.prototype.publishLast = publishLast_1.publishLast; //# sourceMappingURL=publishLast.js.map\n\n/***/ }),\n\n/***/ \"q+iv\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar AsyncScheduler_1 = /*@__PURE__*/__webpack_require__(\"FXL7\");\n\nvar AsapScheduler = function (_super) {\n  __extends(AsapScheduler, _super);\n\n  function AsapScheduler() {\n    _super.apply(this, arguments);\n  }\n\n  AsapScheduler.prototype.flush = function (action) {\n    this.active = true;\n    this.scheduled = undefined;\n    var actions = this.actions;\n    var error;\n    var index = -1;\n    var count = actions.length;\n    action = action || actions.shift();\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (++index < count && (action = actions.shift()));\n\n    this.active = false;\n\n    if (error) {\n      while (++index < count && (action = actions.shift())) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  return AsapScheduler;\n}(AsyncScheduler_1.AsyncScheduler);\n\nexports.AsapScheduler = AsapScheduler;\n\n/***/ }),\n\n/***/ \"q6z3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar withLatestFrom_1 = __webpack_require__(\"IEzG\");\n\nObservable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom; //# sourceMappingURL=withLatestFrom.js.map\n\n/***/ }),\n\n/***/ \"q9sB\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\n\n\nfunction finalize(callback) {\n  return function (source) {\n    return source.lift(new FinallyOperator(callback));\n  };\n}\n\nexports.finalize = finalize;\n\nvar FinallyOperator = /*@__PURE__*/function () {\n  function FinallyOperator(callback) {\n    this.callback = callback;\n  }\n\n  FinallyOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n  };\n\n  return FinallyOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar FinallySubscriber = function (_super) {\n  __extends(FinallySubscriber, _super);\n\n  function FinallySubscriber(destination, callback) {\n    _super.call(this, destination);\n\n    this.add(new Subscription_1.Subscription(callback));\n  }\n\n  return FinallySubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"qJ4/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar publishReplay_1 = /*@__PURE__*/__webpack_require__(\"f947\");\n/* tslint:enable:max-line-length */\n\n/**\n * @param bufferSize\n * @param windowTime\n * @param selectorOrScheduler\n * @param scheduler\n * @return {Observable<T> | ConnectableObservable<T>}\n * @method publishReplay\n * @owner Observable\n */\n\n\nfunction publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n  return publishReplay_1.publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler)(this);\n}\n\nexports.publishReplay = publishReplay;\n\n/***/ }),\n\n/***/ \"qKmH\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar GenerateObservable_1 = /*@__PURE__*/__webpack_require__(\"yl3g\");\n\nexports.generate = GenerateObservable_1.GenerateObservable.create;\n\n/***/ }),\n\n/***/ \"qN2p\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar find_1 = /*@__PURE__*/__webpack_require__(\"DKXc\");\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * <img src=\"./img/findIndex.png\" width=\"100%\">\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\n\n\nfunction findIndex(predicate, thisArg) {\n  return function (source) {\n    return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg));\n  };\n}\n\nexports.findIndex = findIndex;\n\n/***/ }),\n\n/***/ \"qQIA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar IntervalObservable_1 = /*@__PURE__*/__webpack_require__(\"Mnf/\");\n\nexports.interval = IntervalObservable_1.IntervalObservable.create;\n\n/***/ }),\n\n/***/ \"qnU5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar forkJoin_1 = __webpack_require__(\"JLi8\");\n\nObservable_1.Observable.forkJoin = forkJoin_1.forkJoin; //# sourceMappingURL=forkJoin.js.map\n\n/***/ }),\n\n/***/ \"qnn9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar concatMapTo_1 = /*@__PURE__*/__webpack_require__(\"zVww\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\n\n\nfunction concatMapTo(innerObservable, resultSelector) {\n  return concatMapTo_1.concatMapTo(innerObservable, resultSelector)(this);\n}\n\nexports.concatMapTo = concatMapTo;\n\n/***/ }),\n\n/***/ \"r2oo\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar root_1 = /*@__PURE__*/__webpack_require__(\"/WK6\");\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar PromiseObservable = function (_super) {\n  __extends(PromiseObservable, _super);\n\n  function PromiseObservable(promise, scheduler) {\n    _super.call(this);\n\n    this.promise = promise;\n    this.scheduler = scheduler;\n  }\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n\n\n  PromiseObservable.create = function (promise, scheduler) {\n    return new PromiseObservable(promise, scheduler);\n  };\n  /** @deprecated internal use only */\n\n\n  PromiseObservable.prototype._subscribe = function (subscriber) {\n    var _this = this;\n\n    var promise = this.promise;\n    var scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(function (value) {\n          _this.value = value;\n          _this._isScalar = true;\n\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        }, function (err) {\n          if (!subscriber.closed) {\n            subscriber.error(err);\n          }\n        }).then(null, function (err) {\n          // escape the promise trap, throw unhandled errors\n          root_1.root.setTimeout(function () {\n            throw err;\n          });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, {\n            value: this.value,\n            subscriber: subscriber\n          });\n        }\n      } else {\n        promise.then(function (value) {\n          _this.value = value;\n          _this._isScalar = true;\n\n          if (!subscriber.closed) {\n            subscriber.add(scheduler.schedule(dispatchNext, 0, {\n              value: value,\n              subscriber: subscriber\n            }));\n          }\n        }, function (err) {\n          if (!subscriber.closed) {\n            subscriber.add(scheduler.schedule(dispatchError, 0, {\n              err: err,\n              subscriber: subscriber\n            }));\n          }\n        }).then(null, function (err) {\n          // escape the promise trap, throw unhandled errors\n          root_1.root.setTimeout(function () {\n            throw err;\n          });\n        });\n      }\n    }\n  };\n\n  return PromiseObservable;\n}(Observable_1.Observable);\n\nexports.PromiseObservable = PromiseObservable;\n\nfunction dispatchNext(arg) {\n  var value = arg.value,\n      subscriber = arg.subscriber;\n\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\n\nfunction dispatchError(arg) {\n  var err = arg.err,\n      subscriber = arg.subscriber;\n\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n}\n\n/***/ }),\n\n/***/ \"r9ib\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar BoundCallbackObservable_1 = /*@__PURE__*/__webpack_require__(\"w1ve\");\n\nexports.bindCallback = BoundCallbackObservable_1.BoundCallbackObservable.create;\n\n/***/ }),\n\n/***/ \"rOew\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar shareReplay_1 = /*@__PURE__*/__webpack_require__(\"0Qin\");\n/**\n * @method shareReplay\n * @owner Observable\n */\n\n\nfunction shareReplay(bufferSize, windowTime, scheduler) {\n  return shareReplay_1.shareReplay(bufferSize, windowTime, scheduler)(this);\n}\n\nexports.shareReplay = shareReplay;\n;\n\n/***/ }),\n\n/***/ \"rPn0\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar publishBehavior_1 = /*@__PURE__*/__webpack_require__(\"7f6I\");\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\n\n\nfunction publishBehavior(value) {\n  return publishBehavior_1.publishBehavior(value)(this);\n}\n\nexports.publishBehavior = publishBehavior;\n\n/***/ }),\n\n/***/ \"rVFa\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar ScalarObservable_1 = /*@__PURE__*/__webpack_require__(\"8x9D\");\n\nvar EmptyObservable_1 = /*@__PURE__*/__webpack_require__(\"36rE\");\n\nvar isScheduler_1 = /*@__PURE__*/__webpack_require__(\"NwwV\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar ArrayObservable = function (_super) {\n  __extends(ArrayObservable, _super);\n\n  function ArrayObservable(array, scheduler) {\n    _super.call(this);\n\n    this.array = array;\n    this.scheduler = scheduler;\n\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  ArrayObservable.create = function (array, scheduler) {\n    return new ArrayObservable(array, scheduler);\n  };\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n\n\n  ArrayObservable.of = function () {\n    var array = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      array[_i - 0] = arguments[_i];\n    }\n\n    var scheduler = array[array.length - 1];\n\n    if (isScheduler_1.isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    var len = array.length;\n\n    if (len > 1) {\n      return new ArrayObservable(array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n    } else {\n      return new EmptyObservable_1.EmptyObservable(scheduler);\n    }\n  };\n\n  ArrayObservable.dispatch = function (state) {\n    var array = state.array,\n        index = state.index,\n        count = state.count,\n        subscriber = state.subscriber;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n    this.schedule(state);\n  };\n  /** @deprecated internal use only */\n\n\n  ArrayObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n    var array = this.array;\n    var count = array.length;\n    var scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array: array,\n        index: index,\n        count: count,\n        subscriber: subscriber\n      });\n    } else {\n      for (var i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n\n      subscriber.complete();\n    }\n  };\n\n  return ArrayObservable;\n}(Observable_1.Observable);\n\nexports.ArrayObservable = ArrayObservable;\n\n/***/ }),\n\n/***/ \"rYxE\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar last_1 = __webpack_require__(\"fmye\");\n\nObservable_1.Observable.prototype.last = last_1.last; //# sourceMappingURL=last.js.map\n\n/***/ }),\n\n/***/ \"re5B\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\n\n\nfunction bufferToggle(openings, closingSelector) {\n  return function bufferToggleOperatorFunction(source) {\n    return source.lift(new BufferToggleOperator(openings, closingSelector));\n  };\n}\n\nexports.bufferToggle = bufferToggle;\n\nvar BufferToggleOperator = /*@__PURE__*/function () {\n  function BufferToggleOperator(openings, closingSelector) {\n    this.openings = openings;\n    this.closingSelector = closingSelector;\n  }\n\n  BufferToggleOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n  };\n\n  return BufferToggleOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar BufferToggleSubscriber = function (_super) {\n  __extends(BufferToggleSubscriber, _super);\n\n  function BufferToggleSubscriber(destination, openings, closingSelector) {\n    _super.call(this, destination);\n\n    this.openings = openings;\n    this.closingSelector = closingSelector;\n    this.contexts = [];\n    this.add(subscribeToResult_1.subscribeToResult(this, openings));\n  }\n\n  BufferToggleSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n    var len = contexts.length;\n\n    for (var i = 0; i < len; i++) {\n      contexts[i].buffer.push(value);\n    }\n  };\n\n  BufferToggleSubscriber.prototype._error = function (err) {\n    var contexts = this.contexts;\n\n    while (contexts.length > 0) {\n      var context = contexts.shift();\n      context.subscription.unsubscribe();\n      context.buffer = null;\n      context.subscription = null;\n    }\n\n    this.contexts = null;\n\n    _super.prototype._error.call(this, err);\n  };\n\n  BufferToggleSubscriber.prototype._complete = function () {\n    var contexts = this.contexts;\n\n    while (contexts.length > 0) {\n      var context = contexts.shift();\n      this.destination.next(context.buffer);\n      context.subscription.unsubscribe();\n      context.buffer = null;\n      context.subscription = null;\n    }\n\n    this.contexts = null;\n\n    _super.prototype._complete.call(this);\n  };\n\n  BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n  };\n\n  BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.closeBuffer(innerSub.context);\n  };\n\n  BufferToggleSubscriber.prototype.openBuffer = function (value) {\n    try {\n      var closingSelector = this.closingSelector;\n      var closingNotifier = closingSelector.call(this, value);\n\n      if (closingNotifier) {\n        this.trySubscribe(closingNotifier);\n      }\n    } catch (err) {\n      this._error(err);\n    }\n  };\n\n  BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n    var contexts = this.contexts;\n\n    if (contexts && context) {\n      var buffer = context.buffer,\n          subscription = context.subscription;\n      this.destination.next(buffer);\n      contexts.splice(contexts.indexOf(context), 1);\n      this.remove(subscription);\n      subscription.unsubscribe();\n    }\n  };\n\n  BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n    var contexts = this.contexts;\n    var buffer = [];\n    var subscription = new Subscription_1.Subscription();\n    var context = {\n      buffer: buffer,\n      subscription: subscription\n    };\n    contexts.push(context);\n    var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n\n    if (!innerSubscription || innerSubscription.closed) {\n      this.closeBuffer(context);\n    } else {\n      innerSubscription.context = context;\n      this.add(innerSubscription);\n      subscription.add(innerSubscription);\n    }\n  };\n\n  return BufferToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"rgOj\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\n\n\nfunction distinctUntilChanged(compare, keySelector) {\n  return function (source) {\n    return source.lift(new DistinctUntilChangedOperator(compare, keySelector));\n  };\n}\n\nexports.distinctUntilChanged = distinctUntilChanged;\n\nvar DistinctUntilChangedOperator = /*@__PURE__*/function () {\n  function DistinctUntilChangedOperator(compare, keySelector) {\n    this.compare = compare;\n    this.keySelector = keySelector;\n  }\n\n  DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n  };\n\n  return DistinctUntilChangedOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar DistinctUntilChangedSubscriber = function (_super) {\n  __extends(DistinctUntilChangedSubscriber, _super);\n\n  function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n    _super.call(this, destination);\n\n    this.keySelector = keySelector;\n    this.hasKey = false;\n\n    if (typeof compare === 'function') {\n      this.compare = compare;\n    }\n  }\n\n  DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n    return x === y;\n  };\n\n  DistinctUntilChangedSubscriber.prototype._next = function (value) {\n    var keySelector = this.keySelector;\n    var key = value;\n\n    if (keySelector) {\n      key = tryCatch_1.tryCatch(this.keySelector)(value);\n\n      if (key === errorObject_1.errorObject) {\n        return this.destination.error(errorObject_1.errorObject.e);\n      }\n    }\n\n    var result = false;\n\n    if (this.hasKey) {\n      result = tryCatch_1.tryCatch(this.compare)(this.key, key);\n\n      if (result === errorObject_1.errorObject) {\n        return this.destination.error(errorObject_1.errorObject.e);\n      }\n    } else {\n      this.hasKey = true;\n    }\n\n    if (Boolean(result) === false) {\n      this.key = key;\n      this.destination.next(value);\n    }\n  };\n\n  return DistinctUntilChangedSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"rgyr\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar scan_1 = __webpack_require__(\"8rll\");\n\nObservable_1.Observable.prototype.scan = scan_1.scan; //# sourceMappingURL=scan.js.map\n\n/***/ }),\n\n/***/ \"ri69\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar throttle_1 = __webpack_require__(\"NeaI\");\n\nObservable_1.Observable.prototype.throttle = throttle_1.throttle; //# sourceMappingURL=throttle.js.map\n\n/***/ }),\n\n/***/ \"s3E+\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar do_1 = __webpack_require__(\"Lhs8\");\n\nObservable_1.Observable.prototype.do = do_1._do;\nObservable_1.Observable.prototype._do = do_1._do; //# sourceMappingURL=do.js.map\n\n/***/ }),\n\n/***/ \"s6Xu\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar mergeAll_1 = __webpack_require__(\"e7R1\");\n\nObservable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll; //# sourceMappingURL=mergeAll.js.map\n\n/***/ }),\n\n/***/ \"sBlj\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar debounce_1 = __webpack_require__(\"TzlO\");\n\nObservable_1.Observable.prototype.debounce = debounce_1.debounce; //# sourceMappingURL=debounce.js.map\n\n/***/ }),\n\n/***/ \"sUHN\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar toArray_1 = __webpack_require__(\"ZTY5\");\n\nObservable_1.Observable.prototype.toArray = toArray_1.toArray; //# sourceMappingURL=toArray.js.map\n\n/***/ }),\n\n/***/ \"sYdX\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar EmptyObservable_1 = /*@__PURE__*/__webpack_require__(\"36rE\");\n\nexports.empty = EmptyObservable_1.EmptyObservable.create;\n\n/***/ }),\n\n/***/ \"saxw\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\n\n\nfunction mapTo(value) {\n  return function (source) {\n    return source.lift(new MapToOperator(value));\n  };\n}\n\nexports.mapTo = mapTo;\n\nvar MapToOperator = /*@__PURE__*/function () {\n  function MapToOperator(value) {\n    this.value = value;\n  }\n\n  MapToOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\n  };\n\n  return MapToOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar MapToSubscriber = function (_super) {\n  __extends(MapToSubscriber, _super);\n\n  function MapToSubscriber(destination, value) {\n    _super.call(this, destination);\n\n    this.value = value;\n  }\n\n  MapToSubscriber.prototype._next = function (x) {\n    this.destination.next(this.value);\n  };\n\n  return MapToSubscriber;\n}(Subscriber_1.Subscriber);\n\n/***/ }),\n\n/***/ \"skK3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar zip_1 = /*@__PURE__*/__webpack_require__(\"oQYR\");\n/* tslint:enable:max-line-length */\n\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\n\n\nfunction zipProto() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return zip_1.zip.apply(void 0, observables)(this);\n}\n\nexports.zipProto = zipProto;\n\n/***/ }),\n\n/***/ \"suOF\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar timeInterval_1 = /*@__PURE__*/__webpack_require__(\"BTim\");\n\nexports.TimeInterval = timeInterval_1.TimeInterval;\n/**\n * @param scheduler\n * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timeInterval\n * @owner Observable\n */\n\nfunction timeInterval(scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return timeInterval_1.timeInterval(scheduler)(this);\n}\n\nexports.timeInterval = timeInterval;\n\n/***/ }),\n\n/***/ \"svOU\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar isNumeric_1 = /*@__PURE__*/__webpack_require__(\"zZI/\");\n\nvar isScheduler_1 = /*@__PURE__*/__webpack_require__(\"NwwV\");\n\nvar windowTime_1 = /*@__PURE__*/__webpack_require__(\"3WZS\");\n\nfunction windowTime(windowTimeSpan) {\n  var scheduler = async_1.async;\n  var windowCreationInterval = null;\n  var maxWindowSize = Number.POSITIVE_INFINITY;\n\n  if (isScheduler_1.isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler_1.isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric_1.isNumeric(arguments[2])) {\n    maxWindowSize = arguments[2];\n  }\n\n  if (isScheduler_1.isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric_1.isNumeric(arguments[1])) {\n    windowCreationInterval = arguments[1];\n  }\n\n  return windowTime_1.windowTime(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler)(this);\n}\n\nexports.windowTime = windowTime;\n\n/***/ }),\n\n/***/ \"t4k3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar from_1 = __webpack_require__(\"9Kp9\");\n\nObservable_1.Observable.from = from_1.from; //# sourceMappingURL=from.js.map\n\n/***/ }),\n\n/***/ \"tHdp\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar ArrayObservable_1 = /*@__PURE__*/__webpack_require__(\"rVFa\");\n\nexports.of = ArrayObservable_1.ArrayObservable.of;\n\n/***/ }),\n\n/***/ \"tTnh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar distinct_1 = __webpack_require__(\"FEB/\");\n\nObservable_1.Observable.prototype.distinct = distinct_1.distinct; //# sourceMappingURL=distinct.js.map\n\n/***/ }),\n\n/***/ \"tq08\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar of_1 = __webpack_require__(\"tHdp\");\n\nObservable_1.Observable.of = of_1.of; //# sourceMappingURL=of.js.map\n\n/***/ }),\n\n/***/ \"tyYb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar bindNodeCallback_1 = __webpack_require__(\"codN\");\n\nObservable_1.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback; //# sourceMappingURL=bindNodeCallback.js.map\n\n/***/ }),\n\n/***/ \"uH8Z\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar timestamp_1 = /*@__PURE__*/__webpack_require__(\"Z57B\");\n/**\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\n\n\nfunction timestamp(scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return timestamp_1.timestamp(scheduler)(this);\n}\n\nexports.timestamp = timestamp;\n\n/***/ }),\n\n/***/ \"uJFK\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar max_1 = /*@__PURE__*/__webpack_require__(\"5aaB\");\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * <img src=\"./img/max.png\" width=\"100%\">\n *\n * @example <caption>Get the maximal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .max()\n *   .subscribe(x => console.log(x)); // -> 8\n *\n * @example <caption>Use a comparer function to get the maximal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * }\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\n\n\nfunction max(comparer) {\n  return max_1.max(comparer)(this);\n}\n\nexports.max = max;\n\n/***/ }),\n\n/***/ \"uQuL\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar finally_1 = __webpack_require__(\"IwEe\");\n\nObservable_1.Observable.prototype.finally = finally_1._finally;\nObservable_1.Observable.prototype._finally = finally_1._finally; //# sourceMappingURL=finally.js.map\n\n/***/ }),\n\n/***/ \"uj+q\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar isDate_1 = /*@__PURE__*/__webpack_require__(\"hut+\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/* tslint:enable:max-line-length */\n\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * @example <caption>Add fallback observable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const minutes = Rx.Observable.interval(60 * 1000);\n *\n * seconds.timeoutWith(900, minutes)\n *     .subscribe(\n *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                      // since first value of `seconds` will not arrive fast enough.\n *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n *                                 // but here will never be called.\n *     );\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\n\n\nfunction timeoutWith(due, withObservable, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return function (source) {\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nexports.timeoutWith = timeoutWith;\n\nvar TimeoutWithOperator = /*@__PURE__*/function () {\n  function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n    this.waitFor = waitFor;\n    this.absoluteTimeout = absoluteTimeout;\n    this.withObservable = withObservable;\n    this.scheduler = scheduler;\n  }\n\n  TimeoutWithOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n  };\n\n  return TimeoutWithOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar TimeoutWithSubscriber = function (_super) {\n  __extends(TimeoutWithSubscriber, _super);\n\n  function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n    _super.call(this, destination);\n\n    this.absoluteTimeout = absoluteTimeout;\n    this.waitFor = waitFor;\n    this.withObservable = withObservable;\n    this.scheduler = scheduler;\n    this.action = null;\n    this.scheduleTimeout();\n  }\n\n  TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n    var withObservable = subscriber.withObservable;\n\n    subscriber._unsubscribeAndRecycle();\n\n    subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));\n  };\n\n  TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n    var action = this.action;\n\n    if (action) {\n      // Recycle the action if we've already scheduled one. All the production\n      // Scheduler Actions mutate their state/delay time and return themeselves.\n      // VirtualActions are immutable, so they create and return a clone. In this\n      // case, we need to set the action reference to the most recent VirtualAction,\n      // to ensure that's the one we clone from next time.\n      this.action = action.schedule(this, this.waitFor);\n    } else {\n      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n    }\n  };\n\n  TimeoutWithSubscriber.prototype._next = function (value) {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n\n    _super.prototype._next.call(this, value);\n  };\n  /** @deprecated internal use only */\n\n\n  TimeoutWithSubscriber.prototype._unsubscribe = function () {\n    this.action = null;\n    this.scheduler = null;\n    this.withObservable = null;\n  };\n\n  return TimeoutWithSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"un7O\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar concatAll_1 = /*@__PURE__*/__webpack_require__(\"A0iX\");\n/* tslint:enable:max-line-length */\n\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\n\n\nfunction concatAll() {\n  return concatAll_1.concatAll()(this);\n}\n\nexports.concatAll = concatAll;\n\n/***/ }),\n\n/***/ \"urEZ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar repeatWhen_1 = /*@__PURE__*/__webpack_require__(\"0j0j\");\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\n\n\nfunction repeatWhen(notifier) {\n  return repeatWhen_1.repeatWhen(notifier)(this);\n}\n\nexports.repeatWhen = repeatWhen;\n\n/***/ }),\n\n/***/ \"v/g4\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar windowWhen_1 = __webpack_require__(\"cWud\");\n\nObservable_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen; //# sourceMappingURL=windowWhen.js.map\n\n/***/ }),\n\n/***/ \"vIOj\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar buffer_1 = __webpack_require__(\"LLa1\");\n\nObservable_1.Observable.prototype.buffer = buffer_1.buffer; //# sourceMappingURL=buffer.js.map\n\n/***/ }),\n\n/***/ \"vqpL\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar if_1 = __webpack_require__(\"8tnl\");\n\nObservable_1.Observable.if = if_1._if; //# sourceMappingURL=if.js.map\n\n/***/ }),\n\n/***/ \"w1ve\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar AsyncSubject_1 = /*@__PURE__*/__webpack_require__(\"8G9e\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar BoundCallbackObservable = function (_super) {\n  __extends(BoundCallbackObservable, _super);\n\n  function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n    _super.call(this);\n\n    this.callbackFunc = callbackFunc;\n    this.selector = selector;\n    this.args = args;\n    this.context = context;\n    this.scheduler = scheduler;\n  }\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Converts a callback API to a function that returns an Observable.\n   *\n   * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n   * it will return a function `g` that when called as `g(x)` will output an\n   * Observable.</span>\n   *\n   * `bindCallback` is not an operator because its input and output are not\n   * Observables. The input is a function `func` with some parameters, the\n   * last parameter must be a callback function that `func` calls when it is\n   * done.\n   *\n   * The output of `bindCallback` is a function that takes the same parameters\n   * as `func`, except the last one (the callback). When the output function\n   * is called with arguments it will return an Observable. If function `func`\n   * calls its callback with one argument the Observable will emit that value.\n   * If on the other hand the callback is called with multiple values the resulting\n   * Observable will emit an array with said values as arguments.\n   *\n   * It is very important to remember that input function `func` is not called\n   * when the output function is, but rather when the Observable returned by the output\n   * function is subscribed. This means if `func` makes an AJAX request, that request\n   * will be made every time someone subscribes to the resulting Observable, but not before.\n   *\n   * Optionally, a selector function can be passed to `bindObservable`. The selector function\n   * takes the same arguments as the callback and returns the value that will be emitted by the Observable.\n   * Even though by default multiple arguments passed to callback appear in the stream as an array\n   * the selector function will be called with arguments directly, just as the callback would.\n   * This means you can imagine the default selector (when one is not provided explicitly)\n   * as a function that aggregates all its arguments into an array, or simply returns first argument\n   * if there is only one.\n   *\n   * The last optional parameter - {@link Scheduler} - can be used to control when the call\n   * to `func` happens after someone subscribes to Observable, as well as when results\n   * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`\n   * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,\n   * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler\n   * and call `subscribe` on the output Observable all function calls that are currently executing\n   * will end before `func` is invoked.\n   *\n   * By default results passed to the callback are emitted immediately after `func` invokes the callback.\n   * In particular, if the callback is called synchronously the subscription of the resulting Observable\n   * will call the `next` function synchronously as well.  If you want to defer that call,\n   * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can\n   * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n   *\n   * Note that the Observable created by the output function will always emit a single value\n   * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n   * calls will not appear in the stream. If you need to listen for multiple calls,\n   *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n   *\n   * If `func` depends on some context (`this` property) and is not already bound the context of `func`\n   * will be the context that the output function has at call time. In particular, if `func`\n   * is called as a method of some objec and if `func` is not already bound, in order to preserve the context\n   * it is recommended that the context of the output function is set to that object as well.\n   *\n   * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n   * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n   * provides convenient error handling and probably is a better choice.\n   * `bindCallback` will treat such functions the same as any other and error parameters\n   * (whether passed or not) will always be interpreted as regular callback argument.\n   *\n   *\n   * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\n   * // Suppose we have jQuery.getJSON('/my/url', callback)\n   * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\n   * var result = getJSONAsObservable('/my/url');\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   *\n   * @example <caption>Receive an array of arguments passed to a callback</caption>\n   * someFunction((a, b, c) => {\n   *   console.log(a); // 5\n   *   console.log(b); // 'some string'\n   *   console.log(c); // {someProperty: 'someValue'}\n   * });\n   *\n   * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\n   * boundSomeFunction().subscribe(values => {\n   *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\n   * });\n   *\n   *\n   * @example <caption>Use bindCallback with a selector function</caption>\n   * someFunction((a, b, c) => {\n   *   console.log(a); // 'a'\n   *   console.log(b); // 'b'\n   *   console.log(c); // 'c'\n   * });\n   *\n   * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);\n   * boundSomeFunction().subscribe(value => {\n   *   console.log(value) // 'abc'\n   * });\n   *\n   *\n   * @example <caption>Compare behaviour with and without async Scheduler</caption>\n   * function iCallMyCallbackSynchronously(cb) {\n   *   cb();\n   * }\n   *\n   * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\n   * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n   *\n   * boundSyncFn().subscribe(() => console.log('I was sync!'));\n   * boundAsyncFn().subscribe(() => console.log('I was async!'));\n   * console.log('This happened...');\n   *\n   * // Logs:\n   * // I was sync!\n   * // This happened...\n   * // I was async!\n   *\n   *\n   * @example <caption>Use bindCallback on an object method</caption>\n   * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\n   * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n   * .subscribe(subscriber);\n   *\n   *\n   * @see {@link bindNodeCallback}\n   * @see {@link from}\n   * @see {@link fromPromise}\n   *\n   * @param {function} func A function with a callback as the last parameter.\n   * @param {function} [selector] A function which takes the arguments from the\n   * callback and maps them to a value that is emitted on the output Observable.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * callbacks.\n   * @return {function(...params: *): Observable} A function which returns the\n   * Observable that delivers the same values the callback would deliver.\n   * @static true\n   * @name bindCallback\n   * @owner Observable\n   */\n\n\n  BoundCallbackObservable.create = function (func, selector, scheduler) {\n    if (selector === void 0) {\n      selector = undefined;\n    }\n\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n      }\n\n      return new BoundCallbackObservable(func, selector, args, this, scheduler);\n    };\n  };\n  /** @deprecated internal use only */\n\n\n  BoundCallbackObservable.prototype._subscribe = function (subscriber) {\n    var callbackFunc = this.callbackFunc;\n    var args = this.args;\n    var scheduler = this.scheduler;\n    var subject = this.subject;\n\n    if (!scheduler) {\n      if (!subject) {\n        subject = this.subject = new AsyncSubject_1.AsyncSubject();\n\n        var handler = function handlerFn() {\n          var innerArgs = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            innerArgs[_i - 0] = arguments[_i];\n          }\n\n          var source = handlerFn.source;\n          var selector = source.selector,\n              subject = source.subject;\n\n          if (selector) {\n            var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n\n            if (result_1 === errorObject_1.errorObject) {\n              subject.error(errorObject_1.errorObject.e);\n            } else {\n              subject.next(result_1);\n              subject.complete();\n            }\n          } else {\n            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n            subject.complete();\n          }\n        }; // use named function instance to avoid closure.\n\n\n        handler.source = this;\n        var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n\n        if (result === errorObject_1.errorObject) {\n          subject.error(errorObject_1.errorObject.e);\n        }\n      }\n\n      return subject.subscribe(subscriber);\n    } else {\n      return scheduler.schedule(BoundCallbackObservable.dispatch, 0, {\n        source: this,\n        subscriber: subscriber,\n        context: this.context\n      });\n    }\n  };\n\n  BoundCallbackObservable.dispatch = function (state) {\n    var self = this;\n    var source = state.source,\n        subscriber = state.subscriber,\n        context = state.context;\n    var callbackFunc = source.callbackFunc,\n        args = source.args,\n        scheduler = source.scheduler;\n    var subject = source.subject;\n\n    if (!subject) {\n      subject = source.subject = new AsyncSubject_1.AsyncSubject();\n\n      var handler = function handlerFn() {\n        var innerArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          innerArgs[_i - 0] = arguments[_i];\n        }\n\n        var source = handlerFn.source;\n        var selector = source.selector,\n            subject = source.subject;\n\n        if (selector) {\n          var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n\n          if (result_2 === errorObject_1.errorObject) {\n            self.add(scheduler.schedule(dispatchError, 0, {\n              err: errorObject_1.errorObject.e,\n              subject: subject\n            }));\n          } else {\n            self.add(scheduler.schedule(dispatchNext, 0, {\n              value: result_2,\n              subject: subject\n            }));\n          }\n        } else {\n          var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n          self.add(scheduler.schedule(dispatchNext, 0, {\n            value: value,\n            subject: subject\n          }));\n        }\n      }; // use named function to pass values in without closure\n\n\n      handler.source = source;\n      var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n\n      if (result === errorObject_1.errorObject) {\n        subject.error(errorObject_1.errorObject.e);\n      }\n    }\n\n    self.add(subject.subscribe(subscriber));\n  };\n\n  return BoundCallbackObservable;\n}(Observable_1.Observable);\n\nexports.BoundCallbackObservable = BoundCallbackObservable;\n\nfunction dispatchNext(arg) {\n  var value = arg.value,\n      subject = arg.subject;\n  subject.next(value);\n  subject.complete();\n}\n\nfunction dispatchError(arg) {\n  var err = arg.err,\n      subject = arg.subject;\n  subject.error(err);\n}\n\n/***/ }),\n\n/***/ \"wELj\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar isScheduler_1 = /*@__PURE__*/__webpack_require__(\"NwwV\");\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\n\n\nfunction bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async_1.async;\n\n  if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  var bufferCreationInterval = null;\n\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nexports.bufferTime = bufferTime;\n\nvar BufferTimeOperator = /*@__PURE__*/function () {\n  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n\n  BufferTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n  };\n\n  return BufferTimeOperator;\n}();\n\nvar Context = /*@__PURE__*/function () {\n  function Context() {\n    this.buffer = [];\n  }\n\n  return Context;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar BufferTimeSubscriber = function (_super) {\n  __extends(BufferTimeSubscriber, _super);\n\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    _super.call(this, destination);\n\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n    this.contexts = [];\n    var context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n\n    if (this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: this,\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: this,\n        scheduler: scheduler\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n\n  BufferTimeSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n    var len = contexts.length;\n    var filledBufferContext;\n\n    for (var i = 0; i < len; i++) {\n      var context = contexts[i];\n      var buffer = context.buffer;\n      buffer.push(value);\n\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  };\n\n  BufferTimeSubscriber.prototype._error = function (err) {\n    this.contexts.length = 0;\n\n    _super.prototype._error.call(this, err);\n  };\n\n  BufferTimeSubscriber.prototype._complete = function () {\n    var _a = this,\n        contexts = _a.contexts,\n        destination = _a.destination;\n\n    while (contexts.length > 0) {\n      var context = contexts.shift();\n      destination.next(context.buffer);\n    }\n\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n\n\n  BufferTimeSubscriber.prototype._unsubscribe = function () {\n    this.contexts = null;\n  };\n\n  BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n    this.closeContext(context);\n    var closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      var bufferTimeSpan = this.bufferTimeSpan;\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  };\n\n  BufferTimeSubscriber.prototype.openContext = function () {\n    var context = new Context();\n    this.contexts.push(context);\n    return context;\n  };\n\n  BufferTimeSubscriber.prototype.closeContext = function (context) {\n    this.destination.next(context.buffer);\n    var contexts = this.contexts;\n    var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  };\n\n  return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber);\n\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n      bufferTimeSpan = state.bufferTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n      context = arg.context;\n  subscriber.closeContext(context);\n}\n\n/***/ }),\n\n/***/ \"wEqr\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar partition_1 = /*@__PURE__*/__webpack_require__(\"gSfb\");\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * <img src=\"./img/partition.png\" width=\"100%\">\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n * var clicksOnDivs = parts[0];\n * var clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n */\n\n\nfunction partition(predicate, thisArg) {\n  return partition_1.partition(predicate, thisArg)(this);\n}\n\nexports.partition = partition;\n\n/***/ }),\n\n/***/ \"wR93\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nvar rxSubscriber_1 = /*@__PURE__*/__webpack_require__(\"nkkL\");\n\nvar Observer_1 = /*@__PURE__*/__webpack_require__(\"yz70\");\n\nfunction toSubscriber(nextOrObserver, error, complete) {\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n      return nextOrObserver;\n    }\n\n    if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {\n      return nextOrObserver[rxSubscriber_1.rxSubscriber]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber_1.Subscriber(Observer_1.empty);\n  }\n\n  return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\n\nexports.toSubscriber = toSubscriber;\n\n/***/ }),\n\n/***/ \"we3k\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\n\n\nfunction expand(project, concurrent, scheduler) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  if (scheduler === void 0) {\n    scheduler = undefined;\n  }\n\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n  return function (source) {\n    return source.lift(new ExpandOperator(project, concurrent, scheduler));\n  };\n}\n\nexports.expand = expand;\n\nvar ExpandOperator = /*@__PURE__*/function () {\n  function ExpandOperator(project, concurrent, scheduler) {\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n  }\n\n  ExpandOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n  };\n\n  return ExpandOperator;\n}();\n\nexports.ExpandOperator = ExpandOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar ExpandSubscriber = function (_super) {\n  __extends(ExpandSubscriber, _super);\n\n  function ExpandSubscriber(destination, project, concurrent, scheduler) {\n    _super.call(this, destination);\n\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n    this.index = 0;\n    this.active = 0;\n    this.hasCompleted = false;\n\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      this.buffer = [];\n    }\n  }\n\n  ExpandSubscriber.dispatch = function (arg) {\n    var subscriber = arg.subscriber,\n        result = arg.result,\n        value = arg.value,\n        index = arg.index;\n    subscriber.subscribeToProjection(result, value, index);\n  };\n\n  ExpandSubscriber.prototype._next = function (value) {\n    var destination = this.destination;\n\n    if (destination.closed) {\n      this._complete();\n\n      return;\n    }\n\n    var index = this.index++;\n\n    if (this.active < this.concurrent) {\n      destination.next(value);\n      var result = tryCatch_1.tryCatch(this.project)(value, index);\n\n      if (result === errorObject_1.errorObject) {\n        destination.error(errorObject_1.errorObject.e);\n      } else if (!this.scheduler) {\n        this.subscribeToProjection(result, value, index);\n      } else {\n        var state = {\n          subscriber: this,\n          result: result,\n          value: value,\n          index: index\n        };\n        this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  };\n\n  ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n    this.active++;\n    this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n  };\n\n  ExpandSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  };\n\n  ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this._next(innerValue);\n  };\n\n  ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n    var buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n\n    if (buffer && buffer.length > 0) {\n      this._next(buffer.shift());\n    }\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  };\n\n  return ExpandSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\nexports.ExpandSubscriber = ExpandSubscriber;\n\n/***/ }),\n\n/***/ \"wowj\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar window_1 = /*@__PURE__*/__webpack_require__(\"0Iwa\");\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var result = clicks.window(interval)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\n\n\nfunction window(windowBoundaries) {\n  return window_1.window(windowBoundaries)(this);\n}\n\nexports.window = window;\n\n/***/ }),\n\n/***/ \"wqBB\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar sequenceEqual_1 = __webpack_require__(\"8FKM\");\n\nObservable_1.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual; //# sourceMappingURL=sequenceEqual.js.map\n\n/***/ }),\n\n/***/ \"xFrw\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar groupBy_1 = /*@__PURE__*/__webpack_require__(\"Q6nm\");\n\nexports.GroupedObservable = groupBy_1.GroupedObservable;\n/* tslint:enable:max-line-length */\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\n\nfunction groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n  return groupBy_1.groupBy(keySelector, elementSelector, durationSelector, subjectSelector)(this);\n}\n\nexports.groupBy = groupBy;\n\n/***/ }),\n\n/***/ \"xL+R\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar min_1 = __webpack_require__(\"jRt/\");\n\nObservable_1.Observable.prototype.min = min_1.min; //# sourceMappingURL=min.js.map\n\n/***/ }),\n\n/***/ \"xLgF\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar range_1 = __webpack_require__(\"iaCc\");\n\nObservable_1.Observable.range = range_1.range; //# sourceMappingURL=range.js.map\n\n/***/ }),\n\n/***/ \"xQMj\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar filter_1 = /*@__PURE__*/__webpack_require__(\"ZXB4\");\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\n\n\nfunction filter(predicate, thisArg) {\n  return filter_1.filter(predicate, thisArg)(this);\n}\n\nexports.filter = filter;\n\n/***/ }),\n\n/***/ \"xxrh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar PromiseObservable_1 = /*@__PURE__*/__webpack_require__(\"r2oo\");\n\nexports.fromPromise = PromiseObservable_1.PromiseObservable.create;\n\n/***/ }),\n\n/***/ \"xzWc\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/* tslint:disable:no-unused-variable */\n// Subject imported before Observable to bypass circular dependency issue since\n// Subject extends Observable and Observable references Subject in it's\n// definition\n\nvar Subject_1 = /*@__PURE__*/__webpack_require__(\"4WIM\");\n\nexports.Subject = Subject_1.Subject;\nexports.AnonymousSubject = Subject_1.AnonymousSubject;\n/* tslint:enable:no-unused-variable */\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nexports.Observable = Observable_1.Observable; // statics\n\n/* tslint:disable:no-use-before-declare */\n\n/*@__PURE__*/\n\n__webpack_require__(\"T3D5\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"tyYb\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"7qd/\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"zSqD\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"BbYg\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"1BBg\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"qnU5\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"t4k3\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"EeVn\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"g1x8\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"DsW9\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"07YY\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"vqpL\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"BPHu\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Xn12\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"y7vd\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"o/sf\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"tq08\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"90cS\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"JWmB\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"xLgF\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"oonV\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"aUw6\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"pNQw\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Sevg\"); //dom\n\n/*@__PURE__*/\n\n\n__webpack_require__(\"KHtr\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"SfWB\"); //operators\n\n/*@__PURE__*/\n\n\n__webpack_require__(\"vIOj\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"QY9E\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"/Gz8\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"zlBQ\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"ZzdT\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"lCqY\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"A17Z\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"lBaL\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"DAeC\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"D9at\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"nfiU\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"mz1d\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"IYeR\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Vo3M\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"sBlj\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"pi/U\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"yP7H\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"hgYf\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"53d5\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"tTnh\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"1xzA\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"AF4n\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"s3E+\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"VIOb\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"dAHb\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"A1NZ\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Pg5x\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"6Tb1\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"uQuL\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"z1j8\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"zIAK\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"8SF3\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"6m09\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"K4Q0\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Jvmm\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Y4yW\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"zbiA\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"rYxE\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"GCyh\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"yA04\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"7bsd\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"OtNS\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"2FQM\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Q0aF\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"1jHa\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"s6Xu\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"bZxC\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"JLRC\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"laXh\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"xL+R\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"G7wb\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"J//a\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"nXmG\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"2HR8\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"MB5B\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"jc2T\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"BQYW\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"4JC2\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"dxsx\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"puri\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Ht43\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"nD5C\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"5/1k\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"/mgN\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"mSFr\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"0U/2\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"HTvz\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"jNrO\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"rgyr\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"wqBB\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"DbqF\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"gugg\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Wv9J\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"RYdh\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"UGt1\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"mXuN\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"HH2i\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"VLEn\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"1G/o\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"cdxN\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"FYEZ\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Vrlg\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"98qG\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"l1g9\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"UCNy\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Bgoh\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"ri69\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"M1gx\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Fgpt\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"RIQZ\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"l/bX\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"b4nC\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"sUHN\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"Jmzy\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"zZax\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"XMAI\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"cP0Y\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"zrM/\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"v/g4\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"q6z3\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"GJlw\");\n/*@__PURE__*/\n\n\n__webpack_require__(\"XzFz\");\n/* tslint:disable:no-unused-variable */\n\n\nvar Subscription_1 = /*@__PURE__*/__webpack_require__(\"y2i3\");\n\nexports.Subscription = Subscription_1.Subscription;\n\nvar Subscriber_1 = /*@__PURE__*/__webpack_require__(\"1uGz\");\n\nexports.Subscriber = Subscriber_1.Subscriber;\n\nvar AsyncSubject_1 = /*@__PURE__*/__webpack_require__(\"8G9e\");\n\nexports.AsyncSubject = AsyncSubject_1.AsyncSubject;\n\nvar ReplaySubject_1 = /*@__PURE__*/__webpack_require__(\"BjeI\");\n\nexports.ReplaySubject = ReplaySubject_1.ReplaySubject;\n\nvar BehaviorSubject_1 = /*@__PURE__*/__webpack_require__(\"Bx9r\");\n\nexports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;\n\nvar ConnectableObservable_1 = /*@__PURE__*/__webpack_require__(\"3VCA\");\n\nexports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;\n\nvar Notification_1 = /*@__PURE__*/__webpack_require__(\"9x29\");\n\nexports.Notification = Notification_1.Notification;\n\nvar EmptyError_1 = /*@__PURE__*/__webpack_require__(\"2fIB\");\n\nexports.EmptyError = EmptyError_1.EmptyError;\n\nvar ArgumentOutOfRangeError_1 = /*@__PURE__*/__webpack_require__(\"8kg7\");\n\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n\nvar ObjectUnsubscribedError_1 = /*@__PURE__*/__webpack_require__(\"PCq3\");\n\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;\n\nvar TimeoutError_1 = /*@__PURE__*/__webpack_require__(\"4qOA\");\n\nexports.TimeoutError = TimeoutError_1.TimeoutError;\n\nvar UnsubscriptionError_1 = /*@__PURE__*/__webpack_require__(\"kwlx\");\n\nexports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;\n\nvar timeInterval_1 = /*@__PURE__*/__webpack_require__(\"suOF\");\n\nexports.TimeInterval = timeInterval_1.TimeInterval;\n\nvar timestamp_1 = /*@__PURE__*/__webpack_require__(\"Z57B\");\n\nexports.Timestamp = timestamp_1.Timestamp;\n\nvar TestScheduler_1 = /*@__PURE__*/__webpack_require__(\"ZnfZ\");\n\nexports.TestScheduler = TestScheduler_1.TestScheduler;\n\nvar VirtualTimeScheduler_1 = /*@__PURE__*/__webpack_require__(\"J9JT\");\n\nexports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;\n\nvar AjaxObservable_1 = /*@__PURE__*/__webpack_require__(\"oemf\");\n\nexports.AjaxResponse = AjaxObservable_1.AjaxResponse;\nexports.AjaxError = AjaxObservable_1.AjaxError;\nexports.AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;\n\nvar pipe_1 = /*@__PURE__*/__webpack_require__(\"GyLc\");\n\nexports.pipe = pipe_1.pipe;\n\nvar asap_1 = /*@__PURE__*/__webpack_require__(\"JB8t\");\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar queue_1 = /*@__PURE__*/__webpack_require__(\"VZMG\");\n\nvar animationFrame_1 = /*@__PURE__*/__webpack_require__(\"BoXX\");\n\nvar rxSubscriber_1 = /*@__PURE__*/__webpack_require__(\"nkkL\");\n\nvar iterator_1 = /*@__PURE__*/__webpack_require__(\"+2+e\");\n\nvar observable_1 = /*@__PURE__*/__webpack_require__(\"WU5C\");\n\nvar _operators = /*@__PURE__*/__webpack_require__(\"f0q5\");\n\nexports.operators = _operators;\n/* tslint:enable:no-unused-variable */\n\n/**\n * @typedef {Object} Rx.Scheduler\n * @property {Scheduler} queue Schedules on a queue in the current event frame\n * (trampoline scheduler). Use this for iteration operations.\n * @property {Scheduler} asap Schedules on the micro task queue, which uses the\n * fastest transport mechanism available, either Node.js' `process.nextTick()`\n * or Web Worker MessageChannel or setTimeout or others. Use this for\n * asynchronous conversions.\n * @property {Scheduler} async Schedules work with `setInterval`. Use this for\n * time-based operations.\n * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.\n * Use this for synchronizing with the platform's painting\n */\n\nvar Scheduler = {\n  asap: asap_1.asap,\n  queue: queue_1.queue,\n  animationFrame: animationFrame_1.animationFrame,\n  async: async_1.async\n};\nexports.Scheduler = Scheduler;\n/**\n * @typedef {Object} Rx.Symbol\n * @property {Symbol|string} rxSubscriber A symbol to use as a property name to\n * retrieve an \"Rx safe\" Observer from an object. \"Rx safety\" can be defined as\n * an object that has all of the traits of an Rx Subscriber, including the\n * ability to add and remove subscriptions to the subscription chain and\n * guarantees involving event triggering (can't \"next\" after unsubscription,\n * etc).\n * @property {Symbol|string} observable A symbol to use as a property name to\n * retrieve an Observable as defined by the [ECMAScript \"Observable\" spec](https://github.com/zenparsing/es-observable).\n * @property {Symbol|string} iterator The ES6 symbol to use as a property name\n * to retrieve an iterator from an object.\n */\n\nvar Symbol = {\n  rxSubscriber: rxSubscriber_1.rxSubscriber,\n  observable: observable_1.observable,\n  iterator: iterator_1.iterator\n};\nexports.Symbol = Symbol;\n\n/***/ }),\n\n/***/ \"y2i3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isArray_1 = /*@__PURE__*/__webpack_require__(\"G2HO\");\n\nvar isObject_1 = /*@__PURE__*/__webpack_require__(\"pYXR\");\n\nvar isFunction_1 = /*@__PURE__*/__webpack_require__(\"PFc+\");\n\nvar tryCatch_1 = /*@__PURE__*/__webpack_require__(\"zKHA\");\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar UnsubscriptionError_1 = /*@__PURE__*/__webpack_require__(\"kwlx\");\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\n\n\nvar Subscription = /*@__PURE__*/function () {\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  function Subscription(unsubscribe) {\n    /**\n     * A flag to indicate whether this Subscription has already been unsubscribed.\n     * @type {boolean}\n     */\n    this.closed = false;\n    this._parent = null;\n    this._parents = null;\n    this._subscriptions = null;\n\n    if (unsubscribe) {\n      this._unsubscribe = unsubscribe;\n    }\n  }\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n\n\n  Subscription.prototype.unsubscribe = function () {\n    var hasErrors = false;\n    var errors;\n\n    if (this.closed) {\n      return;\n    }\n\n    var _a = this,\n        _parent = _a._parent,\n        _parents = _a._parents,\n        _unsubscribe = _a._unsubscribe,\n        _subscriptions = _a._subscriptions;\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null; // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n\n    this._subscriptions = null;\n    var index = -1;\n    var len = _parents ? _parents.length : 0; // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n\n    while (_parent) {\n      _parent.remove(this); // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n\n\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction_1.isFunction(_unsubscribe)) {\n      var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n\n      if (trial === errorObject_1.errorObject) {\n        hasErrors = true;\n        errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n      }\n    }\n\n    if (isArray_1.isArray(_subscriptions)) {\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        var sub = _subscriptions[index];\n\n        if (isObject_1.isObject(sub)) {\n          var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n\n          if (trial === errorObject_1.errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            var err = errorObject_1.errorObject.e;\n\n            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n    }\n  };\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n\n\n  Subscription.prototype.add = function (teardown) {\n    if (!teardown || teardown === Subscription.EMPTY) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    var subscription = teardown;\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(teardown);\n\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function'\n        /* quack quack */\n        ) {\n          var tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n\n        break;\n\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    var subscriptions = this._subscriptions || (this._subscriptions = []);\n    subscriptions.push(subscription);\n\n    subscription._addParent(this);\n\n    return subscription;\n  };\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n\n\n  Subscription.prototype.remove = function (subscription) {\n    var subscriptions = this._subscriptions;\n\n    if (subscriptions) {\n      var subscriptionIndex = subscriptions.indexOf(subscription);\n\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  };\n\n  Subscription.prototype._addParent = function (parent) {\n    var _a = this,\n        _parent = _a._parent,\n        _parents = _a._parents;\n\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  };\n\n  Subscription.EMPTY = function (empty) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription());\n\n  return Subscription;\n}();\n\nexports.Subscription = Subscription;\n\nfunction flattenUnsubscriptionErrors(errors) {\n  return errors.reduce(function (errs, err) {\n    return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);\n  }, []);\n}\n\n/***/ }),\n\n/***/ \"y7vd\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar race_1 = __webpack_require__(\"6VCA\");\n\nObservable_1.Observable.race = race_1.race; //# sourceMappingURL=race.js.map\n\n/***/ }),\n\n/***/ \"yA04\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar every_1 = __webpack_require__(\"OVX6\");\n\nObservable_1.Observable.prototype.every = every_1.every; //# sourceMappingURL=every.js.map\n\n/***/ }),\n\n/***/ \"yP7H\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar defaultIfEmpty_1 = __webpack_require__(\"pZ8H\");\n\nObservable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty; //# sourceMappingURL=defaultIfEmpty.js.map\n\n/***/ }),\n\n/***/ \"ybuh\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"ProductsModule\", function() { return /* binding */ products_module_ProductsModule; });\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/forms/__ivy_ngcc__/fesm2015/forms.js\nvar fesm2015_forms = __webpack_require__(\"3Pt+\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js + 6 modules\nvar fesm2015_router = __webpack_require__(\"tyNb\");\n\n// EXTERNAL MODULE: ./node_modules/@ngx-translate/core/__ivy_ngcc__/fesm2015/ngx-translate-core.js + 2 modules\nvar ngx_translate_core = __webpack_require__(\"sYmb\");\n\n// EXTERNAL MODULE: ./node_modules/ngx-bootstrap/__ivy_ngcc__/datepicker/fesm2015/ngx-bootstrap-datepicker.js + 2 modules\nvar ngx_bootstrap_datepicker = __webpack_require__(\"hzby\");\n\n// EXTERNAL MODULE: ./node_modules/ngx-bootstrap/__ivy_ngcc__/pagination/fesm2015/ngx-bootstrap-pagination.js\nvar ngx_bootstrap_pagination = __webpack_require__(\"Lm2G\");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(\"rePB\");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nvar classCallCheck = __webpack_require__(\"1OyB\");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js\nvar createClass = __webpack_require__(\"vuIU\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js + 4 modules\nvar core = __webpack_require__(\"fXoL\");\n\n// CONCATENATED MODULE: ./node_modules/ngx-bootstrap/__ivy_ngcc__/tabs/fesm2015/ngx-bootstrap-tabs.js\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\n\n\nfunction TabsetComponent_li_1_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r6 = core[\"Tb\" /* getCurrentView */]();\n\n    core[\"Sb\" /* elementStart */](0, \"span\", 7);\n    core[\"Zb\" /* listener */](\"click\", function TabsetComponent_li_1_span_4_Template_span_click_0_listener($event) {\n      core[\"vc\" /* restoreView */](_r6);\n      var tabz_r1 = core[\"bc\" /* nextContext */]().$implicit;\n      var ctx_r4 = core[\"bc\" /* nextContext */]();\n      $event.preventDefault();\n      return ctx_r4.removeTab(tabz_r1);\n    });\n    core[\"Dc\" /* text */](1, \" \\u274C\");\n    core[\"Rb\" /* elementEnd */]();\n  }\n}\n\nvar _c0 = function _c0(a1) {\n  return [\"nav-item\", a1];\n};\n\nfunction TabsetComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r8 = core[\"Tb\" /* getCurrentView */]();\n\n    core[\"Sb\" /* elementStart */](0, \"li\", 3);\n    core[\"Zb\" /* listener */](\"keydown\", function TabsetComponent_li_1_Template_li_keydown_0_listener($event) {\n      core[\"vc\" /* restoreView */](_r8);\n      var i_r2 = ctx.index;\n      var ctx_r7 = core[\"bc\" /* nextContext */]();\n      return ctx_r7.keyNavActions($event, i_r2);\n    });\n    core[\"Sb\" /* elementStart */](1, \"a\", 4);\n    core[\"Zb\" /* listener */](\"click\", function TabsetComponent_li_1_Template_a_click_1_listener() {\n      var tabz_r1 = ctx.$implicit;\n      return tabz_r1.active = true;\n    });\n    core[\"Sb\" /* elementStart */](2, \"span\", 5);\n    core[\"Dc\" /* text */](3);\n    core[\"Rb\" /* elementEnd */]();\n    core[\"Bc\" /* template */](4, TabsetComponent_li_1_span_4_Template, 2, 0, \"span\", 6);\n    core[\"Rb\" /* elementEnd */]();\n    core[\"Rb\" /* elementEnd */]();\n  }\n\n  if (rf & 2) {\n    var tabz_r1 = ctx.$implicit;\n    core[\"Eb\" /* classProp */](\"active\", tabz_r1.active)(\"disabled\", tabz_r1.disabled);\n    core[\"ic\" /* property */](\"ngClass\", core[\"mc\" /* pureFunction1 */](15, _c0, tabz_r1.customClass || \"\"));\n    core[\"Ab\" /* advance */](1);\n    core[\"Eb\" /* classProp */](\"active\", tabz_r1.active)(\"disabled\", tabz_r1.disabled);\n    core[\"Bb\" /* attribute */](\"aria-controls\", tabz_r1.id ? tabz_r1.id : \"\")(\"aria-selected\", !!tabz_r1.active)(\"id\", tabz_r1.id ? tabz_r1.id + \"-link\" : \"\");\n    core[\"Ab\" /* advance */](1);\n    core[\"ic\" /* property */](\"ngTransclude\", tabz_r1.headingRef);\n    core[\"Ab\" /* advance */](1);\n    core[\"Ec\" /* textInterpolate */](tabz_r1.heading);\n    core[\"Ab\" /* advance */](1);\n    core[\"ic\" /* property */](\"ngIf\", tabz_r1.removable);\n  }\n}\n\nvar _c1 = [\"*\"];\n\nvar ngx_bootstrap_tabs_NgTranscludeDirective = /*@__PURE__*/function () {\n  var NgTranscludeDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} viewRef\n     */\n    function NgTranscludeDirective(viewRef) {\n      Object(classCallCheck[\"a\" /* default */])(this, NgTranscludeDirective);\n\n      this.viewRef = viewRef;\n    }\n    /**\n     * @param {?} templateRef\n     * @return {?}\n     */\n\n\n    return Object(createClass[\"a\" /* default */])(NgTranscludeDirective, [{\n      key: \"ngTransclude\",\n      get:\n      /* tslint:disable-next-line:no-any */\n\n      /**\n       * @return {?}\n       */\n      function get() {\n        return this._ngTransclude;\n      },\n      set: function set(templateRef) {\n        this._ngTransclude = templateRef;\n\n        if (templateRef) {\n          this.viewRef.createEmbeddedView(templateRef);\n        }\n      }\n    }]);\n  }();\n\n  NgTranscludeDirective.fac = function NgTranscludeDirective_Factory(t) {\n    return new (t || NgTranscludeDirective)(core[\"Mb\" /* directiveInject */](core[\"P\" /* ViewContainerRef */]));\n  };\n\n  NgTranscludeDirective.dir = core[\"Hb\" /* defineDirective */]({\n    type: NgTranscludeDirective,\n    selectors: [[\"\", \"ngTransclude\", \"\"]],\n    inputs: {\n      ngTransclude: \"ngTransclude\"\n    }\n  });\n  return NgTranscludeDirective;\n}();\n\nif (false) {}\n\nvar ngx_bootstrap_tabs_TabsetConfig = /*@__PURE__*/function () {\n  var TabsetConfig = /*#__PURE__*/Object(createClass[\"a\" /* default */])(function TabsetConfig() {\n    Object(classCallCheck[\"a\" /* default */])(this, TabsetConfig);\n\n    /**\n     * provides default navigation context class: 'tabs' or 'pills'\n     */\n    this.type = 'tabs';\n    /**\n     * provides possibility to set keyNavigations enable or disable, by default is enable\n     */\n\n    this.isKeysAllowed = true;\n    /**\n     * aria label for tab list\n     */\n\n    this.ariaLabel = 'Tabs';\n  });\n\n  TabsetConfig.fac = function TabsetConfig_Factory(t) {\n    return new (t || TabsetConfig)();\n  };\n  /** @nocollapse */\n\n\n  TabsetConfig.prov = Object(core[\"Ib\" /* defineInjectable */])({\n    factory: function TabsetConfig_Factory() {\n      return new TabsetConfig();\n    },\n    token: TabsetConfig,\n    providedIn: \"root\"\n  });\n  return TabsetConfig;\n}();\n\nif (false) {}\n\nvar ngx_bootstrap_tabs_TabsetComponent = /*@__PURE__*/function () {\n  var TabsetComponent = /*#__PURE__*/function () {\n    /**\n     * @param {?} config\n     * @param {?} renderer\n     * @param {?} elementRef\n     */\n    function TabsetComponent(config, renderer, elementRef) {\n      Object(classCallCheck[\"a\" /* default */])(this, TabsetComponent);\n\n      this.renderer = renderer;\n      this.elementRef = elementRef;\n      this.clazz = true;\n      this.tabs = [];\n      this.classMap = {};\n      Object.assign(this, config);\n    }\n    /**\n     * if true tabs will be placed vertically\n     * @return {?}\n     */\n\n\n    return Object(createClass[\"a\" /* default */])(TabsetComponent, [{\n      key: \"vertical\",\n      get: function get() {\n        return this._vertical;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._vertical = value;\n        this.setClassMap();\n      }\n      /**\n       * if true tabs fill the container and have a consistent width\n       * @return {?}\n       */\n\n    }, {\n      key: \"justified\",\n      get: function get() {\n        return this._justified;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._justified = value;\n        this.setClassMap();\n      }\n      /**\n       * navigation context class: 'tabs' or 'pills'\n       * @return {?}\n       */\n\n    }, {\n      key: \"type\",\n      get: function get() {\n        return this._type;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._type = value;\n        this.setClassMap();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isKeysAllowed\",\n      get: function get() {\n        return this._isKeysAllowed;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._isKeysAllowed = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.isDestroyed = true;\n      }\n      /**\n       * @param {?} tab\n       * @return {?}\n       */\n\n    }, {\n      key: \"addTab\",\n      value: function addTab(tab) {\n        this.tabs.push(tab);\n        tab.active = this.tabs.length === 1 && typeof tab.active === 'undefined';\n      }\n      /**\n       * @param {?} tab\n       * @param {?=} options\n       * @return {?}\n       */\n\n    }, {\n      key: \"removeTab\",\n      value: function removeTab(tab) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n          reselect: true,\n          emit: true\n        };\n\n        /** @type {?} */\n        var index = this.tabs.indexOf(tab);\n\n        if (index === -1 || this.isDestroyed) {\n          return;\n        } // Select a new tab if the tab to be removed is selected and not destroyed\n\n\n        if (options.reselect && tab.active && this.hasAvailableTabs(index)) {\n          /** @type {?} */\n          var newActiveIndex = this.getClosestTabIndex(index);\n          this.tabs[newActiveIndex].active = true;\n        }\n\n        if (options.emit) {\n          tab.removed.emit(tab);\n        }\n\n        this.tabs.splice(index, 1);\n\n        if (tab.elementRef.nativeElement.parentNode) {\n          this.renderer.removeChild(tab.elementRef.nativeElement.parentNode, tab.elementRef.nativeElement);\n        }\n      }\n      /* tslint:disable-next-line: cyclomatic-complexity */\n\n      /**\n       * @param {?} event\n       * @param {?} index\n       * @return {?}\n       */\n\n    }, {\n      key: \"keyNavActions\",\n      value: function keyNavActions(event, index) {\n        if (!this.isKeysAllowed) {\n          return;\n        }\n        /** @type {?} */\n\n\n        var list = Array.from(this.elementRef.nativeElement.querySelectorAll('.nav-link')); // const activeElList = list.filter((el: HTMLElement) => !el.classList.contains('disabled'));\n        // tslint:disable-next-line:deprecation\n\n        if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n          event.preventDefault();\n          /** @type {?} */\n\n          var currentTab = list[index % list.length];\n          currentTab.click();\n          return;\n        } // tslint:disable-next-line:deprecation\n\n\n        if (event.keyCode === 39 || event.key === 'RightArrow') {\n          /** @type {?} */\n          var nextTab;\n          /** @type {?} */\n\n          var shift = 1;\n\n          do {\n            nextTab = list[(index + shift) % list.length];\n            shift++;\n          } while (nextTab.classList.contains('disabled'));\n\n          nextTab.focus();\n          return;\n        } // tslint:disable-next-line:deprecation\n\n\n        if (event.keyCode === 37 || event.key === 'LeftArrow') {\n          /** @type {?} */\n          var previousTab;\n          /** @type {?} */\n\n          var _shift = 1;\n          /** @type {?} */\n\n          var i = index;\n\n          do {\n            if (i - _shift < 0) {\n              i = list.length - 1;\n              previousTab = list[i];\n              _shift = 0;\n            } else {\n              previousTab = list[i - _shift];\n            }\n\n            _shift++;\n          } while (previousTab.classList.contains('disabled'));\n\n          previousTab.focus();\n          return;\n        } // tslint:disable-next-line:deprecation\n\n\n        if (event.keyCode === 36 || event.key === 'Home') {\n          event.preventDefault();\n          /** @type {?} */\n\n          var firstTab;\n          /** @type {?} */\n\n          var _shift2 = 0;\n\n          do {\n            firstTab = list[_shift2 % list.length];\n            _shift2++;\n          } while (firstTab.classList.contains('disabled'));\n\n          firstTab.focus();\n          return;\n        } // tslint:disable-next-line:deprecation\n\n\n        if (event.keyCode === 35 || event.key === 'End') {\n          event.preventDefault();\n          /** @type {?} */\n\n          var lastTab;\n          /** @type {?} */\n\n          var _shift3 = 1;\n          /** @type {?} */\n\n          var _i = index;\n\n          do {\n            if (_i - _shift3 < 0) {\n              _i = list.length - 1;\n              lastTab = list[_i];\n              _shift3 = 0;\n            } else {\n              lastTab = list[_i - _shift3];\n            }\n\n            _shift3++;\n          } while (lastTab.classList.contains('disabled'));\n\n          lastTab.focus();\n          return;\n        } // tslint:disable-next-line:deprecation\n\n\n        if (event.keyCode === 46 || event.key === 'Delete') {\n          if (this.tabs[index].removable) {\n            this.removeTab(this.tabs[index]);\n\n            if (list[index + 1]) {\n              list[(index + 1) % list.length].focus();\n              return;\n            }\n\n            if (list[list.length - 1]) {\n              list[0].focus();\n            }\n          }\n        }\n      }\n      /**\n       * @protected\n       * @param {?} index\n       * @return {?}\n       */\n\n    }, {\n      key: \"getClosestTabIndex\",\n      value: function getClosestTabIndex(index) {\n        /** @type {?} */\n        var tabsLength = this.tabs.length;\n\n        if (!tabsLength) {\n          return -1;\n        }\n\n        for (var step = 1; step <= tabsLength; step += 1) {\n          /** @type {?} */\n          var prevIndex = index - step;\n          /** @type {?} */\n\n          var nextIndex = index + step;\n\n          if (this.tabs[prevIndex] && !this.tabs[prevIndex].disabled) {\n            return prevIndex;\n          }\n\n          if (this.tabs[nextIndex] && !this.tabs[nextIndex].disabled) {\n            return nextIndex;\n          }\n        }\n\n        return -1;\n      }\n      /**\n       * @protected\n       * @param {?} index\n       * @return {?}\n       */\n\n    }, {\n      key: \"hasAvailableTabs\",\n      value: function hasAvailableTabs(index) {\n        /** @type {?} */\n        var tabsLength = this.tabs.length;\n\n        if (!tabsLength) {\n          return false;\n        }\n\n        for (var i = 0; i < tabsLength; i += 1) {\n          if (!this.tabs[i].disabled && i !== index) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      /**\n       * @protected\n       * @return {?}\n       */\n\n    }, {\n      key: \"setClassMap\",\n      value: function setClassMap() {\n        this.classMap = Object(defineProperty[\"a\" /* default */])({\n          'nav-stacked': this.vertical,\n          'flex-column': this.vertical,\n          'nav-justified': this.justified\n        }, \"nav-\".concat(this.type), true);\n      }\n    }]);\n  }();\n\n  TabsetComponent.fac = function TabsetComponent_Factory(t) {\n    return new (t || TabsetComponent)(core[\"Mb\" /* directiveInject */](ngx_bootstrap_tabs_TabsetConfig), core[\"Mb\" /* directiveInject */](core[\"E\" /* Renderer2 */]), core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]));\n  };\n\n  TabsetComponent.cmp = core[\"Gb\" /* defineComponent */]({\n    type: TabsetComponent,\n    selectors: [[\"tabset\"]],\n    hostVars: 2,\n    hostBindings: function TabsetComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        core[\"Eb\" /* classProp */](\"tab-container\", ctx.clazz);\n      }\n    },\n    inputs: {\n      vertical: \"vertical\",\n      justified: \"justified\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c1,\n    decls: 4,\n    vars: 3,\n    consts: [[\"role\", \"tablist\", 1, \"nav\", 3, \"ngClass\", \"click\"], [3, \"ngClass\", \"active\", \"disabled\", \"keydown\", 4, \"ngFor\", \"ngForOf\"], [1, \"tab-content\"], [3, \"ngClass\", \"keydown\"], [\"href\", \"javascript:void(0);\", \"role\", \"tab\", 1, \"nav-link\", 3, \"click\"], [3, \"ngTransclude\"], [\"class\", \"bs-remove-tab\", 3, \"click\", 4, \"ngIf\"], [1, \"bs-remove-tab\", 3, \"click\"]],\n    template: function TabsetComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        core[\"hc\" /* projectionDef */]();\n        core[\"Sb\" /* elementStart */](0, \"ul\", 0);\n        core[\"Zb\" /* listener */](\"click\", function TabsetComponent_Template_ul_click_0_listener($event) {\n          return $event.preventDefault();\n        });\n        core[\"Bc\" /* template */](1, TabsetComponent_li_1_Template, 5, 17, \"li\", 1);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](2, \"div\", 2);\n        core[\"gc\" /* projection */](3);\n        core[\"Rb\" /* elementEnd */]();\n      }\n\n      if (rf & 2) {\n        core[\"ic\" /* property */](\"ngClass\", ctx.classMap);\n        core[\"Bb\" /* attribute */](\"aria-label\", ctx.ariaLabel);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngForOf\", ctx.tabs);\n      }\n    },\n    directives: [common[\"j\" /* NgClass */], common[\"k\" /* NgForOf */], ngx_bootstrap_tabs_NgTranscludeDirective, common[\"l\" /* NgIf */]],\n    styles: [\"[_nghost-%COMP%]   .nav-tabs[_ngcontent-%COMP%]   .nav-item.disabled[_ngcontent-%COMP%]   a.disabled[_ngcontent-%COMP%]{cursor:default}\"]\n  });\n  return TabsetComponent;\n}();\n\nif (false) {}\n\nvar ngx_bootstrap_tabs_TabDirective = /*@__PURE__*/function () {\n  var TabDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} tabset\n     * @param {?} elementRef\n     * @param {?} renderer\n     */\n    function TabDirective(tabset, elementRef, renderer) {\n      Object(classCallCheck[\"a\" /* default */])(this, TabDirective);\n\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      /**\n       * fired when tab became active, $event:Tab equals to selected instance of Tab component\n       */\n\n      this.selectTab = new core[\"n\" /* EventEmitter */]();\n      /**\n       * fired when tab became inactive, $event:Tab equals to deselected instance of Tab component\n       */\n\n      this.deselect = new core[\"n\" /* EventEmitter */]();\n      /**\n       * fired before tab will be removed, $event:Tab equals to instance of removed tab\n       */\n\n      this.removed = new core[\"n\" /* EventEmitter */]();\n      this.addClass = true;\n      this.role = 'tabpanel';\n      this.tabset = tabset;\n      this.tabset.addTab(this);\n    }\n    /**\n     * if set, will be added to the tab's class attribute. Multiple classes are supported.\n     * @return {?}\n     */\n\n\n    return Object(createClass[\"a\" /* default */])(TabDirective, [{\n      key: \"customClass\",\n      get: function get() {\n        return this._customClass;\n      }\n      /**\n       * @param {?} customClass\n       * @return {?}\n       */\n      ,\n      set: function set(customClass) {\n        var _this = this;\n\n        if (this.customClass) {\n          this.customClass.split(' ').forEach(\n          /**\n          * @param {?} cssClass\n          * @return {?}\n          */\n          function (cssClass) {\n            _this.renderer.removeClass(_this.elementRef.nativeElement, cssClass);\n          });\n        }\n\n        this._customClass = customClass ? customClass.trim() : null;\n\n        if (this.customClass) {\n          this.customClass.split(' ').forEach(\n          /**\n          * @param {?} cssClass\n          * @return {?}\n          */\n          function (cssClass) {\n            _this.renderer.addClass(_this.elementRef.nativeElement, cssClass);\n          });\n        }\n      }\n      /**\n       * tab active state toggle\n       * @return {?}\n       */\n\n    }, {\n      key: \"active\",\n      get: function get() {\n        return this._active;\n      }\n      /**\n       * @param {?} active\n       * @return {?}\n       */\n      ,\n      set: function set(active) {\n        var _this2 = this;\n\n        if (this._active === active) {\n          return;\n        }\n\n        if (this.disabled && active || !active) {\n          if (this._active && !active) {\n            this.deselect.emit(this);\n            this._active = active;\n          }\n\n          return;\n        }\n\n        this._active = active;\n        this.selectTab.emit(this);\n        this.tabset.tabs.forEach(\n        /**\n        * @param {?} tab\n        * @return {?}\n        */\n        function (tab) {\n          if (tab !== _this2) {\n            tab.active = false;\n          }\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ariaLabelledby\",\n      get: function get() {\n        return this.id ? \"\".concat(this.id, \"-link\") : '';\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.removable = this.removable;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.tabset.removeTab(this, {\n          reselect: false,\n          emit: false\n        });\n      }\n    }]);\n  }();\n\n  TabDirective.fac = function TabDirective_Factory(t) {\n    return new (t || TabDirective)(core[\"Mb\" /* directiveInject */](ngx_bootstrap_tabs_TabsetComponent), core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"E\" /* Renderer2 */]));\n  };\n\n  TabDirective.dir = core[\"Hb\" /* defineDirective */]({\n    type: TabDirective,\n    selectors: [[\"tab\"], [\"\", \"tab\", \"\"]],\n    hostVars: 7,\n    hostBindings: function TabDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        core[\"Bb\" /* attribute */](\"role\", ctx.role)(\"aria-labelledby\", ctx.ariaLabelledby)(\"id\", ctx.id);\n        core[\"Eb\" /* classProp */](\"tab-pane\", ctx.addClass)(\"active\", ctx.active);\n      }\n    },\n    inputs: {\n      customClass: \"customClass\",\n      active: \"active\",\n      removable: \"removable\",\n      heading: \"heading\",\n      id: \"id\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      selectTab: \"selectTab\",\n      deselect: \"deselect\",\n      removed: \"removed\"\n    },\n    exportAs: [\"tab\"]\n  });\n  return TabDirective;\n}();\n\nif (false) {}\n\nvar ngx_bootstrap_tabs_TabHeadingDirective = /*@__PURE__*/function () {\n  var TabHeadingDirective = /*#__PURE__*/Object(createClass[\"a\" /* default */])(\n  /* tslint:disable-next-line:no-any */\n\n  /**\n   * @param {?} templateRef\n   * @param {?} tab\n   */\n  function TabHeadingDirective(templateRef, tab) {\n    Object(classCallCheck[\"a\" /* default */])(this, TabHeadingDirective);\n\n    tab.headingRef = templateRef;\n  });\n\n  TabHeadingDirective.fac = function TabHeadingDirective_Factory(t) {\n    return new (t || TabHeadingDirective)(core[\"Mb\" /* directiveInject */](core[\"L\" /* TemplateRef */]), core[\"Mb\" /* directiveInject */](ngx_bootstrap_tabs_TabDirective));\n  };\n\n  TabHeadingDirective.dir = core[\"Hb\" /* defineDirective */]({\n    type: TabHeadingDirective,\n    selectors: [[\"\", \"tabHeading\", \"\"]]\n  });\n  return TabHeadingDirective;\n}();\n\nif (false) {}\n\nvar ngx_bootstrap_tabs_TabsModule = /*@__PURE__*/function () {\n  var TabsModule = /*#__PURE__*/function () {\n    function TabsModule() {\n      Object(classCallCheck[\"a\" /* default */])(this, TabsModule);\n    }\n\n    return Object(createClass[\"a\" /* default */])(TabsModule, null, [{\n      key: \"forRoot\",\n      value:\n      /**\n       * @return {?}\n       */\n      function forRoot() {\n        return {\n          ngModule: TabsModule,\n          providers: []\n        };\n      }\n    }]);\n  }();\n\n  TabsModule.fac = function TabsModule_Factory(t) {\n    return new (t || TabsModule)();\n  };\n\n  TabsModule.mod = core[\"Kb\" /* defineNgModule */]({\n    type: TabsModule\n  });\n  TabsModule.inj = core[\"Jb\" /* defineInjector */]({\n    imports: [[common[\"c\" /* CommonModule */]]]\n  });\n  return TabsModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"yc\" /* setNgModuleScope */](ngx_bootstrap_tabs_TabsModule, {\n    declarations: function declarations() {\n      return [ngx_bootstrap_tabs_NgTranscludeDirective, ngx_bootstrap_tabs_TabDirective, ngx_bootstrap_tabs_TabsetComponent, ngx_bootstrap_tabs_TabHeadingDirective];\n    },\n    imports: function imports() {\n      return [common[\"c\" /* CommonModule */]];\n    },\n    exports: function exports() {\n      return [ngx_bootstrap_tabs_TabDirective, ngx_bootstrap_tabs_TabsetComponent, ngx_bootstrap_tabs_TabHeadingDirective, ngx_bootstrap_tabs_NgTranscludeDirective];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\n //# sourceMappingURL=ngx-bootstrap-tabs.js.map\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js + 1 modules\nvar possibleConstructorReturn = __webpack_require__(\"md7G\");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js\nvar isNativeReflectConstruct = __webpack_require__(\"2WcH\");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\nvar getPrototypeOf = __webpack_require__(\"foSv\");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js\nvar inherits = __webpack_require__(\"Ji7U\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js\nvar BehaviorSubject = __webpack_require__(\"2Vo4\");\n\n// EXTERNAL MODULE: ./node_modules/ngx-bootstrap/__ivy_ngcc__/mini-ngrx/fesm2015/ngx-bootstrap-mini-ngrx.js\nvar ngx_bootstrap_mini_ngrx = __webpack_require__(\"2oBD\");\n\n// CONCATENATED MODULE: ./node_modules/ngx-bootstrap/__ivy_ngcc__/timepicker/fesm2015/ngx-bootstrap-timepicker.js\n\n\n\n\n\n\n\nfunction _callSuper(t, o, e) { return o = Object(getPrototypeOf[\"a\" /* default */])(o), Object(possibleConstructorReturn[\"a\" /* default */])(t, Object(isNativeReflectConstruct[\"a\" /* default */])() ? Reflect.construct(o, e || [], Object(getPrototypeOf[\"a\" /* default */])(t).constructor) : o.apply(t, e)); }\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\n\n\nfunction TimepickerComponent_td_6_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Dc\" /* text */](1, \"\\xA0\\xA0\\xA0\");\n    core[\"Rb\" /* elementEnd */]();\n  }\n}\n\nfunction TimepickerComponent_td_7_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r19 = core[\"Tb\" /* getCurrentView */]();\n\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Sb\" /* elementStart */](1, \"a\", 1);\n    core[\"Zb\" /* listener */](\"click\", function TimepickerComponent_td_7_Template_a_click_1_listener() {\n      core[\"vc\" /* restoreView */](_r19);\n      var ctx_r18 = core[\"bc\" /* nextContext */]();\n      return ctx_r18.changeMinutes(ctx_r18.minuteStep);\n    });\n    core[\"Nb\" /* element */](2, \"span\", 2);\n    core[\"Rb\" /* elementEnd */]();\n    core[\"Rb\" /* elementEnd */]();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = core[\"bc\" /* nextContext */]();\n    core[\"Ab\" /* advance */](1);\n    core[\"Eb\" /* classProp */](\"disabled\", !ctx_r1.canIncrementMinutes || !ctx_r1.isEditable);\n  }\n}\n\nfunction TimepickerComponent_td_8_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Dc\" /* text */](1, \"\\xA0\");\n    core[\"Rb\" /* elementEnd */]();\n  }\n}\n\nfunction TimepickerComponent_td_9_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r21 = core[\"Tb\" /* getCurrentView */]();\n\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Sb\" /* elementStart */](1, \"a\", 1);\n    core[\"Zb\" /* listener */](\"click\", function TimepickerComponent_td_9_Template_a_click_1_listener() {\n      core[\"vc\" /* restoreView */](_r21);\n      var ctx_r20 = core[\"bc\" /* nextContext */]();\n      return ctx_r20.changeSeconds(ctx_r20.secondsStep);\n    });\n    core[\"Nb\" /* element */](2, \"span\", 2);\n    core[\"Rb\" /* elementEnd */]();\n    core[\"Rb\" /* elementEnd */]();\n  }\n\n  if (rf & 2) {\n    var ctx_r3 = core[\"bc\" /* nextContext */]();\n    core[\"Ab\" /* advance */](1);\n    core[\"Eb\" /* classProp */](\"disabled\", !ctx_r3.canIncrementSeconds || !ctx_r3.isEditable);\n  }\n}\n\nfunction TimepickerComponent_td_10_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Dc\" /* text */](1, \"\\xA0\\xA0\\xA0\");\n    core[\"Rb\" /* elementEnd */]();\n  }\n}\n\nfunction TimepickerComponent_td_11_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Nb\" /* element */](0, \"td\");\n  }\n}\n\nfunction TimepickerComponent_td_15_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Dc\" /* text */](1, \"\\xA0:\\xA0\");\n    core[\"Rb\" /* elementEnd */]();\n  }\n}\n\nfunction TimepickerComponent_td_16_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r23 = core[\"Tb\" /* getCurrentView */]();\n\n    core[\"Sb\" /* elementStart */](0, \"td\", 4);\n    core[\"Sb\" /* elementStart */](1, \"input\", 5);\n    core[\"Zb\" /* listener */](\"wheel\", function TimepickerComponent_td_16_Template_input_wheel_1_listener($event) {\n      core[\"vc\" /* restoreView */](_r23);\n      var ctx_r22 = core[\"bc\" /* nextContext */]();\n      ctx_r22.prevDef($event);\n      return ctx_r22.changeMinutes(ctx_r22.minuteStep * ctx_r22.wheelSign($event), \"wheel\");\n    })(\"keydown.ArrowUp\", function TimepickerComponent_td_16_Template_input_keydown_ArrowUp_1_listener() {\n      core[\"vc\" /* restoreView */](_r23);\n      var ctx_r24 = core[\"bc\" /* nextContext */]();\n      return ctx_r24.changeMinutes(ctx_r24.minuteStep, \"key\");\n    })(\"keydown.ArrowDown\", function TimepickerComponent_td_16_Template_input_keydown_ArrowDown_1_listener() {\n      core[\"vc\" /* restoreView */](_r23);\n      var ctx_r25 = core[\"bc\" /* nextContext */]();\n      return ctx_r25.changeMinutes(-ctx_r25.minuteStep, \"key\");\n    })(\"change\", function TimepickerComponent_td_16_Template_input_change_1_listener($event) {\n      core[\"vc\" /* restoreView */](_r23);\n      var ctx_r26 = core[\"bc\" /* nextContext */]();\n      return ctx_r26.updateMinutes($event.target.value);\n    });\n    core[\"Rb\" /* elementEnd */]();\n    core[\"Rb\" /* elementEnd */]();\n  }\n\n  if (rf & 2) {\n    var ctx_r7 = core[\"bc\" /* nextContext */]();\n    core[\"Eb\" /* classProp */](\"has-error\", ctx_r7.invalidMinutes);\n    core[\"Ab\" /* advance */](1);\n    core[\"Eb\" /* classProp */](\"is-invalid\", ctx_r7.invalidMinutes);\n    core[\"ic\" /* property */](\"placeholder\", ctx_r7.minutesPlaceholder)(\"readonly\", ctx_r7.readonlyInput)(\"disabled\", ctx_r7.disabled)(\"value\", ctx_r7.minutes);\n    core[\"Bb\" /* attribute */](\"aria-label\", ctx_r7.labelMinutes);\n  }\n}\n\nfunction TimepickerComponent_td_17_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Dc\" /* text */](1, \"\\xA0:\\xA0\");\n    core[\"Rb\" /* elementEnd */]();\n  }\n}\n\nfunction TimepickerComponent_td_18_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r28 = core[\"Tb\" /* getCurrentView */]();\n\n    core[\"Sb\" /* elementStart */](0, \"td\", 4);\n    core[\"Sb\" /* elementStart */](1, \"input\", 5);\n    core[\"Zb\" /* listener */](\"wheel\", function TimepickerComponent_td_18_Template_input_wheel_1_listener($event) {\n      core[\"vc\" /* restoreView */](_r28);\n      var ctx_r27 = core[\"bc\" /* nextContext */]();\n      ctx_r27.prevDef($event);\n      return ctx_r27.changeSeconds(ctx_r27.secondsStep * ctx_r27.wheelSign($event), \"wheel\");\n    })(\"keydown.ArrowUp\", function TimepickerComponent_td_18_Template_input_keydown_ArrowUp_1_listener() {\n      core[\"vc\" /* restoreView */](_r28);\n      var ctx_r29 = core[\"bc\" /* nextContext */]();\n      return ctx_r29.changeSeconds(ctx_r29.secondsStep, \"key\");\n    })(\"keydown.ArrowDown\", function TimepickerComponent_td_18_Template_input_keydown_ArrowDown_1_listener() {\n      core[\"vc\" /* restoreView */](_r28);\n      var ctx_r30 = core[\"bc\" /* nextContext */]();\n      return ctx_r30.changeSeconds(-ctx_r30.secondsStep, \"key\");\n    })(\"change\", function TimepickerComponent_td_18_Template_input_change_1_listener($event) {\n      core[\"vc\" /* restoreView */](_r28);\n      var ctx_r31 = core[\"bc\" /* nextContext */]();\n      return ctx_r31.updateSeconds($event.target.value);\n    });\n    core[\"Rb\" /* elementEnd */]();\n    core[\"Rb\" /* elementEnd */]();\n  }\n\n  if (rf & 2) {\n    var ctx_r9 = core[\"bc\" /* nextContext */]();\n    core[\"Eb\" /* classProp */](\"has-error\", ctx_r9.invalidSeconds);\n    core[\"Ab\" /* advance */](1);\n    core[\"Eb\" /* classProp */](\"is-invalid\", ctx_r9.invalidSeconds);\n    core[\"ic\" /* property */](\"placeholder\", ctx_r9.secondsPlaceholder)(\"readonly\", ctx_r9.readonlyInput)(\"disabled\", ctx_r9.disabled)(\"value\", ctx_r9.seconds);\n    core[\"Bb\" /* attribute */](\"aria-label\", ctx_r9.labelSeconds);\n  }\n}\n\nfunction TimepickerComponent_td_19_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Dc\" /* text */](1, \"\\xA0\\xA0\\xA0\");\n    core[\"Rb\" /* elementEnd */]();\n  }\n}\n\nfunction TimepickerComponent_td_20_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r33 = core[\"Tb\" /* getCurrentView */]();\n\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Sb\" /* elementStart */](1, \"button\", 8);\n    core[\"Zb\" /* listener */](\"click\", function TimepickerComponent_td_20_Template_button_click_1_listener() {\n      core[\"vc\" /* restoreView */](_r33);\n      var ctx_r32 = core[\"bc\" /* nextContext */]();\n      return ctx_r32.toggleMeridian();\n    });\n    core[\"Dc\" /* text */](2);\n    core[\"Rb\" /* elementEnd */]();\n    core[\"Rb\" /* elementEnd */]();\n  }\n\n  if (rf & 2) {\n    var ctx_r11 = core[\"bc\" /* nextContext */]();\n    core[\"Ab\" /* advance */](1);\n    core[\"Eb\" /* classProp */](\"disabled\", !ctx_r11.isEditable || !ctx_r11.canToggleMeridian);\n    core[\"ic\" /* property */](\"disabled\", !ctx_r11.isEditable || !ctx_r11.canToggleMeridian);\n    core[\"Ab\" /* advance */](1);\n    core[\"Fc\" /* textInterpolate1 */](\"\", ctx_r11.meridian, \" \");\n  }\n}\n\nfunction TimepickerComponent_td_25_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Dc\" /* text */](1, \"\\xA0\\xA0\\xA0\");\n    core[\"Rb\" /* elementEnd */]();\n  }\n}\n\nfunction TimepickerComponent_td_26_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r35 = core[\"Tb\" /* getCurrentView */]();\n\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Sb\" /* elementStart */](1, \"a\", 1);\n    core[\"Zb\" /* listener */](\"click\", function TimepickerComponent_td_26_Template_a_click_1_listener() {\n      core[\"vc\" /* restoreView */](_r35);\n      var ctx_r34 = core[\"bc\" /* nextContext */]();\n      return ctx_r34.changeMinutes(-ctx_r34.minuteStep);\n    });\n    core[\"Nb\" /* element */](2, \"span\", 7);\n    core[\"Rb\" /* elementEnd */]();\n    core[\"Rb\" /* elementEnd */]();\n  }\n\n  if (rf & 2) {\n    var ctx_r13 = core[\"bc\" /* nextContext */]();\n    core[\"Ab\" /* advance */](1);\n    core[\"Eb\" /* classProp */](\"disabled\", !ctx_r13.canDecrementMinutes || !ctx_r13.isEditable);\n  }\n}\n\nfunction TimepickerComponent_td_27_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Dc\" /* text */](1, \"\\xA0\");\n    core[\"Rb\" /* elementEnd */]();\n  }\n}\n\nfunction TimepickerComponent_td_28_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r37 = core[\"Tb\" /* getCurrentView */]();\n\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Sb\" /* elementStart */](1, \"a\", 1);\n    core[\"Zb\" /* listener */](\"click\", function TimepickerComponent_td_28_Template_a_click_1_listener() {\n      core[\"vc\" /* restoreView */](_r37);\n      var ctx_r36 = core[\"bc\" /* nextContext */]();\n      return ctx_r36.changeSeconds(-ctx_r36.secondsStep);\n    });\n    core[\"Nb\" /* element */](2, \"span\", 7);\n    core[\"Rb\" /* elementEnd */]();\n    core[\"Rb\" /* elementEnd */]();\n  }\n\n  if (rf & 2) {\n    var ctx_r15 = core[\"bc\" /* nextContext */]();\n    core[\"Ab\" /* advance */](1);\n    core[\"Eb\" /* classProp */](\"disabled\", !ctx_r15.canDecrementSeconds || !ctx_r15.isEditable);\n  }\n}\n\nfunction TimepickerComponent_td_29_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Sb\" /* elementStart */](0, \"td\");\n    core[\"Dc\" /* text */](1, \"\\xA0\\xA0\\xA0\");\n    core[\"Rb\" /* elementEnd */]();\n  }\n}\n\nfunction TimepickerComponent_td_30_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Nb\" /* element */](0, \"td\");\n  }\n}\n\nvar ngx_bootstrap_timepicker_TimepickerActions = /*@__PURE__*/function () {\n  var TimepickerActions = /*#__PURE__*/function () {\n    function TimepickerActions() {\n      Object(classCallCheck[\"a\" /* default */])(this, TimepickerActions);\n    }\n\n    return Object(createClass[\"a\" /* default */])(TimepickerActions, [{\n      key: \"writeValue\",\n      value:\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      function writeValue(value) {\n        return {\n          type: TimepickerActions.WRITE_VALUE,\n          payload: value\n        };\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"changeHours\",\n      value: function changeHours(event) {\n        return {\n          type: TimepickerActions.CHANGE_HOURS,\n          payload: event\n        };\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"changeMinutes\",\n      value: function changeMinutes(event) {\n        return {\n          type: TimepickerActions.CHANGE_MINUTES,\n          payload: event\n        };\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"changeSeconds\",\n      value: function changeSeconds(event) {\n        return {\n          type: TimepickerActions.CHANGE_SECONDS,\n          payload: event\n        };\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"setTime\",\n      value: function setTime(value) {\n        return {\n          type: TimepickerActions.SET_TIME_UNIT,\n          payload: value\n        };\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateControls\",\n      value: function updateControls(value) {\n        return {\n          type: TimepickerActions.UPDATE_CONTROLS,\n          payload: value\n        };\n      }\n    }]);\n  }();\n\n  TimepickerActions.fac = function TimepickerActions_Factory(t) {\n    return new (t || TimepickerActions)();\n  };\n\n  TimepickerActions.prov = core[\"Ib\" /* defineInjectable */]({\n    token: TimepickerActions,\n    factory: TimepickerActions.fac\n  });\n  TimepickerActions.WRITE_VALUE = '[timepicker] write value from ng model';\n  TimepickerActions.CHANGE_HOURS = '[timepicker] change hours';\n  TimepickerActions.CHANGE_MINUTES = '[timepicker] change minutes';\n  TimepickerActions.CHANGE_SECONDS = '[timepicker] change seconds';\n  TimepickerActions.SET_TIME_UNIT = '[timepicker] set time unit';\n  TimepickerActions.UPDATE_CONTROLS = '[timepicker] update controls';\n  return TimepickerActions;\n}();\n\nif (false) {}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar dex = 10;\n/** @type {?} */\n\nvar hoursPerDay = 24;\n/** @type {?} */\n\nvar hoursPerDayHalf = 12;\n/** @type {?} */\n\nvar minutesPerHour = 60;\n/** @type {?} */\n\nvar secondsPerMinute = 60;\n/**\n * @param {?=} value\n * @return {?}\n */\n\nfunction isValidDate(value) {\n  if (!value) {\n    return false;\n  }\n\n  if (value instanceof Date && isNaN(value.getHours())) {\n    return false;\n  }\n\n  if (typeof value === 'string') {\n    return isValidDate(new Date(value));\n  }\n\n  return true;\n}\n/**\n * @param {?} controls\n * @param {?} newDate\n * @return {?}\n */\n\n\nfunction isValidLimit(controls, newDate) {\n  if (controls.min && newDate < controls.min) {\n    return false;\n  }\n\n  if (controls.max && newDate > controls.max) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction toNumber(value) {\n  if (typeof value === 'number') {\n    return value;\n  }\n\n  return parseInt(value, dex);\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isNumber(value) {\n  return !isNaN(toNumber(value));\n}\n/**\n * @param {?} value\n * @param {?=} isPM\n * @return {?}\n */\n\n\nfunction parseHours(value) {\n  var isPM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  /** @type {?} */\n  var hour = toNumber(value);\n\n  if (isNaN(hour) || hour < 0 || hour > (isPM ? hoursPerDayHalf : hoursPerDay)) {\n    return NaN;\n  }\n\n  return hour;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction parseMinutes(value) {\n  /** @type {?} */\n  var minute = toNumber(value);\n\n  if (isNaN(minute) || minute < 0 || minute > minutesPerHour) {\n    return NaN;\n  }\n\n  return minute;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction parseSeconds(value) {\n  /** @type {?} */\n  var seconds = toNumber(value);\n\n  if (isNaN(seconds) || seconds < 0 || seconds > secondsPerMinute) {\n    return NaN;\n  }\n\n  return seconds;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction parseTime(value) {\n  if (typeof value === 'string') {\n    return new Date(value);\n  }\n\n  return value;\n}\n/**\n * @param {?} value\n * @param {?} diff\n * @return {?}\n */\n\n\nfunction changeTime(value, diff) {\n  if (!value) {\n    return changeTime(createDate(new Date(), 0, 0, 0), diff);\n  }\n  /** @type {?} */\n\n\n  var hour = value.getHours();\n  /** @type {?} */\n\n  var minutes = value.getMinutes();\n  /** @type {?} */\n\n  var seconds = value.getSeconds();\n\n  if (diff.hour) {\n    hour = hour + toNumber(diff.hour);\n  }\n\n  if (diff.minute) {\n    minutes = minutes + toNumber(diff.minute);\n  }\n\n  if (diff.seconds) {\n    seconds = seconds + toNumber(diff.seconds);\n  }\n\n  return createDate(value, hour, minutes, seconds);\n}\n/**\n * @param {?} value\n * @param {?} opts\n * @return {?}\n */\n\n\nfunction setTime(value, opts) {\n  /** @type {?} */\n  var hour = parseHours(opts.hour);\n  /** @type {?} */\n\n  var minute = parseMinutes(opts.minute);\n  /** @type {?} */\n\n  var seconds = parseSeconds(opts.seconds) || 0;\n\n  if (opts.isPM && hour !== 12) {\n    hour += hoursPerDayHalf;\n  }\n\n  if (!value) {\n    if (!isNaN(hour) && !isNaN(minute)) {\n      return createDate(new Date(), hour, minute, seconds);\n    }\n\n    return value;\n  }\n\n  if (isNaN(hour) || isNaN(minute)) {\n    return value;\n  }\n\n  return createDate(value, hour, minute, seconds);\n}\n/**\n * @param {?} value\n * @param {?} hours\n * @param {?} minutes\n * @param {?} seconds\n * @return {?}\n */\n\n\nfunction createDate(value, hours, minutes, seconds) {\n  /** @type {?} */\n  var newValue = new Date(value.getFullYear(), value.getMonth(), value.getDate(), hours, minutes, seconds, value.getMilliseconds()); // #3139 ensure date part remains unchanged\n\n  newValue.setFullYear(value.getFullYear());\n  newValue.setMonth(value.getMonth());\n  newValue.setDate(value.getDate());\n  return newValue;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction padNumber(value) {\n  /** @type {?} */\n  var _value = value.toString();\n\n  if (_value.length > 1) {\n    return _value;\n  }\n\n  return \"0\".concat(_value);\n}\n/**\n * @param {?} hours\n * @param {?} isPM\n * @return {?}\n */\n\n\nfunction isHourInputValid(hours, isPM) {\n  return !isNaN(parseHours(hours, isPM));\n}\n/**\n * @param {?} minutes\n * @return {?}\n */\n\n\nfunction isMinuteInputValid(minutes) {\n  return !isNaN(parseMinutes(minutes));\n}\n/**\n * @param {?} seconds\n * @return {?}\n */\n\n\nfunction isSecondInputValid(seconds) {\n  return !isNaN(parseSeconds(seconds));\n}\n/**\n * @param {?} diff\n * @param {?} max\n * @param {?} min\n * @return {?}\n */\n\n\nfunction isInputLimitValid(diff, max, min) {\n  /** @type {?} */\n  var newDate = setTime(new Date(), diff);\n\n  if (max && newDate > max) {\n    return false;\n  }\n\n  if (min && newDate < min) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {?} hours\n * @param {?=} minutes\n * @param {?=} seconds\n * @param {?=} isPM\n * @return {?}\n */\n\n\nfunction isInputValid(hours) {\n  var minutes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0';\n  var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';\n  var isPM = arguments.length > 3 ? arguments[3] : undefined;\n  return isHourInputValid(hours, isPM) && isMinuteInputValid(minutes) && isSecondInputValid(seconds);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} state\n * @param {?=} event\n * @return {?}\n */\n\n\nfunction canChangeValue(state, event) {\n  if (state.readonlyInput || state.disabled) {\n    return false;\n  }\n\n  if (event) {\n    if (event.source === 'wheel' && !state.mousewheel) {\n      return false;\n    }\n\n    if (event.source === 'key' && !state.arrowkeys) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @param {?} event\n * @param {?} controls\n * @return {?}\n */\n\n\nfunction canChangeHours(event, controls) {\n  if (!event.step) {\n    return false;\n  }\n\n  if (event.step > 0 && !controls.canIncrementHours) {\n    return false;\n  }\n\n  if (event.step < 0 && !controls.canDecrementHours) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {?} event\n * @param {?} controls\n * @return {?}\n */\n\n\nfunction canChangeMinutes(event, controls) {\n  if (!event.step) {\n    return false;\n  }\n\n  if (event.step > 0 && !controls.canIncrementMinutes) {\n    return false;\n  }\n\n  if (event.step < 0 && !controls.canDecrementMinutes) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {?} event\n * @param {?} controls\n * @return {?}\n */\n\n\nfunction canChangeSeconds(event, controls) {\n  if (!event.step) {\n    return false;\n  }\n\n  if (event.step > 0 && !controls.canIncrementSeconds) {\n    return false;\n  }\n\n  if (event.step < 0 && !controls.canDecrementSeconds) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {?} state\n * @return {?}\n */\n\n\nfunction getControlsValue(state) {\n  var hourStep = state.hourStep,\n      minuteStep = state.minuteStep,\n      secondsStep = state.secondsStep,\n      readonlyInput = state.readonlyInput,\n      disabled = state.disabled,\n      mousewheel = state.mousewheel,\n      arrowkeys = state.arrowkeys,\n      showSpinners = state.showSpinners,\n      showMeridian = state.showMeridian,\n      showSeconds = state.showSeconds,\n      meridians = state.meridians,\n      min = state.min,\n      max = state.max;\n  return {\n    hourStep: hourStep,\n    minuteStep: minuteStep,\n    secondsStep: secondsStep,\n    readonlyInput: readonlyInput,\n    disabled: disabled,\n    mousewheel: mousewheel,\n    arrowkeys: arrowkeys,\n    showSpinners: showSpinners,\n    showMeridian: showMeridian,\n    showSeconds: showSeconds,\n    meridians: meridians,\n    min: min,\n    max: max\n  };\n}\n/**\n * @param {?} value\n * @param {?} state\n * @return {?}\n */\n\n\nfunction timepickerControls(value, state) {\n  /** @type {?} */\n  var hoursPerDay = 24;\n  /** @type {?} */\n\n  var hoursPerDayHalf = 12;\n  var min = state.min,\n      max = state.max,\n      hourStep = state.hourStep,\n      minuteStep = state.minuteStep,\n      secondsStep = state.secondsStep,\n      showSeconds = state.showSeconds;\n  /** @type {?} */\n\n  var res = {\n    canIncrementHours: true,\n    canIncrementMinutes: true,\n    canIncrementSeconds: true,\n    canDecrementHours: true,\n    canDecrementMinutes: true,\n    canDecrementSeconds: true,\n    canToggleMeridian: true\n  };\n\n  if (!value) {\n    return res;\n  } // compare dates\n\n\n  if (max) {\n    /** @type {?} */\n    var _newHour = changeTime(value, {\n      hour: hourStep\n    });\n\n    res.canIncrementHours = max > _newHour && value.getHours() + hourStep < hoursPerDay;\n\n    if (!res.canIncrementHours) {\n      /** @type {?} */\n      var _newMinutes = changeTime(value, {\n        minute: minuteStep\n      });\n\n      res.canIncrementMinutes = showSeconds ? max > _newMinutes : max >= _newMinutes;\n    }\n\n    if (!res.canIncrementMinutes) {\n      /** @type {?} */\n      var _newSeconds = changeTime(value, {\n        seconds: secondsStep\n      });\n\n      res.canIncrementSeconds = max >= _newSeconds;\n    }\n\n    if (value.getHours() < hoursPerDayHalf) {\n      res.canToggleMeridian = changeTime(value, {\n        hour: hoursPerDayHalf\n      }) < max;\n    }\n  }\n\n  if (min) {\n    /** @type {?} */\n    var _newHour2 = changeTime(value, {\n      hour: -hourStep\n    });\n\n    res.canDecrementHours = min < _newHour2;\n\n    if (!res.canDecrementHours) {\n      /** @type {?} */\n      var _newMinutes2 = changeTime(value, {\n        minute: -minuteStep\n      });\n\n      res.canDecrementMinutes = showSeconds ? min < _newMinutes2 : min <= _newMinutes2;\n    }\n\n    if (!res.canDecrementMinutes) {\n      /** @type {?} */\n      var _newSeconds2 = changeTime(value, {\n        seconds: -secondsStep\n      });\n\n      res.canDecrementSeconds = min <= _newSeconds2;\n    }\n\n    if (value.getHours() >= hoursPerDayHalf) {\n      res.canToggleMeridian = changeTime(value, {\n        hour: -hoursPerDayHalf\n      }) > min;\n    }\n  }\n\n  return res;\n}\n\nvar ngx_bootstrap_timepicker_TimepickerConfig = /*@__PURE__*/function () {\n  var TimepickerConfig = /*#__PURE__*/Object(createClass[\"a\" /* default */])(function TimepickerConfig() {\n    Object(classCallCheck[\"a\" /* default */])(this, TimepickerConfig);\n\n    /**\n     * hours change step\n     */\n    this.hourStep = 1;\n    /**\n     * minutes change step\n     */\n\n    this.minuteStep = 5;\n    /**\n     * seconds changes step\n     */\n\n    this.secondsStep = 10;\n    /**\n     * if true works in 12H mode and displays AM/PM. If false works in 24H mode and hides AM/PM\n     */\n\n    this.showMeridian = true;\n    /**\n     * meridian labels based on locale\n     */\n\n    this.meridians = ['AM', 'PM'];\n    /**\n     * if true hours and minutes fields will be readonly\n     */\n\n    this.readonlyInput = false;\n    /**\n     * if true hours and minutes fields will be disabled\n     */\n\n    this.disabled = false;\n    /**\n     * if true scroll inside hours and minutes inputs will change time\n     */\n\n    this.mousewheel = true;\n    /**\n     * if true the values of hours and minutes can be changed using the up/down arrow keys on the keyboard\n     */\n\n    this.arrowkeys = true;\n    /**\n     * if true spinner arrows above and below the inputs will be shown\n     */\n\n    this.showSpinners = true;\n    /**\n     * show seconds in timepicker\n     */\n\n    this.showSeconds = false;\n    /**\n     * show minutes in timepicker\n     */\n\n    this.showMinutes = true;\n    /**\n     * placeholder for hours field in timepicker\n     */\n\n    this.hoursPlaceholder = 'HH';\n    /**\n     * placeholder for minutes field in timepicker\n     */\n\n    this.minutesPlaceholder = 'MM';\n    /**\n     * placeholder for seconds field in timepicker\n     */\n\n    this.secondsPlaceholder = 'SS';\n    /**\n     * hours aria label\n     */\n\n    this.ariaLabelHours = 'hours';\n    /**\n     * minutes aria label\n     */\n\n    this.ariaLabelMinutes = 'minutes';\n    /**\n     * seconds aria label\n     */\n\n    this.ariaLabelSeconds = 'seconds';\n  });\n\n  TimepickerConfig.fac = function TimepickerConfig_Factory(t) {\n    return new (t || TimepickerConfig)();\n  };\n  /** @nocollapse */\n\n\n  TimepickerConfig.prov = Object(core[\"Ib\" /* defineInjectable */])({\n    factory: function TimepickerConfig_Factory() {\n      return new TimepickerConfig();\n    },\n    token: TimepickerConfig,\n    providedIn: \"root\"\n  });\n  return TimepickerConfig;\n}();\n\nif (false) {}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar ngx_bootstrap_timepicker_TimepickerState = /*#__PURE__*/Object(createClass[\"a\" /* default */])(function TimepickerState() {\n  Object(classCallCheck[\"a\" /* default */])(this, TimepickerState);\n});\n\nif (false) {}\n/** @type {?} */\n\n\nvar initialState = {\n  value: null,\n  config: new ngx_bootstrap_timepicker_TimepickerConfig(),\n  controls: {\n    canIncrementHours: true,\n    canIncrementMinutes: true,\n    canIncrementSeconds: true,\n    canDecrementHours: true,\n    canDecrementMinutes: true,\n    canDecrementSeconds: true,\n    canToggleMeridian: true\n  }\n}; // tslint:disable-next-line:cyclomatic-complexity\n\n/**\n * @param {?=} state\n * @param {?=} action\n * @return {?}\n */\n\nfunction timepickerReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case ngx_bootstrap_timepicker_TimepickerActions.WRITE_VALUE:\n      {\n        return Object.assign({}, state, {\n          value: action.payload\n        });\n      }\n\n    case ngx_bootstrap_timepicker_TimepickerActions.CHANGE_HOURS:\n      {\n        if (!canChangeValue(state.config, action.payload) || !canChangeHours(action.payload, state.controls)) {\n          return state;\n        }\n        /** @type {?} */\n\n\n        var _newTime = changeTime(state.value, {\n          hour: action.payload.step\n        });\n\n        if ((state.config.max || state.config.min) && !isValidLimit(state.config, _newTime)) {\n          return state;\n        }\n\n        return Object.assign({}, state, {\n          value: _newTime\n        });\n      }\n\n    case ngx_bootstrap_timepicker_TimepickerActions.CHANGE_MINUTES:\n      {\n        if (!canChangeValue(state.config, action.payload) || !canChangeMinutes(action.payload, state.controls)) {\n          return state;\n        }\n        /** @type {?} */\n\n\n        var _newTime2 = changeTime(state.value, {\n          minute: action.payload.step\n        });\n\n        if ((state.config.max || state.config.min) && !isValidLimit(state.config, _newTime2)) {\n          return state;\n        }\n\n        return Object.assign({}, state, {\n          value: _newTime2\n        });\n      }\n\n    case ngx_bootstrap_timepicker_TimepickerActions.CHANGE_SECONDS:\n      {\n        if (!canChangeValue(state.config, action.payload) || !canChangeSeconds(action.payload, state.controls)) {\n          return state;\n        }\n        /** @type {?} */\n\n\n        var _newTime3 = changeTime(state.value, {\n          seconds: action.payload.step\n        });\n\n        if ((state.config.max || state.config.min) && !isValidLimit(state.config, _newTime3)) {\n          return state;\n        }\n\n        return Object.assign({}, state, {\n          value: _newTime3\n        });\n      }\n\n    case ngx_bootstrap_timepicker_TimepickerActions.SET_TIME_UNIT:\n      {\n        if (!canChangeValue(state.config)) {\n          return state;\n        }\n        /** @type {?} */\n\n\n        var _newTime4 = setTime(state.value, action.payload);\n\n        return Object.assign({}, state, {\n          value: _newTime4\n        });\n      }\n\n    case ngx_bootstrap_timepicker_TimepickerActions.UPDATE_CONTROLS:\n      {\n        /** @type {?} */\n        var _newControlsState = timepickerControls(state.value, action.payload);\n        /** @type {?} */\n\n\n        var _newState = {\n          value: state.value,\n          config: action.payload,\n          controls: _newControlsState\n        };\n\n        if (state.config.showMeridian !== _newState.config.showMeridian) {\n          if (state.value) {\n            _newState.value = new Date(state.value);\n          }\n        }\n\n        return Object.assign({}, state, _newState);\n      }\n\n    default:\n      return state;\n  }\n}\n\nvar ngx_bootstrap_timepicker_TimepickerStore = /*@__PURE__*/function () {\n  var TimepickerStore = /*#__PURE__*/function (_MiniStore) {\n    function TimepickerStore() {\n      Object(classCallCheck[\"a\" /* default */])(this, TimepickerStore);\n\n      /** @type {?} */\n      var _dispatcher = new BehaviorSubject[\"a\" /* BehaviorSubject */]({\n        type: '[mini-ngrx] dispatcher init'\n      });\n      /** @type {?} */\n\n\n      var state = new ngx_bootstrap_mini_ngrx[\"a\" /* MiniState */](initialState, _dispatcher, timepickerReducer);\n      return _callSuper(this, TimepickerStore, [_dispatcher, timepickerReducer, state]);\n    }\n\n    Object(inherits[\"a\" /* default */])(TimepickerStore, _MiniStore);\n\n    return Object(createClass[\"a\" /* default */])(TimepickerStore);\n  }(ngx_bootstrap_mini_ngrx[\"b\" /* MiniStore */]);\n\n  TimepickerStore.fac = function TimepickerStore_Factory(t) {\n    return new (t || TimepickerStore)();\n  };\n\n  TimepickerStore.prov = core[\"Ib\" /* defineInjectable */]({\n    token: TimepickerStore,\n    factory: TimepickerStore.fac\n  });\n  return TimepickerStore;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar TIMEPICKER_CONTROL_VALUE_ACCESSOR = {\n  provide: fesm2015_forms[\"h\" /* NG_VALUE_ACCESSOR */],\n\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: Object(core[\"T\" /* forwardRef */])(\n  /**\n  * @return {?}\n  */\n  function () {\n    return ngx_bootstrap_timepicker_TimepickerComponent;\n  }),\n  multi: true\n};\n\nvar ngx_bootstrap_timepicker_TimepickerComponent = /*@__PURE__*/function () {\n  var TimepickerComponent = /*#__PURE__*/function () {\n    /**\n     * @param {?} _config\n     * @param {?} _cd\n     * @param {?} _store\n     * @param {?} _timepickerActions\n     */\n    function TimepickerComponent(_config, _cd, _store, _timepickerActions) {\n      var _this = this;\n\n      Object(classCallCheck[\"a\" /* default */])(this, TimepickerComponent);\n\n      this._cd = _cd;\n      this._store = _store;\n      this._timepickerActions = _timepickerActions;\n      /**\n       * emits true if value is a valid date\n       */\n\n      this.isValid = new core[\"n\" /* EventEmitter */](); // min\\max validation for input fields\n\n      this.invalidHours = false;\n      this.invalidMinutes = false;\n      this.invalidSeconds = false; // control value accessor methods\n      // tslint:disable-next-line:no-any\n\n      this.onChange = Function.prototype; // tslint:disable-next-line:no-any\n\n      this.onTouched = Function.prototype;\n      Object.assign(this, _config);\n      this.timepickerSub = _store.select(\n      /**\n      * @param {?} state\n      * @return {?}\n      */\n\n      /**\n      * @param {?} state\n      * @return {?}\n      */\n      function (state) {\n        return state.value;\n      }).subscribe(\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        // update UI values if date changed\n        _this._renderTime(value);\n\n        _this.onChange(value);\n\n        _this._store.dispatch(_this._timepickerActions.updateControls(getControlsValue(_this)));\n      });\n\n      _store.select(\n      /**\n      * @param {?} state\n      * @return {?}\n      */\n\n      /**\n      * @param {?} state\n      * @return {?}\n      */\n      function (state) {\n        return state.controls;\n      }).subscribe(\n      /**\n      * @param {?} controlsState\n      * @return {?}\n      */\n      function (controlsState) {\n        _this.isValid.emit(isInputValid(_this.hours, _this.minutes, _this.seconds, _this.isPM()));\n\n        Object.assign(_this, controlsState);\n\n        _cd.markForCheck();\n      });\n    }\n    /**\n     * @deprecated - please use `isEditable` instead\n     * @return {?}\n     */\n\n\n    return Object(createClass[\"a\" /* default */])(TimepickerComponent, [{\n      key: \"isSpinnersVisible\",\n      get: function get() {\n        return this.showSpinners && !this.readonlyInput;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isEditable\",\n      get: function get() {\n        return !(this.readonlyInput || this.disabled);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"resetValidation\",\n      value: function resetValidation() {\n        this.invalidHours = false;\n        this.invalidMinutes = false;\n        this.invalidSeconds = false;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isPM\",\n      value: function isPM() {\n        return this.showMeridian && this.meridian === this.meridians[1];\n      }\n      /**\n       * @param {?} $event\n       * @return {?}\n       */\n\n    }, {\n      key: \"prevDef\",\n      value: function prevDef($event) {\n        $event.preventDefault();\n      }\n      /**\n       * @param {?} $event\n       * @return {?}\n       */\n\n    }, {\n      key: \"wheelSign\",\n      value: function wheelSign($event) {\n        return Math.sign($event.deltaY) * -1;\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this._store.dispatch(this._timepickerActions.updateControls(getControlsValue(this)));\n      }\n      /**\n       * @param {?} step\n       * @param {?=} source\n       * @return {?}\n       */\n\n    }, {\n      key: \"changeHours\",\n      value: function changeHours(step) {\n        var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        this.resetValidation();\n\n        this._store.dispatch(this._timepickerActions.changeHours({\n          step: step,\n          source: source\n        }));\n      }\n      /**\n       * @param {?} step\n       * @param {?=} source\n       * @return {?}\n       */\n\n    }, {\n      key: \"changeMinutes\",\n      value: function changeMinutes(step) {\n        var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        this.resetValidation();\n\n        this._store.dispatch(this._timepickerActions.changeMinutes({\n          step: step,\n          source: source\n        }));\n      }\n      /**\n       * @param {?} step\n       * @param {?=} source\n       * @return {?}\n       */\n\n    }, {\n      key: \"changeSeconds\",\n      value: function changeSeconds(step) {\n        var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        this.resetValidation();\n\n        this._store.dispatch(this._timepickerActions.changeSeconds({\n          step: step,\n          source: source\n        }));\n      }\n      /**\n       * @param {?} hours\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateHours\",\n      value: function updateHours(hours) {\n        this.resetValidation();\n        this.hours = hours;\n        /** @type {?} */\n\n        var isValid = isHourInputValid(this.hours, this.isPM()) && this.isValidLimit();\n\n        if (!isValid) {\n          this.invalidHours = true;\n          this.isValid.emit(false);\n          this.onChange(null);\n          return;\n        }\n\n        this._updateTime();\n      }\n      /**\n       * @param {?} minutes\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateMinutes\",\n      value: function updateMinutes(minutes) {\n        this.resetValidation();\n        this.minutes = minutes;\n        /** @type {?} */\n\n        var isValid = isMinuteInputValid(this.minutes) && this.isValidLimit();\n\n        if (!isValid) {\n          this.invalidMinutes = true;\n          this.isValid.emit(false);\n          this.onChange(null);\n          return;\n        }\n\n        this._updateTime();\n      }\n      /**\n       * @param {?} seconds\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateSeconds\",\n      value: function updateSeconds(seconds) {\n        this.resetValidation();\n        this.seconds = seconds;\n        /** @type {?} */\n\n        var isValid = isSecondInputValid(this.seconds) && this.isValidLimit();\n\n        if (!isValid) {\n          this.invalidSeconds = true;\n          this.isValid.emit(false);\n          this.onChange(null);\n          return;\n        }\n\n        this._updateTime();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isValidLimit\",\n      value: function isValidLimit() {\n        return isInputLimitValid({\n          hour: this.hours,\n          minute: this.minutes,\n          seconds: this.seconds,\n          isPM: this.isPM()\n        }, this.max, this.min);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_updateTime\",\n      value: function _updateTime() {\n        /** @type {?} */\n        var _seconds = this.showSeconds ? this.seconds : void 0;\n        /** @type {?} */\n\n\n        var _minutes = this.showMinutes ? this.minutes : void 0;\n\n        if (!isInputValid(this.hours, _minutes, _seconds, this.isPM())) {\n          this.isValid.emit(false);\n          this.onChange(null);\n          return;\n        }\n\n        this._store.dispatch(this._timepickerActions.setTime({\n          hour: this.hours,\n          minute: this.minutes,\n          seconds: this.seconds,\n          isPM: this.isPM()\n        }));\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"toggleMeridian\",\n      value: function toggleMeridian() {\n        if (!this.showMeridian || !this.isEditable) {\n          return;\n        }\n        /** @type {?} */\n\n\n        var _hoursPerDayHalf = 12;\n\n        this._store.dispatch(this._timepickerActions.changeHours({\n          step: _hoursPerDayHalf,\n          source: ''\n        }));\n      }\n      /**\n       * Write a new value to the element.\n       * @param {?} obj\n       * @return {?}\n       */\n\n    }, {\n      key: \"writeValue\",\n      value: function writeValue(obj) {\n        if (isValidDate(obj)) {\n          this._store.dispatch(this._timepickerActions.writeValue(parseTime(obj)));\n        } else if (obj == null) {\n          this._store.dispatch(this._timepickerActions.writeValue(null));\n        }\n      }\n      /**\n       * Set the function to be called when the control receives a change event.\n       * @param {?} fn\n       * @return {?}\n       */\n      // tslint:disable-next-line:no-any\n\n    }, {\n      key: \"registerOnChange\",\n      value: function registerOnChange(fn) {\n        this.onChange = fn;\n      }\n      /**\n       * Set the function to be called when the control receives a touch event.\n       * @param {?} fn\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnTouched\",\n      value: function registerOnTouched(fn) {\n        this.onTouched = fn;\n      }\n      /**\n       * This function is called when the control status changes to or from \"disabled\".\n       * Depending on the value, it will enable or disable the appropriate DOM element.\n       *\n       * @param {?} isDisabled\n       * @return {?}\n       */\n\n    }, {\n      key: \"setDisabledState\",\n      value: function setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n\n        this._cd.markForCheck();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.timepickerSub.unsubscribe();\n      }\n      /**\n       * @private\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"_renderTime\",\n      value: function _renderTime(value) {\n        if (!isValidDate(value)) {\n          this.hours = '';\n          this.minutes = '';\n          this.seconds = '';\n          this.meridian = this.meridians[0];\n          return;\n        }\n        /** @type {?} */\n\n\n        var _value = parseTime(value);\n        /** @type {?} */\n\n\n        var _hoursPerDayHalf = 12;\n        /** @type {?} */\n\n        var _hours = _value.getHours();\n\n        if (this.showMeridian) {\n          this.meridian = this.meridians[_hours >= _hoursPerDayHalf ? 1 : 0];\n          _hours = _hours % _hoursPerDayHalf; // should be 12 PM, not 00 PM\n\n          if (_hours === 0) {\n            _hours = _hoursPerDayHalf;\n          }\n        }\n\n        this.hours = padNumber(_hours);\n        this.minutes = padNumber(_value.getMinutes());\n        this.seconds = padNumber(_value.getUTCSeconds());\n      }\n    }]);\n  }();\n\n  TimepickerComponent.fac = function TimepickerComponent_Factory(t) {\n    return new (t || TimepickerComponent)(core[\"Mb\" /* directiveInject */](ngx_bootstrap_timepicker_TimepickerConfig), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](ngx_bootstrap_timepicker_TimepickerStore), core[\"Mb\" /* directiveInject */](ngx_bootstrap_timepicker_TimepickerActions));\n  };\n\n  TimepickerComponent.cmp = core[\"Gb\" /* defineComponent */]({\n    type: TimepickerComponent,\n    selectors: [[\"timepicker\"]],\n    inputs: {\n      disabled: \"disabled\",\n      hourStep: \"hourStep\",\n      minuteStep: \"minuteStep\",\n      secondsStep: \"secondsStep\",\n      readonlyInput: \"readonlyInput\",\n      mousewheel: \"mousewheel\",\n      arrowkeys: \"arrowkeys\",\n      showSpinners: \"showSpinners\",\n      showMeridian: \"showMeridian\",\n      showMinutes: \"showMinutes\",\n      showSeconds: \"showSeconds\",\n      meridians: \"meridians\",\n      min: \"min\",\n      max: \"max\",\n      hoursPlaceholder: \"hoursPlaceholder\",\n      minutesPlaceholder: \"minutesPlaceholder\",\n      secondsPlaceholder: \"secondsPlaceholder\"\n    },\n    outputs: {\n      isValid: \"isValid\"\n    },\n    features: [core[\"zb\" /* ProvidersFeature */]([TIMEPICKER_CONTROL_VALUE_ACCESSOR, ngx_bootstrap_timepicker_TimepickerStore]), core[\"yb\" /* NgOnChangesFeature */]],\n    decls: 31,\n    vars: 33,\n    consts: [[1, \"text-center\", 3, \"hidden\"], [1, \"btn\", \"btn-link\", 3, \"click\"], [1, \"bs-chevron\", \"bs-chevron-up\"], [4, \"ngIf\"], [1, \"form-group\"], [\"type\", \"text\", \"maxlength\", \"2\", 1, \"form-control\", \"text-center\", \"bs-timepicker-field\", 3, \"placeholder\", \"readonly\", \"disabled\", \"value\", \"wheel\", \"keydown.ArrowUp\", \"keydown.ArrowDown\", \"change\"], [\"class\", \"form-group\", 3, \"has-error\", 4, \"ngIf\"], [1, \"bs-chevron\", \"bs-chevron-down\"], [\"type\", \"button\", 1, \"btn\", \"btn-default\", \"text-center\", 3, \"disabled\", \"click\"]],\n    template: function TimepickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"table\");\n        core[\"Sb\" /* elementStart */](1, \"tbody\");\n        core[\"Sb\" /* elementStart */](2, \"tr\", 0);\n        core[\"Sb\" /* elementStart */](3, \"td\");\n        core[\"Sb\" /* elementStart */](4, \"a\", 1);\n        core[\"Zb\" /* listener */](\"click\", function TimepickerComponent_Template_a_click_4_listener() {\n          return ctx.changeHours(ctx.hourStep);\n        });\n        core[\"Nb\" /* element */](5, \"span\", 2);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Bc\" /* template */](6, TimepickerComponent_td_6_Template, 2, 0, \"td\", 3);\n        core[\"Bc\" /* template */](7, TimepickerComponent_td_7_Template, 3, 2, \"td\", 3);\n        core[\"Bc\" /* template */](8, TimepickerComponent_td_8_Template, 2, 0, \"td\", 3);\n        core[\"Bc\" /* template */](9, TimepickerComponent_td_9_Template, 3, 2, \"td\", 3);\n        core[\"Bc\" /* template */](10, TimepickerComponent_td_10_Template, 2, 0, \"td\", 3);\n        core[\"Bc\" /* template */](11, TimepickerComponent_td_11_Template, 1, 0, \"td\", 3);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](12, \"tr\");\n        core[\"Sb\" /* elementStart */](13, \"td\", 4);\n        core[\"Sb\" /* elementStart */](14, \"input\", 5);\n        core[\"Zb\" /* listener */](\"wheel\", function TimepickerComponent_Template_input_wheel_14_listener($event) {\n          ctx.prevDef($event);\n          return ctx.changeHours(ctx.hourStep * ctx.wheelSign($event), \"wheel\");\n        })(\"keydown.ArrowUp\", function TimepickerComponent_Template_input_keydown_ArrowUp_14_listener() {\n          return ctx.changeHours(ctx.hourStep, \"key\");\n        })(\"keydown.ArrowDown\", function TimepickerComponent_Template_input_keydown_ArrowDown_14_listener() {\n          return ctx.changeHours(-ctx.hourStep, \"key\");\n        })(\"change\", function TimepickerComponent_Template_input_change_14_listener($event) {\n          return ctx.updateHours($event.target.value);\n        });\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Bc\" /* template */](15, TimepickerComponent_td_15_Template, 2, 0, \"td\", 3);\n        core[\"Bc\" /* template */](16, TimepickerComponent_td_16_Template, 2, 9, \"td\", 6);\n        core[\"Bc\" /* template */](17, TimepickerComponent_td_17_Template, 2, 0, \"td\", 3);\n        core[\"Bc\" /* template */](18, TimepickerComponent_td_18_Template, 2, 9, \"td\", 6);\n        core[\"Bc\" /* template */](19, TimepickerComponent_td_19_Template, 2, 0, \"td\", 3);\n        core[\"Bc\" /* template */](20, TimepickerComponent_td_20_Template, 3, 4, \"td\", 3);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](21, \"tr\", 0);\n        core[\"Sb\" /* elementStart */](22, \"td\");\n        core[\"Sb\" /* elementStart */](23, \"a\", 1);\n        core[\"Zb\" /* listener */](\"click\", function TimepickerComponent_Template_a_click_23_listener() {\n          return ctx.changeHours(-ctx.hourStep);\n        });\n        core[\"Nb\" /* element */](24, \"span\", 7);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Bc\" /* template */](25, TimepickerComponent_td_25_Template, 2, 0, \"td\", 3);\n        core[\"Bc\" /* template */](26, TimepickerComponent_td_26_Template, 3, 2, \"td\", 3);\n        core[\"Bc\" /* template */](27, TimepickerComponent_td_27_Template, 2, 0, \"td\", 3);\n        core[\"Bc\" /* template */](28, TimepickerComponent_td_28_Template, 3, 2, \"td\", 3);\n        core[\"Bc\" /* template */](29, TimepickerComponent_td_29_Template, 2, 0, \"td\", 3);\n        core[\"Bc\" /* template */](30, TimepickerComponent_td_30_Template, 1, 0, \"td\", 3);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n      }\n\n      if (rf & 2) {\n        core[\"Ab\" /* advance */](2);\n        core[\"ic\" /* property */](\"hidden\", !ctx.showSpinners);\n        core[\"Ab\" /* advance */](2);\n        core[\"Eb\" /* classProp */](\"disabled\", !ctx.canIncrementHours || !ctx.isEditable);\n        core[\"Ab\" /* advance */](2);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMinutes);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMinutes);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showSeconds);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showSeconds);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMeridian);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMeridian);\n        core[\"Ab\" /* advance */](2);\n        core[\"Eb\" /* classProp */](\"has-error\", ctx.invalidHours);\n        core[\"Ab\" /* advance */](1);\n        core[\"Eb\" /* classProp */](\"is-invalid\", ctx.invalidHours);\n        core[\"ic\" /* property */](\"placeholder\", ctx.hoursPlaceholder)(\"readonly\", ctx.readonlyInput)(\"disabled\", ctx.disabled)(\"value\", ctx.hours);\n        core[\"Bb\" /* attribute */](\"aria-label\", ctx.labelHours);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMinutes);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMinutes);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showSeconds);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showSeconds);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMeridian);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMeridian);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"hidden\", !ctx.showSpinners);\n        core[\"Ab\" /* advance */](2);\n        core[\"Eb\" /* classProp */](\"disabled\", !ctx.canDecrementHours || !ctx.isEditable);\n        core[\"Ab\" /* advance */](2);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMinutes);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMinutes);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showSeconds);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showSeconds);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMeridian);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx.showMeridian);\n      }\n    },\n    directives: [common[\"l\" /* NgIf */]],\n    styles: [\"\\n    .bs-chevron {\\n      border-style: solid;\\n      display: block;\\n      width: 9px;\\n      height: 9px;\\n      position: relative;\\n      border-width: 3px 0px 0 3px;\\n    }\\n\\n    .bs-chevron-up {\\n      -webkit-transform: rotate(45deg);\\n      transform: rotate(45deg);\\n      top: 2px;\\n    }\\n\\n    .bs-chevron-down {\\n      -webkit-transform: rotate(-135deg);\\n      transform: rotate(-135deg);\\n      top: -2px;\\n    }\\n\\n    .bs-timepicker-field {\\n      width: 50px;\\n      padding: .375rem .55rem;\\n    }\\n  \"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return TimepickerComponent;\n}();\n\nif (false) {}\n\nvar ngx_bootstrap_timepicker_TimepickerModule = /*@__PURE__*/function () {\n  var TimepickerModule = /*#__PURE__*/function () {\n    function TimepickerModule() {\n      Object(classCallCheck[\"a\" /* default */])(this, TimepickerModule);\n    }\n\n    return Object(createClass[\"a\" /* default */])(TimepickerModule, null, [{\n      key: \"forRoot\",\n      value:\n      /**\n       * @return {?}\n       */\n      function forRoot() {\n        return {\n          ngModule: TimepickerModule,\n          providers: [ngx_bootstrap_timepicker_TimepickerActions, ngx_bootstrap_timepicker_TimepickerStore]\n        };\n      }\n    }]);\n  }();\n\n  TimepickerModule.fac = function TimepickerModule_Factory(t) {\n    return new (t || TimepickerModule)();\n  };\n\n  TimepickerModule.mod = core[\"Kb\" /* defineNgModule */]({\n    type: TimepickerModule\n  });\n  TimepickerModule.inj = core[\"Jb\" /* defineInjector */]({\n    imports: [[common[\"c\" /* CommonModule */]]]\n  });\n  return TimepickerModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"yc\" /* setNgModuleScope */](ngx_bootstrap_timepicker_TimepickerModule, {\n    declarations: function declarations() {\n      return [ngx_bootstrap_timepicker_TimepickerComponent];\n    },\n    imports: function imports() {\n      return [common[\"c\" /* CommonModule */]];\n    },\n    exports: function exports() {\n      return [ngx_bootstrap_timepicker_TimepickerComponent];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\n //# sourceMappingURL=ngx-bootstrap-timepicker.js.map\n// EXTERNAL MODULE: ./node_modules/ngx-owl-carousel-o/__ivy_ngcc__/fesm2015/ngx-owl-carousel-o.js + 5 modules\nvar ngx_owl_carousel_o = __webpack_require__(\"bhfF\");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\nvar createForOfIteratorHelper = __webpack_require__(\"uFwe\");\n\n// EXTERNAL MODULE: ./node_modules/ng5-slider/node_modules/rxjs/Rx.js\nvar Rx = __webpack_require__(\"xzWc\");\n\n// EXTERNAL MODULE: ./node_modules/ng5-slider/node_modules/rxjs/operators.js\nvar operators = __webpack_require__(\"f0q5\");\n\n// EXTERNAL MODULE: ./node_modules/detect-passive-events/lib/index.js\nvar lib = __webpack_require__(\"A/ap\");\nvar lib_default = /*#__PURE__*/__webpack_require__.n(lib);\n\n// CONCATENATED MODULE: ./node_modules/ng5-slider/__ivy_ngcc__/esm2015/ng5-slider.js\n\n\n\n\n\n\n\n\nfunction ng5_slider_callSuper(t, o, e) { return o = Object(getPrototypeOf[\"a\" /* default */])(o), Object(possibleConstructorReturn[\"a\" /* default */])(t, Object(isNativeReflectConstruct[\"a\" /* default */])() ? Reflect.construct(o, e || [], Object(getPrototypeOf[\"a\" /* default */])(t).constructor) : o.apply(t, e)); }\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** @enum {number} */\n\n\n\nvar ng5_slider_c0 = [\"tooltipTemplate\"];\nvar ng5_slider_c1 = [\"leftOuterSelectionBar\"];\nvar _c2 = [\"rightOuterSelectionBar\"];\nvar _c3 = [\"fullBar\"];\nvar _c4 = [\"selectionBar\"];\nvar _c5 = [\"minHandle\"];\nvar _c6 = [\"maxHandle\"];\nvar _c7 = [\"floorLabel\"];\nvar _c8 = [\"ceilLabel\"];\nvar _c9 = [\"minHandleLabel\"];\nvar _c10 = [\"maxHandleLabel\"];\nvar _c11 = [\"combinedLabel\"];\nvar _c12 = [\"ticksElement\"];\n\nfunction SliderComponent_span_28_ng5_slider_tooltip_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Nb\" /* element */](0, \"ng5-slider-tooltip-wrapper\", 31);\n  }\n\n  if (rf & 2) {\n    var t_r13 = core[\"bc\" /* nextContext */]().$implicit;\n    var ctx_r14 = core[\"bc\" /* nextContext */]();\n    core[\"ic\" /* property */](\"template\", ctx_r14.tooltipTemplate)(\"tooltip\", t_r13.valueTooltip)(\"placement\", t_r13.valueTooltipPlacement)(\"content\", t_r13.value);\n  }\n}\n\nfunction SliderComponent_span_28_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Nb\" /* element */](0, \"span\", 32);\n  }\n\n  if (rf & 2) {\n    var t_r13 = core[\"bc\" /* nextContext */]().$implicit;\n    core[\"ic\" /* property */](\"innerHTML\", t_r13.legend, core[\"wc\" /* sanitizeHtml */]);\n  }\n}\n\nvar _c13 = function _c13(a0) {\n  return {\n    \"ng5-slider-selected\": a0\n  };\n};\n\nfunction SliderComponent_span_28_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Sb\" /* elementStart */](0, \"span\", 27);\n    core[\"Nb\" /* element */](1, \"ng5-slider-tooltip-wrapper\", 28);\n    core[\"Bc\" /* template */](2, SliderComponent_span_28_ng5_slider_tooltip_wrapper_2_Template, 1, 4, \"ng5-slider-tooltip-wrapper\", 29);\n    core[\"Bc\" /* template */](3, SliderComponent_span_28_span_3_Template, 1, 1, \"span\", 30);\n    core[\"Rb\" /* elementEnd */]();\n  }\n\n  if (rf & 2) {\n    var t_r13 = ctx.$implicit;\n    var ctx_r12 = core[\"bc\" /* nextContext */]();\n    core[\"ic\" /* property */](\"ngClass\", core[\"mc\" /* pureFunction1 */](7, _c13, t_r13.selected))(\"ngStyle\", t_r13.style);\n    core[\"Ab\" /* advance */](1);\n    core[\"ic\" /* property */](\"template\", ctx_r12.tooltipTemplate)(\"tooltip\", t_r13.tooltip)(\"placement\", t_r13.tooltipPlacement);\n    core[\"Ab\" /* advance */](1);\n    core[\"ic\" /* property */](\"ngIf\", t_r13.value != null);\n    core[\"Ab\" /* advance */](1);\n    core[\"ic\" /* property */](\"ngIf\", t_r13.legend != null);\n  }\n}\n\nfunction TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template(rf, ctx) {}\n\nfunction TooltipWrapperComponent_ng_container_0_1_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Bc\" /* template */](0, TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nvar _c14 = function _c14(a0, a1, a2) {\n  return {\n    tooltip: a0,\n    placement: a1,\n    content: a2\n  };\n};\n\nfunction TooltipWrapperComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Qb\" /* elementContainerStart */](0);\n    core[\"Bc\" /* template */](1, TooltipWrapperComponent_ng_container_0_1_Template, 1, 0, undefined, 1);\n    core[\"Pb\" /* elementContainerEnd */]();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = core[\"bc\" /* nextContext */]();\n    core[\"Ab\" /* advance */](1);\n    core[\"ic\" /* property */](\"ngTemplateOutlet\", ctx_r0.template)(\"ngTemplateOutletContext\", core[\"oc\" /* pureFunction3 */](2, _c14, ctx_r0.tooltip, ctx_r0.placement, ctx_r0.content));\n  }\n}\n\nfunction TooltipWrapperComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    core[\"Qb\" /* elementContainerStart */](0);\n    core[\"Sb\" /* elementStart */](1, \"div\", 2);\n    core[\"Dc\" /* text */](2);\n    core[\"Rb\" /* elementEnd */]();\n    core[\"Pb\" /* elementContainerEnd */]();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = core[\"bc\" /* nextContext */]();\n    core[\"Ab\" /* advance */](1);\n    core[\"Bb\" /* attribute */](\"title\", ctx_r1.tooltip)(\"data-tooltip-placement\", ctx_r1.placement);\n    core[\"Ab\" /* advance */](1);\n    core[\"Fc\" /* textInterpolate1 */](\" \", ctx_r1.content, \" \");\n  }\n}\n\nvar PointerType = {\n  /** Low pointer */\n  Min: 0,\n\n  /** High pointer */\n  Max: 1\n};\nPointerType[PointerType.Min] = \"Min\";\nPointerType[PointerType.Max] = \"Max\";\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** @enum {number} */\n\nvar LabelType = {\n  /** Label above low pointer */\n  Low: 0,\n\n  /** Label above high pointer */\n  High: 1,\n\n  /** Label for minimum slider value */\n  Floor: 2,\n\n  /** Label for maximum slider value */\n  Ceil: 3,\n\n  /** Label below legend tick */\n  TickValue: 4\n};\nLabelType[LabelType.Low] = \"Low\";\nLabelType[LabelType.High] = \"High\";\nLabelType[LabelType.Floor] = \"Floor\";\nLabelType[LabelType.Ceil] = \"Ceil\";\nLabelType[LabelType.TickValue] = \"TickValue\";\n/**\n * Custom step definition\n *\n * This can be used to specify custom values and legend values for slider ticks\n * @record\n */\n\n/**\n * Slider options\n */\n\nvar ng5_slider_Options = /*#__PURE__*/Object(createClass[\"a\" /* default */])(function Options() {\n  Object(classCallCheck[\"a\" /* default */])(this, Options);\n\n  /**\n   * Minimum value for a slider.\n   * Not applicable when using stepsArray.\n   */\n  this.floor = 0;\n  /**\n   * Maximum value for a slider.\n   * Not applicable when using stepsArray.\n   */\n\n  this.ceil = null;\n  /**\n   * Step between each value.\n   * Not applicable when using stepsArray.\n   */\n\n  this.step = 1;\n  /**\n   * The minimum range authorized on the slider.\n   * Applies to range slider only.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.minRange = null;\n  /**\n   * The maximum range authorized on the slider.\n   * Applies to range slider only.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.maxRange = null;\n  /**\n   * Set to true to have a push behavior. When the min handle goes above the max,\n   * the max is moved as well (and vice-versa). The range between min and max is\n   * defined by the step option (defaults to 1) and can also be overriden by\n   * the minRange option. Applies to range slider only.\n   */\n\n  this.pushRange = false;\n  /**\n   * The minimum value authorized on the slider.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.minLimit = null;\n  /**\n   * The maximum value authorized on the slider.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.maxLimit = null;\n  /**\n   * Custom translate function. Use this if you want to translate values displayed\n   * on the slider.\n   */\n\n  this.translate = null;\n  /**\n   * Custom function for combining overlapping labels in range slider.\n   * It takes the min and max values (already translated with translate fuction)\n   * and should return how these two values should be combined.\n   * If not provided, the default function will join the two values with\n   * ' - ' as separator.\n   */\n\n  this.combineLabels = null;\n  /**\n   * Use to display legend under ticks (thus, it needs to be used along with\n   * showTicks or showTicksValues). The function will be called with each tick\n   * value and returned content will be displayed under the tick as a legend.\n   * If the returned value is null, then no legend is displayed under\n   * the corresponding tick.You can also directly provide the legend values\n   * in the stepsArray option.\n   */\n\n  this.getLegend = null;\n  /**\n   * If you want to display a slider with non linear/number steps.\n   * Just pass an array with each slider value and that's it; the floor, ceil and step settings\n   * of the slider will be computed automatically.\n   * By default, the value model and valueHigh model values will be the value of the selected item\n   * in the stepsArray.\n   * They can also be bound to the index of the selected item by setting the bindIndexForStepsArray\n   * option to true.\n   */\n\n  this.stepsArray = null;\n  /**\n   * Set to true to bind the index of the selected item to value model and valueHigh model.\n   */\n\n  this.bindIndexForStepsArray = false;\n  /**\n   * When set to true and using a range slider, the range can be dragged by the selection bar.\n   * Applies to range slider only.\n   */\n\n  this.draggableRange = false;\n  /**\n   * Same as draggableRange but the slider range can't be changed.\n   * Applies to range slider only.\n   */\n\n  this.draggableRangeOnly = false;\n  /**\n   * Set to true to always show the selection bar before the slider handle.\n   */\n\n  this.showSelectionBar = false;\n  /**\n   * Set to true to always show the selection bar after the slider handle.\n   */\n\n  this.showSelectionBarEnd = false;\n  /**\n   * Set a number to draw the selection bar between this value and the slider handle.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.showSelectionBarFromValue = null;\n  /**\n   * Only for range slider. Set to true to visualize in different colour the areas\n   * on the left/right (top/bottom for vertical range slider) of selection bar between the handles.\n   */\n\n  this.showOuterSelectionBars = false;\n  /**\n   * Set to true to hide pointer labels\n   */\n\n  this.hidePointerLabels = false;\n  /**\n   * Set to true to hide min / max labels\n   */\n\n  this.hideLimitLabels = false;\n  /**\n   * Set to false to disable the auto-hiding behavior of the limit labels.\n   */\n\n  this.autoHideLimitLabels = true;\n  /**\n   * Set to true to make the slider read-only.\n   */\n\n  this.readOnly = false;\n  /**\n   * Set to true to disable the slider.\n   */\n\n  this.disabled = false;\n  /**\n   * Throttle interval for mouse events in milliseconds.\n   * This is provided to avoid a flood of events when moving the slider with mouse.\n   */\n\n  this.mouseEventsInterval = 50;\n  /**\n   * Throttle interval for touch events in milliseconds.\n   * This is provided to avoid a flood of events when moving the slider with touch gesture.\n   */\n\n  this.touchEventsInterval = 50;\n  /**\n   * Throttle interval for input changes (changes to bindings or reactive form inputs)\n   * This is provided to avoid a flood of events on frequent input binding changes affecting performance.\n   */\n\n  this.inputEventsInterval = 100;\n  /**\n   * Throttle interval for output changes (signalling changes to output bindings and user callbacks)\n   * This is provided to avoid a flood of outgoing events affecting Angular app performance.\n   */\n\n  this.outputEventsInterval = 100;\n  /**\n   * Set to true to display a tick for each step of the slider.\n   */\n\n  this.showTicks = false;\n  /**\n   * Set to true to display a tick and the step value for each step of the slider..\n   */\n\n  this.showTicksValues = false;\n  /* The step between each tick to display. If not set, the step value is used.\n      Not used when ticksArray is specified. */\n\n  this.tickStep = null;\n  /* The step between displaying each tick step value. */\n\n  this.tickValueStep = 1;\n  /**\n   * Use to display ticks at specific positions.\n   * The array contains the index of the ticks that should be displayed.\n   * For example, [0, 1, 5] will display a tick for the first, second and sixth values.\n   */\n\n  this.ticksArray = null;\n  /**\n   * Used to display a tooltip when a tick is hovered.\n   * Set to a function that returns the tooltip content for a given value.\n   */\n\n  this.ticksTooltip = null;\n  /**\n   * Same as ticksTooltip but for ticks values.\n   */\n\n  this.ticksValuesTooltip = null;\n  /**\n   * Set to true to display the slider vertically.\n   * The slider will take the full height of its parent.\n   * Changing this value at runtime is not currently supported.\n   */\n\n  this.vertical = false;\n  /**\n   * Function that returns the current color of the selection bar.\n   * If your color won't change, don't use this option but set it through CSS.\n   * If the returned color depends on a model value (either value or valueHigh),\n   * you should use the argument passed to the function.\n   * Indeed, when the function is called, there is no certainty that the model\n   * has already been updated.\n   */\n\n  this.getSelectionBarColor = null;\n  /**\n   * Function that returns the color of a tick. showTicks must be enabled.\n   */\n\n  this.getTickColor = null;\n  /**\n   * Function that returns the current color of a pointer.\n   * If your color won't change, don't use this option but set it through CSS.\n   * If the returned color depends on a model value (either value or valueHigh),\n   * you should use the argument passed to the function.\n   * Indeed, when the function is called, there is no certainty that the model has already been updated.\n   * To handle range slider pointers independently, you should evaluate pointerType within the given\n   * function where \"min\" stands for value model and \"max\" for valueHigh model values.\n   */\n\n  this.getPointerColor = null;\n  /**\n   * Handles are focusable (on click or with tab) and can be modified using the following keyboard controls:\n   * Left/bottom arrows: -1\n   * Right/top arrows: +1\n   * Page-down: -10%\n   * Page-up: +10%\n   * Home: minimum value\n   * End: maximum value\n   */\n\n  this.keyboardSupport = true;\n  /**\n   * If you display the slider in an element that uses transform: scale(0.5), set the scale value to 2\n   * so that the slider is rendered properly and the events are handled correctly.\n   */\n\n  this.scale = 1;\n  /**\n   * Set to true to force the value to be rounded to the step, even when modified from the outside.\n   * When set to false, if the model values are modified from outside the slider, they are not rounded\n   * and can be between two steps.\n   */\n\n  this.enforceStep = true;\n  /**\n   * Set to true to force the value to be normalised to allowed range (floor to ceil), even when modified from the outside.\n   * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,\n   * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.\n   */\n\n  this.enforceRange = true;\n  /**\n   * Set to true to prevent to user from switching the min and max handles. Applies to range slider only.\n   */\n\n  this.noSwitching = false;\n  /**\n   * Set to true to only bind events on slider handles.\n   */\n\n  this.onlyBindHandles = false;\n  /**\n   * Set to true to show graphs right to left.\n   * If vertical is true it will be from top to bottom and left / right arrow functions reversed.\n   */\n\n  this.rightToLeft = false;\n  /**\n   * Set to true to reverse keyboard navigation:\n   * Right/top arrows: -1\n   * Left/bottom arrows: +1\n   * Page-up: -10%\n   * Page-down: +10%\n   * End: minimum value\n   * Home: maximum value\n   */\n\n  this.reversedControls = false;\n  /**\n   * Set to true to keep the slider labels inside the slider bounds.\n   */\n\n  this.boundPointerLabels = true;\n  /**\n   * Set to true to use a logarithmic scale to display the slider.\n   */\n\n  this.logScale = false;\n  /**\n   * Function that returns the position on the slider for a given value.\n   * The position must be a percentage between 0 and 1.\n   * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n   */\n\n  this.customValueToPosition = null;\n  /**\n   * Function that returns the value for a given position on the slider.\n   * The position is a percentage between 0 and 1.\n   * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n   */\n\n  this.customPositionToValue = null;\n  /**\n   * Precision limit for calculated values.\n   * Values used in calculations will be rounded to this number of significant digits\n   * to prevent accumulating small floating-point errors.\n   */\n\n  this.precisionLimit = 12;\n  /**\n   * Use to display the selection bar as a gradient.\n   * The given object must contain from and to properties which are colors.\n   */\n\n  this.selectionBarGradient = null;\n  /**\n   * Use to add a label directly to the slider for accessibility. Adds the aria-label attribute.\n   */\n\n  this.ariaLabel = null;\n  /**\n   * Use instead of ariaLabel to reference the id of an element which will be used to label the slider.\n   * Adds the aria-labelledby attribute.\n   */\n\n  this.ariaLabelledBy = null;\n  /**\n   * Use to add a label directly to the slider range for accessibility. Adds the aria-label attribute.\n   */\n\n  this.ariaLabelHigh = null;\n  /**\n   * Use instead of ariaLabelHigh to reference the id of an element which will be used to label the slider range.\n   * Adds the aria-labelledby attribute.\n   */\n\n  this.ariaLabelledByHigh = null;\n  /**\n   * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the handle\n   */\n\n  this.handleDimension = null;\n  /**\n   * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the bar\n   */\n\n  this.barDimension = null;\n  /**\n   * Enable/disable CSS animations\n   */\n\n  this.animate = true;\n});\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar ng5_slider_ChangeContext = /*#__PURE__*/Object(createClass[\"a\" /* default */])(function ChangeContext() {\n  Object(classCallCheck[\"a\" /* default */])(this, ChangeContext);\n});\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n *  Collection of functions to handle conversions/lookups of values\n */\n\n\nvar ng5_slider_ValueHelper = /*#__PURE__*/function () {\n  function ValueHelper() {\n    Object(classCallCheck[\"a\" /* default */])(this, ValueHelper);\n  }\n\n  return Object(createClass[\"a\" /* default */])(ValueHelper, null, [{\n    key: \"isNullOrUndefined\",\n    value:\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    function isNullOrUndefined(value) {\n      return value === undefined || value === null;\n    }\n    /**\n     * @param {?} val\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"linearValueToPosition\",\n    value: function linearValueToPosition(val, minVal, maxVal) {\n      var\n      /** @type {?} */\n      range = maxVal - minVal;\n      return (val - minVal) / range;\n    }\n    /**\n     * @param {?} val\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"logValueToPosition\",\n    value: function logValueToPosition(val, minVal, maxVal) {\n      val = Math.log(val);\n      minVal = Math.log(minVal);\n      maxVal = Math.log(maxVal);\n      var\n      /** @type {?} */\n      range = maxVal - minVal;\n      return (val - minVal) / range;\n    }\n    /**\n     * @param {?} percent\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"linearPositionToValue\",\n    value: function linearPositionToValue(percent, minVal, maxVal) {\n      return percent * (maxVal - minVal) + minVal;\n    }\n    /**\n     * @param {?} percent\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"logPositionToValue\",\n    value: function logPositionToValue(percent, minVal, maxVal) {\n      minVal = Math.log(minVal);\n      maxVal = Math.log(maxVal);\n      var\n      /** @type {?} */\n      value = percent * (maxVal - minVal) + minVal;\n      return Math.exp(value);\n    }\n    /**\n     * @param {?} modelValue\n     * @param {?} stepsArray\n     * @return {?}\n     */\n\n  }, {\n    key: \"findStepIndex\",\n    value: function findStepIndex(modelValue, stepsArray) {\n      var\n      /** @type {?} */\n      differences = stepsArray.map(function (step) {\n        return Math.abs(modelValue - step.value);\n      });\n      var\n      /** @type {?} */\n      minDifferenceIndex = 0;\n\n      for (var\n      /** @type {?} */\n      index = 0; index < stepsArray.length; index++) {\n        if (differences[index] !== differences[minDifferenceIndex] && differences[index] < differences[minDifferenceIndex]) {\n          minDifferenceIndex = index;\n        }\n      }\n\n      return minDifferenceIndex;\n    }\n  }]);\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Helper with compatibility functions to support different browsers\n */\n\n\nvar ng5_slider_CompatibilityHelper = /*#__PURE__*/function () {\n  function CompatibilityHelper() {\n    Object(classCallCheck[\"a\" /* default */])(this, CompatibilityHelper);\n  }\n\n  return Object(createClass[\"a\" /* default */])(CompatibilityHelper, null, [{\n    key: \"isTouchEvent\",\n    value:\n    /**\n     * Workaround for TouchEvent constructor sadly not being available on all browsers (e.g. Firefox, Safari)\n     * @param {?} event\n     * @return {?}\n     */\n    function isTouchEvent(event) {\n      if (\n      /** @type {?} */\n      window.TouchEvent !== undefined) {\n        return event instanceof TouchEvent;\n      }\n\n      return event.touches !== undefined;\n    }\n    /**\n     * Detect presence of ResizeObserver API\n     * @return {?}\n     */\n\n  }, {\n    key: \"isResizeObserverAvailable\",\n    value: function isResizeObserverAvailable() {\n      return (\n        /** @type {?} */\n        window.ResizeObserver !== undefined\n      );\n    }\n  }]);\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Helper with mathematical functions\n */\n\n\nvar ng5_slider_MathHelper = /*#__PURE__*/function () {\n  function MathHelper() {\n    Object(classCallCheck[\"a\" /* default */])(this, MathHelper);\n  }\n\n  return Object(createClass[\"a\" /* default */])(MathHelper, null, [{\n    key: \"roundToPrecisionLimit\",\n    value:\n    /**\n     * @param {?} value\n     * @param {?} precisionLimit\n     * @return {?}\n     */\n    function roundToPrecisionLimit(value, precisionLimit) {\n      return +value.toPrecision(precisionLimit);\n    }\n    /**\n     * @param {?} value\n     * @param {?} floor\n     * @param {?} ceil\n     * @return {?}\n     */\n\n  }, {\n    key: \"clampToRange\",\n    value: function clampToRange(value, floor, ceil) {\n      return Math.min(Math.max(value, floor), ceil);\n    }\n  }]);\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar ng5_slider_EventListener = /*#__PURE__*/Object(createClass[\"a\" /* default */])(function EventListener() {\n  Object(classCallCheck[\"a\" /* default */])(this, EventListener);\n\n  this.eventName = null;\n  this.events = null;\n  this.eventsSubscription = null;\n  this.teardownCallback = null;\n});\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Helper class to attach event listeners to DOM elements with debounce support using rxjs\n */\n\n\nvar ng5_slider_EventListenerHelper = /*#__PURE__*/function () {\n  /**\n   * @param {?} renderer\n   */\n  function EventListenerHelper(renderer) {\n    Object(classCallCheck[\"a\" /* default */])(this, EventListenerHelper);\n\n    this.renderer = renderer;\n  }\n  /**\n   * @param {?} nativeElement\n   * @param {?} eventName\n   * @param {?} callback\n   * @param {?=} throttleInterval\n   * @return {?}\n   */\n\n\n  return Object(createClass[\"a\" /* default */])(EventListenerHelper, [{\n    key: \"attachPassiveEventListener\",\n    value: function attachPassiveEventListener(nativeElement, eventName, callback, throttleInterval) {\n      // Only use passive event listeners if the browser supports it\n      if (lib_default.a.hasSupport !== true) {\n        return this.attachEventListener(nativeElement, eventName, callback, throttleInterval);\n      } // Angular doesn't support passive event handlers (yet), so we need to roll our own code using native functions\n\n\n      var\n      /** @type {?} */\n      listener = new ng5_slider_EventListener();\n      listener.eventName = eventName;\n      listener.events = new Rx[\"Subject\"]();\n\n      var\n      /** @type {?} */\n      observerCallback = function observerCallback(event) {\n        listener.events.next(event);\n      };\n\n      nativeElement.addEventListener(eventName, observerCallback, {\n        passive: true,\n        capture: false\n      });\n\n      listener.teardownCallback = function () {\n        nativeElement.removeEventListener(eventName, observerCallback, {\n          passive: true,\n          capture: false\n        });\n      };\n\n      listener.eventsSubscription = listener.events.pipe(!ng5_slider_ValueHelper.isNullOrUndefined(throttleInterval) ? Object(operators[\"throttleTime\"])(throttleInterval, undefined, {\n        leading: true,\n        trailing: true\n      }) : Object(operators[\"tap\"])(function () {}) // no-op\n      ).subscribe(function (event) {\n        callback(event);\n      });\n      return listener;\n    }\n    /**\n     * @param {?} eventListener\n     * @return {?}\n     */\n\n  }, {\n    key: \"detachEventListener\",\n    value: function detachEventListener(eventListener) {\n      if (!ng5_slider_ValueHelper.isNullOrUndefined(eventListener.eventsSubscription)) {\n        eventListener.eventsSubscription.unsubscribe();\n        eventListener.eventsSubscription = null;\n      }\n\n      if (!ng5_slider_ValueHelper.isNullOrUndefined(eventListener.events)) {\n        eventListener.events.complete();\n        eventListener.events = null;\n      }\n\n      if (!ng5_slider_ValueHelper.isNullOrUndefined(eventListener.teardownCallback)) {\n        eventListener.teardownCallback();\n        eventListener.teardownCallback = null;\n      }\n    }\n    /**\n     * @param {?} nativeElement\n     * @param {?} eventName\n     * @param {?} callback\n     * @param {?=} throttleInterval\n     * @return {?}\n     */\n\n  }, {\n    key: \"attachEventListener\",\n    value: function attachEventListener(nativeElement, eventName, callback, throttleInterval) {\n      var\n      /** @type {?} */\n      listener = new ng5_slider_EventListener();\n      listener.eventName = eventName;\n      listener.events = new Rx[\"Subject\"]();\n\n      var\n      /** @type {?} */\n      observerCallback = function observerCallback(event) {\n        listener.events.next(event);\n      };\n\n      listener.teardownCallback = this.renderer.listen(nativeElement, eventName, observerCallback);\n      listener.eventsSubscription = listener.events.pipe(!ng5_slider_ValueHelper.isNullOrUndefined(throttleInterval) ? Object(operators[\"throttleTime\"])(throttleInterval, undefined, {\n        leading: true,\n        trailing: true\n      }) : Object(operators[\"tap\"])(function () {}) // no-op\n      ).subscribe(function (event) {\n        callback(event);\n      });\n      return listener;\n    }\n  }]);\n}();\n\nvar ng5_slider_SliderElementDirective = /*@__PURE__*/function () {\n  var SliderElementDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} elemRef\n     * @param {?} renderer\n     * @param {?} changeDetectionRef\n     */\n    function SliderElementDirective(elemRef, renderer, changeDetectionRef) {\n      Object(classCallCheck[\"a\" /* default */])(this, SliderElementDirective);\n\n      this.elemRef = elemRef;\n      this.renderer = renderer;\n      this.changeDetectionRef = changeDetectionRef;\n      this._position = 0;\n      this._dimension = 0;\n      this._alwaysHide = false;\n      this._vertical = false;\n      this._scale = 1;\n      this.opacity = 1;\n      this.visibility = 'visible';\n      this.left = '';\n      this.bottom = '';\n      this.height = '';\n      this.width = '';\n      this.eventListeners = [];\n      this.eventListenerHelper = new ng5_slider_EventListenerHelper(this.renderer);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    return Object(createClass[\"a\" /* default */])(SliderElementDirective, [{\n      key: \"position\",\n      get: function get() {\n        return this._position;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"dimension\",\n      get: function get() {\n        return this._dimension;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"alwaysHide\",\n      get: function get() {\n        return this._alwaysHide;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"vertical\",\n      get: function get() {\n        return this._vertical;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"scale\",\n      get: function get() {\n        return this._scale;\n      }\n      /**\n       * @param {?} hide\n       * @return {?}\n       */\n\n    }, {\n      key: \"setAlwaysHide\",\n      value: function setAlwaysHide(hide) {\n        this._alwaysHide = hide;\n\n        if (hide) {\n          this.visibility = 'hidden';\n        } else {\n          this.visibility = 'visible';\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.opacity = 0;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        if (this.alwaysHide) {\n          return;\n        }\n\n        this.opacity = 1;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isVisible\",\n      value: function isVisible() {\n        if (this.alwaysHide) {\n          return false;\n        }\n\n        return this.opacity !== 0;\n      }\n      /**\n       * @param {?} vertical\n       * @return {?}\n       */\n\n    }, {\n      key: \"setVertical\",\n      value: function setVertical(vertical) {\n        this._vertical = vertical;\n\n        if (this._vertical) {\n          this.left = '';\n          this.width = '';\n        } else {\n          this.bottom = '';\n          this.height = '';\n        }\n      }\n      /**\n       * @param {?} scale\n       * @return {?}\n       */\n\n    }, {\n      key: \"setScale\",\n      value: function setScale(scale) {\n        this._scale = scale;\n      }\n      /**\n       * @param {?} pos\n       * @return {?}\n       */\n\n    }, {\n      key: \"setPosition\",\n      value: function setPosition(pos) {\n        if (this._position !== pos && !this.isRefDestroyed()) {\n          this.changeDetectionRef.markForCheck();\n        }\n\n        this._position = pos;\n\n        if (this._vertical) {\n          this.bottom = Math.round(pos) + 'px';\n        } else {\n          this.left = Math.round(pos) + 'px';\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"calculateDimension\",\n      value: function calculateDimension() {\n        var\n        /** @type {?} */\n        val = this.getBoundingClientRect();\n\n        if (this.vertical) {\n          this._dimension = (val.bottom - val.top) * this.scale;\n        } else {\n          this._dimension = (val.right - val.left) * this.scale;\n        }\n      }\n      /**\n       * @param {?} dim\n       * @return {?}\n       */\n\n    }, {\n      key: \"setDimension\",\n      value: function setDimension(dim) {\n        if (this._dimension !== dim && !this.isRefDestroyed()) {\n          this.changeDetectionRef.markForCheck();\n        }\n\n        this._dimension = dim;\n\n        if (this._vertical) {\n          this.height = Math.round(dim) + 'px';\n        } else {\n          this.width = Math.round(dim) + 'px';\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getBoundingClientRect\",\n      value: function getBoundingClientRect() {\n        return this.elemRef.nativeElement.getBoundingClientRect();\n      }\n      /**\n       * @param {?} eventName\n       * @param {?} callback\n       * @param {?=} debounceInterval\n       * @return {?}\n       */\n\n    }, {\n      key: \"on\",\n      value: function on(eventName, callback, debounceInterval) {\n        var\n        /** @type {?} */\n        listener = this.eventListenerHelper.attachEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n        this.eventListeners.push(listener);\n      }\n      /**\n       * @param {?} eventName\n       * @param {?} callback\n       * @param {?=} debounceInterval\n       * @return {?}\n       */\n\n    }, {\n      key: \"onPassive\",\n      value: function onPassive(eventName, callback, debounceInterval) {\n        var\n        /** @type {?} */\n        listener = this.eventListenerHelper.attachPassiveEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n        this.eventListeners.push(listener);\n      }\n      /**\n       * @param {?=} eventName\n       * @return {?}\n       */\n\n    }, {\n      key: \"off\",\n      value: function off(eventName) {\n        var\n        /** @type {?} */\n        listenersToKeep;\n        var\n        /** @type {?} */\n        listenersToRemove;\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(eventName)) {\n          listenersToKeep = this.eventListeners.filter(function (event) {\n            return event.eventName !== eventName;\n          });\n          listenersToRemove = this.eventListeners.filter(function (event) {\n            return event.eventName === eventName;\n          });\n        } else {\n          listenersToKeep = [];\n          listenersToRemove = this.eventListeners;\n        }\n\n        var _iterator = Object(createForOfIteratorHelper[\"a\" /* default */])(listenersToRemove),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var listener = _step.value;\n            this.eventListenerHelper.detachEventListener(listener);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this.eventListeners = listenersToKeep;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isRefDestroyed\",\n      value: function isRefDestroyed() {\n        return ng5_slider_ValueHelper.isNullOrUndefined(this.changeDetectionRef) || this.changeDetectionRef['destroyed'];\n      }\n    }]);\n  }();\n\n  SliderElementDirective.fac = function SliderElementDirective_Factory(t) {\n    return new (t || SliderElementDirective)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"E\" /* Renderer2 */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]));\n  };\n\n  SliderElementDirective.dir = core[\"Hb\" /* defineDirective */]({\n    type: SliderElementDirective,\n    selectors: [[\"\", \"ng5SliderElement\", \"\"]],\n    hostVars: 12,\n    hostBindings: function SliderElementDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        core[\"zc\" /* styleProp */](\"opacity\", ctx.opacity)(\"visibility\", ctx.visibility)(\"left\", ctx.left)(\"bottom\", ctx.bottom)(\"height\", ctx.height)(\"width\", ctx.width);\n      }\n    }\n  });\n  return SliderElementDirective;\n}();\n\nvar ng5_slider_SliderHandleDirective = /*@__PURE__*/function () {\n  var SliderHandleDirective = /*#__PURE__*/function (_SliderElementDirecti) {\n    /**\n     * @param {?} elemRef\n     * @param {?} renderer\n     * @param {?} changeDetectionRef\n     */\n    function SliderHandleDirective(elemRef, renderer, changeDetectionRef) {\n      var _this;\n\n      Object(classCallCheck[\"a\" /* default */])(this, SliderHandleDirective);\n\n      _this = ng5_slider_callSuper(this, SliderHandleDirective, [elemRef, renderer, changeDetectionRef]);\n      _this.active = false;\n      _this.role = '';\n      _this.tabindex = '';\n      _this.ariaOrientation = '';\n      _this.ariaLabel = '';\n      _this.ariaLabelledBy = '';\n      _this.ariaValueNow = '';\n      _this.ariaValueText = '';\n      _this.ariaValueMin = '';\n      _this.ariaValueMax = '';\n      return _this;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    Object(inherits[\"a\" /* default */])(SliderHandleDirective, _SliderElementDirecti);\n\n    return Object(createClass[\"a\" /* default */])(SliderHandleDirective, [{\n      key: \"focus\",\n      value: function focus() {\n        this.elemRef.nativeElement.focus();\n      }\n    }]);\n  }(ng5_slider_SliderElementDirective);\n\n  SliderHandleDirective.fac = function SliderHandleDirective_Factory(t) {\n    return new (t || SliderHandleDirective)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"E\" /* Renderer2 */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]));\n  };\n\n  SliderHandleDirective.dir = core[\"Hb\" /* defineDirective */]({\n    type: SliderHandleDirective,\n    selectors: [[\"\", \"ng5SliderHandle\", \"\"]],\n    hostVars: 11,\n    hostBindings: function SliderHandleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        core[\"Bb\" /* attribute */](\"role\", ctx.role)(\"tabindex\", ctx.tabindex)(\"aria-orientation\", ctx.ariaOrientation)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledBy)(\"aria-valuenow\", ctx.ariaValueNow)(\"aria-valuetext\", ctx.ariaValueText)(\"aria-valuemin\", ctx.ariaValueMin)(\"aria-valuemax\", ctx.ariaValueMax);\n        core[\"Eb\" /* classProp */](\"ng5-slider-active\", ctx.active);\n      }\n    },\n    features: [core[\"xb\" /* InheritDefinitionFeature */]]\n  });\n  return SliderHandleDirective;\n}();\n\nvar ng5_slider_SliderLabelDirective = /*@__PURE__*/function () {\n  var SliderLabelDirective = /*#__PURE__*/function (_SliderElementDirecti2) {\n    /**\n     * @param {?} elemRef\n     * @param {?} renderer\n     * @param {?} changeDetectionRef\n     */\n    function SliderLabelDirective(elemRef, renderer, changeDetectionRef) {\n      var _this2;\n\n      Object(classCallCheck[\"a\" /* default */])(this, SliderLabelDirective);\n\n      _this2 = ng5_slider_callSuper(this, SliderLabelDirective, [elemRef, renderer, changeDetectionRef]);\n      _this2._value = null;\n      return _this2;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    Object(inherits[\"a\" /* default */])(SliderLabelDirective, _SliderElementDirecti2);\n\n    return Object(createClass[\"a\" /* default */])(SliderLabelDirective, [{\n      key: \"value\",\n      get: function get() {\n        return this._value;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"setValue\",\n      value: function setValue(value) {\n        var\n        /** @type {?} */\n        recalculateDimension = false;\n\n        if (!this.alwaysHide && (ng5_slider_ValueHelper.isNullOrUndefined(this.value) || this.value.length !== value.length || this.value.length > 0 && this.dimension === 0)) {\n          recalculateDimension = true;\n        }\n\n        this._value = value;\n        this.elemRef.nativeElement.innerHTML = value; // Update dimension only when length of the label have changed\n\n        if (recalculateDimension) {\n          this.calculateDimension();\n        }\n      }\n    }]);\n  }(ng5_slider_SliderElementDirective);\n\n  SliderLabelDirective.fac = function SliderLabelDirective_Factory(t) {\n    return new (t || SliderLabelDirective)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"E\" /* Renderer2 */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]));\n  };\n\n  SliderLabelDirective.dir = core[\"Hb\" /* defineDirective */]({\n    type: SliderLabelDirective,\n    selectors: [[\"\", \"ng5SliderLabel\", \"\"]],\n    features: [core[\"xb\" /* InheritDefinitionFeature */]]\n  });\n  return SliderLabelDirective;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar ng5_slider_Tick = /*#__PURE__*/Object(createClass[\"a\" /* default */])(function Tick() {\n  Object(classCallCheck[\"a\" /* default */])(this, Tick);\n\n  this.selected = false;\n  this.style = {};\n  this.tooltip = null;\n  this.tooltipPlacement = null;\n  this.value = null;\n  this.valueTooltip = null;\n  this.valueTooltipPlacement = null;\n  this.legend = null;\n});\n\nvar ng5_slider_Dragging = /*#__PURE__*/Object(createClass[\"a\" /* default */])(function Dragging() {\n  Object(classCallCheck[\"a\" /* default */])(this, Dragging);\n\n  this.active = false;\n  this.value = 0;\n  this.difference = 0;\n  this.position = 0;\n  this.lowLimit = 0;\n  this.highLimit = 0;\n});\n\nvar ng5_slider_ModelValues = /*#__PURE__*/function () {\n  function ModelValues() {\n    Object(classCallCheck[\"a\" /* default */])(this, ModelValues);\n  }\n\n  return Object(createClass[\"a\" /* default */])(ModelValues, null, [{\n    key: \"compare\",\n    value:\n    /**\n     * @param {?=} x\n     * @param {?=} y\n     * @return {?}\n     */\n    function compare(x, y) {\n      if (ng5_slider_ValueHelper.isNullOrUndefined(x) && ng5_slider_ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      if (ng5_slider_ValueHelper.isNullOrUndefined(x) !== ng5_slider_ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      return x.value === y.value && x.highValue === y.highValue;\n    }\n  }]);\n}();\n\nvar ng5_slider_ModelChange = /*#__PURE__*/function (_ModelValues) {\n  function ModelChange() {\n    Object(classCallCheck[\"a\" /* default */])(this, ModelChange);\n\n    return ng5_slider_callSuper(this, ModelChange, arguments);\n  }\n\n  Object(inherits[\"a\" /* default */])(ModelChange, _ModelValues);\n\n  return Object(createClass[\"a\" /* default */])(ModelChange, null, [{\n    key: \"compare\",\n    value:\n    /**\n     * @param {?=} x\n     * @param {?=} y\n     * @return {?}\n     */\n    function compare(x, y) {\n      if (ng5_slider_ValueHelper.isNullOrUndefined(x) && ng5_slider_ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      if (ng5_slider_ValueHelper.isNullOrUndefined(x) !== ng5_slider_ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      return x.value === y.value && x.highValue === y.highValue && x.forceChange === y.forceChange;\n    }\n  }]);\n}(ng5_slider_ModelValues);\n\nvar NG5_SLIDER_CONTROL_VALUE_ACCESSOR = {\n  provide: fesm2015_forms[\"h\" /* NG_VALUE_ACCESSOR */],\n\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: Object(core[\"T\" /* forwardRef */])(function () {\n    return ng5_slider_SliderComponent;\n  }),\n  multi: true\n};\n\nvar ng5_slider_SliderComponent = /*@__PURE__*/function () {\n  var SliderComponent = /*#__PURE__*/function () {\n    /**\n     * @param {?} renderer\n     * @param {?} elementRef\n     * @param {?} changeDetectionRef\n     * @param {?} zone\n     */\n    function SliderComponent(renderer, elementRef, changeDetectionRef, zone) {\n      Object(classCallCheck[\"a\" /* default */])(this, SliderComponent);\n\n      this.renderer = renderer;\n      this.elementRef = elementRef;\n      this.changeDetectionRef = changeDetectionRef;\n      this.zone = zone; // Model for low value of slider. For simple slider, this is the only input. For range slider, this is the low value.\n\n      this.value = null; // Output for low value slider to support two-way bindings\n\n      this.valueChange = new core[\"n\" /* EventEmitter */](); // Model for high value of slider. Not used in simple slider. For range slider, this is the high value.\n\n      this.highValue = null; // Output for high value slider to support two-way bindings\n\n      this.highValueChange = new core[\"n\" /* EventEmitter */](); // An object with all the other options of the slider.\n      // Each option can be updated at runtime and the slider will automatically be re-rendered.\n\n      this.options = new ng5_slider_Options(); // Event emitted when user starts interaction with the slider\n\n      this.userChangeStart = new core[\"n\" /* EventEmitter */](); // Event emitted on each change coming from user interaction\n\n      this.userChange = new core[\"n\" /* EventEmitter */](); // Event emitted when user finishes interaction with the slider\n\n      this.userChangeEnd = new core[\"n\" /* EventEmitter */]();\n      this.initHasRun = false;\n      this.inputModelChangeSubject = new Rx[\"Subject\"]();\n      this.inputModelChangeSubscription = null;\n      this.outputModelChangeSubject = new Rx[\"Subject\"]();\n      this.outputModelChangeSubscription = null;\n      this.viewLowValue = null;\n      this.viewHighValue = null;\n      this.viewOptions = new ng5_slider_Options();\n      this.handleHalfDimension = 0;\n      this.maxHandlePosition = 0;\n      this.currentTrackingPointer = null;\n      this.currentFocusPointer = null;\n      this.firstKeyDown = false;\n      this.touchId = null;\n      this.dragging = new ng5_slider_Dragging(); // Host element class bindings\n\n      this.sliderElementVerticalClass = false;\n      this.sliderElementAnimateClass = false;\n      this.sliderElementDisabledAttr = null;\n      this.barStyle = {};\n      this.minPointerStyle = {};\n      this.maxPointerStyle = {};\n      this.fullBarTransparentClass = false;\n      this.selectionBarDraggableClass = false;\n      this.ticksUnderValuesClass = false;\n      this.intermediateTicks = false;\n      this.ticks = [];\n      this.eventListenerHelper = null;\n      this.onMoveEventListener = null;\n      this.onEndEventListener = null;\n      this.resizeObserver = null;\n      this.onTouchedCallback = null;\n      this.onChangeCallback = null;\n      this.eventListenerHelper = new ng5_slider_EventListenerHelper(this.renderer);\n    }\n    /**\n     * @param {?} manualRefresh\n     * @return {?}\n     */\n\n\n    return Object(createClass[\"a\" /* default */])(SliderComponent, [{\n      key: \"manualRefresh\",\n      set: function set(manualRefresh) {\n        var _this3 = this;\n\n        this.unsubscribeManualRefresh();\n        this.manualRefreshSubscription = manualRefresh.subscribe(function () {\n          setTimeout(function () {\n            return _this3.calculateViewDimensionsAndDetectChanges();\n          });\n        });\n      }\n      /**\n       * @param {?} triggerFocus\n       * @return {?}\n       */\n\n    }, {\n      key: \"triggerFocus\",\n      set: function set(triggerFocus) {\n        var _this4 = this;\n\n        this.unsubscribeTriggerFocus();\n        this.triggerFocusSubscription = triggerFocus.subscribe(function (pointerType) {\n          _this4.focusPointer(pointerType);\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"range\",\n      get: function get() {\n        return !ng5_slider_ValueHelper.isNullOrUndefined(this.value) && !ng5_slider_ValueHelper.isNullOrUndefined(this.highValue);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"showTicks\",\n      get: function get() {\n        return this.viewOptions.showTicks;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.viewOptions = new ng5_slider_Options();\n        Object.assign(this.viewOptions, this.options); // We need to run these two things first, before the rest of the init in ngAfterViewInit(),\n        // because these two settings are set through @HostBinding and Angular change detection\n        // mechanism doesn't like them changing in ngAfterViewInit()\n\n        this.updateDisabledState();\n        this.updateVerticalState();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        this.applyOptions();\n        this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n        this.subscribeOutputModelChangeSubject(this.viewOptions.outputEventsInterval); // Once we apply options, we need to normalise model values for the first time\n\n        this.renormaliseModelValues();\n        this.viewLowValue = this.modelValueToViewValue(this.value);\n\n        if (this.range) {\n          this.viewHighValue = this.modelValueToViewValue(this.highValue);\n        } else {\n          this.viewHighValue = null;\n        }\n\n        this.updateVerticalState(); // need to run this again to cover changes to slider elements\n\n        this.manageElementsStyle();\n        this.updateDisabledState();\n        this.calculateViewDimensions();\n        this.addAccessibility();\n        this.updateCeilLabel();\n        this.updateFloorLabel();\n        this.initHandles();\n        this.manageEventsBindings();\n        this.subscribeResizeObserver();\n        this.initHasRun = true; // Run change detection manually to resolve some issues when init procedure changes values used in the view\n\n        if (!this.isRefDestroyed()) {\n          this.changeDetectionRef.detectChanges();\n        }\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        // Always apply options first\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(changes[\"options\"])) {\n          this.onChangeOptions();\n        } // Then value changes\n\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(changes[\"value\"]) || !ng5_slider_ValueHelper.isNullOrUndefined(changes[\"highValue\"])) {\n          this.inputModelChangeSubject.next({\n            value: this.value,\n            highValue: this.highValue,\n            forceChange: false,\n            internalChange: false\n          });\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.unbindEvents();\n        this.unsubscribeResizeObserver();\n        this.unsubscribeInputModelChangeSubject();\n        this.unsubscribeOutputModelChangeSubject();\n        this.unsubscribeManualRefresh();\n        this.unsubscribeTriggerFocus();\n      }\n      /**\n       * @param {?} obj\n       * @return {?}\n       */\n\n    }, {\n      key: \"writeValue\",\n      value: function writeValue(obj) {\n        if (obj instanceof Array) {\n          this.value = obj[0];\n          this.highValue = obj[1];\n        } else {\n          this.value = obj;\n        } // ngOnChanges() is not called in this instance, so we need to communicate the change manually\n\n\n        this.inputModelChangeSubject.next({\n          value: this.value,\n          highValue: this.highValue,\n          forceChange: false,\n          internalChange: false\n        });\n      }\n      /**\n       * @param {?} onChangeCallback\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnChange\",\n      value: function registerOnChange(onChangeCallback) {\n        this.onChangeCallback = onChangeCallback;\n      }\n      /**\n       * @param {?} onTouchedCallback\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnTouched\",\n      value: function registerOnTouched(onTouchedCallback) {\n        this.onTouchedCallback = onTouchedCallback;\n      }\n      /**\n       * @param {?} isDisabled\n       * @return {?}\n       */\n\n    }, {\n      key: \"setDisabledState\",\n      value: function setDisabledState(isDisabled) {\n        this.viewOptions.disabled = isDisabled;\n        this.updateDisabledState();\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onResize\",\n      value: function onResize(event) {\n        this.calculateViewDimensionsAndDetectChanges();\n      }\n      /**\n       * @param {?=} interval\n       * @return {?}\n       */\n\n    }, {\n      key: \"subscribeInputModelChangeSubject\",\n      value: function subscribeInputModelChangeSubject(interval) {\n        var _this5 = this;\n\n        this.inputModelChangeSubscription = this.inputModelChangeSubject.pipe(Object(operators[\"distinctUntilChanged\"])(ng5_slider_ModelChange.compare), // Hack to reset the status of the distinctUntilChanged() - if a \"fake\" event comes through with forceChange=true,\n        // we forcefully by-pass distinctUntilChanged(), but otherwise drop the event\n        Object(operators[\"filter\"])(function (modelChange) {\n          return !modelChange.forceChange && !modelChange.internalChange;\n        }), !ng5_slider_ValueHelper.isNullOrUndefined(interval) ? Object(operators[\"throttleTime\"])(interval, undefined, {\n          leading: true,\n          trailing: true\n        }) : Object(operators[\"tap\"])(function () {}) // no-op\n        ).subscribe(function (modelChange) {\n          return _this5.applyInputModelChange(modelChange);\n        });\n      }\n      /**\n       * @param {?=} interval\n       * @return {?}\n       */\n\n    }, {\n      key: \"subscribeOutputModelChangeSubject\",\n      value: function subscribeOutputModelChangeSubject(interval) {\n        var _this6 = this;\n\n        this.outputModelChangeSubscription = this.outputModelChangeSubject.pipe(Object(operators[\"distinctUntilChanged\"])(ng5_slider_ModelChange.compare), !ng5_slider_ValueHelper.isNullOrUndefined(interval) ? Object(operators[\"throttleTime\"])(interval, undefined, {\n          leading: true,\n          trailing: true\n        }) : Object(operators[\"tap\"])(function () {}) // no-op\n        ).subscribe(function (modelChange) {\n          return _this6.publishOutputModelChange(modelChange);\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"subscribeResizeObserver\",\n      value: function subscribeResizeObserver() {\n        var _this7 = this;\n\n        if (ng5_slider_CompatibilityHelper.isResizeObserverAvailable()) {\n          this.resizeObserver = new ResizeObserver(function () {\n            return _this7.calculateViewDimensionsAndDetectChanges();\n          });\n          this.resizeObserver.observe(this.elementRef.nativeElement);\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeResizeObserver\",\n      value: function unsubscribeResizeObserver() {\n        if (ng5_slider_CompatibilityHelper.isResizeObserverAvailable() && this.resizeObserver !== null) {\n          this.resizeObserver.disconnect();\n          this.resizeObserver = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeOnMove\",\n      value: function unsubscribeOnMove() {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.onMoveEventListener)) {\n          this.eventListenerHelper.detachEventListener(this.onMoveEventListener);\n          this.onMoveEventListener = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeOnEnd\",\n      value: function unsubscribeOnEnd() {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.onEndEventListener)) {\n          this.eventListenerHelper.detachEventListener(this.onEndEventListener);\n          this.onEndEventListener = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeInputModelChangeSubject\",\n      value: function unsubscribeInputModelChangeSubject() {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.inputModelChangeSubscription)) {\n          this.inputModelChangeSubscription.unsubscribe();\n          this.inputModelChangeSubscription = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeOutputModelChangeSubject\",\n      value: function unsubscribeOutputModelChangeSubject() {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.outputModelChangeSubscription)) {\n          this.outputModelChangeSubscription.unsubscribe();\n          this.outputModelChangeSubscription = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeManualRefresh\",\n      value: function unsubscribeManualRefresh() {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.manualRefreshSubscription)) {\n          this.manualRefreshSubscription.unsubscribe();\n          this.manualRefreshSubscription = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeTriggerFocus\",\n      value: function unsubscribeTriggerFocus() {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.triggerFocusSubscription)) {\n          this.triggerFocusSubscription.unsubscribe();\n          this.triggerFocusSubscription = null;\n        }\n      }\n      /**\n       * @param {?} pointerType\n       * @return {?}\n       */\n\n    }, {\n      key: \"getPointerElement\",\n      value: function getPointerElement(pointerType) {\n        if (pointerType === PointerType.Min) {\n          return this.minHandleElement;\n        } else if (pointerType === PointerType.Max) {\n          return this.maxHandleElement;\n        }\n\n        return null;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getCurrentTrackingValue\",\n      value: function getCurrentTrackingValue() {\n        if (this.currentTrackingPointer === PointerType.Min) {\n          return this.viewLowValue;\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          return this.viewHighValue;\n        }\n\n        return null;\n      }\n      /**\n       * @param {?} modelValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"modelValueToViewValue\",\n      value: function modelValueToViewValue(modelValue) {\n        if (ng5_slider_ValueHelper.isNullOrUndefined(modelValue)) {\n          return NaN;\n        }\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n          return ng5_slider_ValueHelper.findStepIndex(+modelValue, this.viewOptions.stepsArray);\n        }\n\n        return +modelValue;\n      }\n      /**\n       * @param {?} viewValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"viewValueToModelValue\",\n      value: function viewValueToModelValue(viewValue) {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n          return this.getStepValue(viewValue);\n        }\n\n        return viewValue;\n      }\n      /**\n       * @param {?} sliderValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"getStepValue\",\n      value: function getStepValue(sliderValue) {\n        var\n        /** @type {?} */\n        step = this.viewOptions.stepsArray[sliderValue];\n        return !ng5_slider_ValueHelper.isNullOrUndefined(step) ? step.value : NaN;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyViewChange\",\n      value: function applyViewChange() {\n        this.value = this.viewValueToModelValue(this.viewLowValue);\n\n        if (this.range) {\n          this.highValue = this.viewValueToModelValue(this.viewHighValue);\n        }\n\n        this.outputModelChangeSubject.next({\n          value: this.value,\n          highValue: this.highValue,\n          userEventInitiated: true,\n          forceChange: false\n        }); // At this point all changes are applied and outputs are emitted, so we should be done.\n        // However, input changes are communicated in different stream and we need to be ready to\n        // act on the next input change even if it is exactly the same as last input change.\n        // Therefore, we send a special event to reset the stream.\n\n        this.inputModelChangeSubject.next({\n          value: this.value,\n          highValue: this.highValue,\n          forceChange: false,\n          internalChange: true\n        });\n      }\n      /**\n       * @param {?} modelChange\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyInputModelChange\",\n      value: function applyInputModelChange(modelChange) {\n        var\n        /** @type {?} */\n        normalisedModelChange = this.normaliseModelValues(modelChange); // If normalised model change is different, apply the change to the model values\n\n        var\n        /** @type {?} */\n        normalisationChange = !ng5_slider_ModelValues.compare(modelChange, normalisedModelChange);\n\n        if (normalisationChange) {\n          this.value = normalisedModelChange.value;\n          this.highValue = normalisedModelChange.highValue;\n        }\n\n        this.viewLowValue = this.modelValueToViewValue(normalisedModelChange.value);\n\n        if (this.range) {\n          this.viewHighValue = this.modelValueToViewValue(normalisedModelChange.highValue);\n        } else {\n          this.viewHighValue = null;\n        }\n\n        this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n\n        if (this.range) {\n          this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n        }\n\n        this.updateSelectionBar();\n        this.updateTicksScale();\n        this.updateAriaAttributes();\n\n        if (this.range) {\n          this.updateCombinedLabel();\n        } // At the end, we need to communicate the model change to the outputs as well\n        // Normalisation changes are also always forced out to ensure that subscribers always end up in correct state\n\n\n        this.outputModelChangeSubject.next({\n          value: normalisedModelChange.value,\n          highValue: normalisedModelChange.highValue,\n          forceChange: normalisationChange,\n          userEventInitiated: false\n        });\n      }\n      /**\n       * @param {?} modelChange\n       * @return {?}\n       */\n\n    }, {\n      key: \"publishOutputModelChange\",\n      value: function publishOutputModelChange(modelChange) {\n        var _this8 = this;\n\n        var\n        /** @type {?} */\n        emitOutputs = function emitOutputs() {\n          _this8.valueChange.emit(modelChange.value);\n\n          if (_this8.range) {\n            _this8.highValueChange.emit(modelChange.highValue);\n          }\n\n          if (!ng5_slider_ValueHelper.isNullOrUndefined(_this8.onChangeCallback)) {\n            if (_this8.range) {\n              _this8.onChangeCallback([modelChange.value, modelChange.highValue]);\n            } else {\n              _this8.onChangeCallback(modelChange.value);\n            }\n          }\n\n          if (!ng5_slider_ValueHelper.isNullOrUndefined(_this8.onTouchedCallback)) {\n            if (_this8.range) {\n              _this8.onTouchedCallback([modelChange.value, modelChange.highValue]);\n            } else {\n              _this8.onTouchedCallback(modelChange.value);\n            }\n          }\n        };\n\n        if (modelChange.userEventInitiated) {\n          // If this change was initiated by a user event, we can emit outputs in the same tick\n          emitOutputs();\n          this.userChange.emit(this.getChangeContext());\n        } else {\n          // But, if the change was initated by something else like a change in input bindings,\n          // we need to wait until next tick to emit the outputs to keep Angular change detection happy\n          setTimeout(function () {\n            emitOutputs();\n          });\n        }\n      }\n      /**\n       * @param {?} input\n       * @return {?}\n       */\n\n    }, {\n      key: \"normaliseModelValues\",\n      value: function normaliseModelValues(input) {\n        var\n        /** @type {?} */\n        normalisedInput = new ng5_slider_ModelValues();\n        normalisedInput.value = input.value;\n        normalisedInput.highValue = input.highValue;\n\n        if (this.viewOptions.enforceStep) {\n          normalisedInput.value = this.roundStep(normalisedInput.value);\n\n          if (this.range) {\n            normalisedInput.highValue = this.roundStep(normalisedInput.highValue);\n          }\n        } // Don't attempt to normalise further when using steps array (steps may be out of order and that is perfectly fine)\n\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) || !this.viewOptions.enforceRange) {\n          return normalisedInput;\n        }\n\n        normalisedInput.value = ng5_slider_MathHelper.clampToRange(normalisedInput.value, this.viewOptions.floor, this.viewOptions.ceil);\n\n        if (this.range) {\n          normalisedInput.highValue = ng5_slider_MathHelper.clampToRange(normalisedInput.highValue, this.viewOptions.floor, this.viewOptions.ceil);\n        } // Make sure that range slider invariant (value <= highValue) is always satisfied\n\n\n        if (this.range && input.value > input.highValue) {\n          // We know that both values are now clamped correctly, they may just be in the wrong order\n          // So the easy solution is to swap them... except swapping is sometimes disabled in options, so we make the two values the same\n          if (this.viewOptions.noSwitching) {\n            normalisedInput.value = normalisedInput.highValue;\n          } else {\n            var\n            /** @type {?} */\n            tempValue = input.value;\n            normalisedInput.value = input.highValue;\n            normalisedInput.highValue = tempValue;\n          }\n        }\n\n        return normalisedInput;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"renormaliseModelValues\",\n      value: function renormaliseModelValues() {\n        var\n        /** @type {?} */\n        previousModelValues = {\n          value: this.value,\n          highValue: this.highValue\n        };\n        var\n        /** @type {?} */\n        normalisedModelValues = this.normaliseModelValues(previousModelValues);\n\n        if (!ng5_slider_ModelValues.compare(normalisedModelValues, previousModelValues)) {\n          this.value = normalisedModelValues.value;\n          this.highValue = normalisedModelValues.highValue;\n          this.outputModelChangeSubject.next({\n            value: this.value,\n            highValue: this.highValue,\n            forceChange: true,\n            userEventInitiated: false\n          });\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"onChangeOptions\",\n      value: function onChangeOptions() {\n        if (!this.initHasRun) {\n          return;\n        }\n\n        var\n        /** @type {?} */\n        previousInputEventsInterval = this.viewOptions.inputEventsInterval;\n        var\n        /** @type {?} */\n        previousOutputEventsInterval = this.viewOptions.outputEventsInterval;\n        this.applyOptions();\n\n        if (previousInputEventsInterval !== this.viewOptions.inputEventsInterval) {\n          this.unsubscribeInputModelChangeSubject();\n          this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n        }\n\n        if (previousOutputEventsInterval !== this.viewOptions.outputEventsInterval) {\n          this.unsubscribeInputModelChangeSubject();\n          this.subscribeInputModelChangeSubject(this.viewOptions.outputEventsInterval);\n        } // With new options, we need to re-normalise model values if necessary\n\n\n        this.renormaliseModelValues();\n        this.viewLowValue = this.modelValueToViewValue(this.value);\n\n        if (this.range) {\n          this.viewHighValue = this.modelValueToViewValue(this.highValue);\n        } else {\n          this.viewHighValue = null;\n        }\n\n        this.resetSlider();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyOptions\",\n      value: function applyOptions() {\n        this.viewOptions = new ng5_slider_Options();\n        Object.assign(this.viewOptions, this.options);\n        this.viewOptions.draggableRange = this.range && this.viewOptions.draggableRange;\n        this.viewOptions.draggableRangeOnly = this.range && this.viewOptions.draggableRangeOnly;\n\n        if (this.viewOptions.draggableRangeOnly) {\n          this.viewOptions.draggableRange = true;\n        }\n\n        this.viewOptions.showTicks = this.viewOptions.showTicks || this.viewOptions.showTicksValues || !ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray);\n\n        if (this.viewOptions.showTicks && (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) || !ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray))) {\n          this.intermediateTicks = true;\n        }\n\n        this.viewOptions.showSelectionBar = this.viewOptions.showSelectionBar || this.viewOptions.showSelectionBarEnd || !ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue);\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n          this.applyStepsArrayOptions();\n        } else {\n          this.applyFloorCeilOptions();\n        }\n\n        if (ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.combineLabels)) {\n          this.viewOptions.combineLabels = function (minValue, maxValue) {\n            return minValue + ' - ' + maxValue;\n          };\n        }\n\n        if (this.viewOptions.logScale && this.viewOptions.floor === 0) {\n          throw Error('Can\\'t use floor=0 with logarithmic scale');\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyStepsArrayOptions\",\n      value: function applyStepsArrayOptions() {\n        var _this9 = this;\n\n        this.viewOptions.floor = 0;\n        this.viewOptions.ceil = this.viewOptions.stepsArray.length - 1;\n        this.viewOptions.step = 1;\n\n        if (ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n          this.viewOptions.translate = function (modelValue) {\n            if (_this9.viewOptions.bindIndexForStepsArray) {\n              return String(_this9.getStepValue(modelValue));\n            }\n\n            return String(modelValue);\n          };\n        }\n\n        this.viewOptions.getLegend = function (index) {\n          var\n          /** @type {?} */\n          step = _this9.viewOptions.stepsArray[index];\n          return step.legend;\n        };\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyFloorCeilOptions\",\n      value: function applyFloorCeilOptions() {\n        if (ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.step)) {\n          this.viewOptions.step = 1;\n        } else {\n          this.viewOptions.step = +this.viewOptions.step;\n\n          if (this.viewOptions.step <= 0) {\n            this.viewOptions.step = 1;\n          }\n        }\n\n        if (ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.ceil) || ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.floor)) {\n          throw Error('floor and ceil options must be supplied');\n        }\n\n        this.viewOptions.ceil = +this.viewOptions.ceil;\n        this.viewOptions.floor = +this.viewOptions.floor;\n\n        if (ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n          this.viewOptions.translate = function (value) {\n            return String(value);\n          };\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"resetSlider\",\n      value: function resetSlider() {\n        this.manageElementsStyle();\n        this.addAccessibility();\n        this.updateCeilLabel();\n        this.updateFloorLabel();\n        this.unbindEvents();\n        this.manageEventsBindings();\n        this.updateDisabledState();\n        this.calculateViewDimensions();\n        this.refocusPointerIfNeeded();\n      }\n      /**\n       * @param {?} pointerType\n       * @return {?}\n       */\n\n    }, {\n      key: \"focusPointer\",\n      value: function focusPointer(pointerType) {\n        // If not supplied, use min pointer as default\n        if (pointerType !== PointerType.Min && pointerType !== PointerType.Max) {\n          pointerType = PointerType.Min;\n        }\n\n        if (pointerType === PointerType.Min) {\n          this.minHandleElement.focus();\n        } else if (this.range && pointerType === PointerType.Max) {\n          this.maxHandleElement.focus();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"refocusPointerIfNeeded\",\n      value: function refocusPointerIfNeeded() {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.currentFocusPointer)) {\n          this.onPointerFocus(this.currentFocusPointer);\n          var\n          /** @type {?} */\n          element = this.getPointerElement(this.currentFocusPointer);\n          element.focus();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"manageElementsStyle\",\n      value: function manageElementsStyle() {\n        var _this10 = this;\n\n        this.updateScale();\n        this.floorLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n        this.ceilLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n        var\n        /** @type {?} */\n        hideLabelsForTicks = this.viewOptions.showTicksValues && !this.intermediateTicks;\n        this.minHandleLabelElement.setAlwaysHide(hideLabelsForTicks || this.viewOptions.hidePointerLabels);\n        this.maxHandleLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n        this.combinedLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n        this.selectionBarElement.setAlwaysHide(!this.range && !this.viewOptions.showSelectionBar);\n        this.leftOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n        this.rightOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n        this.fullBarTransparentClass = this.range && this.viewOptions.showOuterSelectionBars;\n        this.selectionBarDraggableClass = this.viewOptions.draggableRange && !this.viewOptions.onlyBindHandles;\n        this.ticksUnderValuesClass = this.intermediateTicks && this.options.showTicksValues;\n\n        if (this.sliderElementVerticalClass !== this.viewOptions.vertical) {\n          this.updateVerticalState(); // The above change in host component class will not be applied until the end of this cycle\n          // However, functions calculating the slider position expect the slider to be already styled as vertical\n          // So as a workaround, we need to reset the slider once again to compute the correct values\n\n          setTimeout(function () {\n            _this10.resetSlider();\n          });\n        } // Changing animate class may interfere with slider reset/initialisation, so we should set it separately,\n        // after all is properly set up\n\n\n        if (this.sliderElementAnimateClass !== this.viewOptions.animate) {\n          setTimeout(function () {\n            _this10.sliderElementAnimateClass = _this10.viewOptions.animate;\n          });\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"manageEventsBindings\",\n      value: function manageEventsBindings() {\n        if (this.viewOptions.disabled || this.viewOptions.readOnly) {\n          this.unbindEvents();\n        } else {\n          this.bindEvents();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateDisabledState\",\n      value: function updateDisabledState() {\n        this.sliderElementDisabledAttr = this.viewOptions.disabled ? 'disabled' : null;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateVerticalState\",\n      value: function updateVerticalState() {\n        this.sliderElementVerticalClass = this.viewOptions.vertical;\n\n        var _iterator2 = Object(createForOfIteratorHelper[\"a\" /* default */])(this.getAllSliderElements()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var element = _step2.value;\n\n            // This is also called before ngAfterInit, so need to check that view child bindings work\n            if (!ng5_slider_ValueHelper.isNullOrUndefined(element)) {\n              element.setVertical(this.viewOptions.vertical);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateScale\",\n      value: function updateScale() {\n        var _iterator3 = Object(createForOfIteratorHelper[\"a\" /* default */])(this.getAllSliderElements()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var element = _step3.value;\n            element.setScale(this.viewOptions.scale);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getAllSliderElements\",\n      value: function getAllSliderElements() {\n        return [this.leftOuterSelectionBarElement, this.rightOuterSelectionBarElement, this.fullBarElement, this.selectionBarElement, this.minHandleElement, this.maxHandleElement, this.floorLabelElement, this.ceilLabelElement, this.minHandleLabelElement, this.maxHandleLabelElement, this.combinedLabelElement, this.ticksElement];\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"initHandles\",\n      value: function initHandles() {\n        this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n        /*\n           the order here is important since the selection bar should be\n           updated after the high handle but before the combined label\n           */\n\n        if (this.range) {\n          this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n        }\n\n        this.updateSelectionBar();\n\n        if (this.range) {\n          this.updateCombinedLabel();\n        }\n\n        this.updateTicksScale();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"addAccessibility\",\n      value: function addAccessibility() {\n        this.updateAriaAttributes();\n        this.minHandleElement.role = 'slider';\n\n        if (this.viewOptions.keyboardSupport && !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n          this.minHandleElement.tabindex = '0';\n        } else {\n          this.minHandleElement.tabindex = '';\n        }\n\n        if (this.viewOptions.vertical) {\n          this.minHandleElement.ariaOrientation = 'vertical';\n        }\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabel)) {\n          this.minHandleElement.ariaLabel = this.viewOptions.ariaLabel;\n        } else if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledBy)) {\n          this.minHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledBy;\n        }\n\n        if (this.range) {\n          this.maxHandleElement.role = 'slider';\n\n          if (this.viewOptions.keyboardSupport && !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n            this.maxHandleElement.tabindex = '0';\n          } else {\n            this.maxHandleElement.tabindex = '';\n          }\n\n          this.maxHandleElement.ariaOrientation = this.viewOptions.vertical ? 'vertical' : 'horizontal';\n\n          if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelHigh)) {\n            this.maxHandleElement.ariaLabel = this.viewOptions.ariaLabelHigh;\n          } else if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledByHigh)) {\n            this.maxHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledByHigh;\n          }\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateAriaAttributes\",\n      value: function updateAriaAttributes() {\n        this.minHandleElement.ariaValueNow = (+this.value).toString();\n        this.minHandleElement.ariaValueText = this.viewOptions.translate(+this.value, LabelType.Low);\n        this.minHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n        this.minHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n\n        if (this.range) {\n          this.maxHandleElement.ariaValueNow = (+this.highValue).toString();\n          this.maxHandleElement.ariaValueText = this.viewOptions.translate(+this.highValue, LabelType.High);\n          this.maxHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n          this.maxHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"calculateViewDimensions\",\n      value: function calculateViewDimensions() {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.handleDimension)) {\n          this.minHandleElement.setDimension(this.viewOptions.handleDimension);\n        } else {\n          this.minHandleElement.calculateDimension();\n        }\n\n        var\n        /** @type {?} */\n        handleWidth = this.minHandleElement.dimension;\n        this.handleHalfDimension = handleWidth / 2;\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.barDimension)) {\n          this.fullBarElement.setDimension(this.viewOptions.barDimension);\n        } else {\n          this.fullBarElement.calculateDimension();\n        }\n\n        this.maxHandlePosition = this.fullBarElement.dimension - handleWidth;\n\n        if (this.initHasRun) {\n          this.updateFloorLabel();\n          this.updateCeilLabel();\n          this.initHandles();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"calculateViewDimensionsAndDetectChanges\",\n      value: function calculateViewDimensionsAndDetectChanges() {\n        this.calculateViewDimensions();\n\n        if (!this.isRefDestroyed()) {\n          this.changeDetectionRef.detectChanges();\n        }\n      }\n      /**\n       * If the slider reference is already destroyed\n       * @return {?} boolean - true if ref is destroyed\n       */\n\n    }, {\n      key: \"isRefDestroyed\",\n      value: function isRefDestroyed() {\n        return this.changeDetectionRef['destroyed'];\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateTicksScale\",\n      value: function updateTicksScale() {\n        var _this11 = this;\n\n        if (!this.viewOptions.showTicks) {\n          return;\n        }\n\n        var\n        /** @type {?} */\n        ticksArray = !ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray) ? this.viewOptions.ticksArray : this.getTicksArray();\n        var\n        /** @type {?} */\n        translate = this.viewOptions.vertical ? 'translateY' : 'translateX';\n\n        if (this.viewOptions.rightToLeft) {\n          ticksArray.reverse();\n        }\n\n        var\n        /** @type {?} */\n        newTicks = ticksArray.map(function (value) {\n          var\n          /** @type {?} */\n          position = _this11.valueToPosition(value);\n\n          if (_this11.viewOptions.vertical) {\n            position = _this11.maxHandlePosition - position;\n          }\n\n          var\n          /** @type {?} */\n          translation = translate + '(' + Math.round(position) + 'px)';\n          var\n          /** @type {?} */\n          tick = new ng5_slider_Tick();\n          tick.selected = _this11.isTickSelected(value);\n          tick.style = {\n            '-webkit-transform': translation,\n            '-moz-transform': translation,\n            '-o-transform': translation,\n            '-ms-transform': translation,\n            transform: translation\n          };\n\n          if (tick.selected && !ng5_slider_ValueHelper.isNullOrUndefined(_this11.viewOptions.getSelectionBarColor)) {\n            tick.style['background-color'] = _this11.getSelectionBarColor();\n          }\n\n          if (!tick.selected && !ng5_slider_ValueHelper.isNullOrUndefined(_this11.viewOptions.getTickColor)) {\n            tick.style['background-color'] = _this11.getTickColor(value);\n          }\n\n          if (!ng5_slider_ValueHelper.isNullOrUndefined(_this11.viewOptions.ticksTooltip)) {\n            tick.tooltip = _this11.viewOptions.ticksTooltip(value);\n            tick.tooltipPlacement = _this11.viewOptions.vertical ? 'right' : 'top';\n          }\n\n          if (_this11.viewOptions.showTicksValues && value % _this11.viewOptions.tickValueStep === 0) {\n            tick.value = _this11.getDisplayValue(value, LabelType.TickValue);\n\n            if (!ng5_slider_ValueHelper.isNullOrUndefined(_this11.viewOptions.ticksValuesTooltip)) {\n              tick.valueTooltip = _this11.viewOptions.ticksValuesTooltip(value);\n              tick.valueTooltipPlacement = _this11.viewOptions.vertical ? 'right' : 'top';\n            }\n          }\n\n          if (!ng5_slider_ValueHelper.isNullOrUndefined(_this11.viewOptions.getLegend)) {\n            var\n            /** @type {?} */\n            legend = _this11.viewOptions.getLegend(value);\n\n            if (!ng5_slider_ValueHelper.isNullOrUndefined(legend)) {\n              tick.legend = legend;\n            }\n          }\n\n          return tick;\n        }); // We should avoid re-creating the ticks array if possible\n        // This both improves performance and makes CSS animations work correctly\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.ticks) && this.ticks.length === newTicks.length) {\n          for (var\n          /** @type {?} */\n          i = 0; i < newTicks.length; ++i) {\n            Object.assign(this.ticks[i], newTicks[i]);\n          }\n        } else {\n          this.ticks = newTicks;\n        }\n\n        if (!this.isRefDestroyed()) {\n          this.changeDetectionRef.detectChanges();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getTicksArray\",\n      value: function getTicksArray() {\n        var\n        /** @type {?} */\n        step = !ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) ? this.viewOptions.tickStep : this.viewOptions.step;\n        var\n        /** @type {?} */\n        ticksArray = [];\n\n        for (var\n        /** @type {?} */\n        value = this.viewOptions.floor; value <= this.viewOptions.ceil; value += step) {\n          ticksArray.push(value);\n        }\n\n        return ticksArray;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"isTickSelected\",\n      value: function isTickSelected(value) {\n        if (!this.range) {\n          if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n            var\n            /** @type {?} */\n            center = this.viewOptions.showSelectionBarFromValue;\n\n            if (this.viewLowValue > center && value >= center && value <= this.viewLowValue) {\n              return true;\n            } else if (this.viewLowValue < center && value <= center && value >= this.viewLowValue) {\n              return true;\n            }\n          } else if (this.viewOptions.showSelectionBarEnd) {\n            if (value >= this.viewLowValue) {\n              return true;\n            }\n          } else if (this.viewOptions.showSelectionBar && value <= this.viewLowValue) {\n            return true;\n          }\n        }\n\n        if (this.range && value >= this.viewLowValue && value <= this.viewHighValue) {\n          return true;\n        }\n\n        return false;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateFloorLabel\",\n      value: function updateFloorLabel() {\n        if (!this.floorLabelElement.alwaysHide) {\n          this.floorLabelElement.setValue(this.getDisplayValue(this.viewOptions.floor, LabelType.Floor));\n          this.floorLabelElement.calculateDimension();\n          var\n          /** @type {?} */\n          position = this.viewOptions.rightToLeft ? this.fullBarElement.dimension - this.floorLabelElement.dimension : 0;\n          this.floorLabelElement.setPosition(position);\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateCeilLabel\",\n      value: function updateCeilLabel() {\n        if (!this.ceilLabelElement.alwaysHide) {\n          this.ceilLabelElement.setValue(this.getDisplayValue(this.viewOptions.ceil, LabelType.Ceil));\n          this.ceilLabelElement.calculateDimension();\n          var\n          /** @type {?} */\n          position = this.viewOptions.rightToLeft ? 0 : this.fullBarElement.dimension - this.ceilLabelElement.dimension;\n          this.ceilLabelElement.setPosition(position);\n        }\n      }\n      /**\n       * @param {?} which\n       * @param {?} newPos\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateHandles\",\n      value: function updateHandles(which, newPos) {\n        if (which === PointerType.Min) {\n          this.updateLowHandle(newPos);\n        } else if (which === PointerType.Max) {\n          this.updateHighHandle(newPos);\n        }\n\n        this.updateSelectionBar();\n        this.updateTicksScale();\n\n        if (this.range) {\n          this.updateCombinedLabel();\n        }\n      }\n      /**\n       * @param {?} labelType\n       * @param {?} newPos\n       * @return {?}\n       */\n\n    }, {\n      key: \"getHandleLabelPos\",\n      value: function getHandleLabelPos(labelType, newPos) {\n        var\n        /** @type {?} */\n        labelDimension = labelType === PointerType.Min ? this.minHandleLabelElement.dimension : this.maxHandleLabelElement.dimension;\n        var\n        /** @type {?} */\n        nearHandlePos = newPos - labelDimension / 2 + this.handleHalfDimension;\n        var\n        /** @type {?} */\n        endOfBarPos = this.fullBarElement.dimension - labelDimension;\n\n        if (!this.viewOptions.boundPointerLabels) {\n          return nearHandlePos;\n        }\n\n        if (this.viewOptions.rightToLeft && labelType === PointerType.Min || !this.viewOptions.rightToLeft && labelType === PointerType.Max) {\n          return Math.min(nearHandlePos, endOfBarPos);\n        } else {\n          return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);\n        }\n      }\n      /**\n       * @param {?} newPos\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateLowHandle\",\n      value: function updateLowHandle(newPos) {\n        this.minHandleElement.setPosition(newPos);\n        this.minHandleLabelElement.setValue(this.getDisplayValue(this.viewLowValue, LabelType.Low));\n        this.minHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Min, newPos));\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n          this.minPointerStyle = {\n            backgroundColor: this.getPointerColor(PointerType.Min)\n          };\n        }\n\n        if (this.viewOptions.autoHideLimitLabels) {\n          this.updateFloorAndCeilLabelsVisibility();\n        }\n      }\n      /**\n       * @param {?} newPos\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateHighHandle\",\n      value: function updateHighHandle(newPos) {\n        this.maxHandleElement.setPosition(newPos);\n        this.maxHandleLabelElement.setValue(this.getDisplayValue(this.viewHighValue, LabelType.High));\n        this.maxHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Max, newPos));\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n          this.maxPointerStyle = {\n            backgroundColor: this.getPointerColor(PointerType.Max)\n          };\n        }\n\n        if (this.viewOptions.autoHideLimitLabels) {\n          this.updateFloorAndCeilLabelsVisibility();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateFloorAndCeilLabelsVisibility\",\n      value: function updateFloorAndCeilLabelsVisibility() {\n        // Show based only on hideLimitLabels if pointer labels are hidden\n        if (this.viewOptions.hidePointerLabels) {\n          return;\n        }\n\n        var\n        /** @type {?} */\n        floorLabelHidden = false;\n        var\n        /** @type {?} */\n        ceilLabelHidden = false;\n        var\n        /** @type {?} */\n        isMinLabelAtFloor = this.isLabelBelowFloorLabel(this.minHandleLabelElement);\n        var\n        /** @type {?} */\n        isMinLabelAtCeil = this.isLabelAboveCeilLabel(this.minHandleLabelElement);\n        var\n        /** @type {?} */\n        isMaxLabelAtCeil = this.isLabelAboveCeilLabel(this.maxHandleLabelElement);\n        var\n        /** @type {?} */\n        isCombinedLabelAtFloor = this.isLabelBelowFloorLabel(this.combinedLabelElement);\n        var\n        /** @type {?} */\n        isCombinedLabelAtCeil = this.isLabelAboveCeilLabel(this.combinedLabelElement);\n\n        if (isMinLabelAtFloor) {\n          floorLabelHidden = true;\n          this.floorLabelElement.hide();\n        } else {\n          floorLabelHidden = false;\n          this.floorLabelElement.show();\n        }\n\n        if (isMinLabelAtCeil) {\n          ceilLabelHidden = true;\n          this.ceilLabelElement.hide();\n        } else {\n          ceilLabelHidden = false;\n          this.ceilLabelElement.show();\n        }\n\n        if (this.range) {\n          var\n          /** @type {?} */\n          hideCeil = this.combinedLabelElement.isVisible() ? isCombinedLabelAtCeil : isMaxLabelAtCeil;\n          var\n          /** @type {?} */\n          hideFloor = this.combinedLabelElement.isVisible() ? isCombinedLabelAtFloor : isMinLabelAtFloor;\n\n          if (hideCeil) {\n            this.ceilLabelElement.hide();\n          } else if (!ceilLabelHidden) {\n            this.ceilLabelElement.show();\n          } // Hide or show floor label\n\n\n          if (hideFloor) {\n            this.floorLabelElement.hide();\n          } else if (!floorLabelHidden) {\n            this.floorLabelElement.show();\n          }\n        }\n      }\n      /**\n       * @param {?} label\n       * @return {?}\n       */\n\n    }, {\n      key: \"isLabelBelowFloorLabel\",\n      value: function isLabelBelowFloorLabel(label) {\n        var\n        /** @type {?} */\n        pos = label.position;\n        var\n        /** @type {?} */\n        dim = label.dimension;\n        var\n        /** @type {?} */\n        floorPos = this.floorLabelElement.position;\n        var\n        /** @type {?} */\n        floorDim = this.floorLabelElement.dimension;\n        return this.viewOptions.rightToLeft ? pos + dim >= floorPos - 2 : pos <= floorPos + floorDim + 2;\n      }\n      /**\n       * @param {?} label\n       * @return {?}\n       */\n\n    }, {\n      key: \"isLabelAboveCeilLabel\",\n      value: function isLabelAboveCeilLabel(label) {\n        var\n        /** @type {?} */\n        pos = label.position;\n        var\n        /** @type {?} */\n        dim = label.dimension;\n        var\n        /** @type {?} */\n        ceilPos = this.ceilLabelElement.position;\n        var\n        /** @type {?} */\n        ceilDim = this.ceilLabelElement.dimension;\n        return this.viewOptions.rightToLeft ? pos <= ceilPos + ceilDim + 2 : pos + dim >= ceilPos - 2;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateSelectionBar\",\n      value: function updateSelectionBar() {\n        var\n        /** @type {?} */\n        position = 0;\n        var\n        /** @type {?} */\n        dimension = 0;\n        var\n        /** @type {?} */\n        isSelectionBarFromRight = this.viewOptions.rightToLeft ? !this.viewOptions.showSelectionBarEnd : this.viewOptions.showSelectionBarEnd;\n        var\n        /** @type {?} */\n        positionForRange = this.viewOptions.rightToLeft ? this.maxHandleElement.position + this.handleHalfDimension : this.minHandleElement.position + this.handleHalfDimension;\n\n        if (this.range) {\n          dimension = Math.abs(this.maxHandleElement.position - this.minHandleElement.position);\n          position = positionForRange;\n        } else {\n          if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n            var\n            /** @type {?} */\n            center = this.viewOptions.showSelectionBarFromValue;\n            var\n            /** @type {?} */\n            centerPosition = this.valueToPosition(center);\n            var\n            /** @type {?} */\n            isModelGreaterThanCenter = this.viewOptions.rightToLeft ? this.viewLowValue <= center : this.viewLowValue > center;\n\n            if (isModelGreaterThanCenter) {\n              dimension = this.minHandleElement.position - centerPosition;\n              position = centerPosition + this.handleHalfDimension;\n            } else {\n              dimension = centerPosition - this.minHandleElement.position;\n              position = this.minHandleElement.position + this.handleHalfDimension;\n            }\n          } else if (isSelectionBarFromRight) {\n            dimension = Math.ceil(Math.abs(this.maxHandlePosition - this.minHandleElement.position) + this.handleHalfDimension);\n            position = Math.floor(this.minHandleElement.position + this.handleHalfDimension);\n          } else {\n            dimension = this.minHandleElement.position + this.handleHalfDimension;\n            position = 0;\n          }\n        }\n\n        this.selectionBarElement.setDimension(dimension);\n        this.selectionBarElement.setPosition(position);\n\n        if (this.range && this.viewOptions.showOuterSelectionBars) {\n          if (this.viewOptions.rightToLeft) {\n            this.rightOuterSelectionBarElement.setDimension(position);\n            this.rightOuterSelectionBarElement.setPosition(0);\n            this.fullBarElement.calculateDimension();\n            this.leftOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n            this.leftOuterSelectionBarElement.setPosition(position + dimension);\n          } else {\n            this.leftOuterSelectionBarElement.setDimension(position);\n            this.leftOuterSelectionBarElement.setPosition(0);\n            this.fullBarElement.calculateDimension();\n            this.rightOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n            this.rightOuterSelectionBarElement.setPosition(position + dimension);\n          }\n        }\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n          var\n          /** @type {?} */\n          color = this.getSelectionBarColor();\n          this.barStyle = {\n            backgroundColor: color\n          };\n        } else if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.selectionBarGradient)) {\n          var\n          /** @type {?} */\n          offset = !ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue) ? this.valueToPosition(this.viewOptions.showSelectionBarFromValue) : 0;\n          var\n          /** @type {?} */\n          reversed = offset - position > 0 && !isSelectionBarFromRight || offset - position <= 0 && isSelectionBarFromRight;\n          var\n          /** @type {?} */\n          direction = this.viewOptions.vertical ? reversed ? 'bottom' : 'top' : reversed ? 'left' : 'right';\n          this.barStyle = {\n            backgroundImage: 'linear-gradient(to ' + direction + ', ' + this.viewOptions.selectionBarGradient.from + ' 0%,' + this.viewOptions.selectionBarGradient.to + ' 100%)'\n          };\n\n          if (this.viewOptions.vertical) {\n            this.barStyle.backgroundPosition = 'center ' + (offset + dimension + position + (reversed ? -this.handleHalfDimension : 0)) + 'px';\n            this.barStyle.backgroundSize = '100% ' + (this.fullBarElement.dimension - this.handleHalfDimension) + 'px';\n          } else {\n            this.barStyle.backgroundPosition = offset - position + (reversed ? this.handleHalfDimension : 0) + 'px center';\n            this.barStyle.backgroundSize = this.fullBarElement.dimension - this.handleHalfDimension + 'px 100%';\n          }\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getSelectionBarColor\",\n      value: function getSelectionBarColor() {\n        if (this.range) {\n          return this.viewOptions.getSelectionBarColor(this.value, this.highValue);\n        }\n\n        return this.viewOptions.getSelectionBarColor(this.value);\n      }\n      /**\n       * @param {?} pointerType\n       * @return {?}\n       */\n\n    }, {\n      key: \"getPointerColor\",\n      value: function getPointerColor(pointerType) {\n        if (pointerType === PointerType.Max) {\n          return this.viewOptions.getPointerColor(this.highValue, pointerType);\n        }\n\n        return this.viewOptions.getPointerColor(this.value, pointerType);\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"getTickColor\",\n      value: function getTickColor(value) {\n        return this.viewOptions.getTickColor(value);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateCombinedLabel\",\n      value: function updateCombinedLabel() {\n        var\n        /** @type {?} */\n        isLabelOverlap = null;\n\n        if (this.viewOptions.rightToLeft) {\n          isLabelOverlap = this.minHandleLabelElement.position - this.minHandleLabelElement.dimension - 10 <= this.maxHandleLabelElement.position;\n        } else {\n          isLabelOverlap = this.minHandleLabelElement.position + this.minHandleLabelElement.dimension + 10 >= this.maxHandleLabelElement.position;\n        }\n\n        if (isLabelOverlap) {\n          var\n          /** @type {?} */\n          lowDisplayValue = this.getDisplayValue(this.viewLowValue, LabelType.Low);\n          var\n          /** @type {?} */\n          highDisplayValue = this.getDisplayValue(this.viewHighValue, LabelType.High);\n          var\n          /** @type {?} */\n          combinedLabelValue = this.viewOptions.rightToLeft ? this.viewOptions.combineLabels(highDisplayValue, lowDisplayValue) : this.viewOptions.combineLabels(lowDisplayValue, highDisplayValue);\n          this.combinedLabelElement.setValue(combinedLabelValue);\n          var\n          /** @type {?} */\n          pos = this.viewOptions.boundPointerLabels ? Math.min(Math.max(this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2, 0), this.fullBarElement.dimension - this.combinedLabelElement.dimension) : this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2;\n          this.combinedLabelElement.setPosition(pos);\n          this.minHandleLabelElement.hide();\n          this.maxHandleLabelElement.hide();\n          this.combinedLabelElement.show();\n        } else {\n          this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n          this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n          this.maxHandleLabelElement.show();\n          this.minHandleLabelElement.show();\n          this.combinedLabelElement.hide();\n        }\n\n        if (this.viewOptions.autoHideLimitLabels) {\n          this.updateFloorAndCeilLabelsVisibility();\n        }\n      }\n      /**\n       * @param {?} value\n       * @param {?} which\n       * @return {?}\n       */\n\n    }, {\n      key: \"getDisplayValue\",\n      value: function getDisplayValue(value, which) {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n          value = this.getStepValue(value);\n        }\n\n        return this.viewOptions.translate(value, which);\n      }\n      /**\n       * @param {?} value\n       * @param {?=} customStep\n       * @return {?}\n       */\n\n    }, {\n      key: \"roundStep\",\n      value: function roundStep(value, customStep) {\n        var\n        /** @type {?} */\n        step = !ng5_slider_ValueHelper.isNullOrUndefined(customStep) ? customStep : this.viewOptions.step;\n        var\n        /** @type {?} */\n        steppedDifference = ng5_slider_MathHelper.roundToPrecisionLimit((value - this.viewOptions.floor) / step, this.viewOptions.precisionLimit);\n        steppedDifference = Math.round(steppedDifference) * step;\n        return ng5_slider_MathHelper.roundToPrecisionLimit(this.viewOptions.floor + steppedDifference, this.viewOptions.precisionLimit);\n      }\n      /**\n       * @param {?} val\n       * @return {?}\n       */\n\n    }, {\n      key: \"valueToPosition\",\n      value: function valueToPosition(val) {\n        var\n        /** @type {?} */\n        fn = ng5_slider_ValueHelper.linearValueToPosition;\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.customValueToPosition)) {\n          fn = this.viewOptions.customValueToPosition;\n        } else if (this.viewOptions.logScale) {\n          fn = ng5_slider_ValueHelper.logValueToPosition;\n        }\n\n        val = ng5_slider_MathHelper.clampToRange(val, this.viewOptions.floor, this.viewOptions.ceil);\n        var\n        /** @type {?} */\n        percent = fn(val, this.viewOptions.floor, this.viewOptions.ceil);\n\n        if (ng5_slider_ValueHelper.isNullOrUndefined(percent)) {\n          percent = 0;\n        }\n\n        if (this.viewOptions.rightToLeft) {\n          percent = 1 - percent;\n        }\n\n        return percent * this.maxHandlePosition;\n      }\n      /**\n       * @param {?} position\n       * @return {?}\n       */\n\n    }, {\n      key: \"positionToValue\",\n      value: function positionToValue(position) {\n        var\n        /** @type {?} */\n        percent = position / this.maxHandlePosition;\n\n        if (this.viewOptions.rightToLeft) {\n          percent = 1 - percent;\n        }\n\n        var\n        /** @type {?} */\n        fn = ng5_slider_ValueHelper.linearPositionToValue;\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.customPositionToValue)) {\n          fn = this.viewOptions.customPositionToValue;\n        } else if (this.viewOptions.logScale) {\n          fn = ng5_slider_ValueHelper.logPositionToValue;\n        }\n\n        var\n        /** @type {?} */\n        value = fn(percent, this.viewOptions.floor, this.viewOptions.ceil);\n        return !ng5_slider_ValueHelper.isNullOrUndefined(value) ? value : 0;\n      }\n      /**\n       * @param {?} event\n       * @param {?=} targetTouchId\n       * @return {?}\n       */\n\n    }, {\n      key: \"getEventXY\",\n      value: function getEventXY(event, targetTouchId) {\n        if (event instanceof MouseEvent) {\n          return this.viewOptions.vertical ? event.clientY : event.clientX;\n        }\n\n        var\n        /** @type {?} */\n        touchIndex = 0;\n        var\n        /** @type {?} */\n        touches = event.touches;\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(targetTouchId)) {\n          for (var\n          /** @type {?} */\n          i = 0; i < touches.length; i++) {\n            if (touches[i].identifier === targetTouchId) {\n              touchIndex = i;\n              break;\n            }\n          }\n        } // Return the target touch or if the target touch was not found in the event\n        // returns the coordinates of the first touch\n\n\n        return this.viewOptions.vertical ? touches[touchIndex].clientY : touches[touchIndex].clientX;\n      }\n      /**\n       * @param {?} event\n       * @param {?=} targetTouchId\n       * @return {?}\n       */\n\n    }, {\n      key: \"getEventPosition\",\n      value: function getEventPosition(event, targetTouchId) {\n        var\n        /** @type {?} */\n        sliderElementBoundingRect = this.elementRef.nativeElement.getBoundingClientRect();\n        var\n        /** @type {?} */\n        sliderPos = this.viewOptions.vertical ? sliderElementBoundingRect.bottom : sliderElementBoundingRect.left;\n        var\n        /** @type {?} */\n        eventPos = 0;\n\n        if (this.viewOptions.vertical) {\n          eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;\n        } else {\n          eventPos = this.getEventXY(event, targetTouchId) - sliderPos;\n        }\n\n        return eventPos * this.viewOptions.scale - this.handleHalfDimension;\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"getNearestHandle\",\n      value: function getNearestHandle(event) {\n        if (!this.range) {\n          return PointerType.Min;\n        }\n\n        var\n        /** @type {?} */\n        position = this.getEventPosition(event);\n        var\n        /** @type {?} */\n        distanceMin = Math.abs(position - this.minHandleElement.position);\n        var\n        /** @type {?} */\n        distanceMax = Math.abs(position - this.maxHandleElement.position);\n\n        if (distanceMin < distanceMax) {\n          return PointerType.Min;\n        } else if (distanceMin > distanceMax) {\n          return PointerType.Max;\n        } else if (!this.viewOptions.rightToLeft) {\n          // if event is at the same distance from min/max then if it's at left of minH, we return minH else maxH\n          return position < this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n        } // reverse in rtl\n\n\n        return position > this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"bindEvents\",\n      value: function bindEvents() {\n        var _this12 = this;\n\n        var\n        /** @type {?} */\n        draggableRange = this.viewOptions.draggableRange;\n\n        if (!this.viewOptions.onlyBindHandles) {\n          this.selectionBarElement.on('mousedown', function (event) {\n            return _this12.onBarStart(null, draggableRange, event, true, true, true);\n          });\n        }\n\n        if (this.viewOptions.draggableRangeOnly) {\n          this.minHandleElement.on('mousedown', function (event) {\n            return _this12.onBarStart(PointerType.Min, draggableRange, event, true, true);\n          });\n          this.maxHandleElement.on('mousedown', function (event) {\n            return _this12.onBarStart(PointerType.Max, draggableRange, event, true, true);\n          });\n        } else {\n          this.minHandleElement.on('mousedown', function (event) {\n            return _this12.onStart(PointerType.Min, event, true, true);\n          });\n\n          if (this.range) {\n            this.maxHandleElement.on('mousedown', function (event) {\n              return _this12.onStart(PointerType.Max, event, true, true);\n            });\n          }\n\n          if (!this.viewOptions.onlyBindHandles) {\n            this.fullBarElement.on('mousedown', function (event) {\n              return _this12.onStart(null, event, true, true, true);\n            });\n            this.ticksElement.on('mousedown', function (event) {\n              return _this12.onStart(null, event, true, true, true, true);\n            });\n          }\n        }\n\n        if (!this.viewOptions.onlyBindHandles) {\n          this.selectionBarElement.onPassive('touchstart', function (event) {\n            return _this12.onBarStart(null, draggableRange, event, true, true, true);\n          });\n        }\n\n        if (this.viewOptions.draggableRangeOnly) {\n          this.minHandleElement.onPassive('touchstart', function (event) {\n            return _this12.onBarStart(PointerType.Min, draggableRange, event, true, true);\n          });\n          this.maxHandleElement.onPassive('touchstart', function (event) {\n            return _this12.onBarStart(PointerType.Max, draggableRange, event, true, true);\n          });\n        } else {\n          this.minHandleElement.onPassive('touchstart', function (event) {\n            return _this12.onStart(PointerType.Min, event, true, true);\n          });\n\n          if (this.range) {\n            this.maxHandleElement.onPassive('touchstart', function (event) {\n              return _this12.onStart(PointerType.Max, event, true, true);\n            });\n          }\n\n          if (!this.viewOptions.onlyBindHandles) {\n            this.fullBarElement.onPassive('touchstart', function (event) {\n              return _this12.onStart(null, event, true, true, true);\n            });\n            this.ticksElement.onPassive('touchstart', function (event) {\n              return _this12.onStart(null, event, false, false, true, true);\n            });\n          }\n        }\n\n        if (this.viewOptions.keyboardSupport) {\n          this.minHandleElement.on('focus', function () {\n            return _this12.onPointerFocus(PointerType.Min);\n          });\n\n          if (this.range) {\n            this.maxHandleElement.on('focus', function () {\n              return _this12.onPointerFocus(PointerType.Max);\n            });\n          }\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unbindEvents\",\n      value: function unbindEvents() {\n        this.unsubscribeOnMove();\n        this.unsubscribeOnEnd();\n\n        var _iterator4 = Object(createForOfIteratorHelper[\"a\" /* default */])(this.getAllSliderElements()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var element = _step4.value;\n\n            if (!ng5_slider_ValueHelper.isNullOrUndefined(element)) {\n              element.off();\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      /**\n       * @param {?} pointerType\n       * @param {?} draggableRange\n       * @param {?} event\n       * @param {?} bindMove\n       * @param {?} bindEnd\n       * @param {?=} simulateImmediateMove\n       * @param {?=} simulateImmediateEnd\n       * @return {?}\n       */\n\n    }, {\n      key: \"onBarStart\",\n      value: function onBarStart(pointerType, draggableRange, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n        if (draggableRange) {\n          this.onDragStart(pointerType, event, bindMove, bindEnd);\n        } else {\n          this.onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);\n        }\n      }\n      /**\n       * @param {?} pointerType\n       * @param {?} event\n       * @param {?} bindMove\n       * @param {?} bindEnd\n       * @param {?=} simulateImmediateMove\n       * @param {?=} simulateImmediateEnd\n       * @return {?}\n       */\n\n    }, {\n      key: \"onStart\",\n      value: function onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n        var _this13 = this;\n\n        event.stopPropagation(); // Only call preventDefault() when handling non-passive events (passive events don't need it)\n\n        if (!ng5_slider_CompatibilityHelper.isTouchEvent(event) || !lib_default.a.hasSupport) {\n          event.preventDefault();\n        } // We have to do this in case the HTML where the sliders are on\n        // have been animated into view.\n\n\n        this.calculateViewDimensions();\n\n        if (ng5_slider_ValueHelper.isNullOrUndefined(pointerType)) {\n          pointerType = this.getNearestHandle(event);\n        }\n\n        this.currentTrackingPointer = pointerType;\n        var\n        /** @type {?} */\n        pointerElement = this.getPointerElement(pointerType);\n        pointerElement.active = true;\n\n        if (this.viewOptions.keyboardSupport) {\n          pointerElement.focus();\n        }\n\n        if (bindMove) {\n          this.unsubscribeOnMove();\n\n          var\n          /** @type {?} */\n          onMoveCallback = function onMoveCallback(e) {\n            return _this13.dragging.active ? _this13.onDragMove(e) : _this13.onMove(e);\n          };\n\n          if (ng5_slider_CompatibilityHelper.isTouchEvent(event)) {\n            this.onMoveEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchmove', onMoveCallback, this.viewOptions.touchEventsInterval);\n          } else {\n            this.onMoveEventListener = this.eventListenerHelper.attachEventListener(document, 'mousemove', onMoveCallback, this.viewOptions.mouseEventsInterval);\n          }\n        }\n\n        if (bindEnd) {\n          this.unsubscribeOnEnd();\n\n          var\n          /** @type {?} */\n          onEndCallback = function onEndCallback(e) {\n            return _this13.onEnd(e);\n          };\n\n          if (ng5_slider_CompatibilityHelper.isTouchEvent(event)) {\n            this.onEndEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchend', onEndCallback);\n          } else {\n            this.onEndEventListener = this.eventListenerHelper.attachEventListener(document, 'mouseup', onEndCallback);\n          }\n        }\n\n        this.userChangeStart.emit(this.getChangeContext());\n\n        if (ng5_slider_CompatibilityHelper.isTouchEvent(event) && !ng5_slider_ValueHelper.isNullOrUndefined(\n        /** @type {?} */\n        event.changedTouches)) {\n          // Store the touch identifier\n          if (ng5_slider_ValueHelper.isNullOrUndefined(this.touchId)) {\n            this.touchId =\n            /** @type {?} */\n            event.changedTouches[0].identifier;\n          }\n        } // Click events, either with mouse or touch gesture are weird. Sometimes they result in full\n        // start, move, end sequence, and sometimes, they don't - they only invoke mousedown\n        // As a workaround, we simulate the first move event and the end event if it's necessary\n\n\n        if (simulateImmediateMove) {\n          this.onMove(event, true);\n        }\n\n        if (simulateImmediateEnd) {\n          this.onEnd(event);\n        }\n      }\n      /**\n       * @param {?} event\n       * @param {?=} fromTick\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMove\",\n      value: function onMove(event, fromTick) {\n        var\n        /** @type {?} */\n        touchForThisSlider = null;\n\n        if (ng5_slider_CompatibilityHelper.isTouchEvent(event)) {\n          var\n          /** @type {?} */\n          changedTouches =\n          /** @type {?} */\n          event.changedTouches;\n\n          for (var\n          /** @type {?} */\n          i = 0; i < changedTouches.length; i++) {\n            if (changedTouches[i].identifier === this.touchId) {\n              touchForThisSlider = changedTouches[i];\n              break;\n            }\n          }\n\n          if (ng5_slider_ValueHelper.isNullOrUndefined(touchForThisSlider)) {\n            return;\n          }\n        }\n\n        var\n        /** @type {?} */\n        newPos = !ng5_slider_ValueHelper.isNullOrUndefined(touchForThisSlider) ? this.getEventPosition(event, touchForThisSlider.identifier) : this.getEventPosition(event);\n        var\n        /** @type {?} */\n        newValue;\n        var\n        /** @type {?} */\n        ceilValue = this.viewOptions.rightToLeft ? this.viewOptions.floor : this.viewOptions.ceil;\n        var\n        /** @type {?} */\n        floorValue = this.viewOptions.rightToLeft ? this.viewOptions.ceil : this.viewOptions.floor;\n\n        if (newPos <= 0) {\n          newValue = floorValue;\n        } else if (newPos >= this.maxHandlePosition) {\n          newValue = ceilValue;\n        } else {\n          newValue = this.positionToValue(newPos);\n\n          if (fromTick && !ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) {\n            newValue = this.roundStep(newValue, this.viewOptions.tickStep);\n          } else {\n            newValue = this.roundStep(newValue);\n          }\n        }\n\n        this.positionTrackingHandle(newValue);\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onEnd\",\n      value: function onEnd(event) {\n        if (ng5_slider_CompatibilityHelper.isTouchEvent(event)) {\n          var\n          /** @type {?} */\n          changedTouches =\n          /** @type {?} */\n          event.changedTouches;\n\n          if (changedTouches[0].identifier !== this.touchId) {\n            return;\n          }\n        }\n\n        this.touchId = null;\n\n        if (!this.viewOptions.keyboardSupport) {\n          this.minHandleElement.active = false;\n          this.maxHandleElement.active = false;\n          this.currentTrackingPointer = null;\n        }\n\n        this.dragging.active = false;\n        this.unsubscribeOnMove();\n        this.unsubscribeOnEnd();\n        this.userChangeEnd.emit(this.getChangeContext());\n      }\n      /**\n       * @param {?} pointerType\n       * @return {?}\n       */\n\n    }, {\n      key: \"onPointerFocus\",\n      value: function onPointerFocus(pointerType) {\n        var _this14 = this;\n\n        var\n        /** @type {?} */\n        pointerElement = this.getPointerElement(pointerType);\n        pointerElement.on('blur', function () {\n          return _this14.onPointerBlur(pointerElement);\n        });\n        pointerElement.on('keydown', function (event) {\n          return _this14.onKeyboardEvent(event);\n        });\n        pointerElement.on('keyup', function () {\n          return _this14.onKeyUp();\n        });\n        pointerElement.active = true;\n        this.currentTrackingPointer = pointerType;\n        this.currentFocusPointer = pointerType;\n        this.firstKeyDown = true;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"onKeyUp\",\n      value: function onKeyUp() {\n        this.firstKeyDown = true;\n        this.userChangeEnd.emit(this.getChangeContext());\n      }\n      /**\n       * @param {?} pointer\n       * @return {?}\n       */\n\n    }, {\n      key: \"onPointerBlur\",\n      value: function onPointerBlur(pointer) {\n        pointer.off('blur');\n        pointer.off('keydown');\n        pointer.off('keyup');\n        pointer.active = false;\n\n        if (ng5_slider_ValueHelper.isNullOrUndefined(this.touchId)) {\n          this.currentTrackingPointer = null;\n          this.currentFocusPointer = null;\n        }\n      }\n      /**\n       * @param {?} currentValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"getKeyActions\",\n      value: function getKeyActions(currentValue) {\n        var\n        /** @type {?} */\n        valueRange = this.viewOptions.ceil - this.viewOptions.floor;\n        var\n        /** @type {?} */\n        increaseStep = currentValue + this.viewOptions.step;\n        var\n        /** @type {?} */\n        decreaseStep = currentValue - this.viewOptions.step;\n        var\n        /** @type {?} */\n        increasePage = currentValue + valueRange / 10;\n        var\n        /** @type {?} */\n        decreasePage = currentValue - valueRange / 10;\n\n        if (this.viewOptions.reversedControls) {\n          increaseStep = currentValue - this.viewOptions.step;\n          decreaseStep = currentValue + this.viewOptions.step;\n          increasePage = currentValue - valueRange / 10;\n          decreasePage = currentValue + valueRange / 10;\n        } // Left to right default actions\n\n\n        var\n        /** @type {?} */\n        actions = {\n          UP: increaseStep,\n          DOWN: decreaseStep,\n          LEFT: decreaseStep,\n          RIGHT: increaseStep,\n          PAGEUP: increasePage,\n          PAGEDOWN: decreasePage,\n          HOME: this.viewOptions.reversedControls ? this.viewOptions.ceil : this.viewOptions.floor,\n          END: this.viewOptions.reversedControls ? this.viewOptions.floor : this.viewOptions.ceil\n        }; // right to left means swapping right and left arrows\n\n        if (this.viewOptions.rightToLeft) {\n          actions[\"LEFT\"] = increaseStep;\n          actions[\"RIGHT\"] = decreaseStep; // right to left and vertical means we also swap up and down\n\n          if (this.viewOptions.vertical) {\n            actions[\"UP\"] = decreaseStep;\n            actions[\"DOWN\"] = increaseStep;\n          }\n        }\n\n        return actions;\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onKeyboardEvent\",\n      value: function onKeyboardEvent(event) {\n        var\n        /** @type {?} */\n        currentValue = this.getCurrentTrackingValue();\n        var\n        /** @type {?} */\n        keyCode = !ng5_slider_ValueHelper.isNullOrUndefined(event.keyCode) ? event.keyCode : event.which;\n        var\n        /** @type {?} */\n        keys = {\n          38: 'UP',\n          40: 'DOWN',\n          37: 'LEFT',\n          39: 'RIGHT',\n          33: 'PAGEUP',\n          34: 'PAGEDOWN',\n          36: 'HOME',\n          35: 'END'\n        };\n        var\n        /** @type {?} */\n        actions = this.getKeyActions(currentValue);\n        var\n        /** @type {?} */\n        key = keys[keyCode];\n        var\n        /** @type {?} */\n        action = actions[key];\n\n        if (ng5_slider_ValueHelper.isNullOrUndefined(action) || ng5_slider_ValueHelper.isNullOrUndefined(this.currentTrackingPointer)) {\n          return;\n        }\n\n        event.preventDefault();\n\n        if (this.firstKeyDown) {\n          this.firstKeyDown = false;\n          this.userChangeStart.emit(this.getChangeContext());\n        }\n\n        var\n        /** @type {?} */\n        actionValue = ng5_slider_MathHelper.clampToRange(action, this.viewOptions.floor, this.viewOptions.ceil);\n        var\n        /** @type {?} */\n        newValue = this.roundStep(actionValue);\n\n        if (!this.viewOptions.draggableRangeOnly) {\n          this.positionTrackingHandle(newValue);\n        } else {\n          var\n          /** @type {?} */\n          difference = this.viewHighValue - this.viewLowValue;\n          var\n          /** @type {?} */\n          newMinValue;\n          var\n          /** @type {?} */\n          newMaxValue;\n\n          if (this.currentTrackingPointer === PointerType.Min) {\n            newMinValue = newValue;\n            newMaxValue = newValue + difference;\n\n            if (newMaxValue > this.viewOptions.ceil) {\n              newMaxValue = this.viewOptions.ceil;\n              newMinValue = newMaxValue - difference;\n            }\n          } else if (this.currentTrackingPointer === PointerType.Max) {\n            newMaxValue = newValue;\n            newMinValue = newValue - difference;\n\n            if (newMinValue < this.viewOptions.floor) {\n              newMinValue = this.viewOptions.floor;\n              newMaxValue = newMinValue + difference;\n            }\n          }\n\n          this.positionTrackingBar(newMinValue, newMaxValue);\n        }\n      }\n      /**\n       * @param {?} pointerType\n       * @param {?} event\n       * @param {?} bindMove\n       * @param {?} bindEnd\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDragStart\",\n      value: function onDragStart(pointerType, event, bindMove, bindEnd) {\n        var\n        /** @type {?} */\n        position = this.getEventPosition(event);\n        this.dragging = new ng5_slider_Dragging();\n        this.dragging.active = true;\n        this.dragging.value = this.positionToValue(position);\n        this.dragging.difference = this.viewHighValue - this.viewLowValue;\n        this.dragging.lowLimit = this.viewOptions.rightToLeft ? this.minHandleElement.position - position : position - this.minHandleElement.position;\n        this.dragging.highLimit = this.viewOptions.rightToLeft ? position - this.maxHandleElement.position : this.maxHandleElement.position - position;\n        this.onStart(pointerType, event, bindMove, bindEnd);\n      }\n      /**\n       * Get min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft\n       * @param {?} newPos\n       * @param {?} outOfBounds\n       * @param {?} isAbove\n       * @return {?}\n       */\n\n    }, {\n      key: \"getMinValue\",\n      value: function getMinValue(newPos, outOfBounds, isAbove) {\n        var\n        /** @type {?} */\n        isRTL = this.viewOptions.rightToLeft;\n        var\n        /** @type {?} */\n        value = null;\n\n        if (outOfBounds) {\n          if (isAbove) {\n            value = isRTL ? this.viewOptions.floor : this.viewOptions.ceil - this.dragging.difference;\n          } else {\n            value = isRTL ? this.viewOptions.ceil - this.dragging.difference : this.viewOptions.floor;\n          }\n        } else {\n          value = isRTL ? this.positionToValue(newPos + this.dragging.lowLimit) : this.positionToValue(newPos - this.dragging.lowLimit);\n        }\n\n        return this.roundStep(value);\n      }\n      /**\n       * Get max value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft\n       * @param {?} newPos\n       * @param {?} outOfBounds\n       * @param {?} isAbove\n       * @return {?}\n       */\n\n    }, {\n      key: \"getMaxValue\",\n      value: function getMaxValue(newPos, outOfBounds, isAbove) {\n        var\n        /** @type {?} */\n        isRTL = this.viewOptions.rightToLeft;\n        var\n        /** @type {?} */\n        value = null;\n\n        if (outOfBounds) {\n          if (isAbove) {\n            value = isRTL ? this.viewOptions.floor + this.dragging.difference : this.viewOptions.ceil;\n          } else {\n            value = isRTL ? this.viewOptions.ceil : this.viewOptions.floor + this.dragging.difference;\n          }\n        } else {\n          if (isRTL) {\n            value = this.positionToValue(newPos + this.dragging.lowLimit) + this.dragging.difference;\n          } else {\n            value = this.positionToValue(newPos - this.dragging.lowLimit) + this.dragging.difference;\n          }\n        }\n\n        return this.roundStep(value);\n      }\n      /**\n       * @param {?=} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDragMove\",\n      value: function onDragMove(event) {\n        var\n        /** @type {?} */\n        newPos = this.getEventPosition(event);\n        var\n        /** @type {?} */\n        ceilLimit,\n        /** @type {?} */\n        floorLimit,\n        /** @type {?} */\n        floorHandleElement,\n        /** @type {?} */\n        ceilHandleElement;\n\n        if (this.viewOptions.rightToLeft) {\n          ceilLimit = this.dragging.lowLimit;\n          floorLimit = this.dragging.highLimit;\n          floorHandleElement = this.maxHandleElement;\n          ceilHandleElement = this.minHandleElement;\n        } else {\n          ceilLimit = this.dragging.highLimit;\n          floorLimit = this.dragging.lowLimit;\n          floorHandleElement = this.minHandleElement;\n          ceilHandleElement = this.maxHandleElement;\n        }\n\n        var\n        /** @type {?} */\n        isUnderFloorLimit = newPos <= floorLimit;\n        var\n        /** @type {?} */\n        isOverCeilLimit = newPos >= this.maxHandlePosition - ceilLimit;\n        var\n        /** @type {?} */\n        newMinValue;\n        var\n        /** @type {?} */\n        newMaxValue;\n\n        if (isUnderFloorLimit) {\n          if (floorHandleElement.position === 0) {\n            return;\n          }\n\n          newMinValue = this.getMinValue(newPos, true, false);\n          newMaxValue = this.getMaxValue(newPos, true, false);\n        } else if (isOverCeilLimit) {\n          if (ceilHandleElement.position === this.maxHandlePosition) {\n            return;\n          }\n\n          newMaxValue = this.getMaxValue(newPos, true, true);\n          newMinValue = this.getMinValue(newPos, true, true);\n        } else {\n          newMinValue = this.getMinValue(newPos, false, false);\n          newMaxValue = this.getMaxValue(newPos, false, false);\n        }\n\n        this.positionTrackingBar(newMinValue, newMaxValue);\n      }\n      /**\n       * @param {?} newMinValue\n       * @param {?} newMaxValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"positionTrackingBar\",\n      value: function positionTrackingBar(newMinValue, newMaxValue) {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newMinValue < this.viewOptions.minLimit) {\n          newMinValue = this.viewOptions.minLimit;\n          newMaxValue = ng5_slider_MathHelper.roundToPrecisionLimit(newMinValue + this.dragging.difference, this.viewOptions.precisionLimit);\n        }\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newMaxValue > this.viewOptions.maxLimit) {\n          newMaxValue = this.viewOptions.maxLimit;\n          newMinValue = ng5_slider_MathHelper.roundToPrecisionLimit(newMaxValue - this.dragging.difference, this.viewOptions.precisionLimit);\n        }\n\n        this.viewLowValue = newMinValue;\n        this.viewHighValue = newMaxValue;\n        this.applyViewChange();\n        this.updateHandles(PointerType.Min, this.valueToPosition(newMinValue));\n        this.updateHandles(PointerType.Max, this.valueToPosition(newMaxValue));\n      }\n      /**\n       * @param {?} newValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"positionTrackingHandle\",\n      value: function positionTrackingHandle(newValue) {\n        newValue = this.applyMinMaxLimit(newValue);\n\n        if (this.range) {\n          if (this.viewOptions.pushRange) {\n            newValue = this.applyPushRange(newValue);\n          } else {\n            if (this.viewOptions.noSwitching) {\n              if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n                newValue = this.applyMinMaxRange(this.viewHighValue);\n              } else if (this.currentTrackingPointer === PointerType.Max && newValue < this.viewLowValue) {\n                newValue = this.applyMinMaxRange(this.viewLowValue);\n              }\n            }\n\n            newValue = this.applyMinMaxRange(newValue);\n            /* This is to check if we need to switch the min and max handles */\n\n            if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n              this.viewLowValue = this.viewHighValue;\n              this.applyViewChange();\n              this.updateHandles(PointerType.Min, this.maxHandleElement.position);\n              this.updateAriaAttributes();\n              this.currentTrackingPointer = PointerType.Max;\n              this.minHandleElement.active = false;\n              this.maxHandleElement.active = true;\n\n              if (this.viewOptions.keyboardSupport) {\n                this.maxHandleElement.focus();\n              }\n            } else if (this.currentTrackingPointer === PointerType.Max && newValue < this.viewLowValue) {\n              this.viewHighValue = this.viewLowValue;\n              this.applyViewChange();\n              this.updateHandles(PointerType.Max, this.minHandleElement.position);\n              this.updateAriaAttributes();\n              this.currentTrackingPointer = PointerType.Min;\n              this.maxHandleElement.active = false;\n              this.minHandleElement.active = true;\n\n              if (this.viewOptions.keyboardSupport) {\n                this.minHandleElement.focus();\n              }\n            }\n          }\n        }\n\n        if (this.getCurrentTrackingValue() !== newValue) {\n          if (this.currentTrackingPointer === PointerType.Min) {\n            this.viewLowValue = newValue;\n            this.applyViewChange();\n          } else if (this.currentTrackingPointer === PointerType.Max) {\n            this.viewHighValue = newValue;\n            this.applyViewChange();\n          }\n\n          this.updateHandles(this.currentTrackingPointer, this.valueToPosition(newValue));\n          this.updateAriaAttributes();\n        }\n      }\n      /**\n       * @param {?} newValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyMinMaxLimit\",\n      value: function applyMinMaxLimit(newValue) {\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newValue < this.viewOptions.minLimit) {\n          return this.viewOptions.minLimit;\n        }\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newValue > this.viewOptions.maxLimit) {\n          return this.viewOptions.maxLimit;\n        }\n\n        return newValue;\n      }\n      /**\n       * @param {?} newValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyMinMaxRange\",\n      value: function applyMinMaxRange(newValue) {\n        var\n        /** @type {?} */\n        oppositeValue = this.currentTrackingPointer === PointerType.Min ? this.viewHighValue : this.viewLowValue;\n        var\n        /** @type {?} */\n        difference = Math.abs(newValue - oppositeValue);\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.minRange)) {\n          if (difference < this.viewOptions.minRange) {\n            if (this.currentTrackingPointer === PointerType.Min) {\n              return ng5_slider_MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.minRange, this.viewOptions.precisionLimit);\n            } else if (this.currentTrackingPointer === PointerType.Max) {\n              return ng5_slider_MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.minRange, this.viewOptions.precisionLimit);\n            }\n          }\n        }\n\n        if (!ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.maxRange)) {\n          if (difference > this.viewOptions.maxRange) {\n            if (this.currentTrackingPointer === PointerType.Min) {\n              return ng5_slider_MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n            } else if (this.currentTrackingPointer === PointerType.Max) {\n              return ng5_slider_MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n            }\n          }\n        }\n\n        return newValue;\n      }\n      /**\n       * @param {?} newValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyPushRange\",\n      value: function applyPushRange(newValue) {\n        var\n        /** @type {?} */\n        difference = this.currentTrackingPointer === PointerType.Min ? this.viewHighValue - newValue : newValue - this.viewLowValue;\n        var\n        /** @type {?} */\n        minRange = !ng5_slider_ValueHelper.isNullOrUndefined(this.viewOptions.minRange) ? this.viewOptions.minRange : this.viewOptions.step;\n        var\n        /** @type {?} */\n        maxRange = this.viewOptions.maxRange; // if smaller than minRange\n\n        if (difference < minRange) {\n          if (this.currentTrackingPointer === PointerType.Min) {\n            this.viewHighValue = ng5_slider_MathHelper.roundToPrecisionLimit(Math.min(newValue + minRange, this.viewOptions.ceil), this.viewOptions.precisionLimit);\n            newValue = ng5_slider_MathHelper.roundToPrecisionLimit(this.viewHighValue - minRange, this.viewOptions.precisionLimit);\n            this.applyViewChange();\n            this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n          } else if (this.currentTrackingPointer === PointerType.Max) {\n            this.viewLowValue = ng5_slider_MathHelper.roundToPrecisionLimit(Math.max(newValue - minRange, this.viewOptions.floor), this.viewOptions.precisionLimit);\n            newValue = ng5_slider_MathHelper.roundToPrecisionLimit(this.viewLowValue + minRange, this.viewOptions.precisionLimit);\n            this.applyViewChange();\n            this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n          }\n\n          this.updateAriaAttributes();\n        } else if (!ng5_slider_ValueHelper.isNullOrUndefined(maxRange) && difference > maxRange) {\n          // if greater than maxRange\n          if (this.currentTrackingPointer === PointerType.Min) {\n            this.viewHighValue = ng5_slider_MathHelper.roundToPrecisionLimit(newValue + maxRange, this.viewOptions.precisionLimit);\n            this.applyViewChange();\n            this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n          } else if (this.currentTrackingPointer === PointerType.Max) {\n            this.viewLowValue = ng5_slider_MathHelper.roundToPrecisionLimit(newValue - maxRange, this.viewOptions.precisionLimit);\n            this.applyViewChange();\n            this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n          }\n\n          this.updateAriaAttributes();\n        }\n\n        return newValue;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getChangeContext\",\n      value: function getChangeContext() {\n        var\n        /** @type {?} */\n        changeContext = new ng5_slider_ChangeContext();\n        changeContext.pointerType = this.currentTrackingPointer;\n        changeContext.value = +this.value;\n\n        if (this.range) {\n          changeContext.highValue = +this.highValue;\n        }\n\n        return changeContext;\n      }\n    }]);\n  }();\n\n  SliderComponent.fac = function SliderComponent_Factory(t) {\n    return new (t || SliderComponent)(core[\"Mb\" /* directiveInject */](core[\"E\" /* Renderer2 */]), core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]));\n  };\n\n  SliderComponent.cmp = core[\"Gb\" /* defineComponent */]({\n    type: SliderComponent,\n    selectors: [[\"ng5-slider\"]],\n    contentQueries: function SliderComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        core[\"Fb\" /* contentQuery */](dirIndex, ng5_slider_c0, 1);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.tooltipTemplate = _t.first);\n      }\n    },\n    viewQuery: function SliderComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        core[\"Ic\" /* viewQuery */](ng5_slider_c1, 1, ng5_slider_SliderElementDirective);\n        core[\"Ic\" /* viewQuery */](_c2, 1, ng5_slider_SliderElementDirective);\n        core[\"Ic\" /* viewQuery */](_c3, 1, ng5_slider_SliderElementDirective);\n        core[\"Ic\" /* viewQuery */](_c4, 1, ng5_slider_SliderElementDirective);\n        core[\"Ic\" /* viewQuery */](_c5, 1, ng5_slider_SliderHandleDirective);\n        core[\"Ic\" /* viewQuery */](_c6, 1, ng5_slider_SliderHandleDirective);\n        core[\"Ic\" /* viewQuery */](_c7, 1, ng5_slider_SliderLabelDirective);\n        core[\"Ic\" /* viewQuery */](_c8, 1, ng5_slider_SliderLabelDirective);\n        core[\"Ic\" /* viewQuery */](_c9, 1, ng5_slider_SliderLabelDirective);\n        core[\"Ic\" /* viewQuery */](_c10, 1, ng5_slider_SliderLabelDirective);\n        core[\"Ic\" /* viewQuery */](_c11, 1, ng5_slider_SliderLabelDirective);\n        core[\"Ic\" /* viewQuery */](_c12, 1, ng5_slider_SliderElementDirective);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.leftOuterSelectionBarElement = _t.first);\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.rightOuterSelectionBarElement = _t.first);\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.fullBarElement = _t.first);\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.selectionBarElement = _t.first);\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.minHandleElement = _t.first);\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.maxHandleElement = _t.first);\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.floorLabelElement = _t.first);\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.ceilLabelElement = _t.first);\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.minHandleLabelElement = _t.first);\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.maxHandleLabelElement = _t.first);\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.combinedLabelElement = _t.first);\n        core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.ticksElement = _t.first);\n      }\n    },\n    hostAttrs: [1, \"ng5-slider\"],\n    hostVars: 5,\n    hostBindings: function SliderComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        core[\"Zb\" /* listener */](\"resize\", function SliderComponent_resize_HostBindingHandler($event) {\n          return ctx.onResize($event);\n        }, false, core[\"uc\" /* resolveWindow */]);\n      }\n\n      if (rf & 2) {\n        core[\"Bb\" /* attribute */](\"disabled\", ctx.sliderElementDisabledAttr);\n        core[\"Eb\" /* classProp */](\"vertical\", ctx.sliderElementVerticalClass)(\"animate\", ctx.sliderElementAnimateClass);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      highValue: \"highValue\",\n      options: \"options\",\n      manualRefresh: \"manualRefresh\",\n      triggerFocus: \"triggerFocus\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      highValueChange: \"highValueChange\",\n      userChangeStart: \"userChangeStart\",\n      userChange: \"userChange\",\n      userChangeEnd: \"userChangeEnd\"\n    },\n    features: [core[\"zb\" /* ProvidersFeature */]([NG5_SLIDER_CONTROL_VALUE_ACCESSOR]), core[\"yb\" /* NgOnChangesFeature */]],\n    decls: 29,\n    vars: 13,\n    consts: [[\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-left-out-selection\"], [\"leftOuterSelectionBar\", \"\"], [1, \"ng5-slider-span\", \"ng5-slider-bar\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-right-out-selection\"], [\"rightOuterSelectionBar\", \"\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-full-bar\"], [\"fullBar\", \"\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-selection-bar\"], [\"selectionBar\", \"\"], [1, \"ng5-slider-span\", \"ng5-slider-bar\", \"ng5-slider-selection\", 3, \"ngStyle\"], [\"ng5SliderHandle\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-pointer\", \"ng5-slider-pointer-min\", 3, \"ngStyle\"], [\"minHandle\", \"\"], [\"ng5SliderHandle\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-pointer\", \"ng5-slider-pointer-max\", 3, \"ngStyle\"], [\"maxHandle\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-limit\", \"ng5-slider-floor\"], [\"floorLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-limit\", \"ng5-slider-ceil\"], [\"ceilLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-model-value\"], [\"minHandleLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-model-high\"], [\"maxHandleLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-combined\"], [\"combinedLabel\", \"\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-ticks\", 3, \"hidden\"], [\"ticksElement\", \"\"], [\"class\", \"ng5-slider-tick\", 3, \"ngClass\", \"ngStyle\", 4, \"ngFor\", \"ngForOf\"], [1, \"ng5-slider-tick\", 3, \"ngClass\", \"ngStyle\"], [3, \"template\", \"tooltip\", \"placement\"], [\"class\", \"ng5-slider-span ng5-slider-tick-value\", 3, \"template\", \"tooltip\", \"placement\", \"content\", 4, \"ngIf\"], [\"class\", \"ng5-slider-span ng5-slider-tick-legend\", 3, \"innerHTML\", 4, \"ngIf\"], [1, \"ng5-slider-span\", \"ng5-slider-tick-value\", 3, \"template\", \"tooltip\", \"placement\", \"content\"], [1, \"ng5-slider-span\", \"ng5-slider-tick-legend\", 3, \"innerHTML\"]],\n    template: function SliderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"span\", 0, 1);\n        core[\"Nb\" /* element */](2, \"span\", 2);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](3, \"span\", 3, 4);\n        core[\"Nb\" /* element */](5, \"span\", 2);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](6, \"span\", 5, 6);\n        core[\"Nb\" /* element */](8, \"span\", 2);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](9, \"span\", 7, 8);\n        core[\"Nb\" /* element */](11, \"span\", 9);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Nb\" /* element */](12, \"span\", 10, 11);\n        core[\"Nb\" /* element */](14, \"span\", 12, 13);\n        core[\"Nb\" /* element */](16, \"span\", 14, 15);\n        core[\"Nb\" /* element */](18, \"span\", 16, 17);\n        core[\"Nb\" /* element */](20, \"span\", 18, 19);\n        core[\"Nb\" /* element */](22, \"span\", 20, 21);\n        core[\"Nb\" /* element */](24, \"span\", 22, 23);\n        core[\"Sb\" /* elementStart */](26, \"span\", 24, 25);\n        core[\"Bc\" /* template */](28, SliderComponent_span_28_Template, 4, 9, \"span\", 26);\n        core[\"Rb\" /* elementEnd */]();\n      }\n\n      if (rf & 2) {\n        core[\"Ab\" /* advance */](6);\n        core[\"Eb\" /* classProp */](\"ng5-slider-transparent\", ctx.fullBarTransparentClass);\n        core[\"Ab\" /* advance */](3);\n        core[\"Eb\" /* classProp */](\"ng5-slider-draggable\", ctx.selectionBarDraggableClass);\n        core[\"Ab\" /* advance */](2);\n        core[\"ic\" /* property */](\"ngStyle\", ctx.barStyle);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngStyle\", ctx.minPointerStyle);\n        core[\"Ab\" /* advance */](2);\n        core[\"zc\" /* styleProp */](\"display\", ctx.range ? \"inherit\" : \"none\");\n        core[\"ic\" /* property */](\"ngStyle\", ctx.maxPointerStyle);\n        core[\"Ab\" /* advance */](12);\n        core[\"Eb\" /* classProp */](\"ng5-slider-ticks-values-under\", ctx.ticksUnderValuesClass);\n        core[\"ic\" /* property */](\"hidden\", !ctx.showTicks);\n        core[\"Ab\" /* advance */](2);\n        core[\"ic\" /* property */](\"ngForOf\", ctx.ticks);\n      }\n    },\n    directives: function directives() {\n      return [ng5_slider_SliderElementDirective, common[\"m\" /* NgStyle */], ng5_slider_SliderHandleDirective, ng5_slider_SliderLabelDirective, common[\"k\" /* NgForOf */], common[\"j\" /* NgClass */], ng5_slider_TooltipWrapperComponent, common[\"l\" /* NgIf */]];\n    },\n    styles: [\".ng5-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:pan-y;touch-action:pan-y}  .ng5-slider.with-legend{margin-bottom:40px}  .ng5-slider[disabled]{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}  .ng5-slider[disabled] .ng5-slider-draggable{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-selection{background:#8b91a2}  .ng5-slider[disabled] .ng5-slider-tick{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-tick.ng5-slider-selected{background:#8b91a2}  .ng5-slider .ng5-slider-span{white-space:nowrap;position:absolute;display:inline-block}  .ng5-slider .ng5-slider-base{width:100%;height:100%;padding:0}  .ng5-slider .ng5-slider-bar-wrapper{left:0;-webkit-box-sizing:border-box;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}  .ng5-slider .ng5-slider-draggable{cursor:move}  .ng5-slider .ng5-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-transparent .ng5-slider-bar{background:0 0}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-left-out-selection .ng5-slider-bar{background:#df002d}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-right-out-selection .ng5-slider-bar{background:#03a688}  .ng5-slider .ng5-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}  .ng5-slider .ng5-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}  .ng5-slider .ng5-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}  .ng5-slider .ng5-slider-pointer:hover:after{background-color:#fff}  .ng5-slider .ng5-slider-pointer.ng5-slider-active{z-index:4}  .ng5-slider .ng5-slider-pointer.ng5-slider-active:after{background-color:#451aff}  .ng5-slider .ng5-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}  .ng5-slider .ng5-slider-bubble.ng5-slider-limit{color:#55637d}  .ng5-slider .ng5-slider-ticks{-webkit-box-sizing:border-box;box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}  .ng5-slider .ng5-slider-ticks-values-under .ng5-slider-tick-value{top:auto;bottom:-36px}  .ng5-slider .ng5-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}  .ng5-slider .ng5-slider-tick.ng5-slider-selected{background:#0db9f0}  .ng5-slider .ng5-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}  .ng5-slider .ng5-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}  .ng5-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;-ms-touch-action:pan-x;touch-action:pan-x}  .ng5-slider.vertical .ng5-slider-base{width:100%;height:100%;padding:0}  .ng5-slider.vertical .ng5-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}  .ng5-slider.vertical .ng5-slider-bar{bottom:0;left:auto;width:4px;height:100%}  .ng5-slider.vertical .ng5-slider-pointer{left:-14px!important;top:auto;bottom:0}  .ng5-slider.vertical .ng5-slider-bubble{left:16px!important;bottom:0}  .ng5-slider.vertical .ng5-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}  .ng5-slider.vertical .ng5-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}  .ng5-slider.vertical .ng5-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}  .ng5-slider.vertical .ng5-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}  .ng5-slider.vertical .ng5-slider-ticks-values-under .ng5-slider-tick-value{bottom:auto;left:auto;right:24px}  .ng5-slider *{-webkit-transition:none;transition:none}  .ng5-slider.animate .ng5-slider-bar-wrapper{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-selection{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}  .ng5-slider.animate .ng5-slider-pointer{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-bubble{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-bubble.ng5-slider-limit{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}  .ng5-slider.animate .ng5-slider-bubble.ng5-slider-combined{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}  .ng5-slider.animate .ng5-slider-tick{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}\"]\n  });\n  return SliderComponent;\n}();\n\nvar ng5_slider_TooltipWrapperComponent = /*@__PURE__*/function () {\n  var TooltipWrapperComponent = /*#__PURE__*/Object(createClass[\"a\" /* default */])(function TooltipWrapperComponent() {\n    Object(classCallCheck[\"a\" /* default */])(this, TooltipWrapperComponent);\n  });\n\n  TooltipWrapperComponent.fac = function TooltipWrapperComponent_Factory(t) {\n    return new (t || TooltipWrapperComponent)();\n  };\n\n  TooltipWrapperComponent.cmp = core[\"Gb\" /* defineComponent */]({\n    type: TooltipWrapperComponent,\n    selectors: [[\"ng5-slider-tooltip-wrapper\"]],\n    inputs: {\n      template: \"template\",\n      tooltip: \"tooltip\",\n      placement: \"placement\",\n      content: \"content\"\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"ng5-slider-inner-tooltip\"]],\n    template: function TooltipWrapperComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        core[\"Bc\" /* template */](0, TooltipWrapperComponent_ng_container_0_Template, 2, 6, \"ng-container\", 0);\n        core[\"Bc\" /* template */](1, TooltipWrapperComponent_ng_container_1_Template, 3, 3, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        core[\"ic\" /* property */](\"ngIf\", ctx.template);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", !ctx.template);\n      }\n    },\n    directives: [common[\"l\" /* NgIf */], common[\"q\" /* NgTemplateOutlet */]],\n    styles: [\".ng5-slider-inner-tooltip[_ngcontent-%COMP%]{height:100%}\"]\n  });\n  return TooltipWrapperComponent;\n}();\n\nvar ng5_slider_Ng5SliderModule = /*@__PURE__*/function () {\n  var Ng5SliderModule = /*#__PURE__*/Object(createClass[\"a\" /* default */])(function Ng5SliderModule() {\n    Object(classCallCheck[\"a\" /* default */])(this, Ng5SliderModule);\n  });\n\n  Ng5SliderModule.fac = function Ng5SliderModule_Factory(t) {\n    return new (t || Ng5SliderModule)();\n  };\n\n  Ng5SliderModule.mod = core[\"Kb\" /* defineNgModule */]({\n    type: Ng5SliderModule\n  });\n  Ng5SliderModule.inj = core[\"Jb\" /* defineInjector */]({\n    imports: [[common[\"c\" /* CommonModule */]]]\n  });\n  return Ng5SliderModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"yc\" /* setNgModuleScope */](ng5_slider_Ng5SliderModule, {\n    declarations: function declarations() {\n      return [ng5_slider_SliderComponent, ng5_slider_SliderElementDirective, ng5_slider_SliderHandleDirective, ng5_slider_SliderLabelDirective, ng5_slider_TooltipWrapperComponent];\n    },\n    imports: function imports() {\n      return [common[\"c\" /* CommonModule */]];\n    },\n    exports: function exports() {\n      return [ng5_slider_SliderComponent];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n //# sourceMappingURL=ng5-slider.js.map\n// EXTERNAL MODULE: ./node_modules/@angular/animations/__ivy_ngcc__/fesm2015/animations.js\nvar animations = __webpack_require__(\"R0Ic\");\n\n// CONCATENATED MODULE: ./node_modules/ngx-bootstrap/__ivy_ngcc__/collapse/fesm2015/ngx-bootstrap-collapse.js\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\n\nvar COLLAPSE_ANIMATION_TIMING = '400ms cubic-bezier(0.4,0.0,0.2,1)';\n/** @type {?} */\n\nvar expandAnimation = [Object(animations[\"h\" /* style */])({\n  height: 0,\n  visibility: 'hidden'\n}), Object(animations[\"e\" /* animate */])(COLLAPSE_ANIMATION_TIMING, Object(animations[\"h\" /* style */])({\n  height: '*',\n  visibility: 'visible'\n}))];\n/** @type {?} */\n\nvar collapseAnimation = [Object(animations[\"h\" /* style */])({\n  height: '*',\n  visibility: 'visible'\n}), Object(animations[\"e\" /* animate */])(COLLAPSE_ANIMATION_TIMING, Object(animations[\"h\" /* style */])({\n  height: 0,\n  visibility: 'hidden'\n}))];\n\nvar ngx_bootstrap_collapse_CollapseDirective = /*@__PURE__*/function () {\n  var CollapseDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} _el\n     * @param {?} _renderer\n     * @param {?} _builder\n     */\n    function CollapseDirective(_el, _renderer, _builder) {\n      Object(classCallCheck[\"a\" /* default */])(this, CollapseDirective);\n\n      this._el = _el;\n      this._renderer = _renderer;\n      /**\n       * This event fires as soon as content collapses\n       */\n\n      this.collapsed = new core[\"n\" /* EventEmitter */]();\n      /**\n       * This event fires when collapsing is started\n       */\n\n      this.collapses = new core[\"n\" /* EventEmitter */]();\n      /**\n       * This event fires as soon as content becomes visible\n       */\n\n      this.expanded = new core[\"n\" /* EventEmitter */]();\n      /**\n       * This event fires when expansion is started\n       */\n\n      this.expands = new core[\"n\" /* EventEmitter */](); // shown\n\n      this.isExpanded = true;\n      this.collapseNewValue = true; // hidden\n\n      this.isCollapsed = false; // stale state\n\n      this.isCollapse = true; // animation state\n\n      this.isCollapsing = false;\n      /**\n       * turn on/off animation\n       */\n\n      this.isAnimated = false;\n      this._display = 'block';\n      this._stylesLoaded = false;\n      this._COLLAPSE_ACTION_NAME = 'collapse';\n      this._EXPAND_ACTION_NAME = 'expand';\n      this._factoryCollapseAnimation = _builder.build(collapseAnimation);\n      this._factoryExpandAnimation = _builder.build(expandAnimation);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    return Object(createClass[\"a\" /* default */])(CollapseDirective, [{\n      key: \"display\",\n      set: function set(value) {\n        if (!this.isAnimated) {\n          this._renderer.setStyle(this._el.nativeElement, 'display', value);\n\n          return;\n        }\n\n        this._display = value;\n\n        if (value === 'none') {\n          this.hide();\n          return;\n        }\n\n        this.show();\n      }\n      /**\n       * A flag indicating visibility of content (shown or hidden)\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"collapse\",\n      get:\n      /**\n       * @return {?}\n       */\n      function get() {\n        return this.isExpanded;\n      }\n      /**\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this.collapseNewValue = value;\n\n        if (!this._player || this._isAnimationDone) {\n          this.isExpanded = value;\n          this.toggle();\n        }\n      }\n    }, {\n      key: \"ngAfterViewChecked\",\n      value: function ngAfterViewChecked() {\n        this._stylesLoaded = true;\n\n        if (!this._player || !this._isAnimationDone) {\n          return;\n        }\n\n        this._player.reset();\n\n        this._renderer.setStyle(this._el.nativeElement, 'height', '*');\n      }\n      /**\n       * allows to manually toggle content visibility\n       * @return {?}\n       */\n\n    }, {\n      key: \"toggle\",\n      value: function toggle() {\n        if (this.isExpanded) {\n          this.hide();\n        } else {\n          this.show();\n        }\n      }\n      /**\n       * allows to manually hide content\n       * @return {?}\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this = this;\n\n        this.isCollapsing = true;\n        this.isExpanded = false;\n        this.isCollapsed = true;\n        this.isCollapsing = false;\n        this.collapses.emit(this);\n        this._isAnimationDone = false;\n        this.animationRun(this.isAnimated, this._COLLAPSE_ACTION_NAME)(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this._isAnimationDone = true;\n\n          if (_this.collapseNewValue !== _this.isCollapsed && _this.isAnimated) {\n            _this.show();\n\n            return;\n          }\n\n          _this.collapsed.emit(_this);\n\n          _this._renderer.setStyle(_this._el.nativeElement, 'display', 'none');\n        });\n      }\n      /**\n       * allows to manually show collapsed content\n       * @return {?}\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this2 = this;\n\n        this._renderer.setStyle(this._el.nativeElement, 'display', this._display);\n\n        this.isCollapsing = true;\n        this.isExpanded = true;\n        this.isCollapsed = false;\n        this.isCollapsing = false;\n        this.expands.emit(this);\n        this._isAnimationDone = false;\n        this.animationRun(this.isAnimated, this._EXPAND_ACTION_NAME)(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this2._isAnimationDone = true;\n\n          if (_this2.collapseNewValue !== _this2.isCollapsed && _this2.isAnimated) {\n            _this2.hide();\n\n            return;\n          }\n\n          _this2.expanded.emit(_this2);\n\n          _this2._renderer.removeStyle(_this2._el.nativeElement, 'overflow');\n        });\n      }\n      /**\n       * @param {?} isAnimated\n       * @param {?} action\n       * @return {?}\n       */\n\n    }, {\n      key: \"animationRun\",\n      value: function animationRun(isAnimated, action) {\n        var _this3 = this;\n\n        if (!isAnimated || !this._stylesLoaded) {\n          return (\n            /**\n            * @param {?} callback\n            * @return {?}\n            */\n            function (callback) {\n              return callback();\n            }\n          );\n        }\n\n        this._renderer.setStyle(this._el.nativeElement, 'overflow', 'hidden');\n\n        this._renderer.addClass(this._el.nativeElement, 'collapse');\n        /** @type {?} */\n\n\n        var factoryAnimation = action === this._EXPAND_ACTION_NAME ? this._factoryExpandAnimation : this._factoryCollapseAnimation;\n\n        if (this._player) {\n          this._player.destroy();\n        }\n\n        this._player = factoryAnimation.create(this._el.nativeElement);\n\n        this._player.play();\n\n        return (\n          /**\n          * @param {?} callback\n          * @return {?}\n          */\n          function (callback) {\n            return _this3._player.onDone(callback);\n          }\n        );\n      }\n    }]);\n  }();\n\n  CollapseDirective.fac = function CollapseDirective_Factory(t) {\n    return new (t || CollapseDirective)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"E\" /* Renderer2 */]), core[\"Mb\" /* directiveInject */](animations[\"b\" /* AnimationBuilder */]));\n  };\n\n  CollapseDirective.dir = core[\"Hb\" /* defineDirective */]({\n    type: CollapseDirective,\n    selectors: [[\"\", \"collapse\", \"\"]],\n    hostVars: 10,\n    hostBindings: function CollapseDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        core[\"Bb\" /* attribute */](\"aria-expanded\", ctx.isExpanded)(\"aria-hidden\", ctx.isCollapsed);\n        core[\"Eb\" /* classProp */](\"collapse\", ctx.isCollapse)(\"in\", ctx.isExpanded)(\"show\", ctx.isExpanded)(\"collapsing\", ctx.isCollapsing);\n      }\n    },\n    inputs: {\n      isAnimated: \"isAnimated\",\n      display: \"display\",\n      collapse: \"collapse\"\n    },\n    outputs: {\n      collapsed: \"collapsed\",\n      collapses: \"collapses\",\n      expanded: \"expanded\",\n      expands: \"expands\"\n    },\n    exportAs: [\"bs-collapse\"]\n  });\n  return CollapseDirective;\n}();\n\nif (false) {}\n\nvar ngx_bootstrap_collapse_CollapseModule = /*@__PURE__*/function () {\n  var CollapseModule = /*#__PURE__*/function () {\n    function CollapseModule() {\n      Object(classCallCheck[\"a\" /* default */])(this, CollapseModule);\n    }\n\n    return Object(createClass[\"a\" /* default */])(CollapseModule, null, [{\n      key: \"forRoot\",\n      value:\n      /**\n       * @return {?}\n       */\n      function forRoot() {\n        return {\n          ngModule: CollapseModule,\n          providers: []\n        };\n      }\n    }]);\n  }();\n\n  CollapseModule.fac = function CollapseModule_Factory(t) {\n    return new (t || CollapseModule)();\n  };\n\n  CollapseModule.mod = core[\"Kb\" /* defineNgModule */]({\n    type: CollapseModule\n  });\n  CollapseModule.inj = core[\"Jb\" /* defineInjector */]({});\n  return CollapseModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"yc\" /* setNgModuleScope */](ngx_bootstrap_collapse_CollapseModule, {\n    declarations: [ngx_bootstrap_collapse_CollapseDirective],\n    exports: [ngx_bootstrap_collapse_CollapseDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\n //# sourceMappingURL=ngx-bootstrap-collapse.js.map\n// EXTERNAL MODULE: ./node_modules/ng-lazyload-image/__ivy_ngcc__/fesm2015/ng-lazyload-image.js + 2 modules\nvar ng_lazyload_image = __webpack_require__(\"wf0l\");\n\n// EXTERNAL MODULE: ./src/app/frontend/sanitizehtmlpipe/index.ts + 1 modules\nvar sanitizehtmlpipe = __webpack_require__(\"grbu\");\n\n// EXTERNAL MODULE: ./src/app/frontend/modules/heading-box-page/heading-box-page.module.ts\nvar heading_box_page_module = __webpack_require__(\"WEVr\");\n\n// EXTERNAL MODULE: ./src/app/frontend/modules/box-asidebar-left/box-asidebar-left.module.ts\nvar box_asidebar_left_module = __webpack_require__(\"IXfK\");\n\n// EXTERNAL MODULE: ./src/app/frontend/modules/box-content/index.ts + 1 modules\nvar box_content = __webpack_require__(\"u37Z\");\n\n// EXTERNAL MODULE: ./src/app/frontend/modules/box-breadcrumb/box-header-page.module.ts\nvar box_header_page_module = __webpack_require__(\"n8hT\");\n\n// EXTERNAL MODULE: ./src/app/frontend/modules/box-loading/box-loading.module.ts\nvar box_loading_module = __webpack_require__(\"oHwy\");\n\n// EXTERNAL MODULE: ./src/app/frontend/modules/button-back/button-back.module.ts\nvar button_back_module = __webpack_require__(\"jnmN\");\n\n// EXTERNAL MODULE: ./src/app/frontend/modules/sidebar-news/sidebar-news.module.ts\nvar sidebar_news_module = __webpack_require__(\"q2mU\");\n\n// EXTERNAL MODULE: ./src/app/services/integrated/table.service.ts + 1 modules\nvar table_service = __webpack_require__(\"s+OP\");\n\n// EXTERNAL MODULE: ./src/app/services/integrated/toslug.service.ts\nvar toslug_service = __webpack_require__(\"DZKH\");\n\n// EXTERNAL MODULE: ./src/app/globals.ts\nvar app_globals = __webpack_require__(\"xa+l\");\n\n// EXTERNAL MODULE: ./src/app/frontend/modules/box-product/box-product.component.ts\nvar box_product_component = __webpack_require__(\"L65D\");\n\n// CONCATENATED MODULE: ./src/app/frontend/products/getlist/list.component.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar list_component_c0 = function (a0, a1) { return { \"fa-chevron-right\": a0, \"fa-chevron-down\": a1 }; };\nfunction ListProductComponent_li_24_i_4_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Nb\" /* element */](0, \"i\", 33);\n    }\n    if (rf & 2) {\n        var item_r5 = core[\"bc\" /* nextContext */]().$implicit;\n        var ctx_r6 = core[\"bc\" /* nextContext */]();\n        core[\"ic\" /* property */](\"ngClass\", core[\"nc\" /* pureFunction2 */](1, list_component_c0, ctx_r6.collapsedMenu.includes(item_r5.id) == true, ctx_r6.collapsedMenu.includes(item_r5.id) == false));\n    }\n}\nvar list_component_c1 = function (a0) { return [a0]; };\nfunction ListProductComponent_li_24_li_6_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"li\", 34);\n        core[\"Sb\" /* elementStart */](1, \"div\", 35);\n        core[\"Sb\" /* elementStart */](2, \"div\", 36);\n        core[\"Dc\" /* text */](3);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var row_r9 = ctx.$implicit;\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"routerLink\", core[\"mc\" /* pureFunction1 */](2, list_component_c1, \"/san-pham/\" + row_r9.link));\n        core[\"Ab\" /* advance */](2);\n        core[\"Fc\" /* textInterpolate1 */](\" \", row_r9.name, \" \");\n    }\n}\nvar list_component_c2 = function (a0) { return { \"active\": a0 }; };\nfunction ListProductComponent_li_24_Template(rf, ctx) {\n    if (rf & 1) {\n        var _r11 = core[\"Tb\" /* getCurrentView */]();\n        core[\"Sb\" /* elementStart */](0, \"li\");\n        core[\"Sb\" /* elementStart */](1, \"div\", 29);\n        core[\"Zb\" /* listener */](\"click\", function ListProductComponent_li_24_Template_div_click_1_listener() { core[\"vc\" /* restoreView */](_r11); var item_r5 = ctx.$implicit; var ctx_r10 = core[\"bc\" /* nextContext */](); return ctx_r10.collapseMenu(item_r5.id); });\n        core[\"Sb\" /* elementStart */](2, \"div\");\n        core[\"Dc\" /* text */](3);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Bc\" /* template */](4, ListProductComponent_li_24_i_4_Template, 1, 4, \"i\", 30);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](5, \"ul\", 31);\n        core[\"Bc\" /* template */](6, ListProductComponent_li_24_li_6_Template, 4, 4, \"li\", 32);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var item_r5 = ctx.$implicit;\n        var ctx_r0 = core[\"bc\" /* nextContext */]();\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"routerLink\", core[\"mc\" /* pureFunction1 */](7, list_component_c1, \"/san-pham/\" + item_r5.link))(\"ngClass\", core[\"mc\" /* pureFunction1 */](9, list_component_c2, ctx_r0.collapsedMenu.includes(item_r5.id) == false));\n        core[\"Ab\" /* advance */](2);\n        core[\"Ec\" /* textInterpolate */](item_r5.name);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", item_r5.data && +item_r5.data.length > 0);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"collapse\", ctx_r0.collapsedMenu.includes(item_r5.id) == true)(\"isAnimated\", true);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngForOf\", item_r5.data);\n    }\n}\nvar list_component_c3 = function (a0) { return { count: a0 }; };\nfunction ListProductComponent_div_37_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 37);\n        core[\"Dc\" /* text */](1);\n        core[\"cc\" /* pipe */](2, \"translate\");\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var ctx_r1 = core[\"bc\" /* nextContext */]();\n        core[\"Ab\" /* advance */](1);\n        core[\"Fc\" /* textInterpolate1 */](\" \", core[\"ec\" /* pipeBind2 */](2, 1, \"FEProduct.count\", core[\"mc\" /* pureFunction1 */](4, list_component_c3, ctx_r1.count)), \" \");\n    }\n}\nfunction ListProductComponent_div_39_Template(rf, ctx) {\n    if (rf & 1) {\n        var _r15 = core[\"Tb\" /* getCurrentView */]();\n        core[\"Sb\" /* elementStart */](0, \"div\", 38);\n        core[\"Sb\" /* elementStart */](1, \"span\", 39);\n        core[\"Dc\" /* text */](2);\n        core[\"cc\" /* pipe */](3, \"translate\");\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](4, \"button\", 40);\n        core[\"Zb\" /* listener */](\"click\", function ListProductComponent_div_39_Template_button_click_4_listener() { core[\"vc\" /* restoreView */](_r15); var col_r12 = ctx.$implicit; var ctx_r14 = core[\"bc\" /* nextContext */](); return ctx_r14.cwstable._sorting(col_r12.field, \"desc\"); });\n        core[\"Nb\" /* element */](5, \"i\", 41);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](6, \"button\", 42);\n        core[\"Zb\" /* listener */](\"click\", function ListProductComponent_div_39_Template_button_click_6_listener() { core[\"vc\" /* restoreView */](_r15); var col_r12 = ctx.$implicit; var ctx_r16 = core[\"bc\" /* nextContext */](); return ctx_r16.cwstable._sorting(col_r12.field, \"asc\"); });\n        core[\"Nb\" /* element */](7, \"i\", 43);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var col_r12 = ctx.$implicit;\n        core[\"Ab\" /* advance */](2);\n        core[\"Fc\" /* textInterpolate1 */](\"\", core[\"dc\" /* pipeBind1 */](3, 1, col_r12.title), \":\");\n    }\n}\nfunction ListProductComponent_div_40_div_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 48);\n        core[\"Nb\" /* element */](1, \"app-box-product\", 49);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var item_r20 = ctx.$implicit;\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"item\", item_r20);\n    }\n}\nfunction ListProductComponent_div_40_div_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 50);\n        core[\"Sb\" /* elementStart */](1, \"h4\");\n        core[\"Dc\" /* text */](2);\n        core[\"cc\" /* pipe */](3, \"translate\");\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        core[\"Ab\" /* advance */](2);\n        core[\"Ec\" /* textInterpolate */](core[\"dc\" /* pipeBind1 */](3, 1, \"FEProduct.NotHaveProduct\"));\n    }\n}\nfunction ListProductComponent_div_40_div_3_Template(rf, ctx) {\n    if (rf & 1) {\n        var _r22 = core[\"Tb\" /* getCurrentView */]();\n        core[\"Sb\" /* elementStart */](0, \"div\", 51);\n        core[\"Sb\" /* elementStart */](1, \"pagination\", 52);\n        core[\"Zb\" /* listener */](\"pageChanged\", function ListProductComponent_div_40_div_3_Template_pagination_pageChanged_1_listener($event) { core[\"vc\" /* restoreView */](_r22); var ctx_r21 = core[\"bc\" /* nextContext */](2); return ctx_r21.Pagination.change($event); });\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var ctx_r19 = core[\"bc\" /* nextContext */](2);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"directionLinks\", false)(\"totalItems\", ctx_r19.cwstable.cached.length)(\"itemsPerPage\", ctx_r19.Pagination.itemsPerPage)(\"maxSize\", ctx_r19.Pagination.maxSize);\n    }\n}\nfunction ListProductComponent_div_40_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 44);\n        core[\"Bc\" /* template */](1, ListProductComponent_div_40_div_1_Template, 2, 1, \"div\", 45);\n        core[\"Bc\" /* template */](2, ListProductComponent_div_40_div_2_Template, 4, 3, \"div\", 46);\n        core[\"Bc\" /* template */](3, ListProductComponent_div_40_div_3_Template, 2, 4, \"div\", 47);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var ctx_r3 = core[\"bc\" /* nextContext */]();\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngForOf\", ctx_r3.cwstable.data);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", !ctx_r3.cwstable.data || ctx_r3.cwstable.data.length == 0);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx_r3.cwstable.cached.length > ctx_r3.Pagination.itemsPerPage);\n    }\n}\nfunction ListProductComponent_div_41_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 12);\n        core[\"Sb\" /* elementStart */](1, \"div\", 50);\n        core[\"Sb\" /* elementStart */](2, \"h4\");\n        core[\"Dc\" /* text */](3);\n        core[\"cc\" /* pipe */](4, \"translate\");\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        core[\"Ab\" /* advance */](3);\n        core[\"Ec\" /* textInterpolate */](core[\"dc\" /* pipeBind1 */](4, 1, \"FEProduct.NotHaveProduct\"));\n    }\n}\nvar list_component_c4 = function () { return [\"/\"]; };\nvar list_component_c5 = function () { return { exact: true }; };\nvar list_component_ListProductComponent = /** @class */ /*@__PURE__*/ /*@__PURE__*/ (function () {\n    function ListProductComponent(globals, route, router, toSlug, translate) {\n        var _this = this;\n        this.globals = globals;\n        this.route = route;\n        this.router = router;\n        this.toSlug = toSlug;\n        this.translate = translate;\n        this.cwstable = new table_service[\"a\" /* TableService */]();\n        this.searchValue = \"\";\n        this.show = -1;\n        this.price = { min: 0, max: 0 };\n        this.page = {};\n        this.data = [];\n        this.categories = [];\n        this.cateListId = [];\n        this.token = {\n            getProduct: \"api/product/getproduct\",\n            getLink: \"api/product/getlink\",\n            productCategory: \"api/home/getcategories\",\n        };\n        this.width = document.body.getBoundingClientRect().width;\n        this.collapsedMenu = [];\n        this.openMobileFilter = false;\n        this.count = 0;\n        this.cols = [\n            { title: 'FEProduct.sortName', field: 'name', filter: true, active: true },\n            { title: 'FEProduct.sortPrice', field: 'price', filter: true, type: 'number' },\n        ];\n        this.minValue = 0;\n        this.maxValue = 100;\n        this.options = {\n            floor: 0,\n            ceil: 100,\n            translate: function (value, label) {\n                switch (label) {\n                    case LabelType.Low:\n                        return '<b style=\"font-size:12px\">Min: ' + _this.setnumber(value) + '  </b>';\n                    case LabelType.High:\n                        return '<b style=\"font-size:12px\">Max: ' + _this.setnumber(value) + '  </b>';\n                    default:\n                        return _this.setnumber(value);\n                }\n            }\n        };\n        this.Pagination = {\n            maxSize: 5,\n            itemsPerPage: 16,\n            change: function (event) {\n                var startItem = (event.page - 1) * event.itemsPerPage;\n                var endItem = event.page * event.itemsPerPage;\n                _this.cwstable.data = _this.cwstable.cached.slice(startItem, endItem);\n                var el = document.getElementById('ListData');\n                window.scrollTo({\n                    top: 0,\n                    left: 0,\n                    behavior: 'smooth'\n                });\n            }\n        };\n        this.extract = function () {\n            var brand = {};\n            var group = {};\n            var price = { min: 0, max: 0 };\n            if (_this.cwstable.cachedList.length > 0) {\n                price.min = (+_this.cwstable.cachedList[0].price_sale > 0) ? +_this.cwstable.cachedList[0].price_sale : +_this.cwstable.cachedList[0].price;\n                _this.cwstable.cachedList.reduce(function (n, o, i) {\n                    if (o.brand_id && +o.brand_id > 0) {\n                        if (!brand[o.brand_id]) {\n                            brand[o.brand_id] = { id: o.brand_id, name: o.brand_name, count: 0 };\n                        }\n                        if (brand[o.brand_id]) {\n                            brand[o.brand_id].count = +brand[o.brand_id].count + 1;\n                        }\n                    }\n                    if (o.page_id && +o.page_id > 0) {\n                        if (!group[o.page_id]) {\n                            group[o.page_id] = { id: o.page_id, name: o.parent_name, count: 0 };\n                        }\n                        if (group[o.page_id]) {\n                            group[o.page_id].count = +group[o.page_id].count + 1;\n                        }\n                    }\n                    var p = (+o.price_sale > 0) ? +o.price_sale : +o.price;\n                    price.min = p < price.min ? p : price.min;\n                    price.max = p > price.max ? p : price.max;\n                    _this.changeOptions({\n                        floor: 0,\n                        ceil: price.max\n                    });\n                    return n;\n                }, {});\n                _this.price = price;\n            }\n        };\n        this.groupCategory = {\n            data: [],\n            value: [],\n            filter: function (id, skip) {\n                if (skip === void 0) {\n                    skip = 0;\n                }\n                var token = \"page_id\";\n                var filter = _this.cwstable._getFilter(token);\n                var data = !filter.value ? {} : filter.value.reduce(function (n, o) {\n                    n[o] = o;\n                    return n;\n                }, {});\n                if (data[id]) {\n                    _this.groupCategory.value = filter.value.filter(function (item) {\n                        if (skip == 1) {\n                            return true;\n                        }\n                        else {\n                            return +item == id ? false : true;\n                        }\n                    });\n                }\n                else {\n                    _this.groupCategory.value.push(id);\n                }\n                if (_this.groupCategory.value.length == 0) {\n                    _this.cwstable._delFilter(token);\n                }\n                else {\n                    _this.cwstable._setFilter(token, _this.groupCategory.value, 'in');\n                }\n            },\n        };\n        this.connect = this.globals.result.subscribe(function (res) {\n            switch (res.token) {\n                case \"getProduct\":\n                    _this.data = [];\n                    _this.count = -1;\n                    console.log(\" ~ file: list.component.ts:74 ~ ListProductComponent ~ this.connect=this.globals.result.subscribe ~ this.count:\", _this.count);\n                    if (res.data.length > 0) {\n                        _this.data = res.data.filter(function (o) { return o.price_actual = +o.price_sale && +o.price_sale > 0 ? +o.price_sale : +o.price; });\n                    }\n                    _this.show = _this.data && _this.data.length > 0 ? 1 : 0;\n                    _this.count = _this.data && _this.data.length > 0 ? _this.data.length : 0;\n                    console.log(\" ~ file: list.component.ts:79 ~ ListProductComponent ~ this.connect=this.globals.result.subscribe ~ this.count:\", _this.count);\n                    _this.cwstable._concat(_this.data, true);\n                    _this.extract();\n                    setTimeout(function () {\n                        _this.catFilter(_this.data.id);\n                    }, 50);\n                    break;\n                case \"getLink\":\n                    _this.page = {};\n                    _this.page = res.data;\n                    break;\n                case \"productCategory\":\n                    _this.categories = _this.compaid(res.data);\n                    _this.cateListId = res.data.reduce(function (n, o) {\n                        n[o.id] = o;\n                        return n;\n                    }, []);\n                    break;\n                default:\n                    break;\n            }\n        });\n    }\n    ListProductComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.globals.send({ path: this.token.productCategory, token: \"productCategory\", });\n        this.cwstable._ini({\n            data: [], cols: this.cols, keyword: \"getProduct\", count: this.Pagination.itemsPerPage, sorting: { field: \"name\", sort: \"\", type: \"number\" },\n        });\n        this.route.params.subscribe(function (params) {\n            _this.data = [];\n            _this.count = -1;\n            _this.globals.send({ path: _this.token.getLink, token: 'getLink', params: { link: params.links && params.links.length > 0 ? params.links : (params.link || 'san-pham') } });\n            if ((params.link && params.link.length > 0) || (params.links && params.links.length > 0)) {\n                _this.globals.send({ path: _this.token.getProduct, token: 'getProduct', params: { link: params.links && params.links.length > 0 ? params.links : params.link } });\n            }\n            else {\n                _this.globals.send({ path: _this.token.getProduct, token: 'getProduct' });\n            }\n        });\n    };\n    ListProductComponent.prototype.ngOnChanges = function (e) { };\n    ListProductComponent.prototype.catFilter = function (id) {\n        var _this = this;\n        if (this.cateListId[+id] && this.cateListId[+id].length > 0) {\n            this.cateListId[+id].filter(function (res) {\n                _this.groupCategory.filter(res.id, 1);\n            });\n        }\n        else if (+id < 3 || +id > 4) {\n            this.groupCategory.filter(id, 1);\n        }\n    };\n    ListProductComponent.prototype.changeOptions = function (option) {\n        var newOptions = Object.assign({}, this.options);\n        newOptions.ceil = option.ceil;\n        newOptions.floor = option.floor;\n        this.options = newOptions;\n        this.minValue = option.floor;\n        this.maxValue = option.ceil;\n    };\n    ListProductComponent.prototype.onUserChangeEnd = function (changeContext) {\n        this.cwstable._setFilter('price_actual', [changeContext.value, changeContext.highValue], 'between');\n    };\n    ListProductComponent.prototype.setnumber = function (Val) {\n        var a = new Number(Val);\n        return a.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \".\");\n    };\n    ListProductComponent.prototype.collapseMenu = function (id) {\n        if (this.collapsedMenu.includes(id) === true) {\n            var index = this.collapsedMenu.indexOf(id);\n            this.collapsedMenu.splice(index, 1);\n        }\n        else {\n            this.collapsedMenu.push(id);\n        }\n    };\n    ListProductComponent.prototype.setMenuMobile = function (open) {\n        var list = document.getElementsByTagName('body')[0];\n        this.openMobileFilter = open;\n        list.style.position = open ? 'fixed' : 'inherit';\n    };\n    ListProductComponent.prototype.compaid = function (data) {\n        var list = [];\n        var _loop_1 = function (i) {\n            data = data.filter(function (item) {\n                var v = (+item.page_id == +data[i]['id']) ? +item.page_id : 0;\n                v == 0 ? '' : list.push(item);\n                return v == 0 ? true : false;\n            });\n        };\n        for (var i = 0; i < data.length; i++) {\n            _loop_1(i);\n        }\n        ;\n        var compaidmenu = function (data, skip, level) {\n            if (level === void 0) {\n                level = 0;\n            }\n            level = level + 1;\n            if (skip == true) {\n                return data;\n            }\n            else {\n                var _loop_2 = function (i) {\n                    var obj = [];\n                    list = list.filter(function (item) {\n                        var skip = (+item.page_id == +data[i]['id']) ? false : true;\n                        if (data[i].page_id > 0 && +item.page_id == +data[i]['id']) {\n                            data[i].static = true;\n                        }\n                        if (skip == false) {\n                            obj.push(item);\n                        }\n                        return skip;\n                    });\n                    var skip_1 = (obj.length == 0) ? true : false;\n                    data[i]['level'] = level;\n                    data[i]['data'] = compaidmenu(obj, skip_1, level);\n                };\n                for (var i = 0; i < data.length; i++) {\n                    _loop_2(i);\n                }\n                return data;\n            }\n        };\n        return compaidmenu(data, false);\n    };\n    ListProductComponent.fac = function ListProductComponent_Factory(t) { return new (t || ListProductComponent)(core[\"Mb\" /* directiveInject */](app_globals[\"a\" /* Globals */]), core[\"Mb\" /* directiveInject */](fesm2015_router[\"a\" /* ActivatedRoute */]), core[\"Mb\" /* directiveInject */](fesm2015_router[\"c\" /* Router */]), core[\"Mb\" /* directiveInject */](toslug_service[\"a\" /* ToslugService */]), core[\"Mb\" /* directiveInject */](ngx_translate_core[\"e\" /* TranslateService */])); };\n    ListProductComponent.cmp = core[\"Gb\" /* defineComponent */]({ type: ListProductComponent, selectors: [[\"app-product\"]], features: [core[\"zb\" /* ProvidersFeature */]([toslug_service[\"a\" /* ToslugService */]]), core[\"yb\" /* NgOnChangesFeature */]], decls: 42, vars: 23, consts: [[1, \"bg-light\", \"py-md-5\", \"py-3\"], [1, \"container-main\"], [1, \"container-fluid\"], [1, \"title-page\"], [1, \"d-md-flex\", \"align-items-center\", \"justify-content-between\"], [1, \"mb-0\", \"text-uppercase\"], [\"aria-label\", \"breadcrumb\"], [1, \"breadcrumb\", \"bg-transparent\", \"border-0\", \"m-0\", \"p-0\"], [\"aria-current\", \"page\", 1, \"breadcrumb-item\"], [\"routerLinkActive\", \"router-link-active\", 3, \"routerLink\"], [\"routerLinkActive\", \"is--active\", 3, \"routerLink\", \"routerLinkActiveOptions\"], [\"id\", \"list-product\", 1, \"bg-light\"], [1, \"row\"], [1, \"col-3\", \"d-none\", \"d-md-block\"], [1, \"card\", \"rounded-0\", \"border-0\"], [1, \"pl-0\", \"mb-0\"], [4, \"ngFor\", \"ngForOf\"], [1, \"card\", \"mt-2\", \"rounded-0\", \"border-0\"], [1, \"title\", \"p-3\", \"d-flex\", \"justify-content-between\"], [1, \"card-body\", \"p-2\"], [3, \"value\", \"highValue\", \"options\", \"userChangeEnd\", \"valueChange\", \"highValueChange\"], [1, \"col-12\", \"col-md-9\", \"pb-4\"], [1, \"d-flex\", \"justify-content-between\", \"align-items-center\", \"w-100\", \"bg-white\", \"p-2\", \"mb-3\"], [1, \"d-flex\", \"align-items-center\", \"justify-content-between\"], [\"style\", \"color: #595959\", 4, \"ngIf\"], [1, \"d-none\", \"d-md-flex\", \"align-items-center\", \"justify-content-between\"], [\"class\", \"mr-md-3 d-flex align-items-center\", 4, \"ngFor\", \"ngForOf\"], [\"id\", \"ListData\", \"class\", \"row px-2\", 4, \"ngIf\"], [\"class\", \"row\", 4, \"ngIf\"], [\"routerLinkActive\", \"router-link-active\", 1, \"title\", \"p-3\", \"d-flex\", \"justify-content-between\", 3, \"routerLink\", \"ngClass\", \"click\"], [\"class\", \"fas\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"pl-1\", 3, \"collapse\", \"isAnimated\"], [\"class\", \"px-3 pb-3\", \"style\", \"overflow:hidden\", 4, \"ngFor\", \"ngForOf\"], [1, \"fas\", 3, \"ngClass\"], [1, \"px-3\", \"pb-3\", 2, \"overflow\", \"hidden\"], [\"routerLinkActive\", \"router-link-active\", 1, \"d-flex\", \"align-items-center\", \"justify-content-between\", 3, \"routerLink\"], [1, \"item-title\"], [2, \"color\", \"#595959\"], [1, \"mr-md-3\", \"d-flex\", \"align-items-center\"], [1, \"mr-1\"], [1, \"btn\", \"btn-sm\", \"rounded\", \"mr-2\", \"border\", \"px-2\", \"py-1\", 3, \"click\"], [1, \"fas\", \"fa-sort-amount-down\"], [1, \"btn\", \"btn-sm\", \"border\", \"rounded\", \"px-2\", \"py-1\", 3, \"click\"], [1, \"fas\", \"fa-sort-amount-up\"], [\"id\", \"ListData\", 1, \"row\", \"px-2\"], [\"class\", \"col-lg-3 col-md-4 col-6 px-2 mb-4\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"col-12 text-center pt-4 pb-4\", 4, \"ngIf\"], [\"class\", \"col-12\", 4, \"ngIf\"], [1, \"col-lg-3\", \"col-md-4\", \"col-6\", \"px-2\", \"mb-4\"], [3, \"item\"], [1, \"col-12\", \"text-center\", \"pt-4\", \"pb-4\"], [1, \"col-12\"], [1, \"d-flex\", \"justify-content-end\", \"pt-lg-4\", 3, \"directionLinks\", \"totalItems\", \"itemsPerPage\", \"maxSize\", \"pageChanged\"]], template: function ListProductComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Sb\" /* elementStart */](0, \"div\", 0);\n                core[\"Sb\" /* elementStart */](1, \"div\", 1);\n                core[\"Sb\" /* elementStart */](2, \"div\", 2);\n                core[\"Sb\" /* elementStart */](3, \"div\", 3);\n                core[\"Sb\" /* elementStart */](4, \"div\", 4);\n                core[\"Sb\" /* elementStart */](5, \"h4\", 5);\n                core[\"Dc\" /* text */](6);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](7, \"nav\", 6);\n                core[\"Sb\" /* elementStart */](8, \"ol\", 7);\n                core[\"Sb\" /* elementStart */](9, \"li\", 8);\n                core[\"Sb\" /* elementStart */](10, \"a\", 9);\n                core[\"Dc\" /* text */](11);\n                core[\"cc\" /* pipe */](12, \"translate\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](13, \"li\", 8);\n                core[\"Sb\" /* elementStart */](14, \"a\", 10);\n                core[\"Dc\" /* text */](15);\n                core[\"cc\" /* pipe */](16, \"translate\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](17, \"div\", 11);\n                core[\"Sb\" /* elementStart */](18, \"div\", 1);\n                core[\"Sb\" /* elementStart */](19, \"div\", 2);\n                core[\"Sb\" /* elementStart */](20, \"div\", 12);\n                core[\"Sb\" /* elementStart */](21, \"div\", 13);\n                core[\"Sb\" /* elementStart */](22, \"div\", 14);\n                core[\"Sb\" /* elementStart */](23, \"ul\", 15);\n                core[\"Bc\" /* template */](24, ListProductComponent_li_24_Template, 7, 11, \"li\", 16);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](25, \"div\", 17);\n                core[\"Sb\" /* elementStart */](26, \"ul\", 15);\n                core[\"Sb\" /* elementStart */](27, \"li\");\n                core[\"Sb\" /* elementStart */](28, \"div\", 18);\n                core[\"Sb\" /* elementStart */](29, \"div\");\n                core[\"Dc\" /* text */](30);\n                core[\"cc\" /* pipe */](31, \"translate\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](32, \"div\", 19);\n                core[\"Sb\" /* elementStart */](33, \"ng5-slider\", 20);\n                core[\"Zb\" /* listener */](\"userChangeEnd\", function ListProductComponent_Template_ng5_slider_userChangeEnd_33_listener($event) { return ctx.onUserChangeEnd($event); })(\"valueChange\", function ListProductComponent_Template_ng5_slider_valueChange_33_listener($event) { return ctx.minValue = $event; })(\"highValueChange\", function ListProductComponent_Template_ng5_slider_highValueChange_33_listener($event) { return ctx.maxValue = $event; });\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](34, \"div\", 21);\n                core[\"Sb\" /* elementStart */](35, \"div\", 22);\n                core[\"Sb\" /* elementStart */](36, \"div\", 23);\n                core[\"Bc\" /* template */](37, ListProductComponent_div_37_Template, 3, 6, \"div\", 24);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](38, \"div\", 25);\n                core[\"Bc\" /* template */](39, ListProductComponent_div_39_Template, 8, 3, \"div\", 26);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Bc\" /* template */](40, ListProductComponent_div_40_Template, 4, 3, \"div\", 27);\n                core[\"Bc\" /* template */](41, ListProductComponent_div_41_Template, 5, 3, \"div\", 28);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"Ab\" /* advance */](6);\n                core[\"Ec\" /* textInterpolate */](ctx.page.name);\n                core[\"Ab\" /* advance */](4);\n                core[\"ic\" /* property */](\"routerLink\", core[\"lc\" /* pureFunction0 */](21, list_component_c4));\n                core[\"Ab\" /* advance */](1);\n                core[\"Fc\" /* textInterpolate1 */](\" \", core[\"dc\" /* pipeBind1 */](12, 15, \"lblHome\"), \" \");\n                core[\"Ab\" /* advance */](3);\n                core[\"ic\" /* property */](\"routerLink\", \"/san-pham/\")(\"routerLinkActiveOptions\", core[\"lc\" /* pureFunction0 */](22, list_component_c5));\n                core[\"Ab\" /* advance */](1);\n                core[\"Fc\" /* textInterpolate1 */](\" \", core[\"dc\" /* pipeBind1 */](16, 17, \"FEProduct.product\"), \" \");\n                core[\"Ab\" /* advance */](9);\n                core[\"ic\" /* property */](\"ngForOf\", ctx.categories);\n                core[\"Ab\" /* advance */](6);\n                core[\"Ec\" /* textInterpolate */](core[\"dc\" /* pipeBind1 */](31, 19, \"FEProduct.price\"));\n                core[\"Ab\" /* advance */](3);\n                core[\"ic\" /* property */](\"value\", ctx.minValue)(\"highValue\", ctx.maxValue)(\"options\", ctx.options);\n                core[\"Ab\" /* advance */](4);\n                core[\"ic\" /* property */](\"ngIf\", ctx.count > -1);\n                core[\"Ab\" /* advance */](2);\n                core[\"ic\" /* property */](\"ngForOf\", ctx.cwstable.cols);\n                core[\"Ab\" /* advance */](1);\n                core[\"ic\" /* property */](\"ngIf\", ctx.show == 1);\n                core[\"Ab\" /* advance */](1);\n                core[\"ic\" /* property */](\"ngIf\", ctx.show == 0);\n            }\n        }, directives: [fesm2015_router[\"f\" /* RouterLinkWithHref */], fesm2015_router[\"e\" /* RouterLinkActive */], common[\"k\" /* NgForOf */], ng5_slider_SliderComponent, common[\"l\" /* NgIf */], fesm2015_router[\"d\" /* RouterLink */], common[\"j\" /* NgClass */], ngx_bootstrap_collapse_CollapseDirective, box_product_component[\"a\" /* BoxProductComponent */], ngx_bootstrap_pagination[\"a\" /* PaginationComponent */]], pipes: [ngx_translate_core[\"d\" /* TranslatePipe */]], styles: [\"ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{list-style:none}.title[_ngcontent-%COMP%]{font-size:.95rem;cursor:pointer}.btn[_ngcontent-%COMP%]:focus{color:#e24861}.active[_ngcontent-%COMP%], .item-title[_ngcontent-%COMP%]:hover, input[_ngcontent-%COMP%]{cursor:pointer}#mobile-filter[_ngcontent-%COMP%]{height:100%;width:100%;position:fixed;z-index:9999;top:0;left:0;background-color:rgba(0,0,0,.6);overflow-x:hidden;transition:.5s}#mobile-filter[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{position:relative;top:0;width:100%;text-align:center}\"] });\n    return ListProductComponent;\n}());\n\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/http.js\nvar http = __webpack_require__(\"tk/3\");\n\n// CONCATENATED MODULE: ./src/app/services/product/product.service.ts\n\n\n\nvar product_service_ProductService = /** @class */ /*@__PURE__*/ /*@__PURE__*/ (function () {\n    function ProductService(http, globals) {\n        this.http = http;\n        this.globals = globals;\n    }\n    ProductService.prototype.getDetail = function (params) {\n        if (params === void 0) {\n            params = {};\n        }\n        return this.http.get(this.globals.BASE_API_URL + 'api/product/getdetail' + this.globals._params.process(params), this.globals.headersReject).pipe();\n    };\n    ProductService.fac = function ProductService_Factory(t) { return new (t || ProductService)(core[\"Wb\" /* inject */](http[\"b\" /* HttpClient */]), core[\"Wb\" /* inject */](app_globals[\"a\" /* Globals */])); };\n    ProductService.prov = core[\"Ib\" /* defineInjectable */]({ token: ProductService, factory: ProductService.fac, providedIn: 'root' });\n    return ProductService;\n}());\n\n\n// EXTERNAL MODULE: ./src/app/services/apicart/cart.service.ts\nvar cart_service = __webpack_require__(\"a9SS\");\n\n// EXTERNAL MODULE: ./src/app/services/home/home.service.ts\nvar home_service = __webpack_require__(\"tMUy\");\n\n// EXTERNAL MODULE: ./src/app/services/modules/footer.service.ts\nvar footer_service = __webpack_require__(\"nSbU\");\n\n// EXTERNAL MODULE: ./src/app/services/sanitizeHtml.pipe.ts\nvar sanitizeHtml_pipe = __webpack_require__(\"NqMM\");\n\n// CONCATENATED MODULE: ./src/app/frontend/products/detail/detail.component.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar detail_component_c0 = [\"owlLibrary\"];\nvar detail_component_c1 = function (a0) { return [a0]; };\nfunction DetailProductComponent_div_22_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\");\n        core[\"Sb\" /* elementStart */](1, \"div\");\n        core[\"Sb\" /* elementStart */](2, \"a\", 51);\n        core[\"Nb\" /* element */](3, \"img\", 52);\n        core[\"cc\" /* pipe */](4, \"translate\");\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var ctx_r0 = core[\"bc\" /* nextContext */]();\n        core[\"Ab\" /* advance */](2);\n        core[\"ic\" /* property */](\"routerLink\", core[\"mc\" /* pureFunction1 */](8, detail_component_c1, \"/san-pham/\" + ctx_r0.item.href + \"/\" + ctx_r0.item.link));\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"routerLink\", core[\"mc\" /* pureFunction1 */](10, detail_component_c1, \"/san-pham/\" + ctx_r0.item.href + \"/\" + ctx_r0.item.link))(\"defaultImage\", core[\"dc\" /* pipeBind1 */](4, 6, \"FEImagesProduct\"))(\"lazyLoad\", ctx_r0.item.images)(\"title\", ctx_r0.item.name)(\"alt\", ctx_r0.item.name);\n    }\n}\nfunction DetailProductComponent_div_23_ng_container_3_ng_template_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"a\", 60);\n        core[\"Nb\" /* element */](1, \"img\", 61);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var item_r14 = core[\"bc\" /* nextContext */]().$implicit;\n        var ctx_r16 = core[\"bc\" /* nextContext */](2);\n        core[\"ic\" /* property */](\"href\", ctx_r16.globals.BASE_API_URL + \"public/products/\" + item_r14, core[\"xc\" /* sanitizeUrl */]);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"defaultImage\", ctx_r16.globals.BASE_API_URL + \"public/products/\" + item_r14)(\"lazyLoad\", ctx_r16.globals.BASE_API_URL + \"public/products/\" + item_r14)(\"alt\", item_r14)(\"name\", item_r14);\n    }\n}\nfunction DetailProductComponent_div_23_ng_container_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* elementContainerStart */](0);\n        core[\"Bc\" /* template */](1, DetailProductComponent_div_23_ng_container_3_ng_template_1_Template, 2, 5, \"ng-template\", 59);\n        core[\"Pb\" /* elementContainerEnd */]();\n    }\n    if (rf & 2) {\n        var i_r15 = ctx.index;\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"id\", \"images-\" + i_r15);\n    }\n}\nvar detail_component_c2 = function (a0) { return { \"d-none \": a0 }; };\nfunction DetailProductComponent_div_23_div_5_Template(rf, ctx) {\n    if (rf & 1) {\n        var _r21 = core[\"Tb\" /* getCurrentView */]();\n        core[\"Sb\" /* elementStart */](0, \"div\", 62);\n        core[\"Sb\" /* elementStart */](1, \"img\", 63);\n        core[\"Zb\" /* listener */](\"click\", function DetailProductComponent_div_23_div_5_Template_img_click_1_listener() { core[\"vc\" /* restoreView */](_r21); var i_r19 = ctx.index; core[\"bc\" /* nextContext */](); var _r10 = core[\"sc\" /* reference */](2); var ctx_r20 = core[\"bc\" /* nextContext */](); ctx_r20.detail.onClickImageChild(\"images-\" + i_r19 + \"-child\"); return _r10.to(\"images-\" + i_r19); });\n        core[\"cc\" /* pipe */](2, \"translate\");\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var item_r18 = ctx.$implicit;\n        var i_r19 = ctx.index;\n        var ctx_r12 = core[\"bc\" /* nextContext */](2);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngClass\", core[\"mc\" /* pureFunction1 */](8, detail_component_c2, i_r19 > 4))(\"id\", \"images-\" + i_r19 + \"-child\")(\"defaultImage\", core[\"dc\" /* pipeBind1 */](2, 6, \"FEImagesProduct\"))(\"lazyLoad\", ctx_r12.globals.BASE_API_URL + \"public/products/\" + item_r18)(\"alt\", item_r18)(\"name\", item_r18);\n    }\n}\nfunction DetailProductComponent_div_23_div_6_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 62);\n        core[\"Nb\" /* element */](1, \"img\", 64);\n        core[\"Sb\" /* elementStart */](2, \"a\", 65);\n        core[\"Sb\" /* elementStart */](3, \"div\", 66);\n        core[\"Sb\" /* elementStart */](4, \"div\", 67);\n        core[\"Nb\" /* element */](5, \"i\", 68);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var ctx_r13 = core[\"bc\" /* nextContext */](2);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"defaultImage\", \"../../../../assets/img/default.png\")(\"lazyLoad\", ctx_r13.globals.BASE_API_URL + \"public/products/\" + ctx_r13.detail.data.video);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"href\", ctx_r13.detail.data.video_link, core[\"xc\" /* sanitizeUrl */]);\n    }\n}\nfunction DetailProductComponent_div_23_Template(rf, ctx) {\n    if (rf & 1) {\n        var _r23 = core[\"Tb\" /* getCurrentView */]();\n        core[\"Sb\" /* elementStart */](0, \"div\");\n        core[\"Sb\" /* elementStart */](1, \"owl-carousel-o\", 53, 54);\n        core[\"Zb\" /* listener */](\"changed\", function DetailProductComponent_div_23_Template_owl_carousel_o_changed_1_listener($event) { core[\"vc\" /* restoreView */](_r23); var ctx_r22 = core[\"bc\" /* nextContext */](); return ctx_r22.detail.getPassedData($event); })(\"initialized\", function DetailProductComponent_div_23_Template_owl_carousel_o_initialized_1_listener($event) { core[\"vc\" /* restoreView */](_r23); var ctx_r24 = core[\"bc\" /* nextContext */](); return ctx_r24.detail.getPassedData($event); });\n        core[\"Bc\" /* template */](3, DetailProductComponent_div_23_ng_container_3_Template, 2, 1, \"ng-container\", 55);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](4, \"div\", 56);\n        core[\"Bc\" /* template */](5, DetailProductComponent_div_23_div_5_Template, 3, 10, \"div\", 57);\n        core[\"Bc\" /* template */](6, DetailProductComponent_div_23_div_6_Template, 6, 3, \"div\", 58);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var ctx_r1 = core[\"bc\" /* nextContext */]();\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"options\", ctx_r1.customOptions);\n        core[\"Ab\" /* advance */](2);\n        core[\"ic\" /* property */](\"ngForOf\", ctx_r1.listImages.data);\n        core[\"Ab\" /* advance */](2);\n        core[\"ic\" /* property */](\"ngForOf\", ctx_r1.listImages.data);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", ctx_r1.detail.data.video_link && ctx_r1.detail.data.video);\n    }\n}\nvar detail_component_c3 = function () { return { maximumFractionDigits: 5 }; };\nfunction DetailProductComponent_div_28_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 69);\n        core[\"Sb\" /* elementStart */](1, \"div\", 70);\n        core[\"Dc\" /* text */](2);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var ctx_r2 = core[\"bc\" /* nextContext */]();\n        core[\"Ab\" /* advance */](2);\n        core[\"Fc\" /* textInterpolate1 */](\" \", ctx_r2.detail.data.price >= 0 ? ctx_r2.detail.data.price.toLocaleString(\"vi\", core[\"lc\" /* pureFunction0 */](1, detail_component_c3)) : \"\", \" \\u0111 \");\n    }\n}\nfunction DetailProductComponent_div_29_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 69);\n        core[\"Sb\" /* elementStart */](1, \"div\", 71);\n        core[\"Dc\" /* text */](2);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](3, \"div\", 72);\n        core[\"Dc\" /* text */](4);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var ctx_r3 = core[\"bc\" /* nextContext */]();\n        core[\"Ab\" /* advance */](2);\n        core[\"Fc\" /* textInterpolate1 */](\" \", ctx_r3.detail.data.price_sale >= 0 ? ctx_r3.detail.data.price_sale.toLocaleString(\"vi\", core[\"lc\" /* pureFunction0 */](2, detail_component_c3)) : \"\", \" \\u0111 \");\n        core[\"Ab\" /* advance */](2);\n        core[\"Fc\" /* textInterpolate1 */](\" \", ctx_r3.detail.data.price ? ctx_r3.detail.data.price.toLocaleString(\"vi\", core[\"lc\" /* pureFunction0 */](3, detail_component_c3)) : \"\", \" \\u0111 \");\n    }\n}\nfunction DetailProductComponent_span_32_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"span\", 73);\n        core[\"Dc\" /* text */](1, \" H\\u1EBFt h\\u00E0ng \");\n        core[\"Rb\" /* elementEnd */]();\n    }\n}\nfunction DetailProductComponent_span_33_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"span\", 73);\n        core[\"Dc\" /* text */](1, \" C\\u00F2n h\\u00E0ng \");\n        core[\"Rb\" /* elementEnd */]();\n    }\n}\nfunction DetailProductComponent_div_55_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\");\n        core[\"Nb\" /* element */](1, \"div\", 74);\n        core[\"cc\" /* pipe */](2, \"sanitizeHtml\");\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var ctx_r6 = core[\"bc\" /* nextContext */]();\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"innerHTML\", core[\"dc\" /* pipeBind1 */](2, 1, ctx_r6.detail.data.detail), core[\"wc\" /* sanitizeHtml */]);\n    }\n}\nfunction DetailProductComponent_div_63_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 75);\n        core[\"Sb\" /* elementStart */](1, \"div\");\n        core[\"Sb\" /* elementStart */](2, \"a\", 76);\n        core[\"cc\" /* pipe */](3, \"translate\");\n        core[\"Nb\" /* element */](4, \"img\", 77);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](5, \"div\", 38);\n        core[\"Sb\" /* elementStart */](6, \"a\", 39);\n        core[\"cc\" /* pipe */](7, \"translate\");\n        core[\"Dc\" /* text */](8);\n        core[\"cc\" /* pipe */](9, \"translate\");\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        core[\"Ab\" /* advance */](2);\n        core[\"kc\" /* propertyInterpolate1 */](\"href\", \"tel:\", core[\"dc\" /* pipeBind1 */](3, 3, \"FEPhone\"), \"\", core[\"xc\" /* sanitizeUrl */]);\n        core[\"Ab\" /* advance */](4);\n        core[\"kc\" /* propertyInterpolate1 */](\"href\", \"tel:\", core[\"dc\" /* pipeBind1 */](7, 5, \"FEPhone\"), \"\", core[\"xc\" /* sanitizeUrl */]);\n        core[\"Ab\" /* advance */](2);\n        core[\"Fc\" /* textInterpolate1 */](\" \", core[\"dc\" /* pipeBind1 */](9, 7, \"FEPhone\"), \" \");\n    }\n}\nfunction DetailProductComponent_div_84_div_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 75);\n        core[\"Sb\" /* elementStart */](1, \"div\");\n        core[\"Sb\" /* elementStart */](2, \"a\", 76);\n        core[\"cc\" /* pipe */](3, \"translate\");\n        core[\"Nb\" /* element */](4, \"img\", 77);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](5, \"div\", 38);\n        core[\"Sb\" /* elementStart */](6, \"a\", 39);\n        core[\"Dc\" /* text */](7);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var item_r25 = core[\"bc\" /* nextContext */]().$implicit;\n        core[\"Ab\" /* advance */](2);\n        core[\"kc\" /* propertyInterpolate1 */](\"href\", \"tel:\", core[\"dc\" /* pipeBind1 */](3, 3, \"FEPhone\"), \"\", core[\"xc\" /* sanitizeUrl */]);\n        core[\"Ab\" /* advance */](4);\n        core[\"ic\" /* property */](\"href\", \"tel:\" + item_r25.phone, core[\"xc\" /* sanitizeUrl */]);\n        core[\"Ab\" /* advance */](1);\n        core[\"Fc\" /* textInterpolate1 */](\" \", item_r25.phone, \" \");\n    }\n}\nfunction DetailProductComponent_div_84_div_12_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 40);\n        core[\"Sb\" /* elementStart */](1, \"div\");\n        core[\"Nb\" /* element */](2, \"img\", 41);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](3, \"div\", 38);\n        core[\"Sb\" /* elementStart */](4, \"a\", 42);\n        core[\"Dc\" /* text */](5);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var item_r25 = core[\"bc\" /* nextContext */]().$implicit;\n        core[\"Ab\" /* advance */](5);\n        core[\"Ec\" /* textInterpolate */](item_r25.address);\n    }\n}\nfunction DetailProductComponent_div_84_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 78);\n        core[\"Sb\" /* elementStart */](1, \"h6\", 79);\n        core[\"Dc\" /* text */](2);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Bc\" /* template */](3, DetailProductComponent_div_84_div_3_Template, 8, 5, \"div\", 35);\n        core[\"cc\" /* pipe */](4, \"translate\");\n        core[\"cc\" /* pipe */](5, \"translate\");\n        core[\"Sb\" /* elementStart */](6, \"div\", 36);\n        core[\"Sb\" /* elementStart */](7, \"div\");\n        core[\"Nb\" /* element */](8, \"img\", 37);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](9, \"div\", 38);\n        core[\"Sb\" /* elementStart */](10, \"a\", 39);\n        core[\"Dc\" /* text */](11);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Bc\" /* template */](12, DetailProductComponent_div_84_div_12_Template, 6, 1, \"div\", 80);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var item_r25 = ctx.$implicit;\n        core[\"Ab\" /* advance */](2);\n        core[\"Ec\" /* textInterpolate */](item_r25.name);\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", core[\"dc\" /* pipeBind1 */](4, 5, \"FEPhone\") != \"FEPhone\" && core[\"dc\" /* pipeBind1 */](5, 7, \"FEPhone\") != \"\");\n        core[\"Ab\" /* advance */](7);\n        core[\"ic\" /* property */](\"href\", \"mailto:\" + item_r25.email, core[\"xc\" /* sanitizeUrl */]);\n        core[\"Ab\" /* advance */](1);\n        core[\"Fc\" /* textInterpolate1 */](\" \", item_r25.email, \" \");\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"ngIf\", item_r25.address);\n    }\n}\nfunction DetailProductComponent_div_92_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 81);\n        core[\"Nb\" /* element */](1, \"app-box-product\", 82);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        var item_r30 = ctx.$implicit;\n        core[\"Ab\" /* advance */](1);\n        core[\"ic\" /* property */](\"item\", item_r30);\n    }\n}\nvar detail_component_DetailProductComponent = /** @class */ /*@__PURE__*/ /*@__PURE__*/ (function () {\n    function DetailProductComponent(route, router, productService, apiCart, homeService, globals, footerService) {\n        var _this = this;\n        this.route = route;\n        this.router = router;\n        this.productService = productService;\n        this.apiCart = apiCart;\n        this.homeService = homeService;\n        this.globals = globals;\n        this.footerService = footerService;\n        this.item = {};\n        this.listImages = { data: [], cached: [], active: 0 };\n        this.showOwl = false;\n        this.count = 1;\n        this.width = 0;\n        this.link = \"\";\n        this.detail = {\n            amount: 1,\n            images: '',\n            data: [],\n            get: function () {\n                _this.productService.getDetail({ link: _this.link }).subscribe(function (resp) {\n                    if (resp.status == 1) {\n                        _this.detail.data = resp.data;\n                        _this.detail.images = resp.data.images;\n                        var listimages = (resp.data.listimages && resp.data.listimages.length > 5) ? JSON.parse(resp.data.listimages) : [];\n                        _this.listImages.cached = listimages;\n                        if (_this.detail.data.images && _this.detail.data.images.length > 4) {\n                            _this.listImages.cached = [_this.detail.data.images].concat(listimages);\n                        }\n                        else {\n                            _this.detail.data.images = (listimages.length > 0) ? listimages[0] : '';\n                        }\n                        _this.listImages.data = Object.values(_this.listImages.cached);\n                    }\n                });\n            },\n            changeAmount: function () {\n                if (_this.detail.amount <= 0 || !Number.isInteger(_this.detail.amount)) {\n                    _this.detail.amount = 1;\n                }\n            },\n            addCart: function () {\n                _this.detail.data.images = _this.globals.BASE_API_URL + 'public/products/' + _this.detail.images;\n                var data = _this.apiCart.reduce();\n                if (data[_this.detail.data.id]) {\n                    var a = isNaN(+data[_this.detail.data.id].amount) ? 1 : +data[_this.detail.data.id].amount;\n                    _this.detail.data.amount = +a + _this.detail.amount;\n                }\n                else {\n                    _this.detail.data.amount = _this.detail.amount;\n                }\n                _this.apiCart.edit(_this.detail.data, _this.detail.data.id);\n                var element = document.getElementById('cart');\n                window.scroll({ top: element.offsetTop, behavior: 'smooth', });\n                document.getElementById('notification').classList.add(\"d-block\");\n            },\n            getPassedData: function (data) {\n                _this.activeSlides = data;\n                _this.selected = data.slides[0] ? data.slides[0].id : \"\";\n                _this.detail.data.images = _this.selected;\n                setTimeout(function () {\n                    _this.detail.onClickImageChild(_this.selected + '-child');\n                }, 200);\n            },\n            onClickImageChild: function (id) {\n                var items = document.querySelectorAll('.img-child');\n                for (var i = 0; i < items.length; i++) {\n                    items[i].style.opacity = 0.5;\n                    items[i].classList.remove(\"border\");\n                    items[i].classList.remove(\"border-danger\");\n                }\n                document.getElementById(id).style.opacity = '1';\n                document.getElementById(id).classList.add(\"border\");\n                document.getElementById(id).classList.add(\"border-danger\");\n            }\n        };\n        this.address = {\n            show: -1,\n            data: [],\n            _ini: function (data) {\n                if (data && data.length > 0) {\n                    _this.address.data = data;\n                    _this.address.show = data[0].id;\n                }\n            },\n            _onShow: function (id) {\n                _this.address.show = _this.address.show != id ? id : -1;\n            }\n        };\n        this.renderHtml = function () {\n            var main = document.getElementById(\"contentDetail\");\n            if (main) {\n                var el = main.querySelectorAll(\"table\");\n                if (el) {\n                    for (var i = 0; i < el.length; i++) {\n                        var div = document.createElement(\"div\");\n                        div.className = \"table-responsive table-bordered m-0 border-0\";\n                        el[i].parentNode.insertBefore(div, el[i]);\n                        el[i].className = \"table\";\n                        el[i].setAttribute(\"class\", \"table\");\n                        var cls = el[i].getAttribute(\"class\");\n                        el[i];\n                        var newhtml = \"<table class='table'>\" + el[i].innerHTML + \"</table>\";\n                        el[i].remove();\n                        div.innerHTML = newhtml;\n                    }\n                }\n                var image = main.querySelectorAll(\"img\");\n                if (image) {\n                    for (var i = 0; i < image.length; i++) {\n                        var a = document.createElement(\"div\");\n                        a.className = \"images-deatil d-inline\";\n                        image[i].parentNode.insertBefore(a, image[i]);\n                        var style = image[i].style.cssText;\n                        var width = image[i].width || 0;\n                        var heigth = image[i].width || 0;\n                        var src = image[i].currentSrc;\n                        var html = \"<a  class=\\\"fancybox\\\" data-fancybox=\\\"images-preview\\\" data-thumbs=\\\"{&quot;autoStart&quot;:true}\\\" href=\\\"\" +\n                            src + \"\\\">  <img class=\\\"mb-2\\\" width=\\\"\" + width + \"px\\\" heigth=\\\"\" + heigth + \"px\\\" src=\\\"\" + src +\n                            \"\\\" style=\\\"\" + style + \"\\\" alt=\\\"\" + _this.data.name + \"\\\" />   </a>\";\n                        image[i].remove();\n                        a.innerHTML = html;\n                    }\n                }\n            }\n        };\n        this.customOptions = {\n            autoplayTimeout: 8000,\n            autoplaySpeed: 1500,\n            autoWidth: true,\n            mouseDrag: true,\n            touchDrag: true,\n            pullDrag: true,\n            dots: false,\n            mergeFit: false,\n            navSpeed: 500,\n            items: 5,\n            responsive: {\n                300: {\n                    items: 1,\n                    nav: false,\n                    loop: true,\n                    center: false,\n                    margin: 280,\n                    mergeFit: true,\n                },\n                600: {\n                    items: 1,\n                    nav: false,\n                    loop: true,\n                    center: false,\n                    margin: 200,\n                    mergeFit: true,\n                },\n                1000: {\n                    items: 1,\n                    center: false,\n                }\n            }\n        };\n        this.images = [\n            \"../assets/img/bg/shape-1.png\",\n            \"../assets/img/login.jpg\"\n        ];\n        this.product = {\n            data: [],\n            get: function () {\n                _this.homeService.getProduct().subscribe(function (resp) {\n                    if (resp.status == 1) {\n                        _this.product.data = resp.data.featured;\n                    }\n                });\n            },\n        };\n        this.width = document.body.getBoundingClientRect().width;\n        this.route.params.subscribe(function (params) {\n            _this.link = params.link;\n            _this.parent_link = params.parent_link;\n            _this.parent_links = params.parent_links;\n        });\n    }\n    DetailProductComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.getAddress();\n        this.route.params.subscribe(function (params) {\n            _this.link = params.link;\n            _this.detail.get();\n            _this.product.get();\n        });\n    };\n    DetailProductComponent.prototype.getAddress = function () {\n        var _this = this;\n        this.footerService.getAddress().subscribe(function (resp) { return _this.address._ini(resp.data); });\n    };\n    DetailProductComponent.prototype.setCount = function (i) {\n        if (i == 1) {\n            this.count = Math.max(this.count -= 1, 1);\n        }\n        else {\n            this.count += 1;\n        }\n    };\n    DetailProductComponent.fac = function DetailProductComponent_Factory(t) { return new (t || DetailProductComponent)(core[\"Mb\" /* directiveInject */](fesm2015_router[\"a\" /* ActivatedRoute */]), core[\"Mb\" /* directiveInject */](fesm2015_router[\"c\" /* Router */]), core[\"Mb\" /* directiveInject */](product_service_ProductService), core[\"Mb\" /* directiveInject */](cart_service[\"a\" /* CartService */]), core[\"Mb\" /* directiveInject */](home_service[\"a\" /* HomeService */]), core[\"Mb\" /* directiveInject */](app_globals[\"a\" /* Globals */]), core[\"Mb\" /* directiveInject */](footer_service[\"a\" /* FooterService */])); };\n    DetailProductComponent.cmp = core[\"Gb\" /* defineComponent */]({ type: DetailProductComponent, selectors: [[\"app-detail-product\"]], viewQuery: function DetailProductComponent_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Ic\" /* viewQuery */](detail_component_c0, 1);\n            }\n            if (rf & 2) {\n                var _t = void 0;\n                core[\"rc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.owlLibrary = _t.first);\n            }\n        }, inputs: { data: \"data\" }, decls: 93, vars: 38, consts: [[1, \"bg-light\"], [1, \"container-main\"], [1, \"container-fluid\"], [1, \"py-md-4\", \"py-3\"], [1, \"breadcrumb\", \"bg-transparent\", \"border-0\", \"m-0\", \"p-0\"], [1, \"breadcrumb-item\"], [\"href\", \"\"], [2, \"text-decoration\", \"none\", 3, \"routerLink\"], [1, \"breadcrumb-item\", \"active\"], [1, \"bg-white\", \"p-3\"], [1, \"row\"], [1, \"col-md-9\"], [1, \"col-md-5\", \"col-12\"], [4, \"ngIf\"], [1, \"col-md-7\", \"col-12\"], [1, \"w-100\", \"py-1\"], [\"class\", \"d-flex align-items-baseline\", 4, \"ngIf\"], [1, \"py-3\"], [\"class\", \"font-weight-bold\", 4, \"ngIf\"], [1, \"d-flex\", \"align-items-end\"], [1, \"mr-md-5\", \"mr-3\"], [1, \"group-input\", \"position-relative\", \"mt-2\"], [3, \"click\"], [\"type\", \"number\", \"min\", \"1\", 1, \"input\", \"pr-3\", 3, \"ngModel\", \"value\", \"ngModelChange\", \"focusout\"], [1, \"position-absolute\", 3, \"click\"], [1, \"btn\", \"btn-cart\", \"btn-outline-danger\", \"d-flex\", \"align-items-center\", \"justify-content-center\", \"text-uppercase\", \"font-weight-bold\", \"p-2\", 3, \"click\"], [1, \"fas\", \"fa-cart-plus\", \"mr-2\"], [1, \"detail-title\"], [1, \"mb-0\", \"font-weight-bold\", \"text-uppercase\", \"d-inline-block\", \"text-danger\", \"bg-white\"], [1, \"detail-content\", \"mt-3\"], [1, \"col-md-3\"], [2, \"position\", \"sticky\", \"z-index\", \"0\", \"top\", \"0\"], [1, \"bg-white\"], [1, \"card-header\", \"text-white\", \"text-uppercase\", \"font-weight-bold\", \"border-0\", \"text-center\", 2, \"background-color\", \"#ff0000\"], [1, \"card-body\", \"pl-2\", \"pr-2\", \"border\"], [\"class\", \" d-flex align-items-center \", 4, \"ngIf\"], [1, \"mt-2\", \"d-flex\", \"align-items-center\"], [\"src\", \"../../../assets/img/mail1.png \", 1, \"mr-2\", 2, \"width\", \"20px\"], [2, \"font-size\", \"15px\"], [1, \"ml-1\", \"text-dark\", 3, \"href\"], [1, \"mt-2\", \"d-flex\"], [\"src\", \"../../../assets/img/address.png \", 1, \"mr-2\", 2, \"width\", \"20px\"], [1, \"ml-1\", \"text-dark\"], [1, \"card-header\", \"text-white\", \"text-uppercase\", \"font-weight-bold\", \"border-0\", \"text-center\", \"mt-3\", \"bg-primary\"], [1, \"card-body\", \"pl-2\", \"pr-2\", \"border\", 2, \"max-height\", \"400px\", \"overflow\", \"auto\"], [\"class\", \"mb-4\", 4, \"ngFor\", \"ngForOf\"], [1, \"bg-light\", \"pt-4\", \"pb-5\"], [1, \"border-bottom\", \"border-primary\", \"mb-3\", \"d-flex\", \"align-items-center\", \"justify-content-between\"], [1, \"text-white\", \"bg-primary\", \"d-inline-flex\", \"text-nowrap\", \"p-2\", \"mb-0\"], [1, \"row\", \"px-2\"], [\"class\", \"col-6 col-md-3 col-xl-2dot4 px-2 mb-3\", 4, \"ngFor\", \"ngForOf\"], [1, \"p-0\", \"w-100\", \"h-100\", 3, \"routerLink\"], [1, \"box-img\", \"w-100\", 3, \"routerLink\", \"defaultImage\", \"lazyLoad\", \"title\", \"alt\"], [1, \"owl-product\", 2, \"overflow\", \"hidden\", 3, \"options\", \"changed\", \"initialized\"], [\"owlLibrary\", \"\"], [4, \"ngFor\", \"ngForOf\"], [1, \"pt-2\", \"d-flex\", \"justify-content-center\", \"overflow-hidden\"], [\"class\", \"position-relative\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"position-relative\", 4, \"ngIf\"], [\"carouselSlide\", \"\", \"style\", \"overflow:hidden; \", 3, \"id\"], [\"data-fancybox\", \"images-preview-desk\", \"data-thumbs\", \"{\\\"autoStart\\\":true}\", 3, \"href\"], [1, \"rounded\", \"images-detail\", 3, \"defaultImage\", \"lazyLoad\", \"alt\", \"name\"], [1, \"position-relative\"], [1, \"img-child\", 3, \"ngClass\", \"id\", \"defaultImage\", \"lazyLoad\", \"alt\", \"name\", \"click\"], [1, \"img-child\", 2, \"object-fit\", \"cover\", 3, \"defaultImage\", \"lazyLoad\"], [\"data-fancybox\", \"\", 1, \"venobox\", \"vbox-item\", 3, \"href\"], [1, \"icon-video\"], [1, \"icon-video-circle\", \"d-flex\", \"justify-content-center\", \"align-items-center\"], [1, \"fa\", \"fa-play\", \"text-white\", 2, \"font-size\", \"8px\"], [1, \"d-flex\", \"align-items-baseline\"], [1, \"text-danger\", \"font-weight-bold\", \"price-sale\"], [1, \"text-danger\", \"font-weight-bold\", \"price-sale\", \"mr-3\"], [1, \"price-default\", \"text-muted\", \"p-1\", \"font-weight-bold\"], [1, \"font-weight-bold\"], [\"id\", \"page-detail\", 1, \"fr-view\", \"pt-3\", 3, \"innerHTML\"], [1, \"d-flex\", \"align-items-center\"], [1, \"text-white\", \"mr-1\", 3, \"href\"], [\"src\", \"../../../../assets//img/phone-call.png \", 1, \"mr-2\", 2, \"width\", \"20px\"], [1, \"mb-4\"], [1, \"\"], [\"class\", \" mt-2 d-flex \", 4, \"ngIf\"], [1, \"col-6\", \"col-md-3\", \"col-xl-2dot4\", \"px-2\", \"mb-3\"], [3, \"item\"]], template: function DetailProductComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Sb\" /* elementStart */](0, \"div\", 0);\n                core[\"Sb\" /* elementStart */](1, \"div\", 1);\n                core[\"Sb\" /* elementStart */](2, \"div\", 2);\n                core[\"Sb\" /* elementStart */](3, \"nav\", 3);\n                core[\"Sb\" /* elementStart */](4, \"ol\", 4);\n                core[\"Sb\" /* elementStart */](5, \"li\", 5);\n                core[\"Sb\" /* elementStart */](6, \"a\", 6);\n                core[\"Dc\" /* text */](7);\n                core[\"cc\" /* pipe */](8, \"translate\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](9, \"li\", 5);\n                core[\"Sb\" /* elementStart */](10, \"a\", 7);\n                core[\"Dc\" /* text */](11);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](12, \"li\", 8);\n                core[\"Dc\" /* text */](13);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](14, \"div\", 0);\n                core[\"Sb\" /* elementStart */](15, \"div\", 1);\n                core[\"Sb\" /* elementStart */](16, \"div\", 2);\n                core[\"Sb\" /* elementStart */](17, \"div\", 9);\n                core[\"Sb\" /* elementStart */](18, \"div\", 10);\n                core[\"Sb\" /* elementStart */](19, \"div\", 11);\n                core[\"Sb\" /* elementStart */](20, \"div\", 10);\n                core[\"Sb\" /* elementStart */](21, \"div\", 12);\n                core[\"Bc\" /* template */](22, DetailProductComponent_div_22_Template, 5, 12, \"div\", 13);\n                core[\"Bc\" /* template */](23, DetailProductComponent_div_23_Template, 7, 4, \"div\", 13);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](24, \"div\", 14);\n                core[\"Sb\" /* elementStart */](25, \"h4\");\n                core[\"Dc\" /* text */](26);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](27, \"div\", 15);\n                core[\"Bc\" /* template */](28, DetailProductComponent_div_28_Template, 3, 2, \"div\", 16);\n                core[\"Bc\" /* template */](29, DetailProductComponent_div_29_Template, 5, 4, \"div\", 16);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](30, \"div\", 17);\n                core[\"Dc\" /* text */](31, \" Tr\\u1EA1ng th\\u00E1i: \");\n                core[\"Bc\" /* template */](32, DetailProductComponent_span_32_Template, 2, 0, \"span\", 18);\n                core[\"Bc\" /* template */](33, DetailProductComponent_span_33_Template, 2, 0, \"span\", 18);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](34, \"div\", 19);\n                core[\"Sb\" /* elementStart */](35, \"div\", 20);\n                core[\"Dc\" /* text */](36, \" S\\u1ED1 l\\u01B0\\u1EE3ng \");\n                core[\"Sb\" /* elementStart */](37, \"div\", 21);\n                core[\"Sb\" /* elementStart */](38, \"button\", 22);\n                core[\"Zb\" /* listener */](\"click\", function DetailProductComponent_Template_button_click_38_listener() { return ctx.detail.amount = ctx.detail.amount <= 1 ? 1 : ctx.detail.amount - 1; });\n                core[\"Dc\" /* text */](39, \"-\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](40, \"input\", 23);\n                core[\"Zb\" /* listener */](\"ngModelChange\", function DetailProductComponent_Template_input_ngModelChange_40_listener($event) { return ctx.detail.amount = $event; })(\"focusout\", function DetailProductComponent_Template_input_focusout_40_listener() { return ctx.detail.changeAmount(); });\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](41, \"button\", 24);\n                core[\"Zb\" /* listener */](\"click\", function DetailProductComponent_Template_button_click_41_listener() { return ctx.detail.amount = +ctx.detail.amount > 0 ? +ctx.detail.amount + 1 : 1; });\n                core[\"Dc\" /* text */](42, \"+\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](43, \"div\");\n                core[\"Sb\" /* elementStart */](44, \"button\", 25);\n                core[\"Zb\" /* listener */](\"click\", function DetailProductComponent_Template_button_click_44_listener() { return ctx.detail.addCart(); });\n                core[\"Nb\" /* element */](45, \"i\", 26);\n                core[\"Sb\" /* elementStart */](46, \"span\");\n                core[\"Dc\" /* text */](47, \"Th\\u00EAm gi\\u1ECF h\\u00E0ng\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](48, \"div\", 17);\n                core[\"Sb\" /* elementStart */](49, \"div\", 27);\n                core[\"Sb\" /* elementStart */](50, \"h3\", 28);\n                core[\"Dc\" /* text */](51, \" Th\\u00F4ng tin chi ti\\u1EBFt \");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](52, \"div\", 29);\n                core[\"Sb\" /* elementStart */](53, \"h1\");\n                core[\"Dc\" /* text */](54);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Bc\" /* template */](55, DetailProductComponent_div_55_Template, 3, 3, \"div\", 13);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](56, \"div\", 30);\n                core[\"Sb\" /* elementStart */](57, \"div\", 31);\n                core[\"Sb\" /* elementStart */](58, \"div\", 32);\n                core[\"Sb\" /* elementStart */](59, \"div\", 33);\n                core[\"Dc\" /* text */](60);\n                core[\"cc\" /* pipe */](61, \"translate\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](62, \"div\", 34);\n                core[\"Bc\" /* template */](63, DetailProductComponent_div_63_Template, 10, 9, \"div\", 35);\n                core[\"cc\" /* pipe */](64, \"translate\");\n                core[\"cc\" /* pipe */](65, \"translate\");\n                core[\"Sb\" /* elementStart */](66, \"div\", 36);\n                core[\"Sb\" /* elementStart */](67, \"div\");\n                core[\"Nb\" /* element */](68, \"img\", 37);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](69, \"div\", 38);\n                core[\"Sb\" /* elementStart */](70, \"a\", 39);\n                core[\"cc\" /* pipe */](71, \"translate\");\n                core[\"Dc\" /* text */](72);\n                core[\"cc\" /* pipe */](73, \"translate\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](74, \"div\", 40);\n                core[\"Sb\" /* elementStart */](75, \"div\");\n                core[\"Nb\" /* element */](76, \"img\", 41);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](77, \"div\", 38);\n                core[\"Sb\" /* elementStart */](78, \"a\", 42);\n                core[\"Dc\" /* text */](79);\n                core[\"cc\" /* pipe */](80, \"translate\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](81, \"div\", 43);\n                core[\"Dc\" /* text */](82, \" H\\u1EC6 TH\\u1ED0NG C\\u1EE6A H\\u00C0NG \");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](83, \"div\", 44);\n                core[\"Bc\" /* template */](84, DetailProductComponent_div_84_Template, 13, 9, \"div\", 45);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](85, \"div\", 46);\n                core[\"Sb\" /* elementStart */](86, \"div\", 1);\n                core[\"Sb\" /* elementStart */](87, \"div\", 2);\n                core[\"Sb\" /* elementStart */](88, \"div\", 47);\n                core[\"Sb\" /* elementStart */](89, \"h5\", 48);\n                core[\"Dc\" /* text */](90, \" S\\u1EA3n ph\\u1EA9m n\\u1ED5i b\\u1EADt \");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](91, \"div\", 49);\n                core[\"Bc\" /* template */](92, DetailProductComponent_div_92_Template, 2, 1, \"div\", 50);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"Ab\" /* advance */](7);\n                core[\"Fc\" /* textInterpolate1 */](\" \", core[\"dc\" /* pipeBind1 */](8, 22, \"lblHome\"), \" \");\n                core[\"Ab\" /* advance */](3);\n                core[\"ic\" /* property */](\"routerLink\", core[\"mc\" /* pureFunction1 */](36, detail_component_c1, \"/san-pham/\" + ctx.detail.data.href));\n                core[\"Ab\" /* advance */](1);\n                core[\"Fc\" /* textInterpolate1 */](\" \", ctx.detail.data.parent_name, \" \");\n                core[\"Ab\" /* advance */](2);\n                core[\"Fc\" /* textInterpolate1 */](\" \", ctx.detail.data.name, \" \");\n                core[\"Ab\" /* advance */](9);\n                core[\"ic\" /* property */](\"ngIf\", ctx.listImages.data.length == 0);\n                core[\"Ab\" /* advance */](1);\n                core[\"ic\" /* property */](\"ngIf\", ctx.listImages.data && ctx.listImages.data.length > 0);\n                core[\"Ab\" /* advance */](3);\n                core[\"Ec\" /* textInterpolate */](ctx.detail.data.name);\n                core[\"Ab\" /* advance */](2);\n                core[\"ic\" /* property */](\"ngIf\", ctx.detail.data.price_sale == 0);\n                core[\"Ab\" /* advance */](1);\n                core[\"ic\" /* property */](\"ngIf\", ctx.detail.data.price_sale > 0);\n                core[\"Ab\" /* advance */](3);\n                core[\"ic\" /* property */](\"ngIf\", ctx.detail.data.status == 0);\n                core[\"Ab\" /* advance */](1);\n                core[\"ic\" /* property */](\"ngIf\", ctx.detail.data.status == 1);\n                core[\"Ab\" /* advance */](7);\n                core[\"ic\" /* property */](\"ngModel\", ctx.detail.amount)(\"value\", ctx.detail.amount);\n                core[\"Ab\" /* advance */](14);\n                core[\"Fc\" /* textInterpolate1 */](\"\", ctx.detail.data.name, \":\");\n                core[\"Ab\" /* advance */](1);\n                core[\"ic\" /* property */](\"ngIf\", ctx.detail.data.detail && ctx.detail.data.detail.length > 0);\n                core[\"Ab\" /* advance */](5);\n                core[\"Fc\" /* textInterpolate1 */](\" \", core[\"dc\" /* pipeBind1 */](61, 24, \"lblContact\"), \" \");\n                core[\"Ab\" /* advance */](3);\n                core[\"ic\" /* property */](\"ngIf\", core[\"dc\" /* pipeBind1 */](64, 26, \"FEPhone\") != \"FEPhone\" && core[\"dc\" /* pipeBind1 */](65, 28, \"FEPhone\") != \"\");\n                core[\"Ab\" /* advance */](7);\n                core[\"kc\" /* propertyInterpolate1 */](\"href\", \"mailto:\", core[\"dc\" /* pipeBind1 */](71, 30, \"FEMail\"), \"\", core[\"xc\" /* sanitizeUrl */]);\n                core[\"Ab\" /* advance */](2);\n                core[\"Fc\" /* textInterpolate1 */](\" \", core[\"dc\" /* pipeBind1 */](73, 32, \"FEMail\"), \" \");\n                core[\"Ab\" /* advance */](7);\n                core[\"Ec\" /* textInterpolate */](core[\"dc\" /* pipeBind1 */](80, 34, \"FEAddress\"));\n                core[\"Ab\" /* advance */](5);\n                core[\"ic\" /* property */](\"ngForOf\", ctx.address.data);\n                core[\"Ab\" /* advance */](8);\n                core[\"ic\" /* property */](\"ngForOf\", ctx.product.data);\n            }\n        }, directives: [fesm2015_router[\"f\" /* RouterLinkWithHref */], common[\"l\" /* NgIf */], fesm2015_forms[\"n\" /* NumberValueAccessor */], fesm2015_forms[\"b\" /* DefaultValueAccessor */], fesm2015_forms[\"i\" /* NgControlStatus */], fesm2015_forms[\"l\" /* NgModel */], common[\"k\" /* NgForOf */], fesm2015_router[\"d\" /* RouterLink */], ng_lazyload_image[\"a\" /* LazyLoadImageDirective */], ngx_owl_carousel_o[\"a\" /* CarouselComponent */], ngx_owl_carousel_o[\"c\" /* CarouselSlideDirective */], common[\"j\" /* NgClass */], box_product_component[\"a\" /* BoxProductComponent */]], pipes: [ngx_translate_core[\"d\" /* TranslatePipe */], sanitizeHtml_pipe[\"a\" /* SanitizeHtmlPipe */]], styles: [\".images-detail[_ngcontent-%COMP%]{transition:.3s;max-width:100%;max-height:400px;position:relative;overflow:hidden}.images-detail[_ngcontent-%COMP%], .img-child[_ngcontent-%COMP%]{-o-object-fit:contain;object-fit:contain}.img-child[_ngcontent-%COMP%]{width:50px;height:50px;cursor:pointer;padding:2px}@media (max-width:615px){.card-title[_ngcontent-%COMP%]{font-size:1.75rem}}.slide[_ngcontent-%COMP%]{height:400px}.price-sale[_ngcontent-%COMP%]{font-size:24px}.price-default[_ngcontent-%COMP%]{text-decoration:line-through;font-size:.875rem}.input[_ngcontent-%COMP%]{width:30px;padding-left:7px}button[_ngcontent-%COMP%]{height:30px;width:30px;background-color:#fff;border:.5px solid #e4dddd}.input[_ngcontent-%COMP%]{padding-left:10px}.btn-cart[_ngcontent-%COMP%]{width:170px;height:40px}.detail-title[_ngcontent-%COMP%]{font-size:25px;background:#fff none repeat scroll 0 0;padding-right:20px;z-index:2;color:#cc3528;position:relative}.group-input[_ngcontent-%COMP%]{display:flex;align-items:center}.group-input[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:first-child{border-right:none;border-radius:4px 0 0 4px}.group-input[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{cursor:pointer;width:32px;border:1px solid #dee2e6;background-color:#fff}.group-input[_ngcontent-%COMP%]   button[_ngcontent-%COMP%], .group-input[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{height:30px;color:#242424;font-size:14px;text-align:center;outline:none;transition:border-color .15s ease-in-out 0s,box-shadow .15s ease-in-out 0s}.group-input[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:75px;border:1px solid #dee2e6}.group-input[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:last-child{border-radius:0 4px 4px 0;right:0;border-left:1px solid #dee2e6}.detail-title[_ngcontent-%COMP%]:after{background:#f3f3f3 none repeat scroll 0 0;content:\\\"\\\";height:2px;left:0;position:absolute;top:50%;width:100%;z-index:-1}.col-md-3[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:70px}.col-md-3[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]:hover{width:70px;cursor:pointer}.box-img[_ngcontent-%COMP%]{width:100%;-o-object-fit:cover;object-fit:cover;position:relative;background-color:#fff;height:300px;transition:all .3s linear}.input[_ngcontent-%COMP%]{padding-left:17px;text-align:left!important}.btn-outline-danger[_ngcontent-%COMP%]{border-color:#dc3545!important}.bg-primary[_ngcontent-%COMP%]{background-color:red!important}.bg-box[_ngcontent-%COMP%]{background-color:#ff8e00}.border-primary[_ngcontent-%COMP%]{border-color:#cc3528!important}.thumbnail[_ngcontent-%COMP%]{width:60px;height:50px;margin-right:20px;-o-object-fit:cover;object-fit:cover}.thumbnail[_ngcontent-%COMP%]:hover{cursor:pointer}.thumbnail-active[_ngcontent-%COMP%]{border:2px solid red}.venobox[_ngcontent-%COMP%]{position:absolute;top:34%;left:38%}\"] });\n    return DetailProductComponent;\n}());\n\n\n// EXTERNAL MODULE: ./src/app/frontend/modules/box-product/box-product.module.ts\nvar box_product_module = __webpack_require__(\"HHYX\");\n\n// CONCATENATED MODULE: ./src/app/frontend/products/products.module.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar routes = [\n    { path: '', component: list_component_ListProductComponent },\n    { path: ':link', component: list_component_ListProductComponent },\n    { path: ':parent_link/:link', component: detail_component_DetailProductComponent },\n];\nvar products_module_ProductsModule = /** @class */ /*@__PURE__*/ /*@__PURE__*/ (function () {\n    function ProductsModule() {\n    }\n    ProductsModule.fac = function ProductsModule_Factory(t) { return new (t || ProductsModule)(); };\n    ProductsModule.mod = core[\"Kb\" /* defineNgModule */]({ type: ProductsModule });\n    ProductsModule.inj = core[\"Jb\" /* defineInjector */]({ imports: [[\n                common[\"c\" /* CommonModule */],\n                ngx_translate_core[\"c\" /* TranslateModule */],\n                sanitizehtmlpipe[\"a\" /* SanitizeHtmlModule */],\n                fesm2015_router[\"g\" /* RouterModule */].forChild(routes),\n                ngx_bootstrap_pagination[\"b\" /* PaginationModule */].forRoot(),\n                ngx_bootstrap_datepicker[\"c\" /* BsDatepickerModule */].forRoot(),\n                fesm2015_forms[\"f\" /* FormsModule */],\n                ngx_owl_carousel_o[\"b\" /* CarouselModule */],\n                ng5_slider_Ng5SliderModule,\n                fesm2015_forms[\"p\" /* ReactiveFormsModule */],\n                ngx_bootstrap_collapse_CollapseModule,\n                ngx_bootstrap_timepicker_TimepickerModule,\n                ngx_bootstrap_tabs_TabsModule,\n                ng_lazyload_image[\"b\" /* LazyLoadImageModule */],\n                box_product_module[\"a\" /* BoxProductModule */],\n                box_content[\"a\" /* BoxContenntModule */],\n                box_asidebar_left_module[\"a\" /* BoxAsidebarLeftModule */],\n                box_header_page_module[\"a\" /* BoxHeaderPageModule */],\n                box_loading_module[\"a\" /* BoxLoadingModule */],\n                heading_box_page_module[\"a\" /* HeadingBoxPageModule */],\n                button_back_module[\"a\" /* ButtonBackModule */],\n                sidebar_news_module[\"a\" /* SidebarNewsModule */]\n            ]] });\n    return ProductsModule;\n}());\n\n\n\n/***/ }),\n\n/***/ \"yl3g\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar isScheduler_1 = /*@__PURE__*/__webpack_require__(\"NwwV\");\n\nvar selfSelector = function selfSelector(value) {\n  return value;\n};\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar GenerateObservable = function (_super) {\n  __extends(GenerateObservable, _super);\n\n  function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {\n    _super.call(this);\n\n    this.initialState = initialState;\n    this.condition = condition;\n    this.iterate = iterate;\n    this.resultSelector = resultSelector;\n    this.scheduler = scheduler;\n  }\n\n  GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n    if (arguments.length == 1) {\n      return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);\n    }\n\n    if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {\n      return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);\n    }\n\n    return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);\n  };\n  /** @deprecated internal use only */\n\n\n  GenerateObservable.prototype._subscribe = function (subscriber) {\n    var state = this.initialState;\n\n    if (this.scheduler) {\n      return this.scheduler.schedule(GenerateObservable.dispatch, 0, {\n        subscriber: subscriber,\n        iterate: this.iterate,\n        condition: this.condition,\n        resultSelector: this.resultSelector,\n        state: state\n      });\n    }\n\n    var _a = this,\n        condition = _a.condition,\n        resultSelector = _a.resultSelector,\n        iterate = _a.iterate;\n\n    do {\n      if (condition) {\n        var conditionResult = void 0;\n\n        try {\n          conditionResult = condition(state);\n        } catch (err) {\n          subscriber.error(err);\n          return;\n        }\n\n        if (!conditionResult) {\n          subscriber.complete();\n          break;\n        }\n      }\n\n      var value = void 0;\n\n      try {\n        value = resultSelector(state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n\n      subscriber.next(value);\n\n      if (subscriber.closed) {\n        break;\n      }\n\n      try {\n        state = iterate(state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n    } while (true);\n  };\n\n  GenerateObservable.dispatch = function (state) {\n    var subscriber = state.subscriber,\n        condition = state.condition;\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    if (state.needIterate) {\n      try {\n        state.state = state.iterate(state.state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n    } else {\n      state.needIterate = true;\n    }\n\n    if (condition) {\n      var conditionResult = void 0;\n\n      try {\n        conditionResult = condition(state.state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n\n      if (!conditionResult) {\n        subscriber.complete();\n        return;\n      }\n\n      if (subscriber.closed) {\n        return;\n      }\n    }\n\n    var value;\n\n    try {\n      value = state.resultSelector(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return;\n    }\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    subscriber.next(value);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    return this.schedule(state);\n  };\n\n  return GenerateObservable;\n}(Observable_1.Observable);\n\nexports.GenerateObservable = GenerateObservable;\n\n/***/ }),\n\n/***/ \"ypDg\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar async_1 = /*@__PURE__*/__webpack_require__(\"Re0n\");\n\nvar timeout_1 = /*@__PURE__*/__webpack_require__(\"9BwH\");\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\n\n\nfunction timeout(due, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return timeout_1.timeout(due, scheduler)(this);\n}\n\nexports.timeout = timeout;\n\n/***/ }),\n\n/***/ \"yz70\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.empty = {\n  closed: true,\n  next: function next(value) {},\n  error: function error(err) {\n    throw err;\n  },\n  complete: function complete() {}\n};\n\n/***/ }),\n\n/***/ \"z1j8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar find_1 = __webpack_require__(\"RL+e\");\n\nObservable_1.Observable.prototype.find = find_1.find; //# sourceMappingURL=find.js.map\n\n/***/ }),\n\n/***/ \"zIAK\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar findIndex_1 = __webpack_require__(\"eeyt\");\n\nObservable_1.Observable.prototype.findIndex = findIndex_1.findIndex; //# sourceMappingURL=findIndex.js.map\n\n/***/ }),\n\n/***/ \"zKHA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar errorObject_1 = /*@__PURE__*/__webpack_require__(\"AJP0\");\n\nvar tryCatchTarget;\n\nfunction tryCatcher() {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject_1.errorObject.e = e;\n    return errorObject_1.errorObject;\n  }\n}\n\nfunction tryCatch(fn) {\n  tryCatchTarget = fn;\n  return tryCatcher;\n}\n\nexports.tryCatch = tryCatch;\n;\n\n/***/ }),\n\n/***/ \"zL8T\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\n\n\nfunction debounce(durationSelector) {\n  return function (source) {\n    return source.lift(new DebounceOperator(durationSelector));\n  };\n}\n\nexports.debounce = debounce;\n\nvar DebounceOperator = /*@__PURE__*/function () {\n  function DebounceOperator(durationSelector) {\n    this.durationSelector = durationSelector;\n  }\n\n  DebounceOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n  };\n\n  return DebounceOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar DebounceSubscriber = function (_super) {\n  __extends(DebounceSubscriber, _super);\n\n  function DebounceSubscriber(destination, durationSelector) {\n    _super.call(this, destination);\n\n    this.durationSelector = durationSelector;\n    this.hasValue = false;\n    this.durationSubscription = null;\n  }\n\n  DebounceSubscriber.prototype._next = function (value) {\n    try {\n      var result = this.durationSelector.call(this, value);\n\n      if (result) {\n        this._tryNext(value, result);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  };\n\n  DebounceSubscriber.prototype._complete = function () {\n    this.emitValue();\n    this.destination.complete();\n  };\n\n  DebounceSubscriber.prototype._tryNext = function (value, duration) {\n    var subscription = this.durationSubscription;\n    this.value = value;\n    this.hasValue = true;\n\n    if (subscription) {\n      subscription.unsubscribe();\n      this.remove(subscription);\n    }\n\n    subscription = subscribeToResult_1.subscribeToResult(this, duration);\n\n    if (!subscription.closed) {\n      this.add(this.durationSubscription = subscription);\n    }\n  };\n\n  DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.emitValue();\n  };\n\n  DebounceSubscriber.prototype.notifyComplete = function () {\n    this.emitValue();\n  };\n\n  DebounceSubscriber.prototype.emitValue = function () {\n    if (this.hasValue) {\n      var value = this.value;\n      var subscription = this.durationSubscription;\n\n      if (subscription) {\n        this.durationSubscription = null;\n        subscription.unsubscribe();\n        this.remove(subscription);\n      }\n\n      this.value = null;\n      this.hasValue = false;\n\n      _super.prototype._next.call(this, value);\n    }\n  };\n\n  return DebounceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"zLeP\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar skip_1 = /*@__PURE__*/__webpack_require__(\"1DV/\");\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\n\n\nfunction skip(count) {\n  return skip_1.skip(count)(this);\n}\n\nexports.skip = skip;\n\n/***/ }),\n\n/***/ \"zMOc\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar single_1 = /*@__PURE__*/__webpack_require__(\"Xrsd\");\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate.\n .\n * @method single\n * @owner Observable\n */\n\n\nfunction single(predicate) {\n  return single_1.single(predicate)(this);\n}\n\nexports.single = single;\n\n/***/ }),\n\n/***/ \"zSqD\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar concat_1 = __webpack_require__(\"6oB3\");\n\nObservable_1.Observable.concat = concat_1.concat; //# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ \"zVww\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar concatMap_1 = /*@__PURE__*/__webpack_require__(\"+WiC\");\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\n\n\nfunction concatMapTo(innerObservable, resultSelector) {\n  return concatMap_1.concatMap(function () {\n    return innerObservable;\n  }, resultSelector);\n}\n\nexports.concatMapTo = concatMapTo;\n\n/***/ }),\n\n/***/ \"zZI/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isArray_1 = /*@__PURE__*/__webpack_require__(\"G2HO\");\n\nfunction isNumeric(val) {\n  // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n  // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n  // subtraction forces infinities to NaN\n  // adding 1 corrects loss of precision from parseFloat (#15100)\n  return !isArray_1.isArray(val) && val - parseFloat(val) + 1 >= 0;\n}\n\nexports.isNumeric = isNumeric;\n;\n\n/***/ }),\n\n/***/ \"zZax\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar window_1 = __webpack_require__(\"wowj\");\n\nObservable_1.Observable.prototype.window = window_1.window; //# sourceMappingURL=window.js.map\n\n/***/ }),\n\n/***/ \"zbiA\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar auditTime_1 = __webpack_require__(\"hV2K\");\n\nObservable_1.Observable.prototype.auditTime = auditTime_1.auditTime; //# sourceMappingURL=auditTime.js.map\n\n/***/ }),\n\n/***/ \"zlBQ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar bufferToggle_1 = __webpack_require__(\"ks6M\");\n\nObservable_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle; //# sourceMappingURL=bufferToggle.js.map\n\n/***/ }),\n\n/***/ \"zobD\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\n\n\nfunction buffer(closingNotifier) {\n  return function bufferOperatorFunction(source) {\n    return source.lift(new BufferOperator(closingNotifier));\n  };\n}\n\nexports.buffer = buffer;\n\nvar BufferOperator = /*@__PURE__*/function () {\n  function BufferOperator(closingNotifier) {\n    this.closingNotifier = closingNotifier;\n  }\n\n  BufferOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n  };\n\n  return BufferOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar BufferSubscriber = function (_super) {\n  __extends(BufferSubscriber, _super);\n\n  function BufferSubscriber(destination, closingNotifier) {\n    _super.call(this, destination);\n\n    this.buffer = [];\n    this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n  }\n\n  BufferSubscriber.prototype._next = function (value) {\n    this.buffer.push(value);\n  };\n\n  BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var buffer = this.buffer;\n    this.buffer = [];\n    this.destination.next(buffer);\n  };\n\n  return BufferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ }),\n\n/***/ \"zrM/\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Observable_1 = __webpack_require__(\"AZf1\");\n\nvar windowToggle_1 = __webpack_require__(\"5UB+\");\n\nObservable_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle; //# sourceMappingURL=windowToggle.js.map\n\n/***/ }),\n\n/***/ \"zx+L\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = /*@__PURE__*/__webpack_require__(\"AZf1\");\n\nvar subscribeToResult_1 = /*@__PURE__*/__webpack_require__(\"Irel\");\n\nvar OuterSubscriber_1 = /*@__PURE__*/__webpack_require__(\"9jZZ\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar IfObservable = function (_super) {\n  __extends(IfObservable, _super);\n\n  function IfObservable(condition, thenSource, elseSource) {\n    _super.call(this);\n\n    this.condition = condition;\n    this.thenSource = thenSource;\n    this.elseSource = elseSource;\n  }\n\n  IfObservable.create = function (condition, thenSource, elseSource) {\n    return new IfObservable(condition, thenSource, elseSource);\n  };\n  /** @deprecated internal use only */\n\n\n  IfObservable.prototype._subscribe = function (subscriber) {\n    var _a = this,\n        condition = _a.condition,\n        thenSource = _a.thenSource,\n        elseSource = _a.elseSource;\n\n    return new IfSubscriber(subscriber, condition, thenSource, elseSource);\n  };\n\n  return IfObservable;\n}(Observable_1.Observable);\n\nexports.IfObservable = IfObservable;\n\nvar IfSubscriber = function (_super) {\n  __extends(IfSubscriber, _super);\n\n  function IfSubscriber(destination, condition, thenSource, elseSource) {\n    _super.call(this, destination);\n\n    this.condition = condition;\n    this.thenSource = thenSource;\n    this.elseSource = elseSource;\n    this.tryIf();\n  }\n\n  IfSubscriber.prototype.tryIf = function () {\n    var _a = this,\n        condition = _a.condition,\n        thenSource = _a.thenSource,\n        elseSource = _a.elseSource;\n\n    var result;\n\n    try {\n      result = condition();\n      var source = result ? thenSource : elseSource;\n\n      if (source) {\n        this.add(subscribeToResult_1.subscribeToResult(this, source));\n      } else {\n        this._complete();\n      }\n    } catch (err) {\n      this._error(err);\n    }\n  };\n\n  return IfSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\n/***/ })\n\n}]);","inputSourceMap":null}