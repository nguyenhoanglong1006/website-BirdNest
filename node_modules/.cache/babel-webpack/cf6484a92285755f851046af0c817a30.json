{"ast":null,"code":"import _possibleConstructorReturn from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _isNativeReflectConstruct from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nimport _getPrototypeOf from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createForOfIteratorHelper from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _createClass from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n\nimport { Subject } from 'rxjs';\nimport { Renderer2, Directive, ElementRef, HostBinding, ChangeDetectorRef, Component, ViewChild, HostListener, Input, EventEmitter, Output, ContentChild, forwardRef, NgZone, NgModule } from '@angular/core';\nimport { throttleTime, tap, distinctUntilChanged, filter } from 'rxjs/operators';\nimport detectPassiveEvents from 'detect-passive-events';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** @enum {number} */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nvar _c0 = [\"tooltipTemplate\"];\nvar _c1 = [\"leftOuterSelectionBar\"];\nvar _c2 = [\"rightOuterSelectionBar\"];\nvar _c3 = [\"fullBar\"];\nvar _c4 = [\"selectionBar\"];\nvar _c5 = [\"minHandle\"];\nvar _c6 = [\"maxHandle\"];\nvar _c7 = [\"floorLabel\"];\nvar _c8 = [\"ceilLabel\"];\nvar _c9 = [\"minHandleLabel\"];\nvar _c10 = [\"maxHandleLabel\"];\nvar _c11 = [\"combinedLabel\"];\nvar _c12 = [\"ticksElement\"];\n\nfunction SliderComponent_span_28_ng5_slider_tooltip_wrapper_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"ng5-slider-tooltip-wrapper\", 31);\n  }\n\n  if (rf & 2) {\n    var t_r13 = ɵngcc0.ɵɵnextContext().$implicit;\n    var ctx_r14 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"template\", ctx_r14.tooltipTemplate)(\"tooltip\", t_r13.valueTooltip)(\"placement\", t_r13.valueTooltipPlacement)(\"content\", t_r13.value);\n  }\n}\n\nfunction SliderComponent_span_28_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 32);\n  }\n\n  if (rf & 2) {\n    var t_r13 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵproperty(\"innerHTML\", t_r13.legend, ɵngcc0.ɵɵsanitizeHtml);\n  }\n}\n\nvar _c13 = function _c13(a0) {\n  return {\n    \"ng5-slider-selected\": a0\n  };\n};\n\nfunction SliderComponent_span_28_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 27);\n    ɵngcc0.ɵɵelement(1, \"ng5-slider-tooltip-wrapper\", 28);\n    ɵngcc0.ɵɵtemplate(2, SliderComponent_span_28_ng5_slider_tooltip_wrapper_2_Template, 1, 4, \"ng5-slider-tooltip-wrapper\", 29);\n    ɵngcc0.ɵɵtemplate(3, SliderComponent_span_28_span_3_Template, 1, 1, \"span\", 30);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var t_r13 = ctx.$implicit;\n    var ctx_r12 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(7, _c13, t_r13.selected))(\"ngStyle\", t_r13.style);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"template\", ctx_r12.tooltipTemplate)(\"tooltip\", t_r13.tooltip)(\"placement\", t_r13.tooltipPlacement);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", t_r13.value != null);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", t_r13.legend != null);\n  }\n}\n\nfunction TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template(rf, ctx) {}\n\nfunction TooltipWrapperComponent_ng_container_0_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, TooltipWrapperComponent_ng_container_0_1_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nvar _c14 = function _c14(a0, a1, a2) {\n  return {\n    tooltip: a0,\n    placement: a1,\n    content: a2\n  };\n};\n\nfunction TooltipWrapperComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TooltipWrapperComponent_ng_container_0_1_Template, 1, 0, undefined, 1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction3(2, _c14, ctx_r0.tooltip, ctx_r0.placement, ctx_r0.content));\n  }\n}\n\nfunction TooltipWrapperComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 2);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"title\", ctx_r1.tooltip)(\"data-tooltip-placement\", ctx_r1.placement);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r1.content, \" \");\n  }\n}\n\nvar PointerType = {\n  /** Low pointer */\n  Min: 0,\n\n  /** High pointer */\n  Max: 1\n};\nPointerType[PointerType.Min] = \"Min\";\nPointerType[PointerType.Max] = \"Max\";\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** @enum {number} */\n\nvar LabelType = {\n  /** Label above low pointer */\n  Low: 0,\n\n  /** Label above high pointer */\n  High: 1,\n\n  /** Label for minimum slider value */\n  Floor: 2,\n\n  /** Label for maximum slider value */\n  Ceil: 3,\n\n  /** Label below legend tick */\n  TickValue: 4\n};\nLabelType[LabelType.Low] = \"Low\";\nLabelType[LabelType.High] = \"High\";\nLabelType[LabelType.Floor] = \"Floor\";\nLabelType[LabelType.Ceil] = \"Ceil\";\nLabelType[LabelType.TickValue] = \"TickValue\";\n/**\n * Custom step definition\n *\n * This can be used to specify custom values and legend values for slider ticks\n * @record\n */\n\n/**\n * Slider options\n */\n\nvar Options = /*#__PURE__*/_createClass(function Options() {\n  _classCallCheck(this, Options);\n\n  /**\n   * Minimum value for a slider.\n   * Not applicable when using stepsArray.\n   */\n  this.floor = 0;\n  /**\n   * Maximum value for a slider.\n   * Not applicable when using stepsArray.\n   */\n\n  this.ceil = null;\n  /**\n   * Step between each value.\n   * Not applicable when using stepsArray.\n   */\n\n  this.step = 1;\n  /**\n   * The minimum range authorized on the slider.\n   * Applies to range slider only.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.minRange = null;\n  /**\n   * The maximum range authorized on the slider.\n   * Applies to range slider only.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.maxRange = null;\n  /**\n   * Set to true to have a push behavior. When the min handle goes above the max,\n   * the max is moved as well (and vice-versa). The range between min and max is\n   * defined by the step option (defaults to 1) and can also be overriden by\n   * the minRange option. Applies to range slider only.\n   */\n\n  this.pushRange = false;\n  /**\n   * The minimum value authorized on the slider.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.minLimit = null;\n  /**\n   * The maximum value authorized on the slider.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.maxLimit = null;\n  /**\n   * Custom translate function. Use this if you want to translate values displayed\n   * on the slider.\n   */\n\n  this.translate = null;\n  /**\n   * Custom function for combining overlapping labels in range slider.\n   * It takes the min and max values (already translated with translate fuction)\n   * and should return how these two values should be combined.\n   * If not provided, the default function will join the two values with\n   * ' - ' as separator.\n   */\n\n  this.combineLabels = null;\n  /**\n   * Use to display legend under ticks (thus, it needs to be used along with\n   * showTicks or showTicksValues). The function will be called with each tick\n   * value and returned content will be displayed under the tick as a legend.\n   * If the returned value is null, then no legend is displayed under\n   * the corresponding tick.You can also directly provide the legend values\n   * in the stepsArray option.\n   */\n\n  this.getLegend = null;\n  /**\n   * If you want to display a slider with non linear/number steps.\n   * Just pass an array with each slider value and that's it; the floor, ceil and step settings\n   * of the slider will be computed automatically.\n   * By default, the value model and valueHigh model values will be the value of the selected item\n   * in the stepsArray.\n   * They can also be bound to the index of the selected item by setting the bindIndexForStepsArray\n   * option to true.\n   */\n\n  this.stepsArray = null;\n  /**\n   * Set to true to bind the index of the selected item to value model and valueHigh model.\n   */\n\n  this.bindIndexForStepsArray = false;\n  /**\n   * When set to true and using a range slider, the range can be dragged by the selection bar.\n   * Applies to range slider only.\n   */\n\n  this.draggableRange = false;\n  /**\n   * Same as draggableRange but the slider range can't be changed.\n   * Applies to range slider only.\n   */\n\n  this.draggableRangeOnly = false;\n  /**\n   * Set to true to always show the selection bar before the slider handle.\n   */\n\n  this.showSelectionBar = false;\n  /**\n   * Set to true to always show the selection bar after the slider handle.\n   */\n\n  this.showSelectionBarEnd = false;\n  /**\n   * Set a number to draw the selection bar between this value and the slider handle.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n\n  this.showSelectionBarFromValue = null;\n  /**\n   * Only for range slider. Set to true to visualize in different colour the areas\n   * on the left/right (top/bottom for vertical range slider) of selection bar between the handles.\n   */\n\n  this.showOuterSelectionBars = false;\n  /**\n   * Set to true to hide pointer labels\n   */\n\n  this.hidePointerLabels = false;\n  /**\n   * Set to true to hide min / max labels\n   */\n\n  this.hideLimitLabels = false;\n  /**\n   * Set to false to disable the auto-hiding behavior of the limit labels.\n   */\n\n  this.autoHideLimitLabels = true;\n  /**\n   * Set to true to make the slider read-only.\n   */\n\n  this.readOnly = false;\n  /**\n   * Set to true to disable the slider.\n   */\n\n  this.disabled = false;\n  /**\n   * Throttle interval for mouse events in milliseconds.\n   * This is provided to avoid a flood of events when moving the slider with mouse.\n   */\n\n  this.mouseEventsInterval = 50;\n  /**\n   * Throttle interval for touch events in milliseconds.\n   * This is provided to avoid a flood of events when moving the slider with touch gesture.\n   */\n\n  this.touchEventsInterval = 50;\n  /**\n   * Throttle interval for input changes (changes to bindings or reactive form inputs)\n   * This is provided to avoid a flood of events on frequent input binding changes affecting performance.\n   */\n\n  this.inputEventsInterval = 100;\n  /**\n   * Throttle interval for output changes (signalling changes to output bindings and user callbacks)\n   * This is provided to avoid a flood of outgoing events affecting Angular app performance.\n   */\n\n  this.outputEventsInterval = 100;\n  /**\n   * Set to true to display a tick for each step of the slider.\n   */\n\n  this.showTicks = false;\n  /**\n   * Set to true to display a tick and the step value for each step of the slider..\n   */\n\n  this.showTicksValues = false;\n  /* The step between each tick to display. If not set, the step value is used.\n      Not used when ticksArray is specified. */\n\n  this.tickStep = null;\n  /* The step between displaying each tick step value. */\n\n  this.tickValueStep = 1;\n  /**\n   * Use to display ticks at specific positions.\n   * The array contains the index of the ticks that should be displayed.\n   * For example, [0, 1, 5] will display a tick for the first, second and sixth values.\n   */\n\n  this.ticksArray = null;\n  /**\n   * Used to display a tooltip when a tick is hovered.\n   * Set to a function that returns the tooltip content for a given value.\n   */\n\n  this.ticksTooltip = null;\n  /**\n   * Same as ticksTooltip but for ticks values.\n   */\n\n  this.ticksValuesTooltip = null;\n  /**\n   * Set to true to display the slider vertically.\n   * The slider will take the full height of its parent.\n   * Changing this value at runtime is not currently supported.\n   */\n\n  this.vertical = false;\n  /**\n   * Function that returns the current color of the selection bar.\n   * If your color won't change, don't use this option but set it through CSS.\n   * If the returned color depends on a model value (either value or valueHigh),\n   * you should use the argument passed to the function.\n   * Indeed, when the function is called, there is no certainty that the model\n   * has already been updated.\n   */\n\n  this.getSelectionBarColor = null;\n  /**\n   * Function that returns the color of a tick. showTicks must be enabled.\n   */\n\n  this.getTickColor = null;\n  /**\n   * Function that returns the current color of a pointer.\n   * If your color won't change, don't use this option but set it through CSS.\n   * If the returned color depends on a model value (either value or valueHigh),\n   * you should use the argument passed to the function.\n   * Indeed, when the function is called, there is no certainty that the model has already been updated.\n   * To handle range slider pointers independently, you should evaluate pointerType within the given\n   * function where \"min\" stands for value model and \"max\" for valueHigh model values.\n   */\n\n  this.getPointerColor = null;\n  /**\n   * Handles are focusable (on click or with tab) and can be modified using the following keyboard controls:\n   * Left/bottom arrows: -1\n   * Right/top arrows: +1\n   * Page-down: -10%\n   * Page-up: +10%\n   * Home: minimum value\n   * End: maximum value\n   */\n\n  this.keyboardSupport = true;\n  /**\n   * If you display the slider in an element that uses transform: scale(0.5), set the scale value to 2\n   * so that the slider is rendered properly and the events are handled correctly.\n   */\n\n  this.scale = 1;\n  /**\n   * Set to true to force the value to be rounded to the step, even when modified from the outside.\n   * When set to false, if the model values are modified from outside the slider, they are not rounded\n   * and can be between two steps.\n   */\n\n  this.enforceStep = true;\n  /**\n   * Set to true to force the value to be normalised to allowed range (floor to ceil), even when modified from the outside.\n   * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,\n   * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.\n   */\n\n  this.enforceRange = true;\n  /**\n   * Set to true to prevent to user from switching the min and max handles. Applies to range slider only.\n   */\n\n  this.noSwitching = false;\n  /**\n   * Set to true to only bind events on slider handles.\n   */\n\n  this.onlyBindHandles = false;\n  /**\n   * Set to true to show graphs right to left.\n   * If vertical is true it will be from top to bottom and left / right arrow functions reversed.\n   */\n\n  this.rightToLeft = false;\n  /**\n   * Set to true to reverse keyboard navigation:\n   * Right/top arrows: -1\n   * Left/bottom arrows: +1\n   * Page-up: -10%\n   * Page-down: +10%\n   * End: minimum value\n   * Home: maximum value\n   */\n\n  this.reversedControls = false;\n  /**\n   * Set to true to keep the slider labels inside the slider bounds.\n   */\n\n  this.boundPointerLabels = true;\n  /**\n   * Set to true to use a logarithmic scale to display the slider.\n   */\n\n  this.logScale = false;\n  /**\n   * Function that returns the position on the slider for a given value.\n   * The position must be a percentage between 0 and 1.\n   * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n   */\n\n  this.customValueToPosition = null;\n  /**\n   * Function that returns the value for a given position on the slider.\n   * The position is a percentage between 0 and 1.\n   * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n   */\n\n  this.customPositionToValue = null;\n  /**\n   * Precision limit for calculated values.\n   * Values used in calculations will be rounded to this number of significant digits\n   * to prevent accumulating small floating-point errors.\n   */\n\n  this.precisionLimit = 12;\n  /**\n   * Use to display the selection bar as a gradient.\n   * The given object must contain from and to properties which are colors.\n   */\n\n  this.selectionBarGradient = null;\n  /**\n   * Use to add a label directly to the slider for accessibility. Adds the aria-label attribute.\n   */\n\n  this.ariaLabel = null;\n  /**\n   * Use instead of ariaLabel to reference the id of an element which will be used to label the slider.\n   * Adds the aria-labelledby attribute.\n   */\n\n  this.ariaLabelledBy = null;\n  /**\n   * Use to add a label directly to the slider range for accessibility. Adds the aria-label attribute.\n   */\n\n  this.ariaLabelHigh = null;\n  /**\n   * Use instead of ariaLabelHigh to reference the id of an element which will be used to label the slider range.\n   * Adds the aria-labelledby attribute.\n   */\n\n  this.ariaLabelledByHigh = null;\n  /**\n   * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the handle\n   */\n\n  this.handleDimension = null;\n  /**\n   * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the bar\n   */\n\n  this.barDimension = null;\n  /**\n   * Enable/disable CSS animations\n   */\n\n  this.animate = true;\n});\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar ChangeContext = /*#__PURE__*/_createClass(function ChangeContext() {\n  _classCallCheck(this, ChangeContext);\n});\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n *  Collection of functions to handle conversions/lookups of values\n */\n\n\nvar ValueHelper = /*#__PURE__*/function () {\n  function ValueHelper() {\n    _classCallCheck(this, ValueHelper);\n  }\n\n  return _createClass(ValueHelper, null, [{\n    key: \"isNullOrUndefined\",\n    value:\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    function isNullOrUndefined(value) {\n      return value === undefined || value === null;\n    }\n    /**\n     * @param {?} val\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"linearValueToPosition\",\n    value: function linearValueToPosition(val, minVal, maxVal) {\n      var\n      /** @type {?} */\n      range = maxVal - minVal;\n      return (val - minVal) / range;\n    }\n    /**\n     * @param {?} val\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"logValueToPosition\",\n    value: function logValueToPosition(val, minVal, maxVal) {\n      val = Math.log(val);\n      minVal = Math.log(minVal);\n      maxVal = Math.log(maxVal);\n      var\n      /** @type {?} */\n      range = maxVal - minVal;\n      return (val - minVal) / range;\n    }\n    /**\n     * @param {?} percent\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"linearPositionToValue\",\n    value: function linearPositionToValue(percent, minVal, maxVal) {\n      return percent * (maxVal - minVal) + minVal;\n    }\n    /**\n     * @param {?} percent\n     * @param {?} minVal\n     * @param {?} maxVal\n     * @return {?}\n     */\n\n  }, {\n    key: \"logPositionToValue\",\n    value: function logPositionToValue(percent, minVal, maxVal) {\n      minVal = Math.log(minVal);\n      maxVal = Math.log(maxVal);\n      var\n      /** @type {?} */\n      value = percent * (maxVal - minVal) + minVal;\n      return Math.exp(value);\n    }\n    /**\n     * @param {?} modelValue\n     * @param {?} stepsArray\n     * @return {?}\n     */\n\n  }, {\n    key: \"findStepIndex\",\n    value: function findStepIndex(modelValue, stepsArray) {\n      var\n      /** @type {?} */\n      differences = stepsArray.map(function (step) {\n        return Math.abs(modelValue - step.value);\n      });\n      var\n      /** @type {?} */\n      minDifferenceIndex = 0;\n\n      for (var\n      /** @type {?} */\n      index = 0; index < stepsArray.length; index++) {\n        if (differences[index] !== differences[minDifferenceIndex] && differences[index] < differences[minDifferenceIndex]) {\n          minDifferenceIndex = index;\n        }\n      }\n\n      return minDifferenceIndex;\n    }\n  }]);\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Helper with compatibility functions to support different browsers\n */\n\n\nvar CompatibilityHelper = /*#__PURE__*/function () {\n  function CompatibilityHelper() {\n    _classCallCheck(this, CompatibilityHelper);\n  }\n\n  return _createClass(CompatibilityHelper, null, [{\n    key: \"isTouchEvent\",\n    value:\n    /**\n     * Workaround for TouchEvent constructor sadly not being available on all browsers (e.g. Firefox, Safari)\n     * @param {?} event\n     * @return {?}\n     */\n    function isTouchEvent(event) {\n      if (\n      /** @type {?} */\n      window.TouchEvent !== undefined) {\n        return event instanceof TouchEvent;\n      }\n\n      return event.touches !== undefined;\n    }\n    /**\n     * Detect presence of ResizeObserver API\n     * @return {?}\n     */\n\n  }, {\n    key: \"isResizeObserverAvailable\",\n    value: function isResizeObserverAvailable() {\n      return (\n        /** @type {?} */\n        window.ResizeObserver !== undefined\n      );\n    }\n  }]);\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Helper with mathematical functions\n */\n\n\nvar MathHelper = /*#__PURE__*/function () {\n  function MathHelper() {\n    _classCallCheck(this, MathHelper);\n  }\n\n  return _createClass(MathHelper, null, [{\n    key: \"roundToPrecisionLimit\",\n    value:\n    /**\n     * @param {?} value\n     * @param {?} precisionLimit\n     * @return {?}\n     */\n    function roundToPrecisionLimit(value, precisionLimit) {\n      return +value.toPrecision(precisionLimit);\n    }\n    /**\n     * @param {?} value\n     * @param {?} floor\n     * @param {?} ceil\n     * @return {?}\n     */\n\n  }, {\n    key: \"clampToRange\",\n    value: function clampToRange(value, floor, ceil) {\n      return Math.min(Math.max(value, floor), ceil);\n    }\n  }]);\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar EventListener = /*#__PURE__*/_createClass(function EventListener() {\n  _classCallCheck(this, EventListener);\n\n  this.eventName = null;\n  this.events = null;\n  this.eventsSubscription = null;\n  this.teardownCallback = null;\n});\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Helper class to attach event listeners to DOM elements with debounce support using rxjs\n */\n\n\nvar EventListenerHelper = /*#__PURE__*/function () {\n  /**\n   * @param {?} renderer\n   */\n  function EventListenerHelper(renderer) {\n    _classCallCheck(this, EventListenerHelper);\n\n    this.renderer = renderer;\n  }\n  /**\n   * @param {?} nativeElement\n   * @param {?} eventName\n   * @param {?} callback\n   * @param {?=} throttleInterval\n   * @return {?}\n   */\n\n\n  return _createClass(EventListenerHelper, [{\n    key: \"attachPassiveEventListener\",\n    value: function attachPassiveEventListener(nativeElement, eventName, callback, throttleInterval) {\n      // Only use passive event listeners if the browser supports it\n      if (detectPassiveEvents.hasSupport !== true) {\n        return this.attachEventListener(nativeElement, eventName, callback, throttleInterval);\n      } // Angular doesn't support passive event handlers (yet), so we need to roll our own code using native functions\n\n\n      var\n      /** @type {?} */\n      listener = new EventListener();\n      listener.eventName = eventName;\n      listener.events = new Subject();\n\n      var\n      /** @type {?} */\n      observerCallback = function observerCallback(event) {\n        listener.events.next(event);\n      };\n\n      nativeElement.addEventListener(eventName, observerCallback, {\n        passive: true,\n        capture: false\n      });\n\n      listener.teardownCallback = function () {\n        nativeElement.removeEventListener(eventName, observerCallback, {\n          passive: true,\n          capture: false\n        });\n      };\n\n      listener.eventsSubscription = listener.events.pipe(!ValueHelper.isNullOrUndefined(throttleInterval) ? throttleTime(throttleInterval, undefined, {\n        leading: true,\n        trailing: true\n      }) : tap(function () {}) // no-op\n      ).subscribe(function (event) {\n        callback(event);\n      });\n      return listener;\n    }\n    /**\n     * @param {?} eventListener\n     * @return {?}\n     */\n\n  }, {\n    key: \"detachEventListener\",\n    value: function detachEventListener(eventListener) {\n      if (!ValueHelper.isNullOrUndefined(eventListener.eventsSubscription)) {\n        eventListener.eventsSubscription.unsubscribe();\n        eventListener.eventsSubscription = null;\n      }\n\n      if (!ValueHelper.isNullOrUndefined(eventListener.events)) {\n        eventListener.events.complete();\n        eventListener.events = null;\n      }\n\n      if (!ValueHelper.isNullOrUndefined(eventListener.teardownCallback)) {\n        eventListener.teardownCallback();\n        eventListener.teardownCallback = null;\n      }\n    }\n    /**\n     * @param {?} nativeElement\n     * @param {?} eventName\n     * @param {?} callback\n     * @param {?=} throttleInterval\n     * @return {?}\n     */\n\n  }, {\n    key: \"attachEventListener\",\n    value: function attachEventListener(nativeElement, eventName, callback, throttleInterval) {\n      var\n      /** @type {?} */\n      listener = new EventListener();\n      listener.eventName = eventName;\n      listener.events = new Subject();\n\n      var\n      /** @type {?} */\n      observerCallback = function observerCallback(event) {\n        listener.events.next(event);\n      };\n\n      listener.teardownCallback = this.renderer.listen(nativeElement, eventName, observerCallback);\n      listener.eventsSubscription = listener.events.pipe(!ValueHelper.isNullOrUndefined(throttleInterval) ? throttleTime(throttleInterval, undefined, {\n        leading: true,\n        trailing: true\n      }) : tap(function () {}) // no-op\n      ).subscribe(function (event) {\n        callback(event);\n      });\n      return listener;\n    }\n  }]);\n}();\n\nvar SliderElementDirective = /*@__PURE__*/function () {\n  var SliderElementDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} elemRef\n     * @param {?} renderer\n     * @param {?} changeDetectionRef\n     */\n    function SliderElementDirective(elemRef, renderer, changeDetectionRef) {\n      _classCallCheck(this, SliderElementDirective);\n\n      this.elemRef = elemRef;\n      this.renderer = renderer;\n      this.changeDetectionRef = changeDetectionRef;\n      this._position = 0;\n      this._dimension = 0;\n      this._alwaysHide = false;\n      this._vertical = false;\n      this._scale = 1;\n      this.opacity = 1;\n      this.visibility = 'visible';\n      this.left = '';\n      this.bottom = '';\n      this.height = '';\n      this.width = '';\n      this.eventListeners = [];\n      this.eventListenerHelper = new EventListenerHelper(this.renderer);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    return _createClass(SliderElementDirective, [{\n      key: \"position\",\n      get: function get() {\n        return this._position;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"dimension\",\n      get: function get() {\n        return this._dimension;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"alwaysHide\",\n      get: function get() {\n        return this._alwaysHide;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"vertical\",\n      get: function get() {\n        return this._vertical;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"scale\",\n      get: function get() {\n        return this._scale;\n      }\n      /**\n       * @param {?} hide\n       * @return {?}\n       */\n\n    }, {\n      key: \"setAlwaysHide\",\n      value: function setAlwaysHide(hide) {\n        this._alwaysHide = hide;\n\n        if (hide) {\n          this.visibility = 'hidden';\n        } else {\n          this.visibility = 'visible';\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.opacity = 0;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        if (this.alwaysHide) {\n          return;\n        }\n\n        this.opacity = 1;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isVisible\",\n      value: function isVisible() {\n        if (this.alwaysHide) {\n          return false;\n        }\n\n        return this.opacity !== 0;\n      }\n      /**\n       * @param {?} vertical\n       * @return {?}\n       */\n\n    }, {\n      key: \"setVertical\",\n      value: function setVertical(vertical) {\n        this._vertical = vertical;\n\n        if (this._vertical) {\n          this.left = '';\n          this.width = '';\n        } else {\n          this.bottom = '';\n          this.height = '';\n        }\n      }\n      /**\n       * @param {?} scale\n       * @return {?}\n       */\n\n    }, {\n      key: \"setScale\",\n      value: function setScale(scale) {\n        this._scale = scale;\n      }\n      /**\n       * @param {?} pos\n       * @return {?}\n       */\n\n    }, {\n      key: \"setPosition\",\n      value: function setPosition(pos) {\n        if (this._position !== pos && !this.isRefDestroyed()) {\n          this.changeDetectionRef.markForCheck();\n        }\n\n        this._position = pos;\n\n        if (this._vertical) {\n          this.bottom = Math.round(pos) + 'px';\n        } else {\n          this.left = Math.round(pos) + 'px';\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"calculateDimension\",\n      value: function calculateDimension() {\n        var\n        /** @type {?} */\n        val = this.getBoundingClientRect();\n\n        if (this.vertical) {\n          this._dimension = (val.bottom - val.top) * this.scale;\n        } else {\n          this._dimension = (val.right - val.left) * this.scale;\n        }\n      }\n      /**\n       * @param {?} dim\n       * @return {?}\n       */\n\n    }, {\n      key: \"setDimension\",\n      value: function setDimension(dim) {\n        if (this._dimension !== dim && !this.isRefDestroyed()) {\n          this.changeDetectionRef.markForCheck();\n        }\n\n        this._dimension = dim;\n\n        if (this._vertical) {\n          this.height = Math.round(dim) + 'px';\n        } else {\n          this.width = Math.round(dim) + 'px';\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getBoundingClientRect\",\n      value: function getBoundingClientRect() {\n        return this.elemRef.nativeElement.getBoundingClientRect();\n      }\n      /**\n       * @param {?} eventName\n       * @param {?} callback\n       * @param {?=} debounceInterval\n       * @return {?}\n       */\n\n    }, {\n      key: \"on\",\n      value: function on(eventName, callback, debounceInterval) {\n        var\n        /** @type {?} */\n        listener = this.eventListenerHelper.attachEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n        this.eventListeners.push(listener);\n      }\n      /**\n       * @param {?} eventName\n       * @param {?} callback\n       * @param {?=} debounceInterval\n       * @return {?}\n       */\n\n    }, {\n      key: \"onPassive\",\n      value: function onPassive(eventName, callback, debounceInterval) {\n        var\n        /** @type {?} */\n        listener = this.eventListenerHelper.attachPassiveEventListener(this.elemRef.nativeElement, eventName, callback, debounceInterval);\n        this.eventListeners.push(listener);\n      }\n      /**\n       * @param {?=} eventName\n       * @return {?}\n       */\n\n    }, {\n      key: \"off\",\n      value: function off(eventName) {\n        var\n        /** @type {?} */\n        listenersToKeep;\n        var\n        /** @type {?} */\n        listenersToRemove;\n\n        if (!ValueHelper.isNullOrUndefined(eventName)) {\n          listenersToKeep = this.eventListeners.filter(function (event) {\n            return event.eventName !== eventName;\n          });\n          listenersToRemove = this.eventListeners.filter(function (event) {\n            return event.eventName === eventName;\n          });\n        } else {\n          listenersToKeep = [];\n          listenersToRemove = this.eventListeners;\n        }\n\n        var _iterator = _createForOfIteratorHelper(listenersToRemove),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var listener = _step.value;\n            this.eventListenerHelper.detachEventListener(listener);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this.eventListeners = listenersToKeep;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isRefDestroyed\",\n      value: function isRefDestroyed() {\n        return ValueHelper.isNullOrUndefined(this.changeDetectionRef) || this.changeDetectionRef['destroyed'];\n      }\n    }]);\n  }();\n\n  SliderElementDirective.ɵfac = function SliderElementDirective_Factory(t) {\n    return new (t || SliderElementDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  SliderElementDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: SliderElementDirective,\n    selectors: [[\"\", \"ng5SliderElement\", \"\"]],\n    hostVars: 12,\n    hostBindings: function SliderElementDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"opacity\", ctx.opacity)(\"visibility\", ctx.visibility)(\"left\", ctx.left)(\"bottom\", ctx.bottom)(\"height\", ctx.height)(\"width\", ctx.width);\n      }\n    }\n  });\n  return SliderElementDirective;\n}();\n\nvar SliderHandleDirective = /*@__PURE__*/function () {\n  var SliderHandleDirective = /*#__PURE__*/function (_SliderElementDirecti) {\n    /**\n     * @param {?} elemRef\n     * @param {?} renderer\n     * @param {?} changeDetectionRef\n     */\n    function SliderHandleDirective(elemRef, renderer, changeDetectionRef) {\n      var _this;\n\n      _classCallCheck(this, SliderHandleDirective);\n\n      _this = _callSuper(this, SliderHandleDirective, [elemRef, renderer, changeDetectionRef]);\n      _this.active = false;\n      _this.role = '';\n      _this.tabindex = '';\n      _this.ariaOrientation = '';\n      _this.ariaLabel = '';\n      _this.ariaLabelledBy = '';\n      _this.ariaValueNow = '';\n      _this.ariaValueText = '';\n      _this.ariaValueMin = '';\n      _this.ariaValueMax = '';\n      return _this;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _inherits(SliderHandleDirective, _SliderElementDirecti);\n\n    return _createClass(SliderHandleDirective, [{\n      key: \"focus\",\n      value: function focus() {\n        this.elemRef.nativeElement.focus();\n      }\n    }]);\n  }(SliderElementDirective);\n\n  SliderHandleDirective.ɵfac = function SliderHandleDirective_Factory(t) {\n    return new (t || SliderHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  SliderHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: SliderHandleDirective,\n    selectors: [[\"\", \"ng5SliderHandle\", \"\"]],\n    hostVars: 11,\n    hostBindings: function SliderHandleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx.tabindex)(\"aria-orientation\", ctx.ariaOrientation)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledBy)(\"aria-valuenow\", ctx.ariaValueNow)(\"aria-valuetext\", ctx.ariaValueText)(\"aria-valuemin\", ctx.ariaValueMin)(\"aria-valuemax\", ctx.ariaValueMax);\n        ɵngcc0.ɵɵclassProp(\"ng5-slider-active\", ctx.active);\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return SliderHandleDirective;\n}();\n\nvar SliderLabelDirective = /*@__PURE__*/function () {\n  var SliderLabelDirective = /*#__PURE__*/function (_SliderElementDirecti2) {\n    /**\n     * @param {?} elemRef\n     * @param {?} renderer\n     * @param {?} changeDetectionRef\n     */\n    function SliderLabelDirective(elemRef, renderer, changeDetectionRef) {\n      var _this2;\n\n      _classCallCheck(this, SliderLabelDirective);\n\n      _this2 = _callSuper(this, SliderLabelDirective, [elemRef, renderer, changeDetectionRef]);\n      _this2._value = null;\n      return _this2;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _inherits(SliderLabelDirective, _SliderElementDirecti2);\n\n    return _createClass(SliderLabelDirective, [{\n      key: \"value\",\n      get: function get() {\n        return this._value;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"setValue\",\n      value: function setValue(value) {\n        var\n        /** @type {?} */\n        recalculateDimension = false;\n\n        if (!this.alwaysHide && (ValueHelper.isNullOrUndefined(this.value) || this.value.length !== value.length || this.value.length > 0 && this.dimension === 0)) {\n          recalculateDimension = true;\n        }\n\n        this._value = value;\n        this.elemRef.nativeElement.innerHTML = value; // Update dimension only when length of the label have changed\n\n        if (recalculateDimension) {\n          this.calculateDimension();\n        }\n      }\n    }]);\n  }(SliderElementDirective);\n\n  SliderLabelDirective.ɵfac = function SliderLabelDirective_Factory(t) {\n    return new (t || SliderLabelDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  SliderLabelDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: SliderLabelDirective,\n    selectors: [[\"\", \"ng5SliderLabel\", \"\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return SliderLabelDirective;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar Tick = /*#__PURE__*/_createClass(function Tick() {\n  _classCallCheck(this, Tick);\n\n  this.selected = false;\n  this.style = {};\n  this.tooltip = null;\n  this.tooltipPlacement = null;\n  this.value = null;\n  this.valueTooltip = null;\n  this.valueTooltipPlacement = null;\n  this.legend = null;\n});\n\nvar Dragging = /*#__PURE__*/_createClass(function Dragging() {\n  _classCallCheck(this, Dragging);\n\n  this.active = false;\n  this.value = 0;\n  this.difference = 0;\n  this.position = 0;\n  this.lowLimit = 0;\n  this.highLimit = 0;\n});\n\nvar ModelValues = /*#__PURE__*/function () {\n  function ModelValues() {\n    _classCallCheck(this, ModelValues);\n  }\n\n  return _createClass(ModelValues, null, [{\n    key: \"compare\",\n    value:\n    /**\n     * @param {?=} x\n     * @param {?=} y\n     * @return {?}\n     */\n    function compare(x, y) {\n      if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      return x.value === y.value && x.highValue === y.highValue;\n    }\n  }]);\n}();\n\nvar ModelChange = /*#__PURE__*/function (_ModelValues) {\n  function ModelChange() {\n    _classCallCheck(this, ModelChange);\n\n    return _callSuper(this, ModelChange, arguments);\n  }\n\n  _inherits(ModelChange, _ModelValues);\n\n  return _createClass(ModelChange, null, [{\n    key: \"compare\",\n    value:\n    /**\n     * @param {?=} x\n     * @param {?=} y\n     * @return {?}\n     */\n    function compare(x, y) {\n      if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n        return false;\n      }\n\n      return x.value === y.value && x.highValue === y.highValue && x.forceChange === y.forceChange;\n    }\n  }]);\n}(ModelValues);\n\nvar NG5_SLIDER_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: forwardRef(function () {\n    return SliderComponent;\n  }),\n  multi: true\n};\n\nvar SliderComponent = /*@__PURE__*/function () {\n  var SliderComponent = /*#__PURE__*/function () {\n    /**\n     * @param {?} renderer\n     * @param {?} elementRef\n     * @param {?} changeDetectionRef\n     * @param {?} zone\n     */\n    function SliderComponent(renderer, elementRef, changeDetectionRef, zone) {\n      _classCallCheck(this, SliderComponent);\n\n      this.renderer = renderer;\n      this.elementRef = elementRef;\n      this.changeDetectionRef = changeDetectionRef;\n      this.zone = zone; // Model for low value of slider. For simple slider, this is the only input. For range slider, this is the low value.\n\n      this.value = null; // Output for low value slider to support two-way bindings\n\n      this.valueChange = new EventEmitter(); // Model for high value of slider. Not used in simple slider. For range slider, this is the high value.\n\n      this.highValue = null; // Output for high value slider to support two-way bindings\n\n      this.highValueChange = new EventEmitter(); // An object with all the other options of the slider.\n      // Each option can be updated at runtime and the slider will automatically be re-rendered.\n\n      this.options = new Options(); // Event emitted when user starts interaction with the slider\n\n      this.userChangeStart = new EventEmitter(); // Event emitted on each change coming from user interaction\n\n      this.userChange = new EventEmitter(); // Event emitted when user finishes interaction with the slider\n\n      this.userChangeEnd = new EventEmitter();\n      this.initHasRun = false;\n      this.inputModelChangeSubject = new Subject();\n      this.inputModelChangeSubscription = null;\n      this.outputModelChangeSubject = new Subject();\n      this.outputModelChangeSubscription = null;\n      this.viewLowValue = null;\n      this.viewHighValue = null;\n      this.viewOptions = new Options();\n      this.handleHalfDimension = 0;\n      this.maxHandlePosition = 0;\n      this.currentTrackingPointer = null;\n      this.currentFocusPointer = null;\n      this.firstKeyDown = false;\n      this.touchId = null;\n      this.dragging = new Dragging(); // Host element class bindings\n\n      this.sliderElementVerticalClass = false;\n      this.sliderElementAnimateClass = false;\n      this.sliderElementDisabledAttr = null;\n      this.barStyle = {};\n      this.minPointerStyle = {};\n      this.maxPointerStyle = {};\n      this.fullBarTransparentClass = false;\n      this.selectionBarDraggableClass = false;\n      this.ticksUnderValuesClass = false;\n      this.intermediateTicks = false;\n      this.ticks = [];\n      this.eventListenerHelper = null;\n      this.onMoveEventListener = null;\n      this.onEndEventListener = null;\n      this.resizeObserver = null;\n      this.onTouchedCallback = null;\n      this.onChangeCallback = null;\n      this.eventListenerHelper = new EventListenerHelper(this.renderer);\n    }\n    /**\n     * @param {?} manualRefresh\n     * @return {?}\n     */\n\n\n    return _createClass(SliderComponent, [{\n      key: \"manualRefresh\",\n      set: function set(manualRefresh) {\n        var _this3 = this;\n\n        this.unsubscribeManualRefresh();\n        this.manualRefreshSubscription = manualRefresh.subscribe(function () {\n          setTimeout(function () {\n            return _this3.calculateViewDimensionsAndDetectChanges();\n          });\n        });\n      }\n      /**\n       * @param {?} triggerFocus\n       * @return {?}\n       */\n\n    }, {\n      key: \"triggerFocus\",\n      set: function set(triggerFocus) {\n        var _this4 = this;\n\n        this.unsubscribeTriggerFocus();\n        this.triggerFocusSubscription = triggerFocus.subscribe(function (pointerType) {\n          _this4.focusPointer(pointerType);\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"range\",\n      get: function get() {\n        return !ValueHelper.isNullOrUndefined(this.value) && !ValueHelper.isNullOrUndefined(this.highValue);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"showTicks\",\n      get: function get() {\n        return this.viewOptions.showTicks;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.viewOptions = new Options();\n        Object.assign(this.viewOptions, this.options); // We need to run these two things first, before the rest of the init in ngAfterViewInit(),\n        // because these two settings are set through @HostBinding and Angular change detection\n        // mechanism doesn't like them changing in ngAfterViewInit()\n\n        this.updateDisabledState();\n        this.updateVerticalState();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        this.applyOptions();\n        this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n        this.subscribeOutputModelChangeSubject(this.viewOptions.outputEventsInterval); // Once we apply options, we need to normalise model values for the first time\n\n        this.renormaliseModelValues();\n        this.viewLowValue = this.modelValueToViewValue(this.value);\n\n        if (this.range) {\n          this.viewHighValue = this.modelValueToViewValue(this.highValue);\n        } else {\n          this.viewHighValue = null;\n        }\n\n        this.updateVerticalState(); // need to run this again to cover changes to slider elements\n\n        this.manageElementsStyle();\n        this.updateDisabledState();\n        this.calculateViewDimensions();\n        this.addAccessibility();\n        this.updateCeilLabel();\n        this.updateFloorLabel();\n        this.initHandles();\n        this.manageEventsBindings();\n        this.subscribeResizeObserver();\n        this.initHasRun = true; // Run change detection manually to resolve some issues when init procedure changes values used in the view\n\n        if (!this.isRefDestroyed()) {\n          this.changeDetectionRef.detectChanges();\n        }\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        // Always apply options first\n        if (!ValueHelper.isNullOrUndefined(changes[\"options\"])) {\n          this.onChangeOptions();\n        } // Then value changes\n\n\n        if (!ValueHelper.isNullOrUndefined(changes[\"value\"]) || !ValueHelper.isNullOrUndefined(changes[\"highValue\"])) {\n          this.inputModelChangeSubject.next({\n            value: this.value,\n            highValue: this.highValue,\n            forceChange: false,\n            internalChange: false\n          });\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.unbindEvents();\n        this.unsubscribeResizeObserver();\n        this.unsubscribeInputModelChangeSubject();\n        this.unsubscribeOutputModelChangeSubject();\n        this.unsubscribeManualRefresh();\n        this.unsubscribeTriggerFocus();\n      }\n      /**\n       * @param {?} obj\n       * @return {?}\n       */\n\n    }, {\n      key: \"writeValue\",\n      value: function writeValue(obj) {\n        if (obj instanceof Array) {\n          this.value = obj[0];\n          this.highValue = obj[1];\n        } else {\n          this.value = obj;\n        } // ngOnChanges() is not called in this instance, so we need to communicate the change manually\n\n\n        this.inputModelChangeSubject.next({\n          value: this.value,\n          highValue: this.highValue,\n          forceChange: false,\n          internalChange: false\n        });\n      }\n      /**\n       * @param {?} onChangeCallback\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnChange\",\n      value: function registerOnChange(onChangeCallback) {\n        this.onChangeCallback = onChangeCallback;\n      }\n      /**\n       * @param {?} onTouchedCallback\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnTouched\",\n      value: function registerOnTouched(onTouchedCallback) {\n        this.onTouchedCallback = onTouchedCallback;\n      }\n      /**\n       * @param {?} isDisabled\n       * @return {?}\n       */\n\n    }, {\n      key: \"setDisabledState\",\n      value: function setDisabledState(isDisabled) {\n        this.viewOptions.disabled = isDisabled;\n        this.updateDisabledState();\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onResize\",\n      value: function onResize(event) {\n        this.calculateViewDimensionsAndDetectChanges();\n      }\n      /**\n       * @param {?=} interval\n       * @return {?}\n       */\n\n    }, {\n      key: \"subscribeInputModelChangeSubject\",\n      value: function subscribeInputModelChangeSubject(interval) {\n        var _this5 = this;\n\n        this.inputModelChangeSubscription = this.inputModelChangeSubject.pipe(distinctUntilChanged(ModelChange.compare), // Hack to reset the status of the distinctUntilChanged() - if a \"fake\" event comes through with forceChange=true,\n        // we forcefully by-pass distinctUntilChanged(), but otherwise drop the event\n        filter(function (modelChange) {\n          return !modelChange.forceChange && !modelChange.internalChange;\n        }), !ValueHelper.isNullOrUndefined(interval) ? throttleTime(interval, undefined, {\n          leading: true,\n          trailing: true\n        }) : tap(function () {}) // no-op\n        ).subscribe(function (modelChange) {\n          return _this5.applyInputModelChange(modelChange);\n        });\n      }\n      /**\n       * @param {?=} interval\n       * @return {?}\n       */\n\n    }, {\n      key: \"subscribeOutputModelChangeSubject\",\n      value: function subscribeOutputModelChangeSubject(interval) {\n        var _this6 = this;\n\n        this.outputModelChangeSubscription = this.outputModelChangeSubject.pipe(distinctUntilChanged(ModelChange.compare), !ValueHelper.isNullOrUndefined(interval) ? throttleTime(interval, undefined, {\n          leading: true,\n          trailing: true\n        }) : tap(function () {}) // no-op\n        ).subscribe(function (modelChange) {\n          return _this6.publishOutputModelChange(modelChange);\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"subscribeResizeObserver\",\n      value: function subscribeResizeObserver() {\n        var _this7 = this;\n\n        if (CompatibilityHelper.isResizeObserverAvailable()) {\n          this.resizeObserver = new ResizeObserver(function () {\n            return _this7.calculateViewDimensionsAndDetectChanges();\n          });\n          this.resizeObserver.observe(this.elementRef.nativeElement);\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeResizeObserver\",\n      value: function unsubscribeResizeObserver() {\n        if (CompatibilityHelper.isResizeObserverAvailable() && this.resizeObserver !== null) {\n          this.resizeObserver.disconnect();\n          this.resizeObserver = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeOnMove\",\n      value: function unsubscribeOnMove() {\n        if (!ValueHelper.isNullOrUndefined(this.onMoveEventListener)) {\n          this.eventListenerHelper.detachEventListener(this.onMoveEventListener);\n          this.onMoveEventListener = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeOnEnd\",\n      value: function unsubscribeOnEnd() {\n        if (!ValueHelper.isNullOrUndefined(this.onEndEventListener)) {\n          this.eventListenerHelper.detachEventListener(this.onEndEventListener);\n          this.onEndEventListener = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeInputModelChangeSubject\",\n      value: function unsubscribeInputModelChangeSubject() {\n        if (!ValueHelper.isNullOrUndefined(this.inputModelChangeSubscription)) {\n          this.inputModelChangeSubscription.unsubscribe();\n          this.inputModelChangeSubscription = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeOutputModelChangeSubject\",\n      value: function unsubscribeOutputModelChangeSubject() {\n        if (!ValueHelper.isNullOrUndefined(this.outputModelChangeSubscription)) {\n          this.outputModelChangeSubscription.unsubscribe();\n          this.outputModelChangeSubscription = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeManualRefresh\",\n      value: function unsubscribeManualRefresh() {\n        if (!ValueHelper.isNullOrUndefined(this.manualRefreshSubscription)) {\n          this.manualRefreshSubscription.unsubscribe();\n          this.manualRefreshSubscription = null;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeTriggerFocus\",\n      value: function unsubscribeTriggerFocus() {\n        if (!ValueHelper.isNullOrUndefined(this.triggerFocusSubscription)) {\n          this.triggerFocusSubscription.unsubscribe();\n          this.triggerFocusSubscription = null;\n        }\n      }\n      /**\n       * @param {?} pointerType\n       * @return {?}\n       */\n\n    }, {\n      key: \"getPointerElement\",\n      value: function getPointerElement(pointerType) {\n        if (pointerType === PointerType.Min) {\n          return this.minHandleElement;\n        } else if (pointerType === PointerType.Max) {\n          return this.maxHandleElement;\n        }\n\n        return null;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getCurrentTrackingValue\",\n      value: function getCurrentTrackingValue() {\n        if (this.currentTrackingPointer === PointerType.Min) {\n          return this.viewLowValue;\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          return this.viewHighValue;\n        }\n\n        return null;\n      }\n      /**\n       * @param {?} modelValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"modelValueToViewValue\",\n      value: function modelValueToViewValue(modelValue) {\n        if (ValueHelper.isNullOrUndefined(modelValue)) {\n          return NaN;\n        }\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n          return ValueHelper.findStepIndex(+modelValue, this.viewOptions.stepsArray);\n        }\n\n        return +modelValue;\n      }\n      /**\n       * @param {?} viewValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"viewValueToModelValue\",\n      value: function viewValueToModelValue(viewValue) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n          return this.getStepValue(viewValue);\n        }\n\n        return viewValue;\n      }\n      /**\n       * @param {?} sliderValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"getStepValue\",\n      value: function getStepValue(sliderValue) {\n        var\n        /** @type {?} */\n        step = this.viewOptions.stepsArray[sliderValue];\n        return !ValueHelper.isNullOrUndefined(step) ? step.value : NaN;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyViewChange\",\n      value: function applyViewChange() {\n        this.value = this.viewValueToModelValue(this.viewLowValue);\n\n        if (this.range) {\n          this.highValue = this.viewValueToModelValue(this.viewHighValue);\n        }\n\n        this.outputModelChangeSubject.next({\n          value: this.value,\n          highValue: this.highValue,\n          userEventInitiated: true,\n          forceChange: false\n        }); // At this point all changes are applied and outputs are emitted, so we should be done.\n        // However, input changes are communicated in different stream and we need to be ready to\n        // act on the next input change even if it is exactly the same as last input change.\n        // Therefore, we send a special event to reset the stream.\n\n        this.inputModelChangeSubject.next({\n          value: this.value,\n          highValue: this.highValue,\n          forceChange: false,\n          internalChange: true\n        });\n      }\n      /**\n       * @param {?} modelChange\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyInputModelChange\",\n      value: function applyInputModelChange(modelChange) {\n        var\n        /** @type {?} */\n        normalisedModelChange = this.normaliseModelValues(modelChange); // If normalised model change is different, apply the change to the model values\n\n        var\n        /** @type {?} */\n        normalisationChange = !ModelValues.compare(modelChange, normalisedModelChange);\n\n        if (normalisationChange) {\n          this.value = normalisedModelChange.value;\n          this.highValue = normalisedModelChange.highValue;\n        }\n\n        this.viewLowValue = this.modelValueToViewValue(normalisedModelChange.value);\n\n        if (this.range) {\n          this.viewHighValue = this.modelValueToViewValue(normalisedModelChange.highValue);\n        } else {\n          this.viewHighValue = null;\n        }\n\n        this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n\n        if (this.range) {\n          this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n        }\n\n        this.updateSelectionBar();\n        this.updateTicksScale();\n        this.updateAriaAttributes();\n\n        if (this.range) {\n          this.updateCombinedLabel();\n        } // At the end, we need to communicate the model change to the outputs as well\n        // Normalisation changes are also always forced out to ensure that subscribers always end up in correct state\n\n\n        this.outputModelChangeSubject.next({\n          value: normalisedModelChange.value,\n          highValue: normalisedModelChange.highValue,\n          forceChange: normalisationChange,\n          userEventInitiated: false\n        });\n      }\n      /**\n       * @param {?} modelChange\n       * @return {?}\n       */\n\n    }, {\n      key: \"publishOutputModelChange\",\n      value: function publishOutputModelChange(modelChange) {\n        var _this8 = this;\n\n        var\n        /** @type {?} */\n        emitOutputs = function emitOutputs() {\n          _this8.valueChange.emit(modelChange.value);\n\n          if (_this8.range) {\n            _this8.highValueChange.emit(modelChange.highValue);\n          }\n\n          if (!ValueHelper.isNullOrUndefined(_this8.onChangeCallback)) {\n            if (_this8.range) {\n              _this8.onChangeCallback([modelChange.value, modelChange.highValue]);\n            } else {\n              _this8.onChangeCallback(modelChange.value);\n            }\n          }\n\n          if (!ValueHelper.isNullOrUndefined(_this8.onTouchedCallback)) {\n            if (_this8.range) {\n              _this8.onTouchedCallback([modelChange.value, modelChange.highValue]);\n            } else {\n              _this8.onTouchedCallback(modelChange.value);\n            }\n          }\n        };\n\n        if (modelChange.userEventInitiated) {\n          // If this change was initiated by a user event, we can emit outputs in the same tick\n          emitOutputs();\n          this.userChange.emit(this.getChangeContext());\n        } else {\n          // But, if the change was initated by something else like a change in input bindings,\n          // we need to wait until next tick to emit the outputs to keep Angular change detection happy\n          setTimeout(function () {\n            emitOutputs();\n          });\n        }\n      }\n      /**\n       * @param {?} input\n       * @return {?}\n       */\n\n    }, {\n      key: \"normaliseModelValues\",\n      value: function normaliseModelValues(input) {\n        var\n        /** @type {?} */\n        normalisedInput = new ModelValues();\n        normalisedInput.value = input.value;\n        normalisedInput.highValue = input.highValue;\n\n        if (this.viewOptions.enforceStep) {\n          normalisedInput.value = this.roundStep(normalisedInput.value);\n\n          if (this.range) {\n            normalisedInput.highValue = this.roundStep(normalisedInput.highValue);\n          }\n        } // Don't attempt to normalise further when using steps array (steps may be out of order and that is perfectly fine)\n\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) || !this.viewOptions.enforceRange) {\n          return normalisedInput;\n        }\n\n        normalisedInput.value = MathHelper.clampToRange(normalisedInput.value, this.viewOptions.floor, this.viewOptions.ceil);\n\n        if (this.range) {\n          normalisedInput.highValue = MathHelper.clampToRange(normalisedInput.highValue, this.viewOptions.floor, this.viewOptions.ceil);\n        } // Make sure that range slider invariant (value <= highValue) is always satisfied\n\n\n        if (this.range && input.value > input.highValue) {\n          // We know that both values are now clamped correctly, they may just be in the wrong order\n          // So the easy solution is to swap them... except swapping is sometimes disabled in options, so we make the two values the same\n          if (this.viewOptions.noSwitching) {\n            normalisedInput.value = normalisedInput.highValue;\n          } else {\n            var\n            /** @type {?} */\n            tempValue = input.value;\n            normalisedInput.value = input.highValue;\n            normalisedInput.highValue = tempValue;\n          }\n        }\n\n        return normalisedInput;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"renormaliseModelValues\",\n      value: function renormaliseModelValues() {\n        var\n        /** @type {?} */\n        previousModelValues = {\n          value: this.value,\n          highValue: this.highValue\n        };\n        var\n        /** @type {?} */\n        normalisedModelValues = this.normaliseModelValues(previousModelValues);\n\n        if (!ModelValues.compare(normalisedModelValues, previousModelValues)) {\n          this.value = normalisedModelValues.value;\n          this.highValue = normalisedModelValues.highValue;\n          this.outputModelChangeSubject.next({\n            value: this.value,\n            highValue: this.highValue,\n            forceChange: true,\n            userEventInitiated: false\n          });\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"onChangeOptions\",\n      value: function onChangeOptions() {\n        if (!this.initHasRun) {\n          return;\n        }\n\n        var\n        /** @type {?} */\n        previousInputEventsInterval = this.viewOptions.inputEventsInterval;\n        var\n        /** @type {?} */\n        previousOutputEventsInterval = this.viewOptions.outputEventsInterval;\n        this.applyOptions();\n\n        if (previousInputEventsInterval !== this.viewOptions.inputEventsInterval) {\n          this.unsubscribeInputModelChangeSubject();\n          this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n        }\n\n        if (previousOutputEventsInterval !== this.viewOptions.outputEventsInterval) {\n          this.unsubscribeInputModelChangeSubject();\n          this.subscribeInputModelChangeSubject(this.viewOptions.outputEventsInterval);\n        } // With new options, we need to re-normalise model values if necessary\n\n\n        this.renormaliseModelValues();\n        this.viewLowValue = this.modelValueToViewValue(this.value);\n\n        if (this.range) {\n          this.viewHighValue = this.modelValueToViewValue(this.highValue);\n        } else {\n          this.viewHighValue = null;\n        }\n\n        this.resetSlider();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyOptions\",\n      value: function applyOptions() {\n        this.viewOptions = new Options();\n        Object.assign(this.viewOptions, this.options);\n        this.viewOptions.draggableRange = this.range && this.viewOptions.draggableRange;\n        this.viewOptions.draggableRangeOnly = this.range && this.viewOptions.draggableRangeOnly;\n\n        if (this.viewOptions.draggableRangeOnly) {\n          this.viewOptions.draggableRange = true;\n        }\n\n        this.viewOptions.showTicks = this.viewOptions.showTicks || this.viewOptions.showTicksValues || !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray);\n\n        if (this.viewOptions.showTicks && (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) || !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray))) {\n          this.intermediateTicks = true;\n        }\n\n        this.viewOptions.showSelectionBar = this.viewOptions.showSelectionBar || this.viewOptions.showSelectionBarEnd || !ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue);\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n          this.applyStepsArrayOptions();\n        } else {\n          this.applyFloorCeilOptions();\n        }\n\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.combineLabels)) {\n          this.viewOptions.combineLabels = function (minValue, maxValue) {\n            return minValue + ' - ' + maxValue;\n          };\n        }\n\n        if (this.viewOptions.logScale && this.viewOptions.floor === 0) {\n          throw Error('Can\\'t use floor=0 with logarithmic scale');\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyStepsArrayOptions\",\n      value: function applyStepsArrayOptions() {\n        var _this9 = this;\n\n        this.viewOptions.floor = 0;\n        this.viewOptions.ceil = this.viewOptions.stepsArray.length - 1;\n        this.viewOptions.step = 1;\n\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n          this.viewOptions.translate = function (modelValue) {\n            if (_this9.viewOptions.bindIndexForStepsArray) {\n              return String(_this9.getStepValue(modelValue));\n            }\n\n            return String(modelValue);\n          };\n        }\n\n        this.viewOptions.getLegend = function (index) {\n          var\n          /** @type {?} */\n          step = _this9.viewOptions.stepsArray[index];\n          return step.legend;\n        };\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyFloorCeilOptions\",\n      value: function applyFloorCeilOptions() {\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.step)) {\n          this.viewOptions.step = 1;\n        } else {\n          this.viewOptions.step = +this.viewOptions.step;\n\n          if (this.viewOptions.step <= 0) {\n            this.viewOptions.step = 1;\n          }\n        }\n\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.ceil) || ValueHelper.isNullOrUndefined(this.viewOptions.floor)) {\n          throw Error('floor and ceil options must be supplied');\n        }\n\n        this.viewOptions.ceil = +this.viewOptions.ceil;\n        this.viewOptions.floor = +this.viewOptions.floor;\n\n        if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n          this.viewOptions.translate = function (value) {\n            return String(value);\n          };\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"resetSlider\",\n      value: function resetSlider() {\n        this.manageElementsStyle();\n        this.addAccessibility();\n        this.updateCeilLabel();\n        this.updateFloorLabel();\n        this.unbindEvents();\n        this.manageEventsBindings();\n        this.updateDisabledState();\n        this.calculateViewDimensions();\n        this.refocusPointerIfNeeded();\n      }\n      /**\n       * @param {?} pointerType\n       * @return {?}\n       */\n\n    }, {\n      key: \"focusPointer\",\n      value: function focusPointer(pointerType) {\n        // If not supplied, use min pointer as default\n        if (pointerType !== PointerType.Min && pointerType !== PointerType.Max) {\n          pointerType = PointerType.Min;\n        }\n\n        if (pointerType === PointerType.Min) {\n          this.minHandleElement.focus();\n        } else if (this.range && pointerType === PointerType.Max) {\n          this.maxHandleElement.focus();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"refocusPointerIfNeeded\",\n      value: function refocusPointerIfNeeded() {\n        if (!ValueHelper.isNullOrUndefined(this.currentFocusPointer)) {\n          this.onPointerFocus(this.currentFocusPointer);\n          var\n          /** @type {?} */\n          element = this.getPointerElement(this.currentFocusPointer);\n          element.focus();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"manageElementsStyle\",\n      value: function manageElementsStyle() {\n        var _this10 = this;\n\n        this.updateScale();\n        this.floorLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n        this.ceilLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n        var\n        /** @type {?} */\n        hideLabelsForTicks = this.viewOptions.showTicksValues && !this.intermediateTicks;\n        this.minHandleLabelElement.setAlwaysHide(hideLabelsForTicks || this.viewOptions.hidePointerLabels);\n        this.maxHandleLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n        this.combinedLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n        this.selectionBarElement.setAlwaysHide(!this.range && !this.viewOptions.showSelectionBar);\n        this.leftOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n        this.rightOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n        this.fullBarTransparentClass = this.range && this.viewOptions.showOuterSelectionBars;\n        this.selectionBarDraggableClass = this.viewOptions.draggableRange && !this.viewOptions.onlyBindHandles;\n        this.ticksUnderValuesClass = this.intermediateTicks && this.options.showTicksValues;\n\n        if (this.sliderElementVerticalClass !== this.viewOptions.vertical) {\n          this.updateVerticalState(); // The above change in host component class will not be applied until the end of this cycle\n          // However, functions calculating the slider position expect the slider to be already styled as vertical\n          // So as a workaround, we need to reset the slider once again to compute the correct values\n\n          setTimeout(function () {\n            _this10.resetSlider();\n          });\n        } // Changing animate class may interfere with slider reset/initialisation, so we should set it separately,\n        // after all is properly set up\n\n\n        if (this.sliderElementAnimateClass !== this.viewOptions.animate) {\n          setTimeout(function () {\n            _this10.sliderElementAnimateClass = _this10.viewOptions.animate;\n          });\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"manageEventsBindings\",\n      value: function manageEventsBindings() {\n        if (this.viewOptions.disabled || this.viewOptions.readOnly) {\n          this.unbindEvents();\n        } else {\n          this.bindEvents();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateDisabledState\",\n      value: function updateDisabledState() {\n        this.sliderElementDisabledAttr = this.viewOptions.disabled ? 'disabled' : null;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateVerticalState\",\n      value: function updateVerticalState() {\n        this.sliderElementVerticalClass = this.viewOptions.vertical;\n\n        var _iterator2 = _createForOfIteratorHelper(this.getAllSliderElements()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var element = _step2.value;\n\n            // This is also called before ngAfterInit, so need to check that view child bindings work\n            if (!ValueHelper.isNullOrUndefined(element)) {\n              element.setVertical(this.viewOptions.vertical);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateScale\",\n      value: function updateScale() {\n        var _iterator3 = _createForOfIteratorHelper(this.getAllSliderElements()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var element = _step3.value;\n            element.setScale(this.viewOptions.scale);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getAllSliderElements\",\n      value: function getAllSliderElements() {\n        return [this.leftOuterSelectionBarElement, this.rightOuterSelectionBarElement, this.fullBarElement, this.selectionBarElement, this.minHandleElement, this.maxHandleElement, this.floorLabelElement, this.ceilLabelElement, this.minHandleLabelElement, this.maxHandleLabelElement, this.combinedLabelElement, this.ticksElement];\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"initHandles\",\n      value: function initHandles() {\n        this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n        /*\n           the order here is important since the selection bar should be\n           updated after the high handle but before the combined label\n           */\n\n        if (this.range) {\n          this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n        }\n\n        this.updateSelectionBar();\n\n        if (this.range) {\n          this.updateCombinedLabel();\n        }\n\n        this.updateTicksScale();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"addAccessibility\",\n      value: function addAccessibility() {\n        this.updateAriaAttributes();\n        this.minHandleElement.role = 'slider';\n\n        if (this.viewOptions.keyboardSupport && !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n          this.minHandleElement.tabindex = '0';\n        } else {\n          this.minHandleElement.tabindex = '';\n        }\n\n        if (this.viewOptions.vertical) {\n          this.minHandleElement.ariaOrientation = 'vertical';\n        }\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabel)) {\n          this.minHandleElement.ariaLabel = this.viewOptions.ariaLabel;\n        } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledBy)) {\n          this.minHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledBy;\n        }\n\n        if (this.range) {\n          this.maxHandleElement.role = 'slider';\n\n          if (this.viewOptions.keyboardSupport && !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n            this.maxHandleElement.tabindex = '0';\n          } else {\n            this.maxHandleElement.tabindex = '';\n          }\n\n          this.maxHandleElement.ariaOrientation = this.viewOptions.vertical ? 'vertical' : 'horizontal';\n\n          if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelHigh)) {\n            this.maxHandleElement.ariaLabel = this.viewOptions.ariaLabelHigh;\n          } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledByHigh)) {\n            this.maxHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledByHigh;\n          }\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateAriaAttributes\",\n      value: function updateAriaAttributes() {\n        this.minHandleElement.ariaValueNow = (+this.value).toString();\n        this.minHandleElement.ariaValueText = this.viewOptions.translate(+this.value, LabelType.Low);\n        this.minHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n        this.minHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n\n        if (this.range) {\n          this.maxHandleElement.ariaValueNow = (+this.highValue).toString();\n          this.maxHandleElement.ariaValueText = this.viewOptions.translate(+this.highValue, LabelType.High);\n          this.maxHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n          this.maxHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"calculateViewDimensions\",\n      value: function calculateViewDimensions() {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.handleDimension)) {\n          this.minHandleElement.setDimension(this.viewOptions.handleDimension);\n        } else {\n          this.minHandleElement.calculateDimension();\n        }\n\n        var\n        /** @type {?} */\n        handleWidth = this.minHandleElement.dimension;\n        this.handleHalfDimension = handleWidth / 2;\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.barDimension)) {\n          this.fullBarElement.setDimension(this.viewOptions.barDimension);\n        } else {\n          this.fullBarElement.calculateDimension();\n        }\n\n        this.maxHandlePosition = this.fullBarElement.dimension - handleWidth;\n\n        if (this.initHasRun) {\n          this.updateFloorLabel();\n          this.updateCeilLabel();\n          this.initHandles();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"calculateViewDimensionsAndDetectChanges\",\n      value: function calculateViewDimensionsAndDetectChanges() {\n        this.calculateViewDimensions();\n\n        if (!this.isRefDestroyed()) {\n          this.changeDetectionRef.detectChanges();\n        }\n      }\n      /**\n       * If the slider reference is already destroyed\n       * @return {?} boolean - true if ref is destroyed\n       */\n\n    }, {\n      key: \"isRefDestroyed\",\n      value: function isRefDestroyed() {\n        return this.changeDetectionRef['destroyed'];\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateTicksScale\",\n      value: function updateTicksScale() {\n        var _this11 = this;\n\n        if (!this.viewOptions.showTicks) {\n          return;\n        }\n\n        var\n        /** @type {?} */\n        ticksArray = !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray) ? this.viewOptions.ticksArray : this.getTicksArray();\n        var\n        /** @type {?} */\n        translate = this.viewOptions.vertical ? 'translateY' : 'translateX';\n\n        if (this.viewOptions.rightToLeft) {\n          ticksArray.reverse();\n        }\n\n        var\n        /** @type {?} */\n        newTicks = ticksArray.map(function (value) {\n          var\n          /** @type {?} */\n          position = _this11.valueToPosition(value);\n\n          if (_this11.viewOptions.vertical) {\n            position = _this11.maxHandlePosition - position;\n          }\n\n          var\n          /** @type {?} */\n          translation = translate + '(' + Math.round(position) + 'px)';\n          var\n          /** @type {?} */\n          tick = new Tick();\n          tick.selected = _this11.isTickSelected(value);\n          tick.style = {\n            '-webkit-transform': translation,\n            '-moz-transform': translation,\n            '-o-transform': translation,\n            '-ms-transform': translation,\n            transform: translation\n          };\n\n          if (tick.selected && !ValueHelper.isNullOrUndefined(_this11.viewOptions.getSelectionBarColor)) {\n            tick.style['background-color'] = _this11.getSelectionBarColor();\n          }\n\n          if (!tick.selected && !ValueHelper.isNullOrUndefined(_this11.viewOptions.getTickColor)) {\n            tick.style['background-color'] = _this11.getTickColor(value);\n          }\n\n          if (!ValueHelper.isNullOrUndefined(_this11.viewOptions.ticksTooltip)) {\n            tick.tooltip = _this11.viewOptions.ticksTooltip(value);\n            tick.tooltipPlacement = _this11.viewOptions.vertical ? 'right' : 'top';\n          }\n\n          if (_this11.viewOptions.showTicksValues && value % _this11.viewOptions.tickValueStep === 0) {\n            tick.value = _this11.getDisplayValue(value, LabelType.TickValue);\n\n            if (!ValueHelper.isNullOrUndefined(_this11.viewOptions.ticksValuesTooltip)) {\n              tick.valueTooltip = _this11.viewOptions.ticksValuesTooltip(value);\n              tick.valueTooltipPlacement = _this11.viewOptions.vertical ? 'right' : 'top';\n            }\n          }\n\n          if (!ValueHelper.isNullOrUndefined(_this11.viewOptions.getLegend)) {\n            var\n            /** @type {?} */\n            legend = _this11.viewOptions.getLegend(value);\n\n            if (!ValueHelper.isNullOrUndefined(legend)) {\n              tick.legend = legend;\n            }\n          }\n\n          return tick;\n        }); // We should avoid re-creating the ticks array if possible\n        // This both improves performance and makes CSS animations work correctly\n\n        if (!ValueHelper.isNullOrUndefined(this.ticks) && this.ticks.length === newTicks.length) {\n          for (var\n          /** @type {?} */\n          i = 0; i < newTicks.length; ++i) {\n            Object.assign(this.ticks[i], newTicks[i]);\n          }\n        } else {\n          this.ticks = newTicks;\n        }\n\n        if (!this.isRefDestroyed()) {\n          this.changeDetectionRef.detectChanges();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getTicksArray\",\n      value: function getTicksArray() {\n        var\n        /** @type {?} */\n        step = !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) ? this.viewOptions.tickStep : this.viewOptions.step;\n        var\n        /** @type {?} */\n        ticksArray = [];\n\n        for (var\n        /** @type {?} */\n        value = this.viewOptions.floor; value <= this.viewOptions.ceil; value += step) {\n          ticksArray.push(value);\n        }\n\n        return ticksArray;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"isTickSelected\",\n      value: function isTickSelected(value) {\n        if (!this.range) {\n          if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n            var\n            /** @type {?} */\n            center = this.viewOptions.showSelectionBarFromValue;\n\n            if (this.viewLowValue > center && value >= center && value <= this.viewLowValue) {\n              return true;\n            } else if (this.viewLowValue < center && value <= center && value >= this.viewLowValue) {\n              return true;\n            }\n          } else if (this.viewOptions.showSelectionBarEnd) {\n            if (value >= this.viewLowValue) {\n              return true;\n            }\n          } else if (this.viewOptions.showSelectionBar && value <= this.viewLowValue) {\n            return true;\n          }\n        }\n\n        if (this.range && value >= this.viewLowValue && value <= this.viewHighValue) {\n          return true;\n        }\n\n        return false;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateFloorLabel\",\n      value: function updateFloorLabel() {\n        if (!this.floorLabelElement.alwaysHide) {\n          this.floorLabelElement.setValue(this.getDisplayValue(this.viewOptions.floor, LabelType.Floor));\n          this.floorLabelElement.calculateDimension();\n          var\n          /** @type {?} */\n          position = this.viewOptions.rightToLeft ? this.fullBarElement.dimension - this.floorLabelElement.dimension : 0;\n          this.floorLabelElement.setPosition(position);\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateCeilLabel\",\n      value: function updateCeilLabel() {\n        if (!this.ceilLabelElement.alwaysHide) {\n          this.ceilLabelElement.setValue(this.getDisplayValue(this.viewOptions.ceil, LabelType.Ceil));\n          this.ceilLabelElement.calculateDimension();\n          var\n          /** @type {?} */\n          position = this.viewOptions.rightToLeft ? 0 : this.fullBarElement.dimension - this.ceilLabelElement.dimension;\n          this.ceilLabelElement.setPosition(position);\n        }\n      }\n      /**\n       * @param {?} which\n       * @param {?} newPos\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateHandles\",\n      value: function updateHandles(which, newPos) {\n        if (which === PointerType.Min) {\n          this.updateLowHandle(newPos);\n        } else if (which === PointerType.Max) {\n          this.updateHighHandle(newPos);\n        }\n\n        this.updateSelectionBar();\n        this.updateTicksScale();\n\n        if (this.range) {\n          this.updateCombinedLabel();\n        }\n      }\n      /**\n       * @param {?} labelType\n       * @param {?} newPos\n       * @return {?}\n       */\n\n    }, {\n      key: \"getHandleLabelPos\",\n      value: function getHandleLabelPos(labelType, newPos) {\n        var\n        /** @type {?} */\n        labelDimension = labelType === PointerType.Min ? this.minHandleLabelElement.dimension : this.maxHandleLabelElement.dimension;\n        var\n        /** @type {?} */\n        nearHandlePos = newPos - labelDimension / 2 + this.handleHalfDimension;\n        var\n        /** @type {?} */\n        endOfBarPos = this.fullBarElement.dimension - labelDimension;\n\n        if (!this.viewOptions.boundPointerLabels) {\n          return nearHandlePos;\n        }\n\n        if (this.viewOptions.rightToLeft && labelType === PointerType.Min || !this.viewOptions.rightToLeft && labelType === PointerType.Max) {\n          return Math.min(nearHandlePos, endOfBarPos);\n        } else {\n          return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);\n        }\n      }\n      /**\n       * @param {?} newPos\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateLowHandle\",\n      value: function updateLowHandle(newPos) {\n        this.minHandleElement.setPosition(newPos);\n        this.minHandleLabelElement.setValue(this.getDisplayValue(this.viewLowValue, LabelType.Low));\n        this.minHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Min, newPos));\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n          this.minPointerStyle = {\n            backgroundColor: this.getPointerColor(PointerType.Min)\n          };\n        }\n\n        if (this.viewOptions.autoHideLimitLabels) {\n          this.updateFloorAndCeilLabelsVisibility();\n        }\n      }\n      /**\n       * @param {?} newPos\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateHighHandle\",\n      value: function updateHighHandle(newPos) {\n        this.maxHandleElement.setPosition(newPos);\n        this.maxHandleLabelElement.setValue(this.getDisplayValue(this.viewHighValue, LabelType.High));\n        this.maxHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Max, newPos));\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n          this.maxPointerStyle = {\n            backgroundColor: this.getPointerColor(PointerType.Max)\n          };\n        }\n\n        if (this.viewOptions.autoHideLimitLabels) {\n          this.updateFloorAndCeilLabelsVisibility();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateFloorAndCeilLabelsVisibility\",\n      value: function updateFloorAndCeilLabelsVisibility() {\n        // Show based only on hideLimitLabels if pointer labels are hidden\n        if (this.viewOptions.hidePointerLabels) {\n          return;\n        }\n\n        var\n        /** @type {?} */\n        floorLabelHidden = false;\n        var\n        /** @type {?} */\n        ceilLabelHidden = false;\n        var\n        /** @type {?} */\n        isMinLabelAtFloor = this.isLabelBelowFloorLabel(this.minHandleLabelElement);\n        var\n        /** @type {?} */\n        isMinLabelAtCeil = this.isLabelAboveCeilLabel(this.minHandleLabelElement);\n        var\n        /** @type {?} */\n        isMaxLabelAtCeil = this.isLabelAboveCeilLabel(this.maxHandleLabelElement);\n        var\n        /** @type {?} */\n        isCombinedLabelAtFloor = this.isLabelBelowFloorLabel(this.combinedLabelElement);\n        var\n        /** @type {?} */\n        isCombinedLabelAtCeil = this.isLabelAboveCeilLabel(this.combinedLabelElement);\n\n        if (isMinLabelAtFloor) {\n          floorLabelHidden = true;\n          this.floorLabelElement.hide();\n        } else {\n          floorLabelHidden = false;\n          this.floorLabelElement.show();\n        }\n\n        if (isMinLabelAtCeil) {\n          ceilLabelHidden = true;\n          this.ceilLabelElement.hide();\n        } else {\n          ceilLabelHidden = false;\n          this.ceilLabelElement.show();\n        }\n\n        if (this.range) {\n          var\n          /** @type {?} */\n          hideCeil = this.combinedLabelElement.isVisible() ? isCombinedLabelAtCeil : isMaxLabelAtCeil;\n          var\n          /** @type {?} */\n          hideFloor = this.combinedLabelElement.isVisible() ? isCombinedLabelAtFloor : isMinLabelAtFloor;\n\n          if (hideCeil) {\n            this.ceilLabelElement.hide();\n          } else if (!ceilLabelHidden) {\n            this.ceilLabelElement.show();\n          } // Hide or show floor label\n\n\n          if (hideFloor) {\n            this.floorLabelElement.hide();\n          } else if (!floorLabelHidden) {\n            this.floorLabelElement.show();\n          }\n        }\n      }\n      /**\n       * @param {?} label\n       * @return {?}\n       */\n\n    }, {\n      key: \"isLabelBelowFloorLabel\",\n      value: function isLabelBelowFloorLabel(label) {\n        var\n        /** @type {?} */\n        pos = label.position;\n        var\n        /** @type {?} */\n        dim = label.dimension;\n        var\n        /** @type {?} */\n        floorPos = this.floorLabelElement.position;\n        var\n        /** @type {?} */\n        floorDim = this.floorLabelElement.dimension;\n        return this.viewOptions.rightToLeft ? pos + dim >= floorPos - 2 : pos <= floorPos + floorDim + 2;\n      }\n      /**\n       * @param {?} label\n       * @return {?}\n       */\n\n    }, {\n      key: \"isLabelAboveCeilLabel\",\n      value: function isLabelAboveCeilLabel(label) {\n        var\n        /** @type {?} */\n        pos = label.position;\n        var\n        /** @type {?} */\n        dim = label.dimension;\n        var\n        /** @type {?} */\n        ceilPos = this.ceilLabelElement.position;\n        var\n        /** @type {?} */\n        ceilDim = this.ceilLabelElement.dimension;\n        return this.viewOptions.rightToLeft ? pos <= ceilPos + ceilDim + 2 : pos + dim >= ceilPos - 2;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateSelectionBar\",\n      value: function updateSelectionBar() {\n        var\n        /** @type {?} */\n        position = 0;\n        var\n        /** @type {?} */\n        dimension = 0;\n        var\n        /** @type {?} */\n        isSelectionBarFromRight = this.viewOptions.rightToLeft ? !this.viewOptions.showSelectionBarEnd : this.viewOptions.showSelectionBarEnd;\n        var\n        /** @type {?} */\n        positionForRange = this.viewOptions.rightToLeft ? this.maxHandleElement.position + this.handleHalfDimension : this.minHandleElement.position + this.handleHalfDimension;\n\n        if (this.range) {\n          dimension = Math.abs(this.maxHandleElement.position - this.minHandleElement.position);\n          position = positionForRange;\n        } else {\n          if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n            var\n            /** @type {?} */\n            center = this.viewOptions.showSelectionBarFromValue;\n            var\n            /** @type {?} */\n            centerPosition = this.valueToPosition(center);\n            var\n            /** @type {?} */\n            isModelGreaterThanCenter = this.viewOptions.rightToLeft ? this.viewLowValue <= center : this.viewLowValue > center;\n\n            if (isModelGreaterThanCenter) {\n              dimension = this.minHandleElement.position - centerPosition;\n              position = centerPosition + this.handleHalfDimension;\n            } else {\n              dimension = centerPosition - this.minHandleElement.position;\n              position = this.minHandleElement.position + this.handleHalfDimension;\n            }\n          } else if (isSelectionBarFromRight) {\n            dimension = Math.ceil(Math.abs(this.maxHandlePosition - this.minHandleElement.position) + this.handleHalfDimension);\n            position = Math.floor(this.minHandleElement.position + this.handleHalfDimension);\n          } else {\n            dimension = this.minHandleElement.position + this.handleHalfDimension;\n            position = 0;\n          }\n        }\n\n        this.selectionBarElement.setDimension(dimension);\n        this.selectionBarElement.setPosition(position);\n\n        if (this.range && this.viewOptions.showOuterSelectionBars) {\n          if (this.viewOptions.rightToLeft) {\n            this.rightOuterSelectionBarElement.setDimension(position);\n            this.rightOuterSelectionBarElement.setPosition(0);\n            this.fullBarElement.calculateDimension();\n            this.leftOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n            this.leftOuterSelectionBarElement.setPosition(position + dimension);\n          } else {\n            this.leftOuterSelectionBarElement.setDimension(position);\n            this.leftOuterSelectionBarElement.setPosition(0);\n            this.fullBarElement.calculateDimension();\n            this.rightOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n            this.rightOuterSelectionBarElement.setPosition(position + dimension);\n          }\n        }\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n          var\n          /** @type {?} */\n          color = this.getSelectionBarColor();\n          this.barStyle = {\n            backgroundColor: color\n          };\n        } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.selectionBarGradient)) {\n          var\n          /** @type {?} */\n          offset = !ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue) ? this.valueToPosition(this.viewOptions.showSelectionBarFromValue) : 0;\n          var\n          /** @type {?} */\n          reversed = offset - position > 0 && !isSelectionBarFromRight || offset - position <= 0 && isSelectionBarFromRight;\n          var\n          /** @type {?} */\n          direction = this.viewOptions.vertical ? reversed ? 'bottom' : 'top' : reversed ? 'left' : 'right';\n          this.barStyle = {\n            backgroundImage: 'linear-gradient(to ' + direction + ', ' + this.viewOptions.selectionBarGradient.from + ' 0%,' + this.viewOptions.selectionBarGradient.to + ' 100%)'\n          };\n\n          if (this.viewOptions.vertical) {\n            this.barStyle.backgroundPosition = 'center ' + (offset + dimension + position + (reversed ? -this.handleHalfDimension : 0)) + 'px';\n            this.barStyle.backgroundSize = '100% ' + (this.fullBarElement.dimension - this.handleHalfDimension) + 'px';\n          } else {\n            this.barStyle.backgroundPosition = offset - position + (reversed ? this.handleHalfDimension : 0) + 'px center';\n            this.barStyle.backgroundSize = this.fullBarElement.dimension - this.handleHalfDimension + 'px 100%';\n          }\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getSelectionBarColor\",\n      value: function getSelectionBarColor() {\n        if (this.range) {\n          return this.viewOptions.getSelectionBarColor(this.value, this.highValue);\n        }\n\n        return this.viewOptions.getSelectionBarColor(this.value);\n      }\n      /**\n       * @param {?} pointerType\n       * @return {?}\n       */\n\n    }, {\n      key: \"getPointerColor\",\n      value: function getPointerColor(pointerType) {\n        if (pointerType === PointerType.Max) {\n          return this.viewOptions.getPointerColor(this.highValue, pointerType);\n        }\n\n        return this.viewOptions.getPointerColor(this.value, pointerType);\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"getTickColor\",\n      value: function getTickColor(value) {\n        return this.viewOptions.getTickColor(value);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateCombinedLabel\",\n      value: function updateCombinedLabel() {\n        var\n        /** @type {?} */\n        isLabelOverlap = null;\n\n        if (this.viewOptions.rightToLeft) {\n          isLabelOverlap = this.minHandleLabelElement.position - this.minHandleLabelElement.dimension - 10 <= this.maxHandleLabelElement.position;\n        } else {\n          isLabelOverlap = this.minHandleLabelElement.position + this.minHandleLabelElement.dimension + 10 >= this.maxHandleLabelElement.position;\n        }\n\n        if (isLabelOverlap) {\n          var\n          /** @type {?} */\n          lowDisplayValue = this.getDisplayValue(this.viewLowValue, LabelType.Low);\n          var\n          /** @type {?} */\n          highDisplayValue = this.getDisplayValue(this.viewHighValue, LabelType.High);\n          var\n          /** @type {?} */\n          combinedLabelValue = this.viewOptions.rightToLeft ? this.viewOptions.combineLabels(highDisplayValue, lowDisplayValue) : this.viewOptions.combineLabels(lowDisplayValue, highDisplayValue);\n          this.combinedLabelElement.setValue(combinedLabelValue);\n          var\n          /** @type {?} */\n          pos = this.viewOptions.boundPointerLabels ? Math.min(Math.max(this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2, 0), this.fullBarElement.dimension - this.combinedLabelElement.dimension) : this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2;\n          this.combinedLabelElement.setPosition(pos);\n          this.minHandleLabelElement.hide();\n          this.maxHandleLabelElement.hide();\n          this.combinedLabelElement.show();\n        } else {\n          this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n          this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n          this.maxHandleLabelElement.show();\n          this.minHandleLabelElement.show();\n          this.combinedLabelElement.hide();\n        }\n\n        if (this.viewOptions.autoHideLimitLabels) {\n          this.updateFloorAndCeilLabelsVisibility();\n        }\n      }\n      /**\n       * @param {?} value\n       * @param {?} which\n       * @return {?}\n       */\n\n    }, {\n      key: \"getDisplayValue\",\n      value: function getDisplayValue(value, which) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n          value = this.getStepValue(value);\n        }\n\n        return this.viewOptions.translate(value, which);\n      }\n      /**\n       * @param {?} value\n       * @param {?=} customStep\n       * @return {?}\n       */\n\n    }, {\n      key: \"roundStep\",\n      value: function roundStep(value, customStep) {\n        var\n        /** @type {?} */\n        step = !ValueHelper.isNullOrUndefined(customStep) ? customStep : this.viewOptions.step;\n        var\n        /** @type {?} */\n        steppedDifference = MathHelper.roundToPrecisionLimit((value - this.viewOptions.floor) / step, this.viewOptions.precisionLimit);\n        steppedDifference = Math.round(steppedDifference) * step;\n        return MathHelper.roundToPrecisionLimit(this.viewOptions.floor + steppedDifference, this.viewOptions.precisionLimit);\n      }\n      /**\n       * @param {?} val\n       * @return {?}\n       */\n\n    }, {\n      key: \"valueToPosition\",\n      value: function valueToPosition(val) {\n        var\n        /** @type {?} */\n        fn = ValueHelper.linearValueToPosition;\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.customValueToPosition)) {\n          fn = this.viewOptions.customValueToPosition;\n        } else if (this.viewOptions.logScale) {\n          fn = ValueHelper.logValueToPosition;\n        }\n\n        val = MathHelper.clampToRange(val, this.viewOptions.floor, this.viewOptions.ceil);\n        var\n        /** @type {?} */\n        percent = fn(val, this.viewOptions.floor, this.viewOptions.ceil);\n\n        if (ValueHelper.isNullOrUndefined(percent)) {\n          percent = 0;\n        }\n\n        if (this.viewOptions.rightToLeft) {\n          percent = 1 - percent;\n        }\n\n        return percent * this.maxHandlePosition;\n      }\n      /**\n       * @param {?} position\n       * @return {?}\n       */\n\n    }, {\n      key: \"positionToValue\",\n      value: function positionToValue(position) {\n        var\n        /** @type {?} */\n        percent = position / this.maxHandlePosition;\n\n        if (this.viewOptions.rightToLeft) {\n          percent = 1 - percent;\n        }\n\n        var\n        /** @type {?} */\n        fn = ValueHelper.linearPositionToValue;\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.customPositionToValue)) {\n          fn = this.viewOptions.customPositionToValue;\n        } else if (this.viewOptions.logScale) {\n          fn = ValueHelper.logPositionToValue;\n        }\n\n        var\n        /** @type {?} */\n        value = fn(percent, this.viewOptions.floor, this.viewOptions.ceil);\n        return !ValueHelper.isNullOrUndefined(value) ? value : 0;\n      }\n      /**\n       * @param {?} event\n       * @param {?=} targetTouchId\n       * @return {?}\n       */\n\n    }, {\n      key: \"getEventXY\",\n      value: function getEventXY(event, targetTouchId) {\n        if (event instanceof MouseEvent) {\n          return this.viewOptions.vertical ? event.clientY : event.clientX;\n        }\n\n        var\n        /** @type {?} */\n        touchIndex = 0;\n        var\n        /** @type {?} */\n        touches = event.touches;\n\n        if (!ValueHelper.isNullOrUndefined(targetTouchId)) {\n          for (var\n          /** @type {?} */\n          i = 0; i < touches.length; i++) {\n            if (touches[i].identifier === targetTouchId) {\n              touchIndex = i;\n              break;\n            }\n          }\n        } // Return the target touch or if the target touch was not found in the event\n        // returns the coordinates of the first touch\n\n\n        return this.viewOptions.vertical ? touches[touchIndex].clientY : touches[touchIndex].clientX;\n      }\n      /**\n       * @param {?} event\n       * @param {?=} targetTouchId\n       * @return {?}\n       */\n\n    }, {\n      key: \"getEventPosition\",\n      value: function getEventPosition(event, targetTouchId) {\n        var\n        /** @type {?} */\n        sliderElementBoundingRect = this.elementRef.nativeElement.getBoundingClientRect();\n        var\n        /** @type {?} */\n        sliderPos = this.viewOptions.vertical ? sliderElementBoundingRect.bottom : sliderElementBoundingRect.left;\n        var\n        /** @type {?} */\n        eventPos = 0;\n\n        if (this.viewOptions.vertical) {\n          eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;\n        } else {\n          eventPos = this.getEventXY(event, targetTouchId) - sliderPos;\n        }\n\n        return eventPos * this.viewOptions.scale - this.handleHalfDimension;\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"getNearestHandle\",\n      value: function getNearestHandle(event) {\n        if (!this.range) {\n          return PointerType.Min;\n        }\n\n        var\n        /** @type {?} */\n        position = this.getEventPosition(event);\n        var\n        /** @type {?} */\n        distanceMin = Math.abs(position - this.minHandleElement.position);\n        var\n        /** @type {?} */\n        distanceMax = Math.abs(position - this.maxHandleElement.position);\n\n        if (distanceMin < distanceMax) {\n          return PointerType.Min;\n        } else if (distanceMin > distanceMax) {\n          return PointerType.Max;\n        } else if (!this.viewOptions.rightToLeft) {\n          // if event is at the same distance from min/max then if it's at left of minH, we return minH else maxH\n          return position < this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n        } // reverse in rtl\n\n\n        return position > this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"bindEvents\",\n      value: function bindEvents() {\n        var _this12 = this;\n\n        var\n        /** @type {?} */\n        draggableRange = this.viewOptions.draggableRange;\n\n        if (!this.viewOptions.onlyBindHandles) {\n          this.selectionBarElement.on('mousedown', function (event) {\n            return _this12.onBarStart(null, draggableRange, event, true, true, true);\n          });\n        }\n\n        if (this.viewOptions.draggableRangeOnly) {\n          this.minHandleElement.on('mousedown', function (event) {\n            return _this12.onBarStart(PointerType.Min, draggableRange, event, true, true);\n          });\n          this.maxHandleElement.on('mousedown', function (event) {\n            return _this12.onBarStart(PointerType.Max, draggableRange, event, true, true);\n          });\n        } else {\n          this.minHandleElement.on('mousedown', function (event) {\n            return _this12.onStart(PointerType.Min, event, true, true);\n          });\n\n          if (this.range) {\n            this.maxHandleElement.on('mousedown', function (event) {\n              return _this12.onStart(PointerType.Max, event, true, true);\n            });\n          }\n\n          if (!this.viewOptions.onlyBindHandles) {\n            this.fullBarElement.on('mousedown', function (event) {\n              return _this12.onStart(null, event, true, true, true);\n            });\n            this.ticksElement.on('mousedown', function (event) {\n              return _this12.onStart(null, event, true, true, true, true);\n            });\n          }\n        }\n\n        if (!this.viewOptions.onlyBindHandles) {\n          this.selectionBarElement.onPassive('touchstart', function (event) {\n            return _this12.onBarStart(null, draggableRange, event, true, true, true);\n          });\n        }\n\n        if (this.viewOptions.draggableRangeOnly) {\n          this.minHandleElement.onPassive('touchstart', function (event) {\n            return _this12.onBarStart(PointerType.Min, draggableRange, event, true, true);\n          });\n          this.maxHandleElement.onPassive('touchstart', function (event) {\n            return _this12.onBarStart(PointerType.Max, draggableRange, event, true, true);\n          });\n        } else {\n          this.minHandleElement.onPassive('touchstart', function (event) {\n            return _this12.onStart(PointerType.Min, event, true, true);\n          });\n\n          if (this.range) {\n            this.maxHandleElement.onPassive('touchstart', function (event) {\n              return _this12.onStart(PointerType.Max, event, true, true);\n            });\n          }\n\n          if (!this.viewOptions.onlyBindHandles) {\n            this.fullBarElement.onPassive('touchstart', function (event) {\n              return _this12.onStart(null, event, true, true, true);\n            });\n            this.ticksElement.onPassive('touchstart', function (event) {\n              return _this12.onStart(null, event, false, false, true, true);\n            });\n          }\n        }\n\n        if (this.viewOptions.keyboardSupport) {\n          this.minHandleElement.on('focus', function () {\n            return _this12.onPointerFocus(PointerType.Min);\n          });\n\n          if (this.range) {\n            this.maxHandleElement.on('focus', function () {\n              return _this12.onPointerFocus(PointerType.Max);\n            });\n          }\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"unbindEvents\",\n      value: function unbindEvents() {\n        this.unsubscribeOnMove();\n        this.unsubscribeOnEnd();\n\n        var _iterator4 = _createForOfIteratorHelper(this.getAllSliderElements()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var element = _step4.value;\n\n            if (!ValueHelper.isNullOrUndefined(element)) {\n              element.off();\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      /**\n       * @param {?} pointerType\n       * @param {?} draggableRange\n       * @param {?} event\n       * @param {?} bindMove\n       * @param {?} bindEnd\n       * @param {?=} simulateImmediateMove\n       * @param {?=} simulateImmediateEnd\n       * @return {?}\n       */\n\n    }, {\n      key: \"onBarStart\",\n      value: function onBarStart(pointerType, draggableRange, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n        if (draggableRange) {\n          this.onDragStart(pointerType, event, bindMove, bindEnd);\n        } else {\n          this.onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);\n        }\n      }\n      /**\n       * @param {?} pointerType\n       * @param {?} event\n       * @param {?} bindMove\n       * @param {?} bindEnd\n       * @param {?=} simulateImmediateMove\n       * @param {?=} simulateImmediateEnd\n       * @return {?}\n       */\n\n    }, {\n      key: \"onStart\",\n      value: function onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {\n        var _this13 = this;\n\n        event.stopPropagation(); // Only call preventDefault() when handling non-passive events (passive events don't need it)\n\n        if (!CompatibilityHelper.isTouchEvent(event) || !detectPassiveEvents.hasSupport) {\n          event.preventDefault();\n        } // We have to do this in case the HTML where the sliders are on\n        // have been animated into view.\n\n\n        this.calculateViewDimensions();\n\n        if (ValueHelper.isNullOrUndefined(pointerType)) {\n          pointerType = this.getNearestHandle(event);\n        }\n\n        this.currentTrackingPointer = pointerType;\n        var\n        /** @type {?} */\n        pointerElement = this.getPointerElement(pointerType);\n        pointerElement.active = true;\n\n        if (this.viewOptions.keyboardSupport) {\n          pointerElement.focus();\n        }\n\n        if (bindMove) {\n          this.unsubscribeOnMove();\n\n          var\n          /** @type {?} */\n          onMoveCallback = function onMoveCallback(e) {\n            return _this13.dragging.active ? _this13.onDragMove(e) : _this13.onMove(e);\n          };\n\n          if (CompatibilityHelper.isTouchEvent(event)) {\n            this.onMoveEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchmove', onMoveCallback, this.viewOptions.touchEventsInterval);\n          } else {\n            this.onMoveEventListener = this.eventListenerHelper.attachEventListener(document, 'mousemove', onMoveCallback, this.viewOptions.mouseEventsInterval);\n          }\n        }\n\n        if (bindEnd) {\n          this.unsubscribeOnEnd();\n\n          var\n          /** @type {?} */\n          onEndCallback = function onEndCallback(e) {\n            return _this13.onEnd(e);\n          };\n\n          if (CompatibilityHelper.isTouchEvent(event)) {\n            this.onEndEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchend', onEndCallback);\n          } else {\n            this.onEndEventListener = this.eventListenerHelper.attachEventListener(document, 'mouseup', onEndCallback);\n          }\n        }\n\n        this.userChangeStart.emit(this.getChangeContext());\n\n        if (CompatibilityHelper.isTouchEvent(event) && !ValueHelper.isNullOrUndefined(\n        /** @type {?} */\n        event.changedTouches)) {\n          // Store the touch identifier\n          if (ValueHelper.isNullOrUndefined(this.touchId)) {\n            this.touchId =\n            /** @type {?} */\n            event.changedTouches[0].identifier;\n          }\n        } // Click events, either with mouse or touch gesture are weird. Sometimes they result in full\n        // start, move, end sequence, and sometimes, they don't - they only invoke mousedown\n        // As a workaround, we simulate the first move event and the end event if it's necessary\n\n\n        if (simulateImmediateMove) {\n          this.onMove(event, true);\n        }\n\n        if (simulateImmediateEnd) {\n          this.onEnd(event);\n        }\n      }\n      /**\n       * @param {?} event\n       * @param {?=} fromTick\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMove\",\n      value: function onMove(event, fromTick) {\n        var\n        /** @type {?} */\n        touchForThisSlider = null;\n\n        if (CompatibilityHelper.isTouchEvent(event)) {\n          var\n          /** @type {?} */\n          changedTouches =\n          /** @type {?} */\n          event.changedTouches;\n\n          for (var\n          /** @type {?} */\n          i = 0; i < changedTouches.length; i++) {\n            if (changedTouches[i].identifier === this.touchId) {\n              touchForThisSlider = changedTouches[i];\n              break;\n            }\n          }\n\n          if (ValueHelper.isNullOrUndefined(touchForThisSlider)) {\n            return;\n          }\n        }\n\n        var\n        /** @type {?} */\n        newPos = !ValueHelper.isNullOrUndefined(touchForThisSlider) ? this.getEventPosition(event, touchForThisSlider.identifier) : this.getEventPosition(event);\n        var\n        /** @type {?} */\n        newValue;\n        var\n        /** @type {?} */\n        ceilValue = this.viewOptions.rightToLeft ? this.viewOptions.floor : this.viewOptions.ceil;\n        var\n        /** @type {?} */\n        floorValue = this.viewOptions.rightToLeft ? this.viewOptions.ceil : this.viewOptions.floor;\n\n        if (newPos <= 0) {\n          newValue = floorValue;\n        } else if (newPos >= this.maxHandlePosition) {\n          newValue = ceilValue;\n        } else {\n          newValue = this.positionToValue(newPos);\n\n          if (fromTick && !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) {\n            newValue = this.roundStep(newValue, this.viewOptions.tickStep);\n          } else {\n            newValue = this.roundStep(newValue);\n          }\n        }\n\n        this.positionTrackingHandle(newValue);\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onEnd\",\n      value: function onEnd(event) {\n        if (CompatibilityHelper.isTouchEvent(event)) {\n          var\n          /** @type {?} */\n          changedTouches =\n          /** @type {?} */\n          event.changedTouches;\n\n          if (changedTouches[0].identifier !== this.touchId) {\n            return;\n          }\n        }\n\n        this.touchId = null;\n\n        if (!this.viewOptions.keyboardSupport) {\n          this.minHandleElement.active = false;\n          this.maxHandleElement.active = false;\n          this.currentTrackingPointer = null;\n        }\n\n        this.dragging.active = false;\n        this.unsubscribeOnMove();\n        this.unsubscribeOnEnd();\n        this.userChangeEnd.emit(this.getChangeContext());\n      }\n      /**\n       * @param {?} pointerType\n       * @return {?}\n       */\n\n    }, {\n      key: \"onPointerFocus\",\n      value: function onPointerFocus(pointerType) {\n        var _this14 = this;\n\n        var\n        /** @type {?} */\n        pointerElement = this.getPointerElement(pointerType);\n        pointerElement.on('blur', function () {\n          return _this14.onPointerBlur(pointerElement);\n        });\n        pointerElement.on('keydown', function (event) {\n          return _this14.onKeyboardEvent(event);\n        });\n        pointerElement.on('keyup', function () {\n          return _this14.onKeyUp();\n        });\n        pointerElement.active = true;\n        this.currentTrackingPointer = pointerType;\n        this.currentFocusPointer = pointerType;\n        this.firstKeyDown = true;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"onKeyUp\",\n      value: function onKeyUp() {\n        this.firstKeyDown = true;\n        this.userChangeEnd.emit(this.getChangeContext());\n      }\n      /**\n       * @param {?} pointer\n       * @return {?}\n       */\n\n    }, {\n      key: \"onPointerBlur\",\n      value: function onPointerBlur(pointer) {\n        pointer.off('blur');\n        pointer.off('keydown');\n        pointer.off('keyup');\n        pointer.active = false;\n\n        if (ValueHelper.isNullOrUndefined(this.touchId)) {\n          this.currentTrackingPointer = null;\n          this.currentFocusPointer = null;\n        }\n      }\n      /**\n       * @param {?} currentValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"getKeyActions\",\n      value: function getKeyActions(currentValue) {\n        var\n        /** @type {?} */\n        valueRange = this.viewOptions.ceil - this.viewOptions.floor;\n        var\n        /** @type {?} */\n        increaseStep = currentValue + this.viewOptions.step;\n        var\n        /** @type {?} */\n        decreaseStep = currentValue - this.viewOptions.step;\n        var\n        /** @type {?} */\n        increasePage = currentValue + valueRange / 10;\n        var\n        /** @type {?} */\n        decreasePage = currentValue - valueRange / 10;\n\n        if (this.viewOptions.reversedControls) {\n          increaseStep = currentValue - this.viewOptions.step;\n          decreaseStep = currentValue + this.viewOptions.step;\n          increasePage = currentValue - valueRange / 10;\n          decreasePage = currentValue + valueRange / 10;\n        } // Left to right default actions\n\n\n        var\n        /** @type {?} */\n        actions = {\n          UP: increaseStep,\n          DOWN: decreaseStep,\n          LEFT: decreaseStep,\n          RIGHT: increaseStep,\n          PAGEUP: increasePage,\n          PAGEDOWN: decreasePage,\n          HOME: this.viewOptions.reversedControls ? this.viewOptions.ceil : this.viewOptions.floor,\n          END: this.viewOptions.reversedControls ? this.viewOptions.floor : this.viewOptions.ceil\n        }; // right to left means swapping right and left arrows\n\n        if (this.viewOptions.rightToLeft) {\n          actions[\"LEFT\"] = increaseStep;\n          actions[\"RIGHT\"] = decreaseStep; // right to left and vertical means we also swap up and down\n\n          if (this.viewOptions.vertical) {\n            actions[\"UP\"] = decreaseStep;\n            actions[\"DOWN\"] = increaseStep;\n          }\n        }\n\n        return actions;\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onKeyboardEvent\",\n      value: function onKeyboardEvent(event) {\n        var\n        /** @type {?} */\n        currentValue = this.getCurrentTrackingValue();\n        var\n        /** @type {?} */\n        keyCode = !ValueHelper.isNullOrUndefined(event.keyCode) ? event.keyCode : event.which;\n        var\n        /** @type {?} */\n        keys = {\n          38: 'UP',\n          40: 'DOWN',\n          37: 'LEFT',\n          39: 'RIGHT',\n          33: 'PAGEUP',\n          34: 'PAGEDOWN',\n          36: 'HOME',\n          35: 'END'\n        };\n        var\n        /** @type {?} */\n        actions = this.getKeyActions(currentValue);\n        var\n        /** @type {?} */\n        key = keys[keyCode];\n        var\n        /** @type {?} */\n        action = actions[key];\n\n        if (ValueHelper.isNullOrUndefined(action) || ValueHelper.isNullOrUndefined(this.currentTrackingPointer)) {\n          return;\n        }\n\n        event.preventDefault();\n\n        if (this.firstKeyDown) {\n          this.firstKeyDown = false;\n          this.userChangeStart.emit(this.getChangeContext());\n        }\n\n        var\n        /** @type {?} */\n        actionValue = MathHelper.clampToRange(action, this.viewOptions.floor, this.viewOptions.ceil);\n        var\n        /** @type {?} */\n        newValue = this.roundStep(actionValue);\n\n        if (!this.viewOptions.draggableRangeOnly) {\n          this.positionTrackingHandle(newValue);\n        } else {\n          var\n          /** @type {?} */\n          difference = this.viewHighValue - this.viewLowValue;\n          var\n          /** @type {?} */\n          newMinValue;\n          var\n          /** @type {?} */\n          newMaxValue;\n\n          if (this.currentTrackingPointer === PointerType.Min) {\n            newMinValue = newValue;\n            newMaxValue = newValue + difference;\n\n            if (newMaxValue > this.viewOptions.ceil) {\n              newMaxValue = this.viewOptions.ceil;\n              newMinValue = newMaxValue - difference;\n            }\n          } else if (this.currentTrackingPointer === PointerType.Max) {\n            newMaxValue = newValue;\n            newMinValue = newValue - difference;\n\n            if (newMinValue < this.viewOptions.floor) {\n              newMinValue = this.viewOptions.floor;\n              newMaxValue = newMinValue + difference;\n            }\n          }\n\n          this.positionTrackingBar(newMinValue, newMaxValue);\n        }\n      }\n      /**\n       * @param {?} pointerType\n       * @param {?} event\n       * @param {?} bindMove\n       * @param {?} bindEnd\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDragStart\",\n      value: function onDragStart(pointerType, event, bindMove, bindEnd) {\n        var\n        /** @type {?} */\n        position = this.getEventPosition(event);\n        this.dragging = new Dragging();\n        this.dragging.active = true;\n        this.dragging.value = this.positionToValue(position);\n        this.dragging.difference = this.viewHighValue - this.viewLowValue;\n        this.dragging.lowLimit = this.viewOptions.rightToLeft ? this.minHandleElement.position - position : position - this.minHandleElement.position;\n        this.dragging.highLimit = this.viewOptions.rightToLeft ? position - this.maxHandleElement.position : this.maxHandleElement.position - position;\n        this.onStart(pointerType, event, bindMove, bindEnd);\n      }\n      /**\n       * Get min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft\n       * @param {?} newPos\n       * @param {?} outOfBounds\n       * @param {?} isAbove\n       * @return {?}\n       */\n\n    }, {\n      key: \"getMinValue\",\n      value: function getMinValue(newPos, outOfBounds, isAbove) {\n        var\n        /** @type {?} */\n        isRTL = this.viewOptions.rightToLeft;\n        var\n        /** @type {?} */\n        value = null;\n\n        if (outOfBounds) {\n          if (isAbove) {\n            value = isRTL ? this.viewOptions.floor : this.viewOptions.ceil - this.dragging.difference;\n          } else {\n            value = isRTL ? this.viewOptions.ceil - this.dragging.difference : this.viewOptions.floor;\n          }\n        } else {\n          value = isRTL ? this.positionToValue(newPos + this.dragging.lowLimit) : this.positionToValue(newPos - this.dragging.lowLimit);\n        }\n\n        return this.roundStep(value);\n      }\n      /**\n       * Get max value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft\n       * @param {?} newPos\n       * @param {?} outOfBounds\n       * @param {?} isAbove\n       * @return {?}\n       */\n\n    }, {\n      key: \"getMaxValue\",\n      value: function getMaxValue(newPos, outOfBounds, isAbove) {\n        var\n        /** @type {?} */\n        isRTL = this.viewOptions.rightToLeft;\n        var\n        /** @type {?} */\n        value = null;\n\n        if (outOfBounds) {\n          if (isAbove) {\n            value = isRTL ? this.viewOptions.floor + this.dragging.difference : this.viewOptions.ceil;\n          } else {\n            value = isRTL ? this.viewOptions.ceil : this.viewOptions.floor + this.dragging.difference;\n          }\n        } else {\n          if (isRTL) {\n            value = this.positionToValue(newPos + this.dragging.lowLimit) + this.dragging.difference;\n          } else {\n            value = this.positionToValue(newPos - this.dragging.lowLimit) + this.dragging.difference;\n          }\n        }\n\n        return this.roundStep(value);\n      }\n      /**\n       * @param {?=} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDragMove\",\n      value: function onDragMove(event) {\n        var\n        /** @type {?} */\n        newPos = this.getEventPosition(event);\n        var\n        /** @type {?} */\n        ceilLimit,\n        /** @type {?} */\n        floorLimit,\n        /** @type {?} */\n        floorHandleElement,\n        /** @type {?} */\n        ceilHandleElement;\n\n        if (this.viewOptions.rightToLeft) {\n          ceilLimit = this.dragging.lowLimit;\n          floorLimit = this.dragging.highLimit;\n          floorHandleElement = this.maxHandleElement;\n          ceilHandleElement = this.minHandleElement;\n        } else {\n          ceilLimit = this.dragging.highLimit;\n          floorLimit = this.dragging.lowLimit;\n          floorHandleElement = this.minHandleElement;\n          ceilHandleElement = this.maxHandleElement;\n        }\n\n        var\n        /** @type {?} */\n        isUnderFloorLimit = newPos <= floorLimit;\n        var\n        /** @type {?} */\n        isOverCeilLimit = newPos >= this.maxHandlePosition - ceilLimit;\n        var\n        /** @type {?} */\n        newMinValue;\n        var\n        /** @type {?} */\n        newMaxValue;\n\n        if (isUnderFloorLimit) {\n          if (floorHandleElement.position === 0) {\n            return;\n          }\n\n          newMinValue = this.getMinValue(newPos, true, false);\n          newMaxValue = this.getMaxValue(newPos, true, false);\n        } else if (isOverCeilLimit) {\n          if (ceilHandleElement.position === this.maxHandlePosition) {\n            return;\n          }\n\n          newMaxValue = this.getMaxValue(newPos, true, true);\n          newMinValue = this.getMinValue(newPos, true, true);\n        } else {\n          newMinValue = this.getMinValue(newPos, false, false);\n          newMaxValue = this.getMaxValue(newPos, false, false);\n        }\n\n        this.positionTrackingBar(newMinValue, newMaxValue);\n      }\n      /**\n       * @param {?} newMinValue\n       * @param {?} newMaxValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"positionTrackingBar\",\n      value: function positionTrackingBar(newMinValue, newMaxValue) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newMinValue < this.viewOptions.minLimit) {\n          newMinValue = this.viewOptions.minLimit;\n          newMaxValue = MathHelper.roundToPrecisionLimit(newMinValue + this.dragging.difference, this.viewOptions.precisionLimit);\n        }\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newMaxValue > this.viewOptions.maxLimit) {\n          newMaxValue = this.viewOptions.maxLimit;\n          newMinValue = MathHelper.roundToPrecisionLimit(newMaxValue - this.dragging.difference, this.viewOptions.precisionLimit);\n        }\n\n        this.viewLowValue = newMinValue;\n        this.viewHighValue = newMaxValue;\n        this.applyViewChange();\n        this.updateHandles(PointerType.Min, this.valueToPosition(newMinValue));\n        this.updateHandles(PointerType.Max, this.valueToPosition(newMaxValue));\n      }\n      /**\n       * @param {?} newValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"positionTrackingHandle\",\n      value: function positionTrackingHandle(newValue) {\n        newValue = this.applyMinMaxLimit(newValue);\n\n        if (this.range) {\n          if (this.viewOptions.pushRange) {\n            newValue = this.applyPushRange(newValue);\n          } else {\n            if (this.viewOptions.noSwitching) {\n              if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n                newValue = this.applyMinMaxRange(this.viewHighValue);\n              } else if (this.currentTrackingPointer === PointerType.Max && newValue < this.viewLowValue) {\n                newValue = this.applyMinMaxRange(this.viewLowValue);\n              }\n            }\n\n            newValue = this.applyMinMaxRange(newValue);\n            /* This is to check if we need to switch the min and max handles */\n\n            if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n              this.viewLowValue = this.viewHighValue;\n              this.applyViewChange();\n              this.updateHandles(PointerType.Min, this.maxHandleElement.position);\n              this.updateAriaAttributes();\n              this.currentTrackingPointer = PointerType.Max;\n              this.minHandleElement.active = false;\n              this.maxHandleElement.active = true;\n\n              if (this.viewOptions.keyboardSupport) {\n                this.maxHandleElement.focus();\n              }\n            } else if (this.currentTrackingPointer === PointerType.Max && newValue < this.viewLowValue) {\n              this.viewHighValue = this.viewLowValue;\n              this.applyViewChange();\n              this.updateHandles(PointerType.Max, this.minHandleElement.position);\n              this.updateAriaAttributes();\n              this.currentTrackingPointer = PointerType.Min;\n              this.maxHandleElement.active = false;\n              this.minHandleElement.active = true;\n\n              if (this.viewOptions.keyboardSupport) {\n                this.minHandleElement.focus();\n              }\n            }\n          }\n        }\n\n        if (this.getCurrentTrackingValue() !== newValue) {\n          if (this.currentTrackingPointer === PointerType.Min) {\n            this.viewLowValue = newValue;\n            this.applyViewChange();\n          } else if (this.currentTrackingPointer === PointerType.Max) {\n            this.viewHighValue = newValue;\n            this.applyViewChange();\n          }\n\n          this.updateHandles(this.currentTrackingPointer, this.valueToPosition(newValue));\n          this.updateAriaAttributes();\n        }\n      }\n      /**\n       * @param {?} newValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyMinMaxLimit\",\n      value: function applyMinMaxLimit(newValue) {\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newValue < this.viewOptions.minLimit) {\n          return this.viewOptions.minLimit;\n        }\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newValue > this.viewOptions.maxLimit) {\n          return this.viewOptions.maxLimit;\n        }\n\n        return newValue;\n      }\n      /**\n       * @param {?} newValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyMinMaxRange\",\n      value: function applyMinMaxRange(newValue) {\n        var\n        /** @type {?} */\n        oppositeValue = this.currentTrackingPointer === PointerType.Min ? this.viewHighValue : this.viewLowValue;\n        var\n        /** @type {?} */\n        difference = Math.abs(newValue - oppositeValue);\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange)) {\n          if (difference < this.viewOptions.minRange) {\n            if (this.currentTrackingPointer === PointerType.Min) {\n              return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.minRange, this.viewOptions.precisionLimit);\n            } else if (this.currentTrackingPointer === PointerType.Max) {\n              return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.minRange, this.viewOptions.precisionLimit);\n            }\n          }\n        }\n\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxRange)) {\n          if (difference > this.viewOptions.maxRange) {\n            if (this.currentTrackingPointer === PointerType.Min) {\n              return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n            } else if (this.currentTrackingPointer === PointerType.Max) {\n              return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n            }\n          }\n        }\n\n        return newValue;\n      }\n      /**\n       * @param {?} newValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyPushRange\",\n      value: function applyPushRange(newValue) {\n        var\n        /** @type {?} */\n        difference = this.currentTrackingPointer === PointerType.Min ? this.viewHighValue - newValue : newValue - this.viewLowValue;\n        var\n        /** @type {?} */\n        minRange = !ValueHelper.isNullOrUndefined(this.viewOptions.minRange) ? this.viewOptions.minRange : this.viewOptions.step;\n        var\n        /** @type {?} */\n        maxRange = this.viewOptions.maxRange; // if smaller than minRange\n\n        if (difference < minRange) {\n          if (this.currentTrackingPointer === PointerType.Min) {\n            this.viewHighValue = MathHelper.roundToPrecisionLimit(Math.min(newValue + minRange, this.viewOptions.ceil), this.viewOptions.precisionLimit);\n            newValue = MathHelper.roundToPrecisionLimit(this.viewHighValue - minRange, this.viewOptions.precisionLimit);\n            this.applyViewChange();\n            this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n          } else if (this.currentTrackingPointer === PointerType.Max) {\n            this.viewLowValue = MathHelper.roundToPrecisionLimit(Math.max(newValue - minRange, this.viewOptions.floor), this.viewOptions.precisionLimit);\n            newValue = MathHelper.roundToPrecisionLimit(this.viewLowValue + minRange, this.viewOptions.precisionLimit);\n            this.applyViewChange();\n            this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n          }\n\n          this.updateAriaAttributes();\n        } else if (!ValueHelper.isNullOrUndefined(maxRange) && difference > maxRange) {\n          // if greater than maxRange\n          if (this.currentTrackingPointer === PointerType.Min) {\n            this.viewHighValue = MathHelper.roundToPrecisionLimit(newValue + maxRange, this.viewOptions.precisionLimit);\n            this.applyViewChange();\n            this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n          } else if (this.currentTrackingPointer === PointerType.Max) {\n            this.viewLowValue = MathHelper.roundToPrecisionLimit(newValue - maxRange, this.viewOptions.precisionLimit);\n            this.applyViewChange();\n            this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n          }\n\n          this.updateAriaAttributes();\n        }\n\n        return newValue;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getChangeContext\",\n      value: function getChangeContext() {\n        var\n        /** @type {?} */\n        changeContext = new ChangeContext();\n        changeContext.pointerType = this.currentTrackingPointer;\n        changeContext.value = +this.value;\n\n        if (this.range) {\n          changeContext.highValue = +this.highValue;\n        }\n\n        return changeContext;\n      }\n    }]);\n  }();\n\n  SliderComponent.ɵfac = function SliderComponent_Factory(t) {\n    return new (t || SliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  SliderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n    type: SliderComponent,\n    selectors: [[\"ng5-slider\"]],\n    contentQueries: function SliderComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c0, 1);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);\n      }\n    },\n    viewQuery: function SliderComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c1, 1, SliderElementDirective);\n        ɵngcc0.ɵɵviewQuery(_c2, 1, SliderElementDirective);\n        ɵngcc0.ɵɵviewQuery(_c3, 1, SliderElementDirective);\n        ɵngcc0.ɵɵviewQuery(_c4, 1, SliderElementDirective);\n        ɵngcc0.ɵɵviewQuery(_c5, 1, SliderHandleDirective);\n        ɵngcc0.ɵɵviewQuery(_c6, 1, SliderHandleDirective);\n        ɵngcc0.ɵɵviewQuery(_c7, 1, SliderLabelDirective);\n        ɵngcc0.ɵɵviewQuery(_c8, 1, SliderLabelDirective);\n        ɵngcc0.ɵɵviewQuery(_c9, 1, SliderLabelDirective);\n        ɵngcc0.ɵɵviewQuery(_c10, 1, SliderLabelDirective);\n        ɵngcc0.ɵɵviewQuery(_c11, 1, SliderLabelDirective);\n        ɵngcc0.ɵɵviewQuery(_c12, 1, SliderElementDirective);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leftOuterSelectionBarElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rightOuterSelectionBarElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fullBarElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.selectionBarElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minHandleElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.maxHandleElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.floorLabelElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ceilLabelElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minHandleLabelElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.maxHandleLabelElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.combinedLabelElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);\n      }\n    },\n    hostAttrs: [1, \"ng5-slider\"],\n    hostVars: 5,\n    hostBindings: function SliderComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"resize\", function SliderComponent_resize_HostBindingHandler($event) {\n          return ctx.onResize($event);\n        }, false, ɵngcc0.ɵɵresolveWindow);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"disabled\", ctx.sliderElementDisabledAttr);\n        ɵngcc0.ɵɵclassProp(\"vertical\", ctx.sliderElementVerticalClass)(\"animate\", ctx.sliderElementAnimateClass);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      highValue: \"highValue\",\n      options: \"options\",\n      manualRefresh: \"manualRefresh\",\n      triggerFocus: \"triggerFocus\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      highValueChange: \"highValueChange\",\n      userChangeStart: \"userChangeStart\",\n      userChange: \"userChange\",\n      userChangeEnd: \"userChangeEnd\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([NG5_SLIDER_CONTROL_VALUE_ACCESSOR]), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 29,\n    vars: 13,\n    consts: [[\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-left-out-selection\"], [\"leftOuterSelectionBar\", \"\"], [1, \"ng5-slider-span\", \"ng5-slider-bar\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-right-out-selection\"], [\"rightOuterSelectionBar\", \"\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-full-bar\"], [\"fullBar\", \"\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bar-wrapper\", \"ng5-slider-selection-bar\"], [\"selectionBar\", \"\"], [1, \"ng5-slider-span\", \"ng5-slider-bar\", \"ng5-slider-selection\", 3, \"ngStyle\"], [\"ng5SliderHandle\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-pointer\", \"ng5-slider-pointer-min\", 3, \"ngStyle\"], [\"minHandle\", \"\"], [\"ng5SliderHandle\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-pointer\", \"ng5-slider-pointer-max\", 3, \"ngStyle\"], [\"maxHandle\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-limit\", \"ng5-slider-floor\"], [\"floorLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-limit\", \"ng5-slider-ceil\"], [\"ceilLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-model-value\"], [\"minHandleLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-model-high\"], [\"maxHandleLabel\", \"\"], [\"ng5SliderLabel\", \"\", 1, \"ng5-slider-span\", \"ng5-slider-bubble\", \"ng5-slider-combined\"], [\"combinedLabel\", \"\"], [\"ng5SliderElement\", \"\", 1, \"ng5-slider-ticks\", 3, \"hidden\"], [\"ticksElement\", \"\"], [\"class\", \"ng5-slider-tick\", 3, \"ngClass\", \"ngStyle\", 4, \"ngFor\", \"ngForOf\"], [1, \"ng5-slider-tick\", 3, \"ngClass\", \"ngStyle\"], [3, \"template\", \"tooltip\", \"placement\"], [\"class\", \"ng5-slider-span ng5-slider-tick-value\", 3, \"template\", \"tooltip\", \"placement\", \"content\", 4, \"ngIf\"], [\"class\", \"ng5-slider-span ng5-slider-tick-legend\", 3, \"innerHTML\", 4, \"ngIf\"], [1, \"ng5-slider-span\", \"ng5-slider-tick-value\", 3, \"template\", \"tooltip\", \"placement\", \"content\"], [1, \"ng5-slider-span\", \"ng5-slider-tick-legend\", 3, \"innerHTML\"]],\n    template: function SliderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"span\", 0, 1);\n        ɵngcc0.ɵɵelement(2, \"span\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(3, \"span\", 3, 4);\n        ɵngcc0.ɵɵelement(5, \"span\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(6, \"span\", 5, 6);\n        ɵngcc0.ɵɵelement(8, \"span\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(9, \"span\", 7, 8);\n        ɵngcc0.ɵɵelement(11, \"span\", 9);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelement(12, \"span\", 10, 11);\n        ɵngcc0.ɵɵelement(14, \"span\", 12, 13);\n        ɵngcc0.ɵɵelement(16, \"span\", 14, 15);\n        ɵngcc0.ɵɵelement(18, \"span\", 16, 17);\n        ɵngcc0.ɵɵelement(20, \"span\", 18, 19);\n        ɵngcc0.ɵɵelement(22, \"span\", 20, 21);\n        ɵngcc0.ɵɵelement(24, \"span\", 22, 23);\n        ɵngcc0.ɵɵelementStart(26, \"span\", 24, 25);\n        ɵngcc0.ɵɵtemplate(28, SliderComponent_span_28_Template, 4, 9, \"span\", 26);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(6);\n        ɵngcc0.ɵɵclassProp(\"ng5-slider-transparent\", ctx.fullBarTransparentClass);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵclassProp(\"ng5-slider-draggable\", ctx.selectionBarDraggableClass);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.barStyle);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.minPointerStyle);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵstyleProp(\"display\", ctx.range ? \"inherit\" : \"none\");\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.maxPointerStyle);\n        ɵngcc0.ɵɵadvance(12);\n        ɵngcc0.ɵɵclassProp(\"ng5-slider-ticks-values-under\", ctx.ticksUnderValuesClass);\n        ɵngcc0.ɵɵproperty(\"hidden\", !ctx.showTicks);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.ticks);\n      }\n    },\n    directives: function directives() {\n      return [SliderElementDirective, ɵngcc1.NgStyle, SliderHandleDirective, SliderLabelDirective, ɵngcc1.NgForOf, ɵngcc1.NgClass, TooltipWrapperComponent, ɵngcc1.NgIf];\n    },\n    styles: [\".ng5-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:pan-y;touch-action:pan-y}  .ng5-slider.with-legend{margin-bottom:40px}  .ng5-slider[disabled]{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}  .ng5-slider[disabled] .ng5-slider-draggable{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-selection{background:#8b91a2}  .ng5-slider[disabled] .ng5-slider-tick{cursor:not-allowed}  .ng5-slider[disabled] .ng5-slider-tick.ng5-slider-selected{background:#8b91a2}  .ng5-slider .ng5-slider-span{white-space:nowrap;position:absolute;display:inline-block}  .ng5-slider .ng5-slider-base{width:100%;height:100%;padding:0}  .ng5-slider .ng5-slider-bar-wrapper{left:0;-webkit-box-sizing:border-box;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}  .ng5-slider .ng5-slider-draggable{cursor:move}  .ng5-slider .ng5-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-transparent .ng5-slider-bar{background:0 0}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-left-out-selection .ng5-slider-bar{background:#df002d}  .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-right-out-selection .ng5-slider-bar{background:#03a688}  .ng5-slider .ng5-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}  .ng5-slider .ng5-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}  .ng5-slider .ng5-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}  .ng5-slider .ng5-slider-pointer:hover:after{background-color:#fff}  .ng5-slider .ng5-slider-pointer.ng5-slider-active{z-index:4}  .ng5-slider .ng5-slider-pointer.ng5-slider-active:after{background-color:#451aff}  .ng5-slider .ng5-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}  .ng5-slider .ng5-slider-bubble.ng5-slider-limit{color:#55637d}  .ng5-slider .ng5-slider-ticks{-webkit-box-sizing:border-box;box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}  .ng5-slider .ng5-slider-ticks-values-under .ng5-slider-tick-value{top:auto;bottom:-36px}  .ng5-slider .ng5-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}  .ng5-slider .ng5-slider-tick.ng5-slider-selected{background:#0db9f0}  .ng5-slider .ng5-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}  .ng5-slider .ng5-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}  .ng5-slider.vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;-ms-touch-action:pan-x;touch-action:pan-x}  .ng5-slider.vertical .ng5-slider-base{width:100%;height:100%;padding:0}  .ng5-slider.vertical .ng5-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}  .ng5-slider.vertical .ng5-slider-bar{bottom:0;left:auto;width:4px;height:100%}  .ng5-slider.vertical .ng5-slider-pointer{left:-14px!important;top:auto;bottom:0}  .ng5-slider.vertical .ng5-slider-bubble{left:16px!important;bottom:0}  .ng5-slider.vertical .ng5-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}  .ng5-slider.vertical .ng5-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}  .ng5-slider.vertical .ng5-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}  .ng5-slider.vertical .ng5-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}  .ng5-slider.vertical .ng5-slider-ticks-values-under .ng5-slider-tick-value{bottom:auto;left:auto;right:24px}  .ng5-slider *{-webkit-transition:none;transition:none}  .ng5-slider.animate .ng5-slider-bar-wrapper{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-selection{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}  .ng5-slider.animate .ng5-slider-pointer{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-bubble{-webkit-transition:all linear .3s;transition:all linear .3s}  .ng5-slider.animate .ng5-slider-bubble.ng5-slider-limit{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}  .ng5-slider.animate .ng5-slider-bubble.ng5-slider-combined{-webkit-transition:opacity linear .3s;transition:opacity linear .3s}  .ng5-slider.animate .ng5-slider-tick{-webkit-transition:background-color linear .3s;transition:background-color linear .3s}\"]\n  });\n  return SliderComponent;\n}();\n\nvar TooltipWrapperComponent = /*@__PURE__*/function () {\n  var TooltipWrapperComponent = /*#__PURE__*/_createClass(function TooltipWrapperComponent() {\n    _classCallCheck(this, TooltipWrapperComponent);\n  });\n\n  TooltipWrapperComponent.ɵfac = function TooltipWrapperComponent_Factory(t) {\n    return new (t || TooltipWrapperComponent)();\n  };\n\n  TooltipWrapperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n    type: TooltipWrapperComponent,\n    selectors: [[\"ng5-slider-tooltip-wrapper\"]],\n    inputs: {\n      template: \"template\",\n      tooltip: \"tooltip\",\n      placement: \"placement\",\n      content: \"content\"\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"ng5-slider-inner-tooltip\"]],\n    template: function TooltipWrapperComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TooltipWrapperComponent_ng_container_0_Template, 2, 6, \"ng-container\", 0);\n        ɵngcc0.ɵɵtemplate(1, TooltipWrapperComponent_ng_container_1_Template, 3, 3, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.template);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.template);\n      }\n    },\n    directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n    styles: [\".ng5-slider-inner-tooltip[_ngcontent-%COMP%]{height:100%}\"]\n  });\n  return TooltipWrapperComponent;\n}();\n\nvar Ng5SliderModule = /*@__PURE__*/function () {\n  var Ng5SliderModule = /*#__PURE__*/_createClass(function Ng5SliderModule() {\n    _classCallCheck(this, Ng5SliderModule);\n  });\n\n  Ng5SliderModule.ɵfac = function Ng5SliderModule_Factory(t) {\n    return new (t || Ng5SliderModule)();\n  };\n\n  Ng5SliderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: Ng5SliderModule\n  });\n  Ng5SliderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return Ng5SliderModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(Ng5SliderModule, {\n    declarations: function declarations() {\n      return [SliderComponent, SliderElementDirective, SliderHandleDirective, SliderLabelDirective, TooltipWrapperComponent];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [SliderComponent];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Ng5SliderModule, ChangeContext, PointerType, LabelType, Options, SliderElementDirective as ɵb, SliderHandleDirective as ɵc, SliderLabelDirective as ɵd, SliderComponent as ɵa, TooltipWrapperComponent as ɵe }; //# sourceMappingURL=ng5-slider.js.map","map":null,"metadata":{},"sourceType":"module"}