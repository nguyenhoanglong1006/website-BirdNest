{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _defineProperty from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _possibleConstructorReturn from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _isNativeReflectConstruct from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nimport _getPrototypeOf from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createClass from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n\nimport { Injectable, EventEmitter, InjectionToken, Inject, Directive, ElementRef, ChangeDetectorRef, Input, Pipe, NgModule } from '@angular/core';\nimport { of, isObservable, forkJoin, concat, defer } from 'rxjs';\nimport { take, shareReplay, map, concatMap, switchMap } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/translate.loader.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @abstract\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar TranslateLoader = /*#__PURE__*/_createClass(function TranslateLoader() {\n  _classCallCheck(this, TranslateLoader);\n});\n\nif (false) {\n  /**\n   * @abstract\n   * @param {?} lang\n   * @return {?}\n   */\n  TranslateLoader.prototype.getTranslation = function (lang) {};\n}\n\nvar TranslateFakeLoader = /*@__PURE__*/function () {\n  var TranslateFakeLoader = /*#__PURE__*/function (_TranslateLoader) {\n    function TranslateFakeLoader() {\n      _classCallCheck(this, TranslateFakeLoader);\n\n      return _callSuper(this, TranslateFakeLoader, arguments);\n    }\n\n    _inherits(TranslateFakeLoader, _TranslateLoader);\n\n    return _createClass(TranslateFakeLoader, [{\n      key: \"getTranslation\",\n      value:\n      /**\n       * @param {?} lang\n       * @return {?}\n       */\n      function getTranslation(lang) {\n        return of({});\n      }\n    }]);\n  }(TranslateLoader);\n\n  TranslateFakeLoader.ɵfac = function TranslateFakeLoader_Factory(t) {\n    return ɵTranslateFakeLoader_BaseFactory(t || TranslateFakeLoader);\n  };\n\n  TranslateFakeLoader.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: TranslateFakeLoader,\n    factory: TranslateFakeLoader.ɵfac\n  });\n  return TranslateFakeLoader;\n}();\n\nvar ɵTranslateFakeLoader_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(TranslateFakeLoader);\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/missing-translation-handler.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\nfunction MissingTranslationHandlerParams() {}\n\nif (false) {\n  /**\n   * the key that's missing in translation files\n   * @type {?}\n   */\n  MissingTranslationHandlerParams.prototype.key;\n  /**\n   * an instance of the service that was unable to translate the key.\n   * @type {?}\n   */\n\n  MissingTranslationHandlerParams.prototype.translateService;\n  /**\n   * interpolation params that were passed along for translating the given key.\n   * @type {?|undefined}\n   */\n\n  MissingTranslationHandlerParams.prototype.interpolateParams;\n}\n/**\n * @abstract\n */\n\n\nvar MissingTranslationHandler = /*#__PURE__*/_createClass(function MissingTranslationHandler() {\n  _classCallCheck(this, MissingTranslationHandler);\n});\n\nif (false) {\n  /**\n   * A function that handles missing translations.\n   *\n   * @abstract\n   * @param {?} params context for resolving a missing translation\n   * @return {?} a value or an observable\n   * If it returns a value, then this value is used.\n   * If it return an observable, the value returned by this observable will be used (except if the method was \"instant\").\n   * If it doesn't return then the key will be used as a value\n   */\n  MissingTranslationHandler.prototype.handle = function (params) {};\n}\n\nvar FakeMissingTranslationHandler = /*@__PURE__*/function () {\n  var FakeMissingTranslationHandler = /*#__PURE__*/function () {\n    function FakeMissingTranslationHandler() {\n      _classCallCheck(this, FakeMissingTranslationHandler);\n    }\n\n    return _createClass(FakeMissingTranslationHandler, [{\n      key: \"handle\",\n      value:\n      /**\n       * @param {?} params\n       * @return {?}\n       */\n      function handle(params) {\n        return params.key;\n      }\n    }]);\n  }();\n\n  FakeMissingTranslationHandler.ɵfac = function FakeMissingTranslationHandler_Factory(t) {\n    return new (t || FakeMissingTranslationHandler)();\n  };\n\n  FakeMissingTranslationHandler.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: FakeMissingTranslationHandler,\n    factory: FakeMissingTranslationHandler.ɵfac\n  });\n  return FakeMissingTranslationHandler;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/util.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/* tslint:disable */\n\n/**\n * Determines if two objects or two values are equivalent.\n *\n * Two objects or values are considered equivalent if at least one of the following is true:\n *\n * * Both objects or values pass `===` comparison.\n * * Both objects or values are of the same type and all of their properties are equal by\n *   comparing them with `equals`.\n *\n * @param {?} o1 Object or value to compare.\n * @param {?} o2 Object or value to compare.\n * @return {?} true if arguments are equal.\n */\n\n\nfunction equals(o1, o2) {\n  if (o1 === o2) return true;\n  if (o1 === null || o2 === null) return false;\n  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN\n  // NaN === NaN\n\n  /** @type {?} */\n\n  var t1 = typeof o1;\n  /** @type {?} */\n\n  var t2 = typeof o2;\n  /** @type {?} */\n\n  var length;\n  /** @type {?} */\n\n  var key;\n  /** @type {?} */\n\n  var keySet;\n\n  if (t1 == t2 && t1 == 'object') {\n    if (Array.isArray(o1)) {\n      if (!Array.isArray(o2)) return false;\n\n      if ((length = o1.length) == o2.length) {\n        for (key = 0; key < length; key++) {\n          if (!equals(o1[key], o2[key])) return false;\n        }\n\n        return true;\n      }\n    } else {\n      if (Array.isArray(o2)) {\n        return false;\n      }\n\n      keySet = Object.create(null);\n\n      for (key in o1) {\n        if (!equals(o1[key], o2[key])) {\n          return false;\n        }\n\n        keySet[key] = true;\n      }\n\n      for (key in o2) {\n        if (!(key in keySet) && typeof o2[key] !== 'undefined') {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n/* tslint:enable */\n\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isDefined(value) {\n  return typeof value !== 'undefined' && value !== null;\n}\n/**\n * @param {?} item\n * @return {?}\n */\n\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n/**\n * @param {?} target\n * @param {?} source\n * @return {?}\n */\n\n\nfunction mergeDeep(target, source) {\n  /** @type {?} */\n  var output = Object.assign({}, target);\n\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach(\n    /**\n    * @param {?} key\n    * @return {?}\n    */\n    function (key) {\n      if (isObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, _defineProperty({}, key, source[key]));\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, _defineProperty({}, key, source[key]));\n      }\n    });\n  }\n\n  return output;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/translate.parser.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @abstract\n */\n\n\nvar TranslateParser = /*#__PURE__*/_createClass(function TranslateParser() {\n  _classCallCheck(this, TranslateParser);\n});\n\nif (false) {\n  /**\n   * Interpolates a string to replace parameters\n   * \"This is a {{ key }}\" ==> \"This is a value\", with params = { key: \"value\" }\n   * @abstract\n   * @param {?} expr\n   * @param {?=} params\n   * @return {?}\n   */\n  TranslateParser.prototype.interpolate = function (expr, params) {};\n  /**\n   * Gets a value from an object by composed key\n   * parser.getValue({ key1: { keyA: 'valueI' }}, 'key1.keyA') ==> 'valueI'\n   * @abstract\n   * @param {?} target\n   * @param {?} key\n   * @return {?}\n   */\n\n\n  TranslateParser.prototype.getValue = function (target, key) {};\n}\n\nvar TranslateDefaultParser = /*@__PURE__*/function () {\n  var TranslateDefaultParser = /*#__PURE__*/function (_TranslateParser) {\n    function TranslateDefaultParser() {\n      var _this;\n\n      _classCallCheck(this, TranslateDefaultParser);\n\n      _this = _callSuper(this, TranslateDefaultParser, arguments);\n      _this.templateMatcher = /{{\\s?([^{}\\s]*)\\s?}}/g;\n      return _this;\n    }\n    /**\n     * @param {?} expr\n     * @param {?=} params\n     * @return {?}\n     */\n\n\n    _inherits(TranslateDefaultParser, _TranslateParser);\n\n    return _createClass(TranslateDefaultParser, [{\n      key: \"interpolate\",\n      value: function interpolate(expr, params) {\n        /** @type {?} */\n        var result;\n\n        if (typeof expr === 'string') {\n          result = this.interpolateString(expr, params);\n        } else if (typeof expr === 'function') {\n          result = this.interpolateFunction(expr, params);\n        } else {\n          // this should not happen, but an unrelated TranslateService test depends on it\n          result =\n          /** @type {?} */\n          expr;\n        }\n\n        return result;\n      }\n      /**\n       * @param {?} target\n       * @param {?} key\n       * @return {?}\n       */\n\n    }, {\n      key: \"getValue\",\n      value: function getValue(target, key) {\n        /** @type {?} */\n        var keys = typeof key === 'string' ? key.split('.') : [key];\n        key = '';\n\n        do {\n          key += keys.shift();\n\n          if (isDefined(target) && isDefined(target[key]) && (typeof target[key] === 'object' || !keys.length)) {\n            target = target[key];\n            key = '';\n          } else if (!keys.length) {\n            target = undefined;\n          } else {\n            key += '.';\n          }\n        } while (keys.length);\n\n        return target;\n      }\n      /**\n       * @private\n       * @param {?} fn\n       * @param {?=} params\n       * @return {?}\n       */\n\n    }, {\n      key: \"interpolateFunction\",\n      value: function interpolateFunction(fn, params) {\n        return fn(params);\n      }\n      /**\n       * @private\n       * @param {?} expr\n       * @param {?=} params\n       * @return {?}\n       */\n\n    }, {\n      key: \"interpolateString\",\n      value: function interpolateString(expr, params) {\n        var _this2 = this;\n\n        if (!params) {\n          return expr;\n        }\n\n        return expr.replace(this.templateMatcher,\n        /**\n        * @param {?} substring\n        * @param {?} b\n        * @return {?}\n        */\n        function (substring, b) {\n          /** @type {?} */\n          var r = _this2.getValue(params, b);\n\n          return isDefined(r) ? r : substring;\n        });\n      }\n    }]);\n  }(TranslateParser);\n\n  TranslateDefaultParser.ɵfac = function TranslateDefaultParser_Factory(t) {\n    return ɵTranslateDefaultParser_BaseFactory(t || TranslateDefaultParser);\n  };\n\n  TranslateDefaultParser.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: TranslateDefaultParser,\n    factory: TranslateDefaultParser.ɵfac\n  });\n  return TranslateDefaultParser;\n}();\n\nvar ɵTranslateDefaultParser_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(TranslateDefaultParser);\n\nif (false) {\n  /** @type {?} */\n  TranslateDefaultParser.prototype.templateMatcher;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/translate.compiler.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @abstract\n */\n\n\nvar TranslateCompiler = /*#__PURE__*/_createClass(function TranslateCompiler() {\n  _classCallCheck(this, TranslateCompiler);\n});\n\nif (false) {\n  /**\n   * @abstract\n   * @param {?} value\n   * @param {?} lang\n   * @return {?}\n   */\n  TranslateCompiler.prototype.compile = function (value, lang) {};\n  /**\n   * @abstract\n   * @param {?} translations\n   * @param {?} lang\n   * @return {?}\n   */\n\n\n  TranslateCompiler.prototype.compileTranslations = function (translations, lang) {};\n}\n\nvar TranslateFakeCompiler = /*@__PURE__*/function () {\n  var TranslateFakeCompiler = /*#__PURE__*/function (_TranslateCompiler) {\n    function TranslateFakeCompiler() {\n      _classCallCheck(this, TranslateFakeCompiler);\n\n      return _callSuper(this, TranslateFakeCompiler, arguments);\n    }\n\n    _inherits(TranslateFakeCompiler, _TranslateCompiler);\n\n    return _createClass(TranslateFakeCompiler, [{\n      key: \"compile\",\n      value:\n      /**\n       * @param {?} value\n       * @param {?} lang\n       * @return {?}\n       */\n      function compile(value, lang) {\n        return value;\n      }\n      /**\n       * @param {?} translations\n       * @param {?} lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"compileTranslations\",\n      value: function compileTranslations(translations, lang) {\n        return translations;\n      }\n    }]);\n  }(TranslateCompiler);\n\n  TranslateFakeCompiler.ɵfac = function TranslateFakeCompiler_Factory(t) {\n    return ɵTranslateFakeCompiler_BaseFactory(t || TranslateFakeCompiler);\n  };\n\n  TranslateFakeCompiler.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: TranslateFakeCompiler,\n    factory: TranslateFakeCompiler.ɵfac\n  });\n  return TranslateFakeCompiler;\n}();\n\nvar ɵTranslateFakeCompiler_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(TranslateFakeCompiler);\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/translate.store.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nvar TranslateStore = /*#__PURE__*/_createClass(function TranslateStore() {\n  _classCallCheck(this, TranslateStore);\n\n  /**\n   * The lang currently used\n   */\n  this.currentLang = this.defaultLang;\n  /**\n   * a list of translations per lang\n   */\n\n  this.translations = {};\n  /**\n   * an array of langs\n   */\n\n  this.langs = [];\n  /**\n   * An EventEmitter to listen to translation change events\n   * onTranslationChange.subscribe((params: TranslationChangeEvent) => {\n   *     // do something\n   * });\n   */\n\n  this.onTranslationChange = new EventEmitter();\n  /**\n   * An EventEmitter to listen to lang change events\n   * onLangChange.subscribe((params: LangChangeEvent) => {\n   *     // do something\n   * });\n   */\n\n  this.onLangChange = new EventEmitter();\n  /**\n   * An EventEmitter to listen to default lang change events\n   * onDefaultLangChange.subscribe((params: DefaultLangChangeEvent) => {\n   *     // do something\n   * });\n   */\n\n  this.onDefaultLangChange = new EventEmitter();\n});\n\nif (false) {\n  /**\n   * The default lang to fallback when translations are missing on the current lang\n   * @type {?}\n   */\n  TranslateStore.prototype.defaultLang;\n  /**\n   * The lang currently used\n   * @type {?}\n   */\n\n  TranslateStore.prototype.currentLang;\n  /**\n   * a list of translations per lang\n   * @type {?}\n   */\n\n  TranslateStore.prototype.translations;\n  /**\n   * an array of langs\n   * @type {?}\n   */\n\n  TranslateStore.prototype.langs;\n  /**\n   * An EventEmitter to listen to translation change events\n   * onTranslationChange.subscribe((params: TranslationChangeEvent) => {\n   *     // do something\n   * });\n   * @type {?}\n   */\n\n  TranslateStore.prototype.onTranslationChange;\n  /**\n   * An EventEmitter to listen to lang change events\n   * onLangChange.subscribe((params: LangChangeEvent) => {\n   *     // do something\n   * });\n   * @type {?}\n   */\n\n  TranslateStore.prototype.onLangChange;\n  /**\n   * An EventEmitter to listen to default lang change events\n   * onDefaultLangChange.subscribe((params: DefaultLangChangeEvent) => {\n   *     // do something\n   * });\n   * @type {?}\n   */\n\n  TranslateStore.prototype.onDefaultLangChange;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/translate.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar USE_STORE = new InjectionToken('USE_STORE');\n/** @type {?} */\n\nvar USE_DEFAULT_LANG = new InjectionToken('USE_DEFAULT_LANG');\n/** @type {?} */\n\nvar DEFAULT_LANGUAGE = new InjectionToken('DEFAULT_LANGUAGE');\n/** @type {?} */\n\nvar USE_EXTEND = new InjectionToken('USE_EXTEND');\n/**\n * @record\n */\n\nfunction TranslationChangeEvent() {}\n\nif (false) {\n  /** @type {?} */\n  TranslationChangeEvent.prototype.translations;\n  /** @type {?} */\n\n  TranslationChangeEvent.prototype.lang;\n}\n/**\n * @record\n */\n\n\nfunction LangChangeEvent() {}\n\nif (false) {\n  /** @type {?} */\n  LangChangeEvent.prototype.lang;\n  /** @type {?} */\n\n  LangChangeEvent.prototype.translations;\n}\n/**\n * @record\n */\n\n\nfunction DefaultLangChangeEvent() {}\n\nif (false) {\n  /** @type {?} */\n  DefaultLangChangeEvent.prototype.lang;\n  /** @type {?} */\n\n  DefaultLangChangeEvent.prototype.translations;\n}\n\nvar TranslateService = /*@__PURE__*/function () {\n  var TranslateService = /*#__PURE__*/function () {\n    /**\n     *\n     * @param {?} store an instance of the store (that is supposed to be unique)\n     * @param {?} currentLoader An instance of the loader currently used\n     * @param {?} compiler An instance of the compiler currently used\n     * @param {?} parser An instance of the parser currently used\n     * @param {?} missingTranslationHandler A handler for missing translations.\n     * @param {?=} useDefaultLang whether we should use default language translation when current language translation is missing.\n     * @param {?=} isolate whether this service should use the store or not\n     * @param {?=} extend To make a child module extend (and use) translations from parent modules.\n     * @param {?=} defaultLanguage Set the default language using configuration\n     */\n    function TranslateService(store, currentLoader, compiler, parser, missingTranslationHandler) {\n      var useDefaultLang = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n      var isolate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      var extend = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n      var defaultLanguage = arguments.length > 8 ? arguments[8] : undefined;\n\n      _classCallCheck(this, TranslateService);\n\n      this.store = store;\n      this.currentLoader = currentLoader;\n      this.compiler = compiler;\n      this.parser = parser;\n      this.missingTranslationHandler = missingTranslationHandler;\n      this.useDefaultLang = useDefaultLang;\n      this.isolate = isolate;\n      this.extend = extend;\n      this.pending = false;\n      this._onTranslationChange = new EventEmitter();\n      this._onLangChange = new EventEmitter();\n      this._onDefaultLangChange = new EventEmitter();\n      this._langs = [];\n      this._translations = {};\n      this._translationRequests = {};\n      /** set the default language from configuration */\n\n      if (defaultLanguage) {\n        this.setDefaultLang(defaultLanguage);\n      }\n    }\n    /**\n     * An EventEmitter to listen to translation change events\n     * onTranslationChange.subscribe((params: TranslationChangeEvent) => {\n     *     // do something\n     * });\n     * @return {?}\n     */\n\n\n    return _createClass(TranslateService, [{\n      key: \"onTranslationChange\",\n      get: function get() {\n        return this.isolate ? this._onTranslationChange : this.store.onTranslationChange;\n      }\n      /**\n       * An EventEmitter to listen to lang change events\n       * onLangChange.subscribe((params: LangChangeEvent) => {\n       *     // do something\n       * });\n       * @return {?}\n       */\n\n    }, {\n      key: \"onLangChange\",\n      get: function get() {\n        return this.isolate ? this._onLangChange : this.store.onLangChange;\n      }\n      /**\n       * An EventEmitter to listen to default lang change events\n       * onDefaultLangChange.subscribe((params: DefaultLangChangeEvent) => {\n       *     // do something\n       * });\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDefaultLangChange\",\n      get: function get() {\n        return this.isolate ? this._onDefaultLangChange : this.store.onDefaultLangChange;\n      }\n      /**\n       * The default lang to fallback when translations are missing on the current lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"defaultLang\",\n      get: function get() {\n        return this.isolate ? this._defaultLang : this.store.defaultLang;\n      }\n      /**\n       * @param {?} defaultLang\n       * @return {?}\n       */\n      ,\n      set: function set(defaultLang) {\n        if (this.isolate) {\n          this._defaultLang = defaultLang;\n        } else {\n          this.store.defaultLang = defaultLang;\n        }\n      }\n      /**\n       * The lang currently used\n       * @return {?}\n       */\n\n    }, {\n      key: \"currentLang\",\n      get: function get() {\n        return this.isolate ? this._currentLang : this.store.currentLang;\n      }\n      /**\n       * @param {?} currentLang\n       * @return {?}\n       */\n      ,\n      set: function set(currentLang) {\n        if (this.isolate) {\n          this._currentLang = currentLang;\n        } else {\n          this.store.currentLang = currentLang;\n        }\n      }\n      /**\n       * an array of langs\n       * @return {?}\n       */\n\n    }, {\n      key: \"langs\",\n      get: function get() {\n        return this.isolate ? this._langs : this.store.langs;\n      }\n      /**\n       * @param {?} langs\n       * @return {?}\n       */\n      ,\n      set: function set(langs) {\n        if (this.isolate) {\n          this._langs = langs;\n        } else {\n          this.store.langs = langs;\n        }\n      }\n      /**\n       * a list of translations per lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"translations\",\n      get: function get() {\n        return this.isolate ? this._translations : this.store.translations;\n      }\n      /**\n       * @param {?} translations\n       * @return {?}\n       */\n      ,\n      set: function set(translations) {\n        if (this.isolate) {\n          this._translations = translations;\n        } else {\n          this.store.translations = translations;\n        }\n      }\n      /**\n       * Sets the default language to use as a fallback\n       * @param {?} lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"setDefaultLang\",\n      value: function setDefaultLang(lang) {\n        var _this3 = this;\n\n        if (lang === this.defaultLang) {\n          return;\n        }\n        /** @type {?} */\n\n\n        var pending = this.retrieveTranslations(lang);\n\n        if (typeof pending !== \"undefined\") {\n          // on init set the defaultLang immediately\n          if (this.defaultLang == null) {\n            this.defaultLang = lang;\n          }\n\n          pending.pipe(take(1)).subscribe(\n          /**\n          * @param {?} res\n          * @return {?}\n          */\n          function (res) {\n            _this3.changeDefaultLang(lang);\n          });\n        } else {\n          // we already have this language\n          this.changeDefaultLang(lang);\n        }\n      }\n      /**\n       * Gets the default language used\n       * @return {?}\n       */\n\n    }, {\n      key: \"getDefaultLang\",\n      value: function getDefaultLang() {\n        return this.defaultLang;\n      }\n      /**\n       * Changes the lang currently used\n       * @param {?} lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"use\",\n      value: function use(lang) {\n        var _this4 = this;\n\n        // don't change the language if the language given is already selected\n        if (lang === this.currentLang) {\n          return of(this.translations[lang]);\n        }\n        /** @type {?} */\n\n\n        var pending = this.retrieveTranslations(lang);\n\n        if (typeof pending !== \"undefined\") {\n          // on init set the currentLang immediately\n          if (!this.currentLang) {\n            this.currentLang = lang;\n          }\n\n          pending.pipe(take(1)).subscribe(\n          /**\n          * @param {?} res\n          * @return {?}\n          */\n          function (res) {\n            _this4.changeLang(lang);\n          });\n          return pending;\n        } else {\n          // we have this language, return an Observable\n          this.changeLang(lang);\n          return of(this.translations[lang]);\n        }\n      }\n      /**\n       * Retrieves the given translations\n       * @private\n       * @param {?} lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"retrieveTranslations\",\n      value: function retrieveTranslations(lang) {\n        /** @type {?} */\n        var pending; // if this language is unavailable or extend is true, ask for it\n\n        if (typeof this.translations[lang] === \"undefined\" || this.extend) {\n          this._translationRequests[lang] = this._translationRequests[lang] || this.getTranslation(lang);\n          pending = this._translationRequests[lang];\n        }\n\n        return pending;\n      }\n      /**\n       * Gets an object of translations for a given language with the current loader\n       * and passes it through the compiler\n       * @param {?} lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"getTranslation\",\n      value: function getTranslation(lang) {\n        var _this5 = this;\n\n        this.pending = true;\n        /** @type {?} */\n\n        var loadingTranslations = this.currentLoader.getTranslation(lang).pipe(shareReplay(1), take(1));\n        this.loadingTranslations = loadingTranslations.pipe(map(\n        /**\n        * @param {?} res\n        * @return {?}\n        */\n        function (res) {\n          return _this5.compiler.compileTranslations(res, lang);\n        }), shareReplay(1), take(1));\n        this.loadingTranslations.subscribe({\n          next:\n          /**\n          * @param {?} res\n          * @return {?}\n          */\n          function next(res) {\n            _this5.translations[lang] = _this5.extend && _this5.translations[lang] ? Object.assign(Object.assign({}, res), _this5.translations[lang]) : res;\n\n            _this5.updateLangs();\n\n            _this5.pending = false;\n          },\n          error:\n          /**\n          * @param {?} err\n          * @return {?}\n          */\n          function error(err) {\n            _this5.pending = false;\n          }\n        });\n        return loadingTranslations;\n      }\n      /**\n       * Manually sets an object of translations for a given language\n       * after passing it through the compiler\n       * @param {?} lang\n       * @param {?} translations\n       * @param {?=} shouldMerge\n       * @return {?}\n       */\n\n    }, {\n      key: \"setTranslation\",\n      value: function setTranslation(lang, translations) {\n        var shouldMerge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        translations = this.compiler.compileTranslations(translations, lang);\n\n        if ((shouldMerge || this.extend) && this.translations[lang]) {\n          this.translations[lang] = mergeDeep(this.translations[lang], translations);\n        } else {\n          this.translations[lang] = translations;\n        }\n\n        this.updateLangs();\n        this.onTranslationChange.emit({\n          lang: lang,\n          translations: this.translations[lang]\n        });\n      }\n      /**\n       * Returns an array of currently available langs\n       * @return {?}\n       */\n\n    }, {\n      key: \"getLangs\",\n      value: function getLangs() {\n        return this.langs;\n      }\n      /**\n       * Add available langs\n       * @param {?} langs\n       * @return {?}\n       */\n\n    }, {\n      key: \"addLangs\",\n      value: function addLangs(langs) {\n        var _this6 = this;\n\n        langs.forEach(\n        /**\n        * @param {?} lang\n        * @return {?}\n        */\n        function (lang) {\n          if (_this6.langs.indexOf(lang) === -1) {\n            _this6.langs.push(lang);\n          }\n        });\n      }\n      /**\n       * Update the list of available langs\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateLangs\",\n      value: function updateLangs() {\n        this.addLangs(Object.keys(this.translations));\n      }\n      /**\n       * Returns the parsed result of the translations\n       * @param {?} translations\n       * @param {?} key\n       * @param {?=} interpolateParams\n       * @return {?}\n       */\n\n    }, {\n      key: \"getParsedResult\",\n      value: function getParsedResult(translations, key, interpolateParams) {\n        /** @type {?} */\n        var res;\n\n        if (key instanceof Array) {\n          /** @type {?} */\n          var result = {};\n          /** @type {?} */\n\n          var observables = false;\n\n          var _iterator = _createForOfIteratorHelper(key),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var k = _step.value;\n              result[k] = this.getParsedResult(translations, k, interpolateParams);\n\n              if (isObservable(result[k])) {\n                observables = true;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          if (observables) {\n            /** @type {?} */\n            var sources = key.map(\n            /**\n            * @param {?} k\n            * @return {?}\n            */\n\n            /**\n            * @param {?} k\n            * @return {?}\n            */\n            function (k) {\n              return isObservable(result[k]) ? result[k] : of(\n              /** @type {?} */\n              result[k]);\n            });\n            return forkJoin(sources).pipe(map(\n            /**\n            * @param {?} arr\n            * @return {?}\n            */\n            function (arr) {\n              /** @type {?} */\n              var obj = {};\n              arr.forEach(\n              /**\n              * @param {?} value\n              * @param {?} index\n              * @return {?}\n              */\n              function (value, index) {\n                obj[key[index]] = value;\n              });\n              return obj;\n            }));\n          }\n\n          return result;\n        }\n\n        if (translations) {\n          res = this.parser.interpolate(this.parser.getValue(translations, key), interpolateParams);\n        }\n\n        if (typeof res === \"undefined\" && this.defaultLang != null && this.defaultLang !== this.currentLang && this.useDefaultLang) {\n          res = this.parser.interpolate(this.parser.getValue(this.translations[this.defaultLang], key), interpolateParams);\n        }\n\n        if (typeof res === \"undefined\") {\n          /** @type {?} */\n          var params = {\n            key: key,\n            translateService: this\n          };\n\n          if (typeof interpolateParams !== 'undefined') {\n            params.interpolateParams = interpolateParams;\n          }\n\n          res = this.missingTranslationHandler.handle(params);\n        }\n\n        return typeof res !== \"undefined\" ? res : key;\n      }\n      /**\n       * Gets the translated value of a key (or an array of keys)\n       * @param {?} key\n       * @param {?=} interpolateParams\n       * @return {?} the translated key, or an object of translated keys\n       */\n\n    }, {\n      key: \"get\",\n      value: function get(key, interpolateParams) {\n        var _this7 = this;\n\n        if (!isDefined(key) || !key.length) {\n          throw new Error(\"Parameter \\\"key\\\" required\");\n        } // check if we are loading a new translation to use\n\n\n        if (this.pending) {\n          return this.loadingTranslations.pipe(concatMap(\n          /**\n          * @param {?} res\n          * @return {?}\n          */\n          function (res) {\n            res = _this7.getParsedResult(res, key, interpolateParams);\n            return isObservable(res) ? res : of(res);\n          }));\n        } else {\n          /** @type {?} */\n          var res = this.getParsedResult(this.translations[this.currentLang], key, interpolateParams);\n          return isObservable(res) ? res : of(res);\n        }\n      }\n      /**\n       * Returns a stream of translated values of a key (or an array of keys) which updates\n       * whenever the translation changes.\n       * @param {?} key\n       * @param {?=} interpolateParams\n       * @return {?} A stream of the translated key, or an object of translated keys\n       */\n\n    }, {\n      key: \"getStreamOnTranslationChange\",\n      value: function getStreamOnTranslationChange(key, interpolateParams) {\n        var _this8 = this;\n\n        if (!isDefined(key) || !key.length) {\n          throw new Error(\"Parameter \\\"key\\\" required\");\n        }\n\n        return concat(defer(\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this8.get(key, interpolateParams);\n        }), this.onTranslationChange.pipe(switchMap(\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        function (event) {\n          /** @type {?} */\n          var res = _this8.getParsedResult(event.translations, key, interpolateParams);\n\n          if (typeof res.subscribe === 'function') {\n            return res;\n          } else {\n            return of(res);\n          }\n        })));\n      }\n      /**\n       * Returns a stream of translated values of a key (or an array of keys) which updates\n       * whenever the language changes.\n       * @param {?} key\n       * @param {?=} interpolateParams\n       * @return {?} A stream of the translated key, or an object of translated keys\n       */\n\n    }, {\n      key: \"stream\",\n      value: function stream(key, interpolateParams) {\n        var _this9 = this;\n\n        if (!isDefined(key) || !key.length) {\n          throw new Error(\"Parameter \\\"key\\\" required\");\n        }\n\n        return concat(defer(\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this9.get(key, interpolateParams);\n        }), this.onLangChange.pipe(switchMap(\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        function (event) {\n          /** @type {?} */\n          var res = _this9.getParsedResult(event.translations, key, interpolateParams);\n\n          return isObservable(res) ? res : of(res);\n        })));\n      }\n      /**\n       * Returns a translation instantly from the internal state of loaded translation.\n       * All rules regarding the current language, the preferred language of even fallback languages will be used except any promise handling.\n       * @param {?} key\n       * @param {?=} interpolateParams\n       * @return {?}\n       */\n\n    }, {\n      key: \"instant\",\n      value: function instant(key, interpolateParams) {\n        if (!isDefined(key) || !key.length) {\n          throw new Error(\"Parameter \\\"key\\\" required\");\n        }\n        /** @type {?} */\n\n\n        var res = this.getParsedResult(this.translations[this.currentLang], key, interpolateParams);\n\n        if (isObservable(res)) {\n          if (key instanceof Array) {\n            /** @type {?} */\n            var obj = {};\n            key.forEach(\n            /**\n            * @param {?} value\n            * @param {?} index\n            * @return {?}\n            */\n            function (value, index) {\n              obj[key[index]] = key[index];\n            });\n            return obj;\n          }\n\n          return key;\n        } else {\n          return res;\n        }\n      }\n      /**\n       * Sets the translated value of a key, after compiling it\n       * @param {?} key\n       * @param {?} value\n       * @param {?=} lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"set\",\n      value: function set(key, value) {\n        var lang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.currentLang;\n        this.translations[lang][key] = this.compiler.compile(value, lang);\n        this.updateLangs();\n        this.onTranslationChange.emit({\n          lang: lang,\n          translations: this.translations[lang]\n        });\n      }\n      /**\n       * Changes the current lang\n       * @private\n       * @param {?} lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"changeLang\",\n      value: function changeLang(lang) {\n        this.currentLang = lang;\n        this.onLangChange.emit({\n          lang: lang,\n          translations: this.translations[lang]\n        }); // if there is no default lang, use the one that we just set\n\n        if (this.defaultLang == null) {\n          this.changeDefaultLang(lang);\n        }\n      }\n      /**\n       * Changes the default lang\n       * @private\n       * @param {?} lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"changeDefaultLang\",\n      value: function changeDefaultLang(lang) {\n        this.defaultLang = lang;\n        this.onDefaultLangChange.emit({\n          lang: lang,\n          translations: this.translations[lang]\n        });\n      }\n      /**\n       * Allows to reload the lang file from the file\n       * @param {?} lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"reloadLang\",\n      value: function reloadLang(lang) {\n        this.resetLang(lang);\n        return this.getTranslation(lang);\n      }\n      /**\n       * Deletes inner translation\n       * @param {?} lang\n       * @return {?}\n       */\n\n    }, {\n      key: \"resetLang\",\n      value: function resetLang(lang) {\n        this._translationRequests[lang] = undefined;\n        this.translations[lang] = undefined;\n      }\n      /**\n       * Returns the language code name from the browser, e.g. \"de\"\n       * @return {?}\n       */\n\n    }, {\n      key: \"getBrowserLang\",\n      value: function getBrowserLang() {\n        if (typeof window === 'undefined' || typeof window.navigator === 'undefined') {\n          return undefined;\n        }\n        /** @type {?} */\n\n\n        var browserLang = window.navigator.languages ? window.navigator.languages[0] : null;\n        browserLang = browserLang || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage;\n\n        if (typeof browserLang === 'undefined') {\n          return undefined;\n        }\n\n        if (browserLang.indexOf('-') !== -1) {\n          browserLang = browserLang.split('-')[0];\n        }\n\n        if (browserLang.indexOf('_') !== -1) {\n          browserLang = browserLang.split('_')[0];\n        }\n\n        return browserLang;\n      }\n      /**\n       * Returns the culture language code name from the browser, e.g. \"de-DE\"\n       * @return {?}\n       */\n\n    }, {\n      key: \"getBrowserCultureLang\",\n      value: function getBrowserCultureLang() {\n        if (typeof window === 'undefined' || typeof window.navigator === 'undefined') {\n          return undefined;\n        }\n        /** @type {?} */\n\n\n        var browserCultureLang = window.navigator.languages ? window.navigator.languages[0] : null;\n        browserCultureLang = browserCultureLang || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage;\n        return browserCultureLang;\n      }\n    }]);\n  }();\n\n  TranslateService.ɵfac = function TranslateService_Factory(t) {\n    return new (t || TranslateService)(ɵngcc0.ɵɵinject(TranslateStore), ɵngcc0.ɵɵinject(TranslateLoader), ɵngcc0.ɵɵinject(TranslateCompiler), ɵngcc0.ɵɵinject(TranslateParser), ɵngcc0.ɵɵinject(MissingTranslationHandler), ɵngcc0.ɵɵinject(USE_DEFAULT_LANG), ɵngcc0.ɵɵinject(USE_STORE), ɵngcc0.ɵɵinject(USE_EXTEND), ɵngcc0.ɵɵinject(DEFAULT_LANGUAGE));\n  };\n\n  TranslateService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: TranslateService,\n    factory: TranslateService.ɵfac\n  });\n  return TranslateService;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  TranslateService.prototype.loadingTranslations;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype.pending;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype._onTranslationChange;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype._onLangChange;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype._onDefaultLangChange;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype._defaultLang;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype._currentLang;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype._langs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype._translations;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype._translationRequests;\n  /** @type {?} */\n\n  TranslateService.prototype.store;\n  /** @type {?} */\n\n  TranslateService.prototype.currentLoader;\n  /** @type {?} */\n\n  TranslateService.prototype.compiler;\n  /** @type {?} */\n\n  TranslateService.prototype.parser;\n  /** @type {?} */\n\n  TranslateService.prototype.missingTranslationHandler;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype.useDefaultLang;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype.isolate;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateService.prototype.extend;\n}\n\nvar TranslateDirective = /*@__PURE__*/function () {\n  var TranslateDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} translateService\n     * @param {?} element\n     * @param {?} _ref\n     */\n    function TranslateDirective(translateService, element, _ref) {\n      var _this10 = this;\n\n      _classCallCheck(this, TranslateDirective);\n\n      this.translateService = translateService;\n      this.element = element;\n      this._ref = _ref; // subscribe to onTranslationChange event, in case the translations of the current lang change\n\n      if (!this.onTranslationChangeSub) {\n        this.onTranslationChangeSub = this.translateService.onTranslationChange.subscribe(\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        function (event) {\n          if (event.lang === _this10.translateService.currentLang) {\n            _this10.checkNodes(true, event.translations);\n          }\n        });\n      } // subscribe to onLangChange event, in case the language changes\n\n\n      if (!this.onLangChangeSub) {\n        this.onLangChangeSub = this.translateService.onLangChange.subscribe(\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        function (event) {\n          _this10.checkNodes(true, event.translations);\n        });\n      } // subscribe to onDefaultLangChange event, in case the default language changes\n\n\n      if (!this.onDefaultLangChangeSub) {\n        this.onDefaultLangChangeSub = this.translateService.onDefaultLangChange.subscribe(\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        function (event) {\n          _this10.checkNodes(true);\n        });\n      }\n    }\n    /**\n     * @param {?} key\n     * @return {?}\n     */\n\n\n    return _createClass(TranslateDirective, [{\n      key: \"translate\",\n      set: function set(key) {\n        if (key) {\n          this.key = key;\n          this.checkNodes();\n        }\n      }\n      /**\n       * @param {?} params\n       * @return {?}\n       */\n\n    }, {\n      key: \"translateParams\",\n      set: function set(params) {\n        if (!equals(this.currentParams, params)) {\n          this.currentParams = params;\n          this.checkNodes(true);\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterViewChecked\",\n      value: function ngAfterViewChecked() {\n        this.checkNodes();\n      }\n      /**\n       * @param {?=} forceUpdate\n       * @param {?=} translations\n       * @return {?}\n       */\n\n    }, {\n      key: \"checkNodes\",\n      value: function checkNodes() {\n        var forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var translations = arguments.length > 1 ? arguments[1] : undefined;\n\n        /** @type {?} */\n        var nodes = this.element.nativeElement.childNodes; // if the element is empty\n\n        if (!nodes.length) {\n          // we add the key as content\n          this.setContent(this.element.nativeElement, this.key);\n          nodes = this.element.nativeElement.childNodes;\n        }\n\n        for (var i = 0; i < nodes.length; ++i) {\n          /** @type {?} */\n          var node = nodes[i];\n\n          if (node.nodeType === 3) {\n            // node type 3 is a text node\n            // node type 3 is a text node\n\n            /** @type {?} */\n            var key = void 0;\n\n            if (forceUpdate) {\n              node.lastKey = null;\n            }\n\n            if (isDefined(node.lookupKey)) {\n              key = node.lookupKey;\n            } else if (this.key) {\n              key = this.key;\n            } else {\n              /** @type {?} */\n              var content = this.getContent(node);\n              /** @type {?} */\n\n              var trimmedContent = content.trim();\n\n              if (trimmedContent.length) {\n                node.lookupKey = trimmedContent; // we want to use the content as a key, not the translation value\n\n                if (content !== node.currentValue) {\n                  key = trimmedContent; // the content was changed from the user, we'll use it as a reference if needed\n\n                  node.originalContent = content || node.originalContent;\n                } else if (node.originalContent) {\n                  // the content seems ok, but the lang has changed\n                  // the current content is the translation, not the key, use the last real content as key\n                  key = node.originalContent.trim();\n                } else if (content !== node.currentValue) {\n                  // we want to use the content as a key, not the translation value\n                  key = trimmedContent; // the content was changed from the user, we'll use it as a reference if needed\n\n                  node.originalContent = content || node.originalContent;\n                }\n              }\n            }\n\n            this.updateValue(key, node, translations);\n          }\n        }\n      }\n      /**\n       * @param {?} key\n       * @param {?} node\n       * @param {?} translations\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateValue\",\n      value: function updateValue(key, node, translations) {\n        var _this11 = this;\n\n        if (key) {\n          if (node.lastKey === key && this.lastParams === this.currentParams) {\n            return;\n          }\n\n          this.lastParams = this.currentParams;\n          /** @type {?} */\n\n          var onTranslation =\n          /**\n          * @param {?} res\n          * @return {?}\n          */\n          function onTranslation(res) {\n            if (res !== key) {\n              node.lastKey = key;\n            }\n\n            if (!node.originalContent) {\n              node.originalContent = _this11.getContent(node);\n            }\n\n            node.currentValue = isDefined(res) ? res : node.originalContent || key; // we replace in the original content to preserve spaces that we might have trimmed\n\n            _this11.setContent(node, _this11.key ? node.currentValue : node.originalContent.replace(key, node.currentValue));\n\n            _this11._ref.markForCheck();\n          };\n\n          if (isDefined(translations)) {\n            /** @type {?} */\n            var res = this.translateService.getParsedResult(translations, key, this.currentParams);\n\n            if (isObservable(res)) {\n              res.subscribe(onTranslation);\n            } else {\n              onTranslation(res);\n            }\n          } else {\n            this.translateService.get(key, this.currentParams).subscribe(onTranslation);\n          }\n        }\n      }\n      /**\n       * @param {?} node\n       * @return {?}\n       */\n\n    }, {\n      key: \"getContent\",\n      value: function getContent(node) {\n        return isDefined(node.textContent) ? node.textContent : node.data;\n      }\n      /**\n       * @param {?} node\n       * @param {?} content\n       * @return {?}\n       */\n\n    }, {\n      key: \"setContent\",\n      value: function setContent(node, content) {\n        if (isDefined(node.textContent)) {\n          node.textContent = content;\n        } else {\n          node.data = content;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.onLangChangeSub) {\n          this.onLangChangeSub.unsubscribe();\n        }\n\n        if (this.onDefaultLangChangeSub) {\n          this.onDefaultLangChangeSub.unsubscribe();\n        }\n\n        if (this.onTranslationChangeSub) {\n          this.onTranslationChangeSub.unsubscribe();\n        }\n      }\n    }]);\n  }();\n\n  TranslateDirective.ɵfac = function TranslateDirective_Factory(t) {\n    return new (t || TranslateDirective)(ɵngcc0.ɵɵdirectiveInject(TranslateService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  TranslateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: TranslateDirective,\n    selectors: [[\"\", \"translate\", \"\"], [\"\", \"ngx-translate\", \"\"]],\n    inputs: {\n      translate: \"translate\",\n      translateParams: \"translateParams\"\n    }\n  });\n  return TranslateDirective;\n}();\n\nif (false) {\n  /** @type {?} */\n  TranslateDirective.prototype.key;\n  /** @type {?} */\n\n  TranslateDirective.prototype.lastParams;\n  /** @type {?} */\n\n  TranslateDirective.prototype.currentParams;\n  /** @type {?} */\n\n  TranslateDirective.prototype.onLangChangeSub;\n  /** @type {?} */\n\n  TranslateDirective.prototype.onDefaultLangChangeSub;\n  /** @type {?} */\n\n  TranslateDirective.prototype.onTranslationChangeSub;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateDirective.prototype.translateService;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateDirective.prototype.element;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslateDirective.prototype._ref;\n}\n\nvar TranslatePipe = /*@__PURE__*/function () {\n  var TranslatePipe = /*#__PURE__*/function () {\n    /**\n     * @param {?} translate\n     * @param {?} _ref\n     */\n    function TranslatePipe(translate, _ref) {\n      _classCallCheck(this, TranslatePipe);\n\n      this.translate = translate;\n      this._ref = _ref;\n      this.value = '';\n    }\n    /**\n     * @param {?} key\n     * @param {?=} interpolateParams\n     * @param {?=} translations\n     * @return {?}\n     */\n\n\n    return _createClass(TranslatePipe, [{\n      key: \"updateValue\",\n      value: function updateValue(key, interpolateParams, translations) {\n        var _this12 = this;\n\n        /** @type {?} */\n        var onTranslation =\n        /**\n        * @param {?} res\n        * @return {?}\n        */\n        function onTranslation(res) {\n          _this12.value = res !== undefined ? res : key;\n          _this12.lastKey = key;\n\n          _this12._ref.markForCheck();\n        };\n\n        if (translations) {\n          /** @type {?} */\n          var res = this.translate.getParsedResult(translations, key, interpolateParams);\n\n          if (isObservable(res.subscribe)) {\n            res.subscribe(onTranslation);\n          } else {\n            onTranslation(res);\n          }\n        }\n\n        this.translate.get(key, interpolateParams).subscribe(onTranslation);\n      }\n      /**\n       * @param {?} query\n       * @param {...?} args\n       * @return {?}\n       */\n\n    }, {\n      key: \"transform\",\n      value: function transform(query) {\n        var _this13 = this;\n\n        if (!query || !query.length) {\n          return query;\n        } // if we ask another time for the same key, return the last value\n\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        if (equals(query, this.lastKey) && equals(args, this.lastParams)) {\n          return this.value;\n        }\n        /** @type {?} */\n\n\n        var interpolateParams;\n\n        if (isDefined(args[0]) && args.length) {\n          if (typeof args[0] === 'string' && args[0].length) {\n            // we accept objects written in the template such as {n:1}, {'n':1}, {n:'v'}\n            // which is why we might need to change it to real JSON objects such as {\"n\":1} or {\"n\":\"v\"}\n\n            /** @type {?} */\n            var validArgs = args[0].replace(/(\\')?([a-zA-Z0-9_]+)(\\')?(\\s)?:/g, '\"$2\":').replace(/:(\\s)?(\\')(.*?)(\\')/g, ':\"$3\"');\n\n            try {\n              interpolateParams = JSON.parse(validArgs);\n            } catch (e) {\n              throw new SyntaxError(\"Wrong parameter in TranslatePipe. Expected a valid Object, received: \".concat(args[0]));\n            }\n          } else if (typeof args[0] === 'object' && !Array.isArray(args[0])) {\n            interpolateParams = args[0];\n          }\n        } // store the query, in case it changes\n\n\n        this.lastKey = query; // store the params, in case they change\n\n        this.lastParams = args; // set the value\n\n        this.updateValue(query, interpolateParams); // if there is a subscription to onLangChange, clean it\n\n        this._dispose(); // subscribe to onTranslationChange event, in case the translations change\n\n\n        if (!this.onTranslationChange) {\n          this.onTranslationChange = this.translate.onTranslationChange.subscribe(\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            if (_this13.lastKey && event.lang === _this13.translate.currentLang) {\n              _this13.lastKey = null;\n\n              _this13.updateValue(query, interpolateParams, event.translations);\n            }\n          });\n        } // subscribe to onLangChange event, in case the language changes\n\n\n        if (!this.onLangChange) {\n          this.onLangChange = this.translate.onLangChange.subscribe(\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            if (_this13.lastKey) {\n              _this13.lastKey = null; // we want to make sure it doesn't return the same value until it's been updated\n\n              _this13.updateValue(query, interpolateParams, event.translations);\n            }\n          });\n        } // subscribe to onDefaultLangChange event, in case the default language changes\n\n\n        if (!this.onDefaultLangChange) {\n          this.onDefaultLangChange = this.translate.onDefaultLangChange.subscribe(\n          /**\n          * @return {?}\n          */\n          function () {\n            if (_this13.lastKey) {\n              _this13.lastKey = null; // we want to make sure it doesn't return the same value until it's been updated\n\n              _this13.updateValue(query, interpolateParams);\n            }\n          });\n        }\n\n        return this.value;\n      }\n      /**\n       * Clean any existing subscription to change events\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"_dispose\",\n      value: function _dispose() {\n        if (typeof this.onTranslationChange !== 'undefined') {\n          this.onTranslationChange.unsubscribe();\n          this.onTranslationChange = undefined;\n        }\n\n        if (typeof this.onLangChange !== 'undefined') {\n          this.onLangChange.unsubscribe();\n          this.onLangChange = undefined;\n        }\n\n        if (typeof this.onDefaultLangChange !== 'undefined') {\n          this.onDefaultLangChange.unsubscribe();\n          this.onDefaultLangChange = undefined;\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._dispose();\n      }\n    }]);\n  }();\n\n  TranslatePipe.ɵfac = function TranslatePipe_Factory(t) {\n    return new (t || TranslatePipe)(ɵngcc0.ɵɵdirectiveInject(TranslateService), ɵngcc0.ɵɵinjectPipeChangeDetectorRef());\n  };\n\n  TranslatePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({\n    name: \"translate\",\n    type: TranslatePipe,\n    pure: false\n  });\n  TranslatePipe.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: TranslatePipe,\n    factory: TranslatePipe.ɵfac\n  });\n  return TranslatePipe;\n}();\n\nif (false) {\n  /** @type {?} */\n  TranslatePipe.prototype.value;\n  /** @type {?} */\n\n  TranslatePipe.prototype.lastKey;\n  /** @type {?} */\n\n  TranslatePipe.prototype.lastParams;\n  /** @type {?} */\n\n  TranslatePipe.prototype.onTranslationChange;\n  /** @type {?} */\n\n  TranslatePipe.prototype.onLangChange;\n  /** @type {?} */\n\n  TranslatePipe.prototype.onDefaultLangChange;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslatePipe.prototype.translate;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TranslatePipe.prototype._ref;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction TranslateModuleConfig() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  TranslateModuleConfig.prototype.loader;\n  /** @type {?|undefined} */\n\n  TranslateModuleConfig.prototype.compiler;\n  /** @type {?|undefined} */\n\n  TranslateModuleConfig.prototype.parser;\n  /** @type {?|undefined} */\n\n  TranslateModuleConfig.prototype.missingTranslationHandler;\n  /** @type {?|undefined} */\n\n  TranslateModuleConfig.prototype.isolate;\n  /** @type {?|undefined} */\n\n  TranslateModuleConfig.prototype.extend;\n  /** @type {?|undefined} */\n\n  TranslateModuleConfig.prototype.useDefaultLang;\n  /** @type {?|undefined} */\n\n  TranslateModuleConfig.prototype.defaultLanguage;\n}\n\nvar TranslateModule = /*@__PURE__*/function () {\n  var TranslateModule = /*#__PURE__*/function () {\n    function TranslateModule() {\n      _classCallCheck(this, TranslateModule);\n    }\n\n    return _createClass(TranslateModule, null, [{\n      key: \"forRoot\",\n      value:\n      /**\n       * Use this method in your root module to provide the TranslateService\n       * @param {?=} config\n       * @return {?}\n       */\n      function forRoot() {\n        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          ngModule: TranslateModule,\n          providers: [config.loader || {\n            provide: TranslateLoader,\n            useClass: TranslateFakeLoader\n          }, config.compiler || {\n            provide: TranslateCompiler,\n            useClass: TranslateFakeCompiler\n          }, config.parser || {\n            provide: TranslateParser,\n            useClass: TranslateDefaultParser\n          }, config.missingTranslationHandler || {\n            provide: MissingTranslationHandler,\n            useClass: FakeMissingTranslationHandler\n          }, TranslateStore, {\n            provide: USE_STORE,\n            useValue: config.isolate\n          }, {\n            provide: USE_DEFAULT_LANG,\n            useValue: config.useDefaultLang\n          }, {\n            provide: USE_EXTEND,\n            useValue: config.extend\n          }, {\n            provide: DEFAULT_LANGUAGE,\n            useValue: config.defaultLanguage\n          }, TranslateService]\n        };\n      }\n      /**\n       * Use this method in your other (non root) modules to import the directive/pipe\n       * @param {?=} config\n       * @return {?}\n       */\n\n    }, {\n      key: \"forChild\",\n      value: function forChild() {\n        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          ngModule: TranslateModule,\n          providers: [config.loader || {\n            provide: TranslateLoader,\n            useClass: TranslateFakeLoader\n          }, config.compiler || {\n            provide: TranslateCompiler,\n            useClass: TranslateFakeCompiler\n          }, config.parser || {\n            provide: TranslateParser,\n            useClass: TranslateDefaultParser\n          }, config.missingTranslationHandler || {\n            provide: MissingTranslationHandler,\n            useClass: FakeMissingTranslationHandler\n          }, {\n            provide: USE_STORE,\n            useValue: config.isolate\n          }, {\n            provide: USE_DEFAULT_LANG,\n            useValue: config.useDefaultLang\n          }, {\n            provide: USE_EXTEND,\n            useValue: config.extend\n          }, {\n            provide: DEFAULT_LANGUAGE,\n            useValue: config.defaultLanguage\n          }, TranslateService]\n        };\n      }\n    }]);\n  }();\n\n  TranslateModule.ɵfac = function TranslateModule_Factory(t) {\n    return new (t || TranslateModule)();\n  };\n\n  TranslateModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: TranslateModule\n  });\n  TranslateModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});\n  return TranslateModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TranslateModule, {\n    declarations: [TranslatePipe, TranslateDirective],\n    exports: [TranslatePipe, TranslateDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: ngx-translate-core.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DEFAULT_LANGUAGE, FakeMissingTranslationHandler, MissingTranslationHandler, TranslateCompiler, TranslateDefaultParser, TranslateDirective, TranslateFakeCompiler, TranslateFakeLoader, TranslateLoader, TranslateModule, TranslateParser, TranslatePipe, TranslateService, TranslateStore, USE_DEFAULT_LANG, USE_EXTEND, USE_STORE }; //# sourceMappingURL=ngx-translate-core.js.map","map":null,"metadata":{},"sourceType":"module"}