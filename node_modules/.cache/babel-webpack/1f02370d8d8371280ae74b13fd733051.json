{"ast":null,"code":"\"use strict\";\n\nmodule.exports = URL;\n\nfunction URL(url) {\n  if (!url) return Object.create(URL.prototype); // Can't use String.trim() since it defines whitespace differently than HTML\n\n  this.url = url.replace(/^[ \\t\\n\\r\\f]+|[ \\t\\n\\r\\f]+$/g, \"\"); // See http://tools.ietf.org/html/rfc3986#appendix-B\n  // and https://url.spec.whatwg.org/#parsing\n\n  var match = URL.pattern.exec(this.url);\n\n  if (match) {\n    if (match[2]) this.scheme = match[2];\n\n    if (match[4]) {\n      // parse username/password\n      var userinfo = match[4].match(URL.userinfoPattern);\n\n      if (userinfo) {\n        this.username = userinfo[1];\n        this.password = userinfo[3];\n        match[4] = match[4].substring(userinfo[0].length);\n      }\n\n      if (match[4].match(URL.portPattern)) {\n        var pos = match[4].lastIndexOf(':');\n        this.host = match[4].substring(0, pos);\n        this.port = match[4].substring(pos + 1);\n      } else {\n        this.host = match[4];\n      }\n    }\n\n    if (match[5]) this.path = match[5];\n    if (match[6]) this.query = match[7];\n    if (match[8]) this.fragment = match[9];\n  }\n}\n\nURL.pattern = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/;\nURL.userinfoPattern = /^([^@:]*)(:([^@]*))?@/;\nURL.portPattern = /:\\d+$/;\nURL.authorityPattern = /^[^:\\/?#]+:\\/\\//;\nURL.hierarchyPattern = /^[^:\\/?#]+:\\//; // Return a percentEncoded version of s.\n// S should be a single-character string\n// XXX: needs to do utf-8 encoding?\n\nURL.percentEncode = function percentEncode(s) {\n  var c = s.charCodeAt(0);\n  if (c < 256) return \"%\" + c.toString(16);else throw Error(\"can't percent-encode codepoints > 255 yet\");\n};\n\nURL.prototype = {\n  constructor: URL,\n  // XXX: not sure if this is the precise definition of absolute\n  isAbsolute: function isAbsolute() {\n    return !!this.scheme;\n  },\n  isAuthorityBased: function isAuthorityBased() {\n    return URL.authorityPattern.test(this.url);\n  },\n  isHierarchical: function isHierarchical() {\n    return URL.hierarchyPattern.test(this.url);\n  },\n  toString: function toString() {\n    var s = \"\";\n    if (this.scheme !== undefined) s += this.scheme + \":\";\n\n    if (this.isAbsolute()) {\n      s += '//';\n\n      if (this.username || this.password) {\n        s += this.username || '';\n\n        if (this.password) {\n          s += ':' + this.password;\n        }\n\n        s += '@';\n      }\n\n      if (this.host) {\n        s += this.host;\n      }\n    }\n\n    if (this.port !== undefined) s += \":\" + this.port;\n    if (this.path !== undefined) s += this.path;\n    if (this.query !== undefined) s += \"?\" + this.query;\n    if (this.fragment !== undefined) s += \"#\" + this.fragment;\n    return s;\n  },\n  // See: http://tools.ietf.org/html/rfc3986#section-5.2\n  // and https://url.spec.whatwg.org/#constructors\n  resolve: function resolve(relative) {\n    var base = this; // The base url we're resolving against\n\n    var r = new URL(relative); // The relative reference url to resolve\n\n    var t = new URL(); // The absolute target url we will return\n\n    if (r.scheme !== undefined) {\n      t.scheme = r.scheme;\n      t.username = r.username;\n      t.password = r.password;\n      t.host = r.host;\n      t.port = r.port;\n      t.path = remove_dot_segments(r.path);\n      t.query = r.query;\n    } else {\n      t.scheme = base.scheme;\n\n      if (r.host !== undefined) {\n        t.username = r.username;\n        t.password = r.password;\n        t.host = r.host;\n        t.port = r.port;\n        t.path = remove_dot_segments(r.path);\n        t.query = r.query;\n      } else {\n        t.username = base.username;\n        t.password = base.password;\n        t.host = base.host;\n        t.port = base.port;\n\n        if (!r.path) {\n          // undefined or empty\n          t.path = base.path;\n          if (r.query !== undefined) t.query = r.query;else t.query = base.query;\n        } else {\n          if (r.path.charAt(0) === \"/\") {\n            t.path = remove_dot_segments(r.path);\n          } else {\n            t.path = merge(base.path, r.path);\n            t.path = remove_dot_segments(t.path);\n          }\n\n          t.query = r.query;\n        }\n      }\n    }\n\n    t.fragment = r.fragment;\n    return t.toString();\n\n    function merge(basepath, refpath) {\n      if (base.host !== undefined && !base.path) return \"/\" + refpath;\n      var lastslash = basepath.lastIndexOf(\"/\");\n      if (lastslash === -1) return refpath;else return basepath.substring(0, lastslash + 1) + refpath;\n    }\n\n    function remove_dot_segments(path) {\n      if (!path) return path; // For \"\" or undefined\n\n      var output = \"\";\n\n      while (path.length > 0) {\n        if (path === \".\" || path === \"..\") {\n          path = \"\";\n          break;\n        }\n\n        var twochars = path.substring(0, 2);\n        var threechars = path.substring(0, 3);\n        var fourchars = path.substring(0, 4);\n\n        if (threechars === \"../\") {\n          path = path.substring(3);\n        } else if (twochars === \"./\") {\n          path = path.substring(2);\n        } else if (threechars === \"/./\") {\n          path = \"/\" + path.substring(3);\n        } else if (twochars === \"/.\" && path.length === 2) {\n          path = \"/\";\n        } else if (fourchars === \"/../\" || threechars === \"/..\" && path.length === 3) {\n          path = \"/\" + path.substring(4);\n          output = output.replace(/\\/?[^\\/]*$/, \"\");\n        } else {\n          var segment = path.match(/(\\/?([^\\/]*))/)[0];\n          output += segment;\n          path = path.substring(segment.length);\n        }\n      }\n\n      return output;\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}