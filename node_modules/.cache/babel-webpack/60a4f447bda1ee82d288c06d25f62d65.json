{"ast":null,"code":"\"use strict\";\n\nmodule.exports = ContainerNode;\n\nvar Node = require('./Node');\n\nvar NodeList = require('./NodeList'); // This class defines common functionality for node subtypes that\n// can have children\n\n\nfunction ContainerNode() {\n  Node.call(this);\n  this._firstChild = this._childNodes = null;\n} // Primary representation is a circular linked list of siblings\n\n\nContainerNode.prototype = Object.create(Node.prototype, {\n  hasChildNodes: {\n    value: function value() {\n      if (this._childNodes) {\n        return this._childNodes.length > 0;\n      }\n\n      return this._firstChild !== null;\n    }\n  },\n  childNodes: {\n    get: function get() {\n      this._ensureChildNodes();\n\n      return this._childNodes;\n    }\n  },\n  firstChild: {\n    get: function get() {\n      if (this._childNodes) {\n        return this._childNodes.length === 0 ? null : this._childNodes[0];\n      }\n\n      return this._firstChild;\n    }\n  },\n  lastChild: {\n    get: function get() {\n      var kids = this._childNodes,\n          first;\n\n      if (kids) {\n        return kids.length === 0 ? null : kids[kids.length - 1];\n      }\n\n      first = this._firstChild;\n\n      if (first === null) {\n        return null;\n      }\n\n      return first._previousSibling; // circular linked list\n    }\n  },\n  _ensureChildNodes: {\n    value: function value() {\n      if (this._childNodes) {\n        return;\n      }\n\n      var first = this._firstChild,\n          kid = first,\n          childNodes = this._childNodes = new NodeList();\n      if (first) do {\n        childNodes.push(kid);\n        kid = kid._nextSibling;\n      } while (kid !== first); // circular linked list\n\n      this._firstChild = null; // free memory\n    }\n  },\n  // Remove all of this node's children.  This is a minor\n  // optimization that only calls modify() once.\n  removeChildren: {\n    value: function removeChildren() {\n      var root = this.rooted ? this.ownerDocument : null,\n          next = this.firstChild,\n          kid;\n\n      while (next !== null) {\n        kid = next;\n        next = kid.nextSibling;\n        if (root) root.mutateRemove(kid);\n        kid.parentNode = null;\n      }\n\n      if (this._childNodes) {\n        this._childNodes.length = 0;\n      } else {\n        this._firstChild = null;\n      }\n\n      this.modify(); // Update last modified type once only\n    }\n  }\n});","map":null,"metadata":{},"sourceType":"script"}