{"ast":null,"code":"/*!\n * depd\n * Copyright(c) 2014-2018 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar relative = require('path').relative;\n/**\n * Module exports.\n */\n\n\nmodule.exports = depd;\n/**\n * Get the path to base files on.\n */\n\nvar basePath = process.cwd();\n/**\n * Determine if namespace is contained in the string.\n */\n\nfunction containsNamespace(str, namespace) {\n  var vals = str.split(/[ ,]+/);\n  var ns = String(namespace).toLowerCase();\n\n  for (var i = 0; i < vals.length; i++) {\n    var val = vals[i]; // namespace contained\n\n    if (val && (val === '*' || val.toLowerCase() === ns)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Convert a data descriptor to accessor descriptor.\n */\n\n\nfunction convertDataDescriptorToAccessor(obj, prop, message) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n  var value = descriptor.value;\n\n  descriptor.get = function getter() {\n    return value;\n  };\n\n  if (descriptor.writable) {\n    descriptor.set = function setter(val) {\n      return value = val;\n    };\n  }\n\n  delete descriptor.value;\n  delete descriptor.writable;\n  Object.defineProperty(obj, prop, descriptor);\n  return descriptor;\n}\n/**\n * Create arguments string to keep arity.\n */\n\n\nfunction createArgumentsString(arity) {\n  var str = '';\n\n  for (var i = 0; i < arity; i++) {\n    str += ', arg' + i;\n  }\n\n  return str.substr(2);\n}\n/**\n * Create stack string from stack.\n */\n\n\nfunction createStackString(stack) {\n  var str = this.name + ': ' + this.namespace;\n\n  if (this.message) {\n    str += ' deprecated ' + this.message;\n  }\n\n  for (var i = 0; i < stack.length; i++) {\n    str += '\\n    at ' + stack[i].toString();\n  }\n\n  return str;\n}\n/**\n * Create deprecate for namespace in caller.\n */\n\n\nfunction depd(namespace) {\n  if (!namespace) {\n    throw new TypeError('argument namespace is required');\n  }\n\n  var stack = getStack();\n  var site = callSiteLocation(stack[1]);\n  var file = site[0];\n\n  function deprecate(message) {\n    // call to self as log\n    log.call(deprecate, message);\n  }\n\n  deprecate._file = file;\n  deprecate._ignored = isignored(namespace);\n  deprecate._namespace = namespace;\n  deprecate._traced = istraced(namespace);\n  deprecate._warned = Object.create(null);\n  deprecate.function = wrapfunction;\n  deprecate.property = wrapproperty;\n  return deprecate;\n}\n/**\n * Determine if event emitter has listeners of a given type.\n *\n * The way to do this check is done three different ways in Node.js >= 0.8\n * so this consolidates them into a minimal set using instance methods.\n *\n * @param {EventEmitter} emitter\n * @param {string} type\n * @returns {boolean}\n * @private\n */\n\n\nfunction eehaslisteners(emitter, type) {\n  var count = typeof emitter.listenerCount !== 'function' ? emitter.listeners(type).length : emitter.listenerCount(type);\n  return count > 0;\n}\n/**\n * Determine if namespace is ignored.\n */\n\n\nfunction isignored(namespace) {\n  if (process.noDeprecation) {\n    // --no-deprecation support\n    return true;\n  }\n\n  var str = process.env.NO_DEPRECATION || ''; // namespace ignored\n\n  return containsNamespace(str, namespace);\n}\n/**\n * Determine if namespace is traced.\n */\n\n\nfunction istraced(namespace) {\n  if (process.traceDeprecation) {\n    // --trace-deprecation support\n    return true;\n  }\n\n  var str = process.env.TRACE_DEPRECATION || ''; // namespace traced\n\n  return containsNamespace(str, namespace);\n}\n/**\n * Display deprecation message.\n */\n\n\nfunction log(message, site) {\n  var haslisteners = eehaslisteners(process, 'deprecation'); // abort early if no destination\n\n  if (!haslisteners && this._ignored) {\n    return;\n  }\n\n  var caller;\n  var callFile;\n  var callSite;\n  var depSite;\n  var i = 0;\n  var seen = false;\n  var stack = getStack();\n  var file = this._file;\n\n  if (site) {\n    // provided site\n    depSite = site;\n    callSite = callSiteLocation(stack[1]);\n    callSite.name = depSite.name;\n    file = callSite[0];\n  } else {\n    // get call site\n    i = 2;\n    depSite = callSiteLocation(stack[i]);\n    callSite = depSite;\n  } // get caller of deprecated thing in relation to file\n\n\n  for (; i < stack.length; i++) {\n    caller = callSiteLocation(stack[i]);\n    callFile = caller[0];\n\n    if (callFile === file) {\n      seen = true;\n    } else if (callFile === this._file) {\n      file = this._file;\n    } else if (seen) {\n      break;\n    }\n  }\n\n  var key = caller ? depSite.join(':') + '__' + caller.join(':') : undefined;\n\n  if (key !== undefined && key in this._warned) {\n    // already warned\n    return;\n  }\n\n  this._warned[key] = true; // generate automatic message from call site\n\n  var msg = message;\n\n  if (!msg) {\n    msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);\n  } // emit deprecation if listeners exist\n\n\n  if (haslisteners) {\n    var err = DeprecationError(this._namespace, msg, stack.slice(i));\n    process.emit('deprecation', err);\n    return;\n  } // format and write message\n\n\n  var format = process.stderr.isTTY ? formatColor : formatPlain;\n  var output = format.call(this, msg, caller, stack.slice(i));\n  process.stderr.write(output + '\\n', 'utf8');\n}\n/**\n * Get call site location as array.\n */\n\n\nfunction callSiteLocation(callSite) {\n  var file = callSite.getFileName() || '<anonymous>';\n  var line = callSite.getLineNumber();\n  var colm = callSite.getColumnNumber();\n\n  if (callSite.isEval()) {\n    file = callSite.getEvalOrigin() + ', ' + file;\n  }\n\n  var site = [file, line, colm];\n  site.callSite = callSite;\n  site.name = callSite.getFunctionName();\n  return site;\n}\n/**\n * Generate a default message from the site.\n */\n\n\nfunction defaultMessage(site) {\n  var callSite = site.callSite;\n  var funcName = site.name; // make useful anonymous name\n\n  if (!funcName) {\n    funcName = '<anonymous@' + formatLocation(site) + '>';\n  }\n\n  var context = callSite.getThis();\n  var typeName = context && callSite.getTypeName(); // ignore useless type name\n\n  if (typeName === 'Object') {\n    typeName = undefined;\n  } // make useful type name\n\n\n  if (typeName === 'Function') {\n    typeName = context.name || typeName;\n  }\n\n  return typeName && callSite.getMethodName() ? typeName + '.' + funcName : funcName;\n}\n/**\n * Format deprecation message without color.\n */\n\n\nfunction formatPlain(msg, caller, stack) {\n  var timestamp = new Date().toUTCString();\n  var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg; // add stack trace\n\n  if (this._traced) {\n    for (var i = 0; i < stack.length; i++) {\n      formatted += '\\n    at ' + stack[i].toString();\n    }\n\n    return formatted;\n  }\n\n  if (caller) {\n    formatted += ' at ' + formatLocation(caller);\n  }\n\n  return formatted;\n}\n/**\n * Format deprecation message with color.\n */\n\n\nfunction formatColor(msg, caller, stack) {\n  var formatted = '\\x1b[36;1m' + this._namespace + '\\x1b[22;39m' + // bold cyan\n  ' \\x1b[33;1mdeprecated\\x1b[22;39m' + // bold yellow\n  ' \\x1b[0m' + msg + '\\x1b[39m'; // reset\n  // add stack trace\n\n  if (this._traced) {\n    for (var i = 0; i < stack.length; i++) {\n      formatted += '\\n    \\x1b[36mat ' + stack[i].toString() + '\\x1b[39m'; // cyan\n    }\n\n    return formatted;\n  }\n\n  if (caller) {\n    formatted += ' \\x1b[36m' + formatLocation(caller) + '\\x1b[39m'; // cyan\n  }\n\n  return formatted;\n}\n/**\n * Format call site location.\n */\n\n\nfunction formatLocation(callSite) {\n  return relative(basePath, callSite[0]) + ':' + callSite[1] + ':' + callSite[2];\n}\n/**\n * Get the stack as array of call sites.\n */\n\n\nfunction getStack() {\n  var limit = Error.stackTraceLimit;\n  var obj = {};\n  var prep = Error.prepareStackTrace;\n  Error.prepareStackTrace = prepareObjectStackTrace;\n  Error.stackTraceLimit = Math.max(10, limit); // capture the stack\n\n  Error.captureStackTrace(obj); // slice this function off the top\n\n  var stack = obj.stack.slice(1);\n  Error.prepareStackTrace = prep;\n  Error.stackTraceLimit = limit;\n  return stack;\n}\n/**\n * Capture call site stack from v8.\n */\n\n\nfunction prepareObjectStackTrace(obj, stack) {\n  return stack;\n}\n/**\n * Return a wrapped function in a deprecation message.\n */\n\n\nfunction wrapfunction(fn, message) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('argument fn must be a function');\n  }\n\n  var args = createArgumentsString(fn.length);\n  var stack = getStack();\n  var site = callSiteLocation(stack[1]);\n  site.name = fn.name; // eslint-disable-next-line no-new-func\n\n  var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site', '\"use strict\"\\n' + 'return function (' + args + ') {' + 'log.call(deprecate, message, site)\\n' + 'return fn.apply(this, arguments)\\n' + '}')(fn, log, this, message, site);\n  return deprecatedfn;\n}\n/**\n * Wrap property in a deprecation message.\n */\n\n\nfunction wrapproperty(obj, prop, message) {\n  if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {\n    throw new TypeError('argument obj must be object');\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n\n  if (!descriptor) {\n    throw new TypeError('must call property on owner object');\n  }\n\n  if (!descriptor.configurable) {\n    throw new TypeError('property must be configurable');\n  }\n\n  var deprecate = this;\n  var stack = getStack();\n  var site = callSiteLocation(stack[1]); // set site name\n\n  site.name = prop; // convert data descriptor\n\n  if ('value' in descriptor) {\n    descriptor = convertDataDescriptorToAccessor(obj, prop, message);\n  }\n\n  var get = descriptor.get;\n  var set = descriptor.set; // wrap getter\n\n  if (typeof get === 'function') {\n    descriptor.get = function getter() {\n      log.call(deprecate, message, site);\n      return get.apply(this, arguments);\n    };\n  } // wrap setter\n\n\n  if (typeof set === 'function') {\n    descriptor.set = function setter() {\n      log.call(deprecate, message, site);\n      return set.apply(this, arguments);\n    };\n  }\n\n  Object.defineProperty(obj, prop, descriptor);\n}\n/**\n * Create DeprecationError for deprecation\n */\n\n\nfunction DeprecationError(namespace, message, stack) {\n  var error = new Error();\n  var stackString;\n  Object.defineProperty(error, 'constructor', {\n    value: DeprecationError\n  });\n  Object.defineProperty(error, 'message', {\n    configurable: true,\n    enumerable: false,\n    value: message,\n    writable: true\n  });\n  Object.defineProperty(error, 'name', {\n    enumerable: false,\n    configurable: true,\n    value: 'DeprecationError',\n    writable: true\n  });\n  Object.defineProperty(error, 'namespace', {\n    configurable: true,\n    enumerable: false,\n    value: namespace,\n    writable: true\n  });\n  Object.defineProperty(error, 'stack', {\n    configurable: true,\n    enumerable: false,\n    get: function get() {\n      if (stackString !== undefined) {\n        return stackString;\n      } // prepare stack trace\n\n\n      return stackString = createStackString.call(this, stack);\n    },\n    set: function setter(val) {\n      stackString = val;\n    }\n  });\n  return error;\n}","map":null,"metadata":{},"sourceType":"script"}