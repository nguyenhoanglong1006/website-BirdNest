{"ast":null,"code":"import _classCallCheck from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _createForOfIteratorHelper from \"/Users/nguyenlong/Project/BirdNest/client-website-BirdNest/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { HttpResponse, HttpHeaders, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { Injectable, ApplicationRef, NgModule, APP_INITIALIZER } from '@angular/core';\nimport { makeStateKey, TransferState, BrowserTransferStateModule } from '@angular/platform-browser';\nimport { of } from 'rxjs';\nimport { filter, take, tap } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/platform-browser';\n\nfunction getHeadersMap(headers) {\n  var headersMap = {};\n\n  var _iterator = _createForOfIteratorHelper(headers.keys()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      headersMap[key] = headers.getAll(key);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return headersMap;\n}\n\nvar TransferHttpCacheInterceptor = /*#__PURE__*/function () {\n  function TransferHttpCacheInterceptor(appRef, transferState) {\n    var _this = this;\n\n    _classCallCheck(this, TransferHttpCacheInterceptor);\n\n    this.transferState = transferState;\n    this.isCacheActive = true; // Stop using the cache if the application has stabilized, indicating initial rendering is\n    // complete.\n    // tslint:disable-next-line: no-floating-promises\n\n    appRef.isStable.pipe(filter(function (isStable) {\n      return isStable;\n    }), take(1)).toPromise().then(function () {\n      _this.isCacheActive = false;\n    });\n  }\n\n  return _createClass(TransferHttpCacheInterceptor, [{\n    key: \"invalidateCacheEntry\",\n    value: function invalidateCacheEntry(url) {\n      var _this2 = this;\n\n      Object.keys(this.transferState['store']).forEach(function (key) {\n        return key.includes(url) ? _this2.transferState.remove(makeStateKey(key)) : null;\n      });\n    }\n  }, {\n    key: \"makeCacheKey\",\n    value: function makeCacheKey(method, url, params) {\n      // make the params encoded same as a url so it's easy to identify\n      var encodedParams = params.keys().sort().map(function (k) {\n        return \"\".concat(k, \"=\").concat(params.getAll(k));\n      }).join('&');\n      var key = (method === 'GET' ? 'G.' : 'H.') + url + '?' + encodedParams;\n      return makeStateKey(key);\n    }\n  }, {\n    key: \"intercept\",\n    value: function intercept(req, next) {\n      var _this3 = this;\n\n      // Stop using the cache if there is a mutating call.\n      if (req.method !== 'GET' && req.method !== 'HEAD') {\n        this.isCacheActive = false;\n        this.invalidateCacheEntry(req.url);\n      }\n\n      if (!this.isCacheActive) {\n        // Cache is no longer active. Pass the request through.\n        return next.handle(req);\n      }\n\n      var storeKey = this.makeCacheKey(req.method, req.url, req.params);\n\n      if (this.transferState.hasKey(storeKey)) {\n        // Request found in cache. Respond using it.\n        var response = this.transferState.get(storeKey, {});\n        return of(new HttpResponse({\n          body: response.body,\n          headers: new HttpHeaders(response.headers),\n          status: response.status,\n          statusText: response.statusText,\n          url: response.url\n        }));\n      } else {\n        // Request not found in cache. Make the request and cache it.\n        var httpEvent = next.handle(req);\n        return httpEvent.pipe(tap(function (event) {\n          if (event instanceof HttpResponse) {\n            _this3.transferState.set(storeKey, {\n              body: event.body,\n              headers: getHeadersMap(event.headers),\n              status: event.status,\n              statusText: event.statusText,\n              url: event.url || ''\n            });\n          }\n        }));\n      }\n    }\n  }]);\n}();\n\nTransferHttpCacheInterceptor.ɵfac = function TransferHttpCacheInterceptor_Factory(t) {\n  return new (t || TransferHttpCacheInterceptor)(ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc1.TransferState));\n};\n\nTransferHttpCacheInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: TransferHttpCacheInterceptor,\n  factory: TransferHttpCacheInterceptor.ɵfac\n});\n\nTransferHttpCacheInterceptor.ctorParameters = function () {\n  return [{\n    type: ApplicationRef\n  }, {\n    type: TransferState\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TransferHttpCacheInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ɵngcc0.ApplicationRef\n    }, {\n      type: ɵngcc1.TransferState\n    }];\n  }, null);\n})();\n/**\n * An NgModule used in conjunction with `ServerTransferHttpCacheModule` to transfer cached HTTP\n * calls from the server to the client application.\n */\n\n\nvar TransferHttpCacheModule = /*#__PURE__*/_createClass(function TransferHttpCacheModule() {\n  _classCallCheck(this, TransferHttpCacheModule);\n});\n\nTransferHttpCacheModule.ɵfac = function TransferHttpCacheModule_Factory(t) {\n  return new (t || TransferHttpCacheModule)();\n};\n\nTransferHttpCacheModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: TransferHttpCacheModule\n});\nTransferHttpCacheModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  providers: [TransferHttpCacheInterceptor, {\n    provide: HTTP_INTERCEPTORS,\n    useExisting: TransferHttpCacheInterceptor,\n    multi: true\n  }],\n  imports: [[BrowserTransferStateModule]]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TransferHttpCacheModule, {\n    imports: function imports() {\n      return [BrowserTransferStateModule];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TransferHttpCacheModule, [{\n    type: NgModule,\n    args: [{\n      imports: [BrowserTransferStateModule],\n      providers: [TransferHttpCacheInterceptor, {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: TransferHttpCacheInterceptor,\n        multi: true\n      }]\n    }]\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction domContentLoadedFactory(doc) {\n  return function () {\n    return new Promise(function (resolve, _reject) {\n      if (doc.readyState === 'complete' || doc.readyState === 'interactive') {\n        resolve();\n        return;\n      }\n\n      var _contentLoaded = function contentLoaded() {\n        doc.removeEventListener('DOMContentLoaded', _contentLoaded);\n        resolve();\n      };\n\n      doc.addEventListener('DOMContentLoaded', _contentLoaded);\n    });\n  };\n}\n\nvar StateTransferInitializerModule = /*#__PURE__*/_createClass(function StateTransferInitializerModule() {\n  _classCallCheck(this, StateTransferInitializerModule);\n});\n\nStateTransferInitializerModule.ɵfac = function StateTransferInitializerModule_Factory(t) {\n  return new (t || StateTransferInitializerModule)();\n};\n\nStateTransferInitializerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: StateTransferInitializerModule\n});\nStateTransferInitializerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  providers: [{\n    provide: APP_INITIALIZER,\n    multi: true,\n    useFactory: domContentLoadedFactory,\n    deps: [DOCUMENT]\n  }]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StateTransferInitializerModule, [{\n    type: NgModule,\n    args: [{\n      providers: [{\n        provide: APP_INITIALIZER,\n        multi: true,\n        useFactory: domContentLoadedFactory,\n        deps: [DOCUMENT]\n      }]\n    }]\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { StateTransferInitializerModule, TransferHttpCacheModule, TransferHttpCacheInterceptor as ɵTransferHttpCacheInterceptor, domContentLoadedFactory as ɵnguniversal_modules_common_common_a }; //# sourceMappingURL=common.js.map","map":null,"metadata":{},"sourceType":"module"}