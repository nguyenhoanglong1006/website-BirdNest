{"ast":null,"code":"\"use strict\";\n\nmodule.exports = FilteredElementList;\n\nvar Node = require('./Node'); //\n// This file defines node list implementation that lazily traverses\n// the document tree (or a subtree rooted at any element) and includes\n// only those elements for which a specified filter function returns true.\n// It is used to implement the\n// {Document,Element}.getElementsBy{TagName,ClassName}{,NS} methods.\n//\n// XXX this should inherit from NodeList\n\n\nfunction FilteredElementList(root, filter) {\n  this.root = root;\n  this.filter = filter;\n  this.lastModTime = root.lastModTime;\n  this.done = false;\n  this.cache = [];\n  this.traverse();\n}\n\nFilteredElementList.prototype = Object.create(Object.prototype, {\n  length: {\n    get: function get() {\n      this.checkcache();\n      if (!this.done) this.traverse();\n      return this.cache.length;\n    }\n  },\n  item: {\n    value: function value(n) {\n      this.checkcache();\n\n      if (!this.done && n >= this.cache.length) {\n        // This can lead to O(N^2) behavior if we stop when we get to n\n        // and the caller is iterating through the items in order; so\n        // be sure to do the full traverse here.\n        this.traverse();\n      }\n\n      return this.cache[n];\n    }\n  },\n  checkcache: {\n    value: function value() {\n      if (this.lastModTime !== this.root.lastModTime) {\n        // subtree has changed, so invalidate cache\n        for (var i = this.cache.length - 1; i >= 0; i--) {\n          this[i] = undefined;\n        }\n\n        this.cache.length = 0;\n        this.done = false;\n        this.lastModTime = this.root.lastModTime;\n      }\n    }\n  },\n  // If n is specified, then traverse the tree until we've found the nth\n  // item (or until we've found all items).  If n is not specified,\n  // traverse until we've found all items.\n  traverse: {\n    value: function value(n) {\n      // increment n so we can compare to length, and so it is never falsy\n      if (n !== undefined) n++;\n      var elt;\n\n      while ((elt = this.next()) !== null) {\n        this[this.cache.length] = elt; //XXX Use proxy instead\n\n        this.cache.push(elt);\n        if (n && this.cache.length === n) return;\n      } // no next element, so we've found everything\n\n\n      this.done = true;\n    }\n  },\n  // Return the next element under root that matches filter\n  next: {\n    value: function value() {\n      var start = this.cache.length === 0 ? this.root // Start at the root or at\n      : this.cache[this.cache.length - 1]; // the last element we found\n\n      var elt;\n      if (start.nodeType === Node.DOCUMENT_NODE) elt = start.documentElement;else elt = start.nextElement(this.root);\n\n      while (elt) {\n        if (this.filter(elt)) {\n          return elt;\n        }\n\n        elt = elt.nextElement(this.root);\n      }\n\n      return null;\n    }\n  }\n});","map":null,"metadata":{},"sourceType":"script"}