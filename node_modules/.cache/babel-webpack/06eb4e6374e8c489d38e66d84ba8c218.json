{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Node;\n\nvar EventTarget = require('./EventTarget');\n\nvar LinkedList = require('./LinkedList');\n\nvar NodeUtils = require('./NodeUtils');\n\nvar utils = require('./utils'); // All nodes have a nodeType and an ownerDocument.\n// Once inserted, they also have a parentNode.\n// This is an abstract class; all nodes in a document are instances\n// of a subtype, so all the properties are defined by more specific\n// constructors.\n\n\nfunction Node() {\n  EventTarget.call(this);\n  this.parentNode = null;\n  this._nextSibling = this._previousSibling = this;\n  this._index = undefined;\n}\n\nvar ELEMENT_NODE = Node.ELEMENT_NODE = 1;\nvar ATTRIBUTE_NODE = Node.ATTRIBUTE_NODE = 2;\nvar TEXT_NODE = Node.TEXT_NODE = 3;\nvar CDATA_SECTION_NODE = Node.CDATA_SECTION_NODE = 4;\nvar ENTITY_REFERENCE_NODE = Node.ENTITY_REFERENCE_NODE = 5;\nvar ENTITY_NODE = Node.ENTITY_NODE = 6;\nvar PROCESSING_INSTRUCTION_NODE = Node.PROCESSING_INSTRUCTION_NODE = 7;\nvar COMMENT_NODE = Node.COMMENT_NODE = 8;\nvar DOCUMENT_NODE = Node.DOCUMENT_NODE = 9;\nvar DOCUMENT_TYPE_NODE = Node.DOCUMENT_TYPE_NODE = 10;\nvar DOCUMENT_FRAGMENT_NODE = Node.DOCUMENT_FRAGMENT_NODE = 11;\nvar NOTATION_NODE = Node.NOTATION_NODE = 12;\nvar DOCUMENT_POSITION_DISCONNECTED = Node.DOCUMENT_POSITION_DISCONNECTED = 0x01;\nvar DOCUMENT_POSITION_PRECEDING = Node.DOCUMENT_POSITION_PRECEDING = 0x02;\nvar DOCUMENT_POSITION_FOLLOWING = Node.DOCUMENT_POSITION_FOLLOWING = 0x04;\nvar DOCUMENT_POSITION_CONTAINS = Node.DOCUMENT_POSITION_CONTAINS = 0x08;\nvar DOCUMENT_POSITION_CONTAINED_BY = Node.DOCUMENT_POSITION_CONTAINED_BY = 0x10;\nvar DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;\nNode.prototype = Object.create(EventTarget.prototype, {\n  // Node that are not inserted into the tree inherit a null parent\n  // XXX: the baseURI attribute is defined by dom core, but\n  // a correct implementation of it requires HTML features, so\n  // we'll come back to this later.\n  baseURI: {\n    get: utils.nyi\n  },\n  parentElement: {\n    get: function get() {\n      return this.parentNode && this.parentNode.nodeType === ELEMENT_NODE ? this.parentNode : null;\n    }\n  },\n  hasChildNodes: {\n    value: utils.shouldOverride\n  },\n  firstChild: {\n    get: utils.shouldOverride\n  },\n  lastChild: {\n    get: utils.shouldOverride\n  },\n  previousSibling: {\n    get: function get() {\n      var parent = this.parentNode;\n      if (!parent) return null;\n      if (this === parent.firstChild) return null;\n      return this._previousSibling;\n    }\n  },\n  nextSibling: {\n    get: function get() {\n      var parent = this.parentNode,\n          next = this._nextSibling;\n      if (!parent) return null;\n      if (next === parent.firstChild) return null;\n      return next;\n    }\n  },\n  textContent: {\n    // Should override for DocumentFragment/Element/Attr/Text/PI/Comment\n    get: function get() {\n      return null;\n    },\n    set: function set(v) {\n      /* do nothing */\n    }\n  },\n  _countChildrenOfType: {\n    value: function value(type) {\n      var sum = 0;\n\n      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n        if (kid.nodeType === type) sum++;\n      }\n\n      return sum;\n    }\n  },\n  _ensureInsertValid: {\n    value: function _ensureInsertValid(node, child, isPreinsert) {\n      var parent = this,\n          i,\n          kid;\n      if (!node.nodeType) throw new TypeError('not a node'); // 1. If parent is not a Document, DocumentFragment, or Element\n      // node, throw a HierarchyRequestError.\n\n      switch (parent.nodeType) {\n        case DOCUMENT_NODE:\n        case DOCUMENT_FRAGMENT_NODE:\n        case ELEMENT_NODE:\n          break;\n\n        default:\n          utils.HierarchyRequestError();\n      } // 2. If node is a host-including inclusive ancestor of parent,\n      // throw a HierarchyRequestError.\n\n\n      if (node.isAncestor(parent)) utils.HierarchyRequestError(); // 3. If child is not null and its parent is not parent, then\n      // throw a NotFoundError. (replaceChild omits the 'child is not null'\n      // and throws a TypeError here if child is null.)\n\n      if (child !== null || !isPreinsert) {\n        if (child.parentNode !== parent) utils.NotFoundError();\n      } // 4. If node is not a DocumentFragment, DocumentType, Element,\n      // Text, ProcessingInstruction, or Comment node, throw a\n      // HierarchyRequestError.\n\n\n      switch (node.nodeType) {\n        case DOCUMENT_FRAGMENT_NODE:\n        case DOCUMENT_TYPE_NODE:\n        case ELEMENT_NODE:\n        case TEXT_NODE:\n        case PROCESSING_INSTRUCTION_NODE:\n        case COMMENT_NODE:\n          break;\n\n        default:\n          utils.HierarchyRequestError();\n      } // 5. If either node is a Text node and parent is a document, or\n      // node is a doctype and parent is not a document, throw a\n      // HierarchyRequestError.\n      // 6. If parent is a document, and any of the statements below, switched\n      // on node, are true, throw a HierarchyRequestError.\n\n\n      if (parent.nodeType === DOCUMENT_NODE) {\n        switch (node.nodeType) {\n          case TEXT_NODE:\n            utils.HierarchyRequestError();\n            break;\n\n          case DOCUMENT_FRAGMENT_NODE:\n            // 6a1. If node has more than one element child or has a Text\n            // node child.\n            if (node._countChildrenOfType(TEXT_NODE) > 0) utils.HierarchyRequestError();\n\n            switch (node._countChildrenOfType(ELEMENT_NODE)) {\n              case 0:\n                break;\n\n              case 1:\n                // 6a2. Otherwise, if node has one element child and either\n                // parent has an element child, child is a doctype, or child\n                // is not null and a doctype is following child. [preinsert]\n                // 6a2. Otherwise, if node has one element child and either\n                // parent has an element child that is not child or a\n                // doctype is following child. [replaceWith]\n                if (child !== null\n                /* always true here for replaceWith */\n                ) {\n                  if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();\n\n                  for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {\n                    if (kid.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();\n                  }\n                }\n\n                i = parent._countChildrenOfType(ELEMENT_NODE);\n\n                if (isPreinsert) {\n                  // \"parent has an element child\"\n                  if (i > 0) utils.HierarchyRequestError();\n                } else {\n                  // \"parent has an element child that is not child\"\n                  if (i > 1 || i === 1 && child.nodeType !== ELEMENT_NODE) utils.HierarchyRequestError();\n                }\n\n                break;\n\n              default:\n                // 6a1, continued. (more than one Element child)\n                utils.HierarchyRequestError();\n            }\n\n            break;\n\n          case ELEMENT_NODE:\n            // 6b. parent has an element child, child is a doctype, or\n            // child is not null and a doctype is following child. [preinsert]\n            // 6b. parent has an element child that is not child or a\n            // doctype is following child. [replaceWith]\n            if (child !== null\n            /* always true here for replaceWith */\n            ) {\n              if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();\n\n              for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {\n                if (kid.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();\n              }\n            }\n\n            i = parent._countChildrenOfType(ELEMENT_NODE);\n\n            if (isPreinsert) {\n              // \"parent has an element child\"\n              if (i > 0) utils.HierarchyRequestError();\n            } else {\n              // \"parent has an element child that is not child\"\n              if (i > 1 || i === 1 && child.nodeType !== ELEMENT_NODE) utils.HierarchyRequestError();\n            }\n\n            break;\n\n          case DOCUMENT_TYPE_NODE:\n            // 6c. parent has a doctype child, child is non-null and an\n            // element is preceding child, or child is null and parent has\n            // an element child. [preinsert]\n            // 6c. parent has a doctype child that is not child, or an\n            // element is preceding child. [replaceWith]\n            if (child === null) {\n              if (parent._countChildrenOfType(ELEMENT_NODE)) utils.HierarchyRequestError();\n            } else {\n              // child is always non-null for [replaceWith] case\n              for (kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {\n                if (kid === child) break;\n                if (kid.nodeType === ELEMENT_NODE) utils.HierarchyRequestError();\n              }\n            }\n\n            i = parent._countChildrenOfType(DOCUMENT_TYPE_NODE);\n\n            if (isPreinsert) {\n              // \"parent has an doctype child\"\n              if (i > 0) utils.HierarchyRequestError();\n            } else {\n              // \"parent has an doctype child that is not child\"\n              if (i > 1 || i === 1 && child.nodeType !== DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();\n            }\n\n            break;\n        }\n      } else {\n        // 5, continued: (parent is not a document)\n        if (node.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();\n      }\n    }\n  },\n  insertBefore: {\n    value: function insertBefore(node, child) {\n      var parent = this; // 1. Ensure pre-insertion validity\n\n      parent._ensureInsertValid(node, child, true); // 2. Let reference child be child.\n\n\n      var refChild = child; // 3. If reference child is node, set it to node's next sibling\n\n      if (refChild === node) {\n        refChild = node.nextSibling;\n      } // 4. Adopt node into parent's node document.\n\n\n      parent.doc.adoptNode(node); // 5. Insert node into parent before reference child.\n\n      node._insertOrReplace(parent, refChild, false); // 6. Return node\n\n\n      return node;\n    }\n  },\n  appendChild: {\n    value: function value(child) {\n      // This invokes _appendChild after doing validity checks.\n      return this.insertBefore(child, null);\n    }\n  },\n  _appendChild: {\n    value: function value(child) {\n      child._insertOrReplace(this, null, false);\n    }\n  },\n  removeChild: {\n    value: function removeChild(child) {\n      var parent = this;\n      if (!child.nodeType) throw new TypeError('not a node');\n      if (child.parentNode !== parent) utils.NotFoundError();\n      child.remove();\n      return child;\n    }\n  },\n  // To replace a `child` with `node` within a `parent` (this)\n  replaceChild: {\n    value: function replaceChild(node, child) {\n      var parent = this; // Ensure validity (slight differences from pre-insertion check)\n\n      parent._ensureInsertValid(node, child, false); // Adopt node into parent's node document.\n\n\n      if (node.doc !== parent.doc) {\n        // XXX adoptNode has side-effect of removing node from its parent\n        // and generating a mutation event, thus causing the _insertOrReplace\n        // to generate two deletes and an insert instead of a 'move'\n        // event.  It looks like the new MutationObserver stuff avoids\n        // this problem, but for now let's only adopt (ie, remove `node`\n        // from its parent) here if we need to.\n        parent.doc.adoptNode(node);\n      } // Do the replace.\n\n\n      node._insertOrReplace(parent, child, true);\n\n      return child;\n    }\n  },\n  // See: http://ejohn.org/blog/comparing-document-position/\n  contains: {\n    value: function contains(node) {\n      if (node === null) {\n        return false;\n      }\n\n      if (this === node) {\n        return true;\n        /* inclusive descendant */\n      }\n      /* jshint bitwise: false */\n\n\n      return (this.compareDocumentPosition(node) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;\n    }\n  },\n  compareDocumentPosition: {\n    value: function compareDocumentPosition(that) {\n      // Basic algorithm for finding the relative position of two nodes.\n      // Make a list the ancestors of each node, starting with the\n      // document element and proceeding down to the nodes themselves.\n      // Then, loop through the lists, looking for the first element\n      // that differs.  The order of those two elements give the\n      // order of their descendant nodes.  Or, if one list is a prefix\n      // of the other one, then that node contains the other.\n      if (this === that) return 0; // If they're not owned by the same document or if one is rooted\n      // and one is not, then they're disconnected.\n\n      if (this.doc !== that.doc || this.rooted !== that.rooted) return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC; // Get arrays of ancestors for this and that\n\n      var these = [],\n          those = [];\n\n      for (var n = this; n !== null; n = n.parentNode) these.push(n);\n\n      for (n = that; n !== null; n = n.parentNode) those.push(n);\n\n      these.reverse(); // So we start with the outermost\n\n      those.reverse();\n      if (these[0] !== those[0]) // No common ancestor\n        return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;\n      n = Math.min(these.length, those.length);\n\n      for (var i = 1; i < n; i++) {\n        if (these[i] !== those[i]) {\n          // We found two different ancestors, so compare\n          // their positions\n          if (these[i].index < those[i].index) return DOCUMENT_POSITION_FOLLOWING;else return DOCUMENT_POSITION_PRECEDING;\n        }\n      } // If we get to here, then one of the nodes (the one with the\n      // shorter list of ancestors) contains the other one.\n\n\n      if (these.length < those.length) return DOCUMENT_POSITION_FOLLOWING + DOCUMENT_POSITION_CONTAINED_BY;else return DOCUMENT_POSITION_PRECEDING + DOCUMENT_POSITION_CONTAINS;\n    }\n  },\n  isSameNode: {\n    value: function isSameNode(node) {\n      return this === node;\n    }\n  },\n  // This method implements the generic parts of node equality testing\n  // and defers to the (non-recursive) type-specific isEqual() method\n  // defined by subclasses\n  isEqualNode: {\n    value: function isEqualNode(node) {\n      if (!node) return false;\n      if (node.nodeType !== this.nodeType) return false; // Check type-specific properties for equality\n\n      if (!this.isEqual(node)) return false; // Now check children for number and equality\n\n      for (var c1 = this.firstChild, c2 = node.firstChild; c1 && c2; c1 = c1.nextSibling, c2 = c2.nextSibling) {\n        if (!c1.isEqualNode(c2)) return false;\n      }\n\n      return c1 === null && c2 === null;\n    }\n  },\n  // This method delegates shallow cloning to a clone() method\n  // that each concrete subclass must implement\n  cloneNode: {\n    value: function value(deep) {\n      // Clone this node\n      var clone = this.clone(); // Handle the recursive case if necessary\n\n      if (deep) {\n        for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n          clone._appendChild(kid.cloneNode(true));\n        }\n      }\n\n      return clone;\n    }\n  },\n  lookupPrefix: {\n    value: function lookupPrefix(ns) {\n      var e;\n      if (ns === '' || ns === null || ns === undefined) return null;\n\n      switch (this.nodeType) {\n        case ELEMENT_NODE:\n          return this._lookupNamespacePrefix(ns, this);\n\n        case DOCUMENT_NODE:\n          e = this.documentElement;\n          return e ? e.lookupPrefix(ns) : null;\n\n        case ENTITY_NODE:\n        case NOTATION_NODE:\n        case DOCUMENT_FRAGMENT_NODE:\n        case DOCUMENT_TYPE_NODE:\n          return null;\n\n        case ATTRIBUTE_NODE:\n          e = this.ownerElement;\n          return e ? e.lookupPrefix(ns) : null;\n\n        default:\n          e = this.parentElement;\n          return e ? e.lookupPrefix(ns) : null;\n      }\n    }\n  },\n  lookupNamespaceURI: {\n    value: function lookupNamespaceURI(prefix) {\n      if (prefix === '' || prefix === undefined) {\n        prefix = null;\n      }\n\n      var e;\n\n      switch (this.nodeType) {\n        case ELEMENT_NODE:\n          return utils.shouldOverride();\n\n        case DOCUMENT_NODE:\n          e = this.documentElement;\n          return e ? e.lookupNamespaceURI(prefix) : null;\n\n        case ENTITY_NODE:\n        case NOTATION_NODE:\n        case DOCUMENT_TYPE_NODE:\n        case DOCUMENT_FRAGMENT_NODE:\n          return null;\n\n        case ATTRIBUTE_NODE:\n          e = this.ownerElement;\n          return e ? e.lookupNamespaceURI(prefix) : null;\n\n        default:\n          e = this.parentElement;\n          return e ? e.lookupNamespaceURI(prefix) : null;\n      }\n    }\n  },\n  isDefaultNamespace: {\n    value: function isDefaultNamespace(ns) {\n      if (ns === '' || ns === undefined) {\n        ns = null;\n      }\n\n      var defaultNamespace = this.lookupNamespaceURI(null);\n      return defaultNamespace === ns;\n    }\n  },\n  // Utility methods for nodes.  Not part of the DOM\n  // Return the index of this node in its parent.\n  // Throw if no parent, or if this node is not a child of its parent\n  index: {\n    get: function get() {\n      var parent = this.parentNode;\n      if (this === parent.firstChild) return 0; // fast case\n\n      var kids = parent.childNodes;\n\n      if (this._index === undefined || kids[this._index] !== this) {\n        // Ensure that we don't have an O(N^2) blowup if none of the\n        // kids have defined indices yet and we're traversing via\n        // nextSibling or previousSibling\n        for (var i = 0; i < kids.length; i++) {\n          kids[i]._index = i;\n        }\n\n        utils.assert(kids[this._index] === this);\n      }\n\n      return this._index;\n    }\n  },\n  // Return true if this node is equal to or is an ancestor of that node\n  // Note that nodes are considered to be ancestors of themselves\n  isAncestor: {\n    value: function value(that) {\n      // If they belong to different documents, then they're unrelated.\n      if (this.doc !== that.doc) return false; // If one is rooted and one isn't then they're not related\n\n      if (this.rooted !== that.rooted) return false; // Otherwise check by traversing the parentNode chain\n\n      for (var e = that; e; e = e.parentNode) {\n        if (e === this) return true;\n      }\n\n      return false;\n    }\n  },\n  // DOMINO Changed the behavior to conform with the specs. See:\n  // https://groups.google.com/d/topic/mozilla.dev.platform/77sIYcpdDmc/discussion\n  ensureSameDoc: {\n    value: function value(that) {\n      if (that.ownerDocument === null) {\n        that.ownerDocument = this.doc;\n      } else if (that.ownerDocument !== this.doc) {\n        utils.WrongDocumentError();\n      }\n    }\n  },\n  removeChildren: {\n    value: utils.shouldOverride\n  },\n  // Insert this node as a child of parent before the specified child,\n  // or insert as the last child of parent if specified child is null,\n  // or replace the specified child with this node, firing mutation events as\n  // necessary\n  _insertOrReplace: {\n    value: function _insertOrReplace(parent, before, isReplace) {\n      var child = this,\n          before_index,\n          i;\n\n      if (child.nodeType === DOCUMENT_FRAGMENT_NODE && child.rooted) {\n        utils.HierarchyRequestError();\n      }\n      /* Ensure index of `before` is cached before we (possibly) remove it. */\n\n\n      if (parent._childNodes) {\n        before_index = before === null ? parent._childNodes.length : before.index;\n        /* ensure _index is cached */\n        // If we are already a child of the specified parent, then\n        // the index may have to be adjusted.\n\n        if (child.parentNode === parent) {\n          var child_index = child.index; // If the child is before the spot it is to be inserted at,\n          // then when it is removed, the index of that spot will be\n          // reduced.\n\n          if (child_index < before_index) {\n            before_index--;\n          }\n        }\n      } // Delete the old child\n\n\n      if (isReplace) {\n        if (before.rooted) before.doc.mutateRemove(before);\n        before.parentNode = null;\n      }\n\n      var n = before;\n\n      if (n === null) {\n        n = parent.firstChild;\n      } // If both the child and the parent are rooted, then we want to\n      // transplant the child without uprooting and rerooting it.\n\n\n      var bothRooted = child.rooted && parent.rooted;\n\n      if (child.nodeType === DOCUMENT_FRAGMENT_NODE) {\n        var spliceArgs = [0, isReplace ? 1 : 0],\n            next;\n\n        for (var kid = child.firstChild; kid !== null; kid = next) {\n          next = kid.nextSibling;\n          spliceArgs.push(kid);\n          kid.parentNode = parent;\n        }\n\n        var len = spliceArgs.length; // Add all nodes to the new parent, overwriting the old child\n\n        if (isReplace) {\n          LinkedList.replace(n, len > 2 ? spliceArgs[2] : null);\n        } else if (len > 2 && n !== null) {\n          LinkedList.insertBefore(spliceArgs[2], n);\n        }\n\n        if (parent._childNodes) {\n          spliceArgs[0] = before === null ? parent._childNodes.length : before._index;\n\n          parent._childNodes.splice.apply(parent._childNodes, spliceArgs);\n\n          for (i = 2; i < len; i++) {\n            spliceArgs[i]._index = spliceArgs[0] + (i - 2);\n          }\n        } else if (parent._firstChild === before) {\n          if (len > 2) {\n            parent._firstChild = spliceArgs[2];\n          } else if (isReplace) {\n            parent._firstChild = null;\n          }\n        } // Remove all nodes from the document fragment\n\n\n        if (child._childNodes) {\n          child._childNodes.length = 0;\n        } else {\n          child._firstChild = null;\n        } // Call the mutation handlers\n        // Use spliceArgs since the original array has been destroyed. The\n        // liveness guarantee requires us to clone the array so that\n        // references to the childNodes of the DocumentFragment will be empty\n        // when the insertion handlers are called.\n\n\n        if (parent.rooted) {\n          parent.modify();\n\n          for (i = 2; i < len; i++) {\n            parent.doc.mutateInsert(spliceArgs[i]);\n          }\n        }\n      } else {\n        if (before === child) {\n          return;\n        }\n\n        if (bothRooted) {\n          // Remove the child from its current position in the tree\n          // without calling remove(), since we don't want to uproot it.\n          child._remove();\n        } else if (child.parentNode) {\n          child.remove();\n        } // Insert it as a child of its new parent\n\n\n        child.parentNode = parent;\n\n        if (isReplace) {\n          LinkedList.replace(n, child);\n\n          if (parent._childNodes) {\n            child._index = before_index;\n            parent._childNodes[before_index] = child;\n          } else if (parent._firstChild === before) {\n            parent._firstChild = child;\n          }\n        } else {\n          if (n !== null) {\n            LinkedList.insertBefore(child, n);\n          }\n\n          if (parent._childNodes) {\n            child._index = before_index;\n\n            parent._childNodes.splice(before_index, 0, child);\n          } else if (parent._firstChild === before) {\n            parent._firstChild = child;\n          }\n        }\n\n        if (bothRooted) {\n          parent.modify(); // Generate a move mutation event\n\n          parent.doc.mutateMove(child);\n        } else if (parent.rooted) {\n          parent.modify();\n          parent.doc.mutateInsert(child);\n        }\n      }\n    }\n  },\n  // Return the lastModTime value for this node. (For use as a\n  // cache invalidation mechanism. If the node does not already\n  // have one, initialize it from the owner document's modclock\n  // property. (Note that modclock does not return the actual\n  // time; it is simply a counter incremented on each document\n  // modification)\n  lastModTime: {\n    get: function get() {\n      if (!this._lastModTime) {\n        this._lastModTime = this.doc.modclock;\n      }\n\n      return this._lastModTime;\n    }\n  },\n  // Increment the owner document's modclock and use the new\n  // value to update the lastModTime value for this node and\n  // all of its ancestors. Nodes that have never had their\n  // lastModTime value queried do not need to have a\n  // lastModTime property set on them since there is no\n  // previously queried value to ever compare the new value\n  // against, so only update nodes that already have a\n  // _lastModTime property.\n  modify: {\n    value: function value() {\n      if (this.doc.modclock) {\n        // Skip while doc.modclock == 0\n        var time = ++this.doc.modclock;\n\n        for (var n = this; n; n = n.parentElement) {\n          if (n._lastModTime) {\n            n._lastModTime = time;\n          }\n        }\n      }\n    }\n  },\n  // This attribute is not part of the DOM but is quite helpful.\n  // It returns the document with which a node is associated.  Usually\n  // this is the ownerDocument. But ownerDocument is null for the\n  // document object itself, so this is a handy way to get the document\n  // regardless of the node type\n  doc: {\n    get: function get() {\n      return this.ownerDocument || this;\n    }\n  },\n  // If the node has a nid (node id), then it is rooted in a document\n  rooted: {\n    get: function get() {\n      return !!this._nid;\n    }\n  },\n  normalize: {\n    value: function value() {\n      var next;\n\n      for (var child = this.firstChild; child !== null; child = next) {\n        next = child.nextSibling;\n\n        if (child.normalize) {\n          child.normalize();\n        }\n\n        if (child.nodeType !== Node.TEXT_NODE) {\n          continue;\n        }\n\n        if (child.nodeValue === \"\") {\n          this.removeChild(child);\n          continue;\n        }\n\n        var prevChild = child.previousSibling;\n\n        if (prevChild === null) {\n          continue;\n        } else if (prevChild.nodeType === Node.TEXT_NODE) {\n          // merge this with previous and remove the child\n          prevChild.appendData(child.nodeValue);\n          this.removeChild(child);\n        }\n      }\n    }\n  },\n  // Convert the children of a node to an HTML string.\n  // This is used by the innerHTML getter\n  // The serialization spec is at:\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#serializing-html-fragments\n  //\n  // The serialization logic is intentionally implemented in a separate\n  // `NodeUtils` helper instead of the more obvious choice of a private\n  // `_serializeOne()` method on the `Node.prototype` in order to avoid\n  // the megamorphic `this._serializeOne` property access, which reduces\n  // performance unnecessarily. If you need specialized behavior for a\n  // certain subclass, you'll need to implement that in `NodeUtils`.\n  // See https://github.com/fgnass/domino/pull/142 for more information.\n  serialize: {\n    value: function value() {\n      var s = '';\n\n      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n        s += NodeUtils.serializeOne(kid, this);\n      }\n\n      return s;\n    }\n  },\n  // Non-standard, but often useful for debugging.\n  outerHTML: {\n    get: function get() {\n      return NodeUtils.serializeOne(this, {\n        nodeType: 0\n      });\n    },\n    set: utils.nyi\n  },\n  // mirror node type properties in the prototype, so they are present\n  // in instances of Node (and subclasses)\n  ELEMENT_NODE: {\n    value: ELEMENT_NODE\n  },\n  ATTRIBUTE_NODE: {\n    value: ATTRIBUTE_NODE\n  },\n  TEXT_NODE: {\n    value: TEXT_NODE\n  },\n  CDATA_SECTION_NODE: {\n    value: CDATA_SECTION_NODE\n  },\n  ENTITY_REFERENCE_NODE: {\n    value: ENTITY_REFERENCE_NODE\n  },\n  ENTITY_NODE: {\n    value: ENTITY_NODE\n  },\n  PROCESSING_INSTRUCTION_NODE: {\n    value: PROCESSING_INSTRUCTION_NODE\n  },\n  COMMENT_NODE: {\n    value: COMMENT_NODE\n  },\n  DOCUMENT_NODE: {\n    value: DOCUMENT_NODE\n  },\n  DOCUMENT_TYPE_NODE: {\n    value: DOCUMENT_TYPE_NODE\n  },\n  DOCUMENT_FRAGMENT_NODE: {\n    value: DOCUMENT_FRAGMENT_NODE\n  },\n  NOTATION_NODE: {\n    value: NOTATION_NODE\n  },\n  DOCUMENT_POSITION_DISCONNECTED: {\n    value: DOCUMENT_POSITION_DISCONNECTED\n  },\n  DOCUMENT_POSITION_PRECEDING: {\n    value: DOCUMENT_POSITION_PRECEDING\n  },\n  DOCUMENT_POSITION_FOLLOWING: {\n    value: DOCUMENT_POSITION_FOLLOWING\n  },\n  DOCUMENT_POSITION_CONTAINS: {\n    value: DOCUMENT_POSITION_CONTAINS\n  },\n  DOCUMENT_POSITION_CONTAINED_BY: {\n    value: DOCUMENT_POSITION_CONTAINED_BY\n  },\n  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: {\n    value: DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\n  }\n});","map":null,"metadata":{},"sourceType":"script"}