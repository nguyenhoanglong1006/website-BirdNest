{"ast":null,"code":"\"use strict\";\n/* jshint eqnull: true */\n\n/**\n * Zest (https://github.com/chjj/zest)\n * A css selector engine.\n * Copyright (c) 2011-2012, Christopher Jeffrey. (MIT Licensed)\n * Domino version based on Zest v0.1.3 with bugfixes applied.\n */\n\n/**\n * Helpers\n */\n\nvar window = Object.create(null, {\n  location: {\n    get: function get() {\n      throw new Error('window.location is not supported.');\n    }\n  }\n});\n\nvar compareDocumentPosition = function compareDocumentPosition(a, b) {\n  return a.compareDocumentPosition(b);\n};\n\nvar order = function order(a, b) {\n  /* jshint bitwise: false */\n  return compareDocumentPosition(a, b) & 2 ? 1 : -1;\n};\n\nvar next = function next(el) {\n  while ((el = el.nextSibling) && el.nodeType !== 1);\n\n  return el;\n};\n\nvar prev = function prev(el) {\n  while ((el = el.previousSibling) && el.nodeType !== 1);\n\n  return el;\n};\n\nvar child = function child(el) {\n  /*jshint -W084 */\n  if (el = el.firstChild) {\n    while (el.nodeType !== 1 && (el = el.nextSibling));\n  }\n\n  return el;\n};\n\nvar lastChild = function lastChild(el) {\n  /*jshint -W084 */\n  if (el = el.lastChild) {\n    while (el.nodeType !== 1 && (el = el.previousSibling));\n  }\n\n  return el;\n};\n\nvar parentIsElement = function parentIsElement(n) {\n  if (!n.parentNode) {\n    return false;\n  }\n\n  var nodeType = n.parentNode.nodeType; // The root `html` element can be a first- or last-child, too.\n\n  return nodeType === 1 || nodeType === 9;\n};\n\nvar unquote = function unquote(str) {\n  if (!str) return str;\n  var ch = str[0];\n\n  if (ch === '\"' || ch === '\\'') {\n    if (str[str.length - 1] === ch) {\n      str = str.slice(1, -1);\n    } else {\n      // bad string.\n      str = str.slice(1);\n    }\n\n    return str.replace(rules.str_escape, function (s) {\n      var m = /^\\\\(?:([0-9A-Fa-f]+)|([\\r\\n\\f]+))/.exec(s);\n\n      if (!m) {\n        return s.slice(1);\n      }\n\n      if (m[2]) {\n        return '';\n        /* escaped newlines are ignored in strings. */\n      }\n\n      var cp = parseInt(m[1], 16);\n      return String.fromCodePoint ? String.fromCodePoint(cp) : // Not all JavaScript implementations have String.fromCodePoint yet.\n      String.fromCharCode(cp);\n    });\n  } else if (rules.ident.test(str)) {\n    return decodeid(str);\n  } else {\n    // NUMBER, PERCENTAGE, DIMENSION, etc\n    return str;\n  }\n};\n\nvar decodeid = function decodeid(str) {\n  return str.replace(rules.escape, function (s) {\n    var m = /^\\\\([0-9A-Fa-f]+)/.exec(s);\n\n    if (!m) {\n      return s[1];\n    }\n\n    var cp = parseInt(m[1], 16);\n    return String.fromCodePoint ? String.fromCodePoint(cp) : // Not all JavaScript implementations have String.fromCodePoint yet.\n    String.fromCharCode(cp);\n  });\n};\n\nvar indexOf = function () {\n  if (Array.prototype.indexOf) {\n    return Array.prototype.indexOf;\n  }\n\n  return function (obj, item) {\n    var i = this.length;\n\n    while (i--) {\n      if (this[i] === item) return i;\n    }\n\n    return -1;\n  };\n}();\n\nvar makeInside = function makeInside(start, end) {\n  var regex = rules.inside.source.replace(/</g, start).replace(/>/g, end);\n  return new RegExp(regex);\n};\n\nvar replace = function replace(regex, name, val) {\n  regex = regex.source;\n  regex = regex.replace(name, val.source || val);\n  return new RegExp(regex);\n};\n\nvar truncateUrl = function truncateUrl(url, num) {\n  return url.replace(/^(?:\\w+:\\/\\/|\\/+)/, '').replace(/(?:\\/+|\\/*#.*?)$/, '').split('/', num).join('/');\n};\n/**\n * Handle `nth` Selectors\n */\n\n\nvar parseNth = function parseNth(param_, test) {\n  var param = param_.replace(/\\s+/g, ''),\n      cap;\n\n  if (param === 'even') {\n    param = '2n+0';\n  } else if (param === 'odd') {\n    param = '2n+1';\n  } else if (param.indexOf('n') === -1) {\n    param = '0n' + param;\n  }\n\n  cap = /^([+-])?(\\d+)?n([+-])?(\\d+)?$/.exec(param);\n  return {\n    group: cap[1] === '-' ? -(cap[2] || 1) : +(cap[2] || 1),\n    offset: cap[4] ? cap[3] === '-' ? -cap[4] : +cap[4] : 0\n  };\n};\n\nvar nth = function nth(param_, test, last) {\n  var param = parseNth(param_),\n      group = param.group,\n      offset = param.offset,\n      find = !last ? child : lastChild,\n      advance = !last ? next : prev;\n  return function (el) {\n    if (!parentIsElement(el)) return;\n    var rel = find(el.parentNode),\n        pos = 0;\n\n    while (rel) {\n      if (test(rel, el)) pos++;\n\n      if (rel === el) {\n        pos -= offset;\n        return group && pos ? pos % group === 0 && pos < 0 === group < 0 : !pos;\n      }\n\n      rel = advance(rel);\n    }\n  };\n};\n/**\n * Simple Selectors\n */\n\n\nvar selectors = {\n  '*': function () {\n    if (false\n    /*function() {\n    var el = document.createElement('div');\n    el.appendChild(document.createComment(''));\n    return !!el.getElementsByTagName('*')[0];\n    }()*/\n    ) {\n      return function (el) {\n        if (el.nodeType === 1) return true;\n      };\n    }\n\n    return function () {\n      return true;\n    };\n  }(),\n  'type': function type(_type) {\n    _type = _type.toLowerCase();\n    return function (el) {\n      return el.nodeName.toLowerCase() === _type;\n    };\n  },\n  'attr': function attr(key, op, val, i) {\n    op = operators[op];\n    return function (el) {\n      var attr;\n\n      switch (key) {\n        case 'for':\n          attr = el.htmlFor;\n          break;\n\n        case 'class':\n          // className is '' when non-existent\n          // getAttribute('class') is null\n          attr = el.className;\n\n          if (attr === '' && el.getAttribute('class') == null) {\n            attr = null;\n          }\n\n          break;\n\n        case 'href':\n        case 'src':\n          attr = el.getAttribute(key, 2);\n          break;\n\n        case 'title':\n          // getAttribute('title') can be '' when non-existent sometimes?\n          attr = el.getAttribute('title') || null;\n          break;\n        // careful with attributes with special getter functions\n\n        case 'id':\n        case 'lang':\n        case 'dir':\n        case 'accessKey':\n        case 'hidden':\n        case 'tabIndex':\n        case 'style':\n          if (el.getAttribute) {\n            attr = el.getAttribute(key);\n            break;\n          }\n\n        /* falls through */\n\n        default:\n          if (el.hasAttribute && !el.hasAttribute(key)) {\n            break;\n          }\n\n          attr = el[key] != null ? el[key] : el.getAttribute && el.getAttribute(key);\n          break;\n      }\n\n      if (attr == null) return;\n      attr = attr + '';\n\n      if (i) {\n        attr = attr.toLowerCase();\n        val = val.toLowerCase();\n      }\n\n      return op(attr, val);\n    };\n  },\n  ':first-child': function firstChild(el) {\n    return !prev(el) && parentIsElement(el);\n  },\n  ':last-child': function lastChild(el) {\n    return !next(el) && parentIsElement(el);\n  },\n  ':only-child': function onlyChild(el) {\n    return !prev(el) && !next(el) && parentIsElement(el);\n  },\n  ':nth-child': function nthChild(param, last) {\n    return nth(param, function () {\n      return true;\n    }, last);\n  },\n  ':nth-last-child': function nthLastChild(param) {\n    return selectors[':nth-child'](param, true);\n  },\n  ':root': function root(el) {\n    return el.ownerDocument.documentElement === el;\n  },\n  ':empty': function empty(el) {\n    return !el.firstChild;\n  },\n  ':not': function not(sel) {\n    var test = compileGroup(sel);\n    return function (el) {\n      return !test(el);\n    };\n  },\n  ':first-of-type': function firstOfType(el) {\n    if (!parentIsElement(el)) return;\n    var type = el.nodeName;\n    /*jshint -W084 */\n\n    while (el = prev(el)) {\n      if (el.nodeName === type) return;\n    }\n\n    return true;\n  },\n  ':last-of-type': function lastOfType(el) {\n    if (!parentIsElement(el)) return;\n    var type = el.nodeName;\n    /*jshint -W084 */\n\n    while (el = next(el)) {\n      if (el.nodeName === type) return;\n    }\n\n    return true;\n  },\n  ':only-of-type': function onlyOfType(el) {\n    return selectors[':first-of-type'](el) && selectors[':last-of-type'](el);\n  },\n  ':nth-of-type': function nthOfType(param, last) {\n    return nth(param, function (rel, el) {\n      return rel.nodeName === el.nodeName;\n    }, last);\n  },\n  ':nth-last-of-type': function nthLastOfType(param) {\n    return selectors[':nth-of-type'](param, true);\n  },\n  ':checked': function checked(el) {\n    return !!(el.checked || el.selected);\n  },\n  ':indeterminate': function indeterminate(el) {\n    return !selectors[':checked'](el);\n  },\n  ':enabled': function enabled(el) {\n    return !el.disabled && el.type !== 'hidden';\n  },\n  ':disabled': function disabled(el) {\n    return !!el.disabled;\n  },\n  ':target': function target(el) {\n    return el.id === window.location.hash.substring(1);\n  },\n  ':focus': function focus(el) {\n    return el === el.ownerDocument.activeElement;\n  },\n  ':is': function is(sel) {\n    return compileGroup(sel);\n  },\n  // :matches is an older name for :is; see\n  // https://github.com/w3c/csswg-drafts/issues/3258\n  ':matches': function matches(sel) {\n    return selectors[':is'](sel);\n  },\n  ':nth-match': function nthMatch(param, last) {\n    var args = param.split(/\\s*,\\s*/),\n        arg = args.shift(),\n        test = compileGroup(args.join(','));\n    return nth(arg, test, last);\n  },\n  ':nth-last-match': function nthLastMatch(param) {\n    return selectors[':nth-match'](param, true);\n  },\n  ':links-here': function linksHere(el) {\n    return el + '' === window.location + '';\n  },\n  ':lang': function lang(param) {\n    return function (el) {\n      while (el) {\n        if (el.lang) return el.lang.indexOf(param) === 0;\n        el = el.parentNode;\n      }\n    };\n  },\n  ':dir': function dir(param) {\n    return function (el) {\n      while (el) {\n        if (el.dir) return el.dir === param;\n        el = el.parentNode;\n      }\n    };\n  },\n  ':scope': function scope(el, con) {\n    var context = con || el.ownerDocument;\n\n    if (context.nodeType === 9) {\n      return el === context.documentElement;\n    }\n\n    return el === context;\n  },\n  ':any-link': function anyLink(el) {\n    return typeof el.href === 'string';\n  },\n  ':local-link': function localLink(el) {\n    if (el.nodeName) {\n      return el.href && el.host === window.location.host;\n    }\n\n    var param = +el + 1;\n    return function (el) {\n      if (!el.href) return;\n      var url = window.location + '',\n          href = el + '';\n      return truncateUrl(url, param) === truncateUrl(href, param);\n    };\n  },\n  ':default': function _default(el) {\n    return !!el.defaultSelected;\n  },\n  ':valid': function valid(el) {\n    return el.willValidate || el.validity && el.validity.valid;\n  },\n  ':invalid': function invalid(el) {\n    return !selectors[':valid'](el);\n  },\n  ':in-range': function inRange(el) {\n    return el.value > el.min && el.value <= el.max;\n  },\n  ':out-of-range': function outOfRange(el) {\n    return !selectors[':in-range'](el);\n  },\n  ':required': function required(el) {\n    return !!el.required;\n  },\n  ':optional': function optional(el) {\n    return !el.required;\n  },\n  ':read-only': function readOnly(el) {\n    if (el.readOnly) return true;\n    var attr = el.getAttribute('contenteditable'),\n        prop = el.contentEditable,\n        name = el.nodeName.toLowerCase();\n    name = name !== 'input' && name !== 'textarea';\n    return (name || el.disabled) && attr == null && prop !== 'true';\n  },\n  ':read-write': function readWrite(el) {\n    return !selectors[':read-only'](el);\n  },\n  ':hover': function hover() {\n    throw new Error(':hover is not supported.');\n  },\n  ':active': function active() {\n    throw new Error(':active is not supported.');\n  },\n  ':link': function link() {\n    throw new Error(':link is not supported.');\n  },\n  ':visited': function visited() {\n    throw new Error(':visited is not supported.');\n  },\n  ':column': function column() {\n    throw new Error(':column is not supported.');\n  },\n  ':nth-column': function nthColumn() {\n    throw new Error(':nth-column is not supported.');\n  },\n  ':nth-last-column': function nthLastColumn() {\n    throw new Error(':nth-last-column is not supported.');\n  },\n  ':current': function current() {\n    throw new Error(':current is not supported.');\n  },\n  ':past': function past() {\n    throw new Error(':past is not supported.');\n  },\n  ':future': function future() {\n    throw new Error(':future is not supported.');\n  },\n  // Non-standard, for compatibility purposes.\n  ':contains': function contains(param) {\n    return function (el) {\n      var text = el.innerText || el.textContent || el.value || '';\n      return text.indexOf(param) !== -1;\n    };\n  },\n  ':has': function has(param) {\n    return function (el) {\n      return find(param, el).length > 0;\n    };\n  } // Potentially add more pseudo selectors for\n  // compatibility with sizzle and most other\n  // selector engines (?).\n\n};\n/**\n * Attribute Operators\n */\n\nvar operators = {\n  '-': function _() {\n    return true;\n  },\n  '=': function _(attr, val) {\n    return attr === val;\n  },\n  '*=': function _(attr, val) {\n    return attr.indexOf(val) !== -1;\n  },\n  '~=': function _(attr, val) {\n    var i, s, f, l;\n\n    for (s = 0; true; s = i + 1) {\n      i = attr.indexOf(val, s);\n      if (i === -1) return false;\n      f = attr[i - 1];\n      l = attr[i + val.length];\n      if ((!f || f === ' ') && (!l || l === ' ')) return true;\n    }\n  },\n  '|=': function _(attr, val) {\n    var i = attr.indexOf(val),\n        l;\n    if (i !== 0) return;\n    l = attr[i + val.length];\n    return l === '-' || !l;\n  },\n  '^=': function _(attr, val) {\n    return attr.indexOf(val) === 0;\n  },\n  '$=': function $(attr, val) {\n    var i = attr.lastIndexOf(val);\n    return i !== -1 && i + val.length === attr.length;\n  },\n  // non-standard\n  '!=': function _(attr, val) {\n    return attr !== val;\n  }\n};\n/**\n * Combinator Logic\n */\n\nvar combinators = {\n  ' ': function _(test) {\n    return function (el) {\n      /*jshint -W084 */\n      while (el = el.parentNode) {\n        if (test(el)) return el;\n      }\n    };\n  },\n  '>': function _(test) {\n    return function (el) {\n      /*jshint -W084 */\n      if (el = el.parentNode) {\n        return test(el) && el;\n      }\n    };\n  },\n  '+': function _(test) {\n    return function (el) {\n      /*jshint -W084 */\n      if (el = prev(el)) {\n        return test(el) && el;\n      }\n    };\n  },\n  '~': function _(test) {\n    return function (el) {\n      /*jshint -W084 */\n      while (el = prev(el)) {\n        if (test(el)) return el;\n      }\n    };\n  },\n  'noop': function noop(test) {\n    return function (el) {\n      return test(el) && el;\n    };\n  },\n  'ref': function ref(test, name) {\n    var node;\n\n    function ref(el) {\n      var doc = el.ownerDocument,\n          nodes = doc.getElementsByTagName('*'),\n          i = nodes.length;\n\n      while (i--) {\n        node = nodes[i];\n\n        if (ref.test(el)) {\n          node = null;\n          return true;\n        }\n      }\n\n      node = null;\n    }\n\n    ref.combinator = function (el) {\n      if (!node || !node.getAttribute) return;\n      var attr = node.getAttribute(name) || '';\n      if (attr[0] === '#') attr = attr.substring(1);\n\n      if (attr === el.id && test(node)) {\n        return node;\n      }\n    };\n\n    return ref;\n  }\n};\n/**\n * Grammar\n */\n\nvar rules = {\n  escape: /\\\\(?:[^0-9A-Fa-f\\r\\n]|[0-9A-Fa-f]{1,6}[\\r\\n\\t ]?)/g,\n  str_escape: /(escape)|\\\\(\\n|\\r\\n?|\\f)/g,\n  nonascii: /[\\u00A0-\\uFFFF]/,\n  cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,\n  qname: /^ *(cssid|\\*)/,\n  simple: /^(?:([.#]cssid)|pseudo|attr)/,\n  ref: /^ *\\/(cssid)\\/ */,\n  combinator: /^(?: +([^ \\w*.#\\\\]) +|( )+|([^ \\w*.#\\\\]))(?! *$)/,\n  attr: /^\\[(cssid)(?:([^\\w]?=)(inside))?\\]/,\n  pseudo: /^(:cssid)(?:\\((inside)\\))?/,\n  inside: /(?:\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|<[^\"'>]*>|\\\\[\"'>]|[^\"'>])*/,\n  ident: /^(cssid)$/\n};\nrules.cssid = replace(rules.cssid, 'nonascii', rules.nonascii);\nrules.cssid = replace(rules.cssid, 'escape', rules.escape);\nrules.qname = replace(rules.qname, 'cssid', rules.cssid);\nrules.simple = replace(rules.simple, 'cssid', rules.cssid);\nrules.ref = replace(rules.ref, 'cssid', rules.cssid);\nrules.attr = replace(rules.attr, 'cssid', rules.cssid);\nrules.pseudo = replace(rules.pseudo, 'cssid', rules.cssid);\nrules.inside = replace(rules.inside, '[^\"\\'>]*', rules.inside);\nrules.attr = replace(rules.attr, 'inside', makeInside('\\\\[', '\\\\]'));\nrules.pseudo = replace(rules.pseudo, 'inside', makeInside('\\\\(', '\\\\)'));\nrules.simple = replace(rules.simple, 'pseudo', rules.pseudo);\nrules.simple = replace(rules.simple, 'attr', rules.attr);\nrules.ident = replace(rules.ident, 'cssid', rules.cssid);\nrules.str_escape = replace(rules.str_escape, 'escape', rules.escape);\n/**\n * Compiling\n */\n\nvar compile = function compile(sel_) {\n  var sel = sel_.replace(/^\\s+|\\s+$/g, ''),\n      test,\n      filter = [],\n      buff = [],\n      subject,\n      qname,\n      cap,\n      op,\n      ref;\n  /*jshint -W084 */\n\n  while (sel) {\n    if (cap = rules.qname.exec(sel)) {\n      sel = sel.substring(cap[0].length);\n      qname = decodeid(cap[1]);\n      buff.push(tok(qname, true));\n    } else if (cap = rules.simple.exec(sel)) {\n      sel = sel.substring(cap[0].length);\n      qname = '*';\n      buff.push(tok(qname, true));\n      buff.push(tok(cap));\n    } else {\n      throw new SyntaxError('Invalid selector.');\n    }\n\n    while (cap = rules.simple.exec(sel)) {\n      sel = sel.substring(cap[0].length);\n      buff.push(tok(cap));\n    }\n\n    if (sel[0] === '!') {\n      sel = sel.substring(1);\n      subject = makeSubject();\n      subject.qname = qname;\n      buff.push(subject.simple);\n    }\n\n    if (cap = rules.ref.exec(sel)) {\n      sel = sel.substring(cap[0].length);\n      ref = combinators.ref(makeSimple(buff), decodeid(cap[1]));\n      filter.push(ref.combinator);\n      buff = [];\n      continue;\n    }\n\n    if (cap = rules.combinator.exec(sel)) {\n      sel = sel.substring(cap[0].length);\n      op = cap[1] || cap[2] || cap[3];\n\n      if (op === ',') {\n        filter.push(combinators.noop(makeSimple(buff)));\n        break;\n      }\n    } else {\n      op = 'noop';\n    }\n\n    if (!combinators[op]) {\n      throw new SyntaxError('Bad combinator.');\n    }\n\n    filter.push(combinators[op](makeSimple(buff)));\n    buff = [];\n  }\n\n  test = makeTest(filter);\n  test.qname = qname;\n  test.sel = sel;\n\n  if (subject) {\n    subject.lname = test.qname;\n    subject.test = test;\n    subject.qname = subject.qname;\n    subject.sel = test.sel;\n    test = subject;\n  }\n\n  if (ref) {\n    ref.test = test;\n    ref.qname = test.qname;\n    ref.sel = test.sel;\n    test = ref;\n  }\n\n  return test;\n};\n\nvar tok = function tok(cap, qname) {\n  // qname\n  if (qname) {\n    return cap === '*' ? selectors['*'] : selectors.type(cap);\n  } // class/id\n\n\n  if (cap[1]) {\n    return cap[1][0] === '.' // XXX unescape here?  or in attr?\n    ? selectors.attr('class', '~=', decodeid(cap[1].substring(1)), false) : selectors.attr('id', '=', decodeid(cap[1].substring(1)), false);\n  } // pseudo-name\n  // inside-pseudo\n\n\n  if (cap[2]) {\n    return cap[3] ? selectors[decodeid(cap[2])](unquote(cap[3])) : selectors[decodeid(cap[2])];\n  } // attr name\n  // attr op\n  // attr value\n\n\n  if (cap[4]) {\n    var value = cap[6];\n    var i = /[\"'\\s]\\s*I$/i.test(value);\n\n    if (i) {\n      value = value.replace(/\\s*I$/i, '');\n    }\n\n    return selectors.attr(decodeid(cap[4]), cap[5] || '-', unquote(value), i);\n  }\n\n  throw new SyntaxError('Unknown Selector.');\n};\n\nvar makeSimple = function makeSimple(func) {\n  var l = func.length,\n      i; // Potentially make sure\n  // `el` is truthy.\n\n  if (l < 2) return func[0];\n  return function (el) {\n    if (!el) return;\n\n    for (i = 0; i < l; i++) {\n      if (!func[i](el)) return;\n    }\n\n    return true;\n  };\n};\n\nvar makeTest = function makeTest(func) {\n  if (func.length < 2) {\n    return function (el) {\n      return !!func[0](el);\n    };\n  }\n\n  return function (el) {\n    var i = func.length;\n\n    while (i--) {\n      if (!(el = func[i](el))) return;\n    }\n\n    return true;\n  };\n};\n\nvar makeSubject = function makeSubject() {\n  var target;\n\n  function subject(el) {\n    var node = el.ownerDocument,\n        scope = node.getElementsByTagName(subject.lname),\n        i = scope.length;\n\n    while (i--) {\n      if (subject.test(scope[i]) && target === el) {\n        target = null;\n        return true;\n      }\n    }\n\n    target = null;\n  }\n\n  subject.simple = function (el) {\n    target = el;\n    return true;\n  };\n\n  return subject;\n};\n\nvar compileGroup = function compileGroup(sel) {\n  var test = compile(sel),\n      tests = [test];\n\n  while (test.sel) {\n    test = compile(test.sel);\n    tests.push(test);\n  }\n\n  if (tests.length < 2) return test;\n  return function (el) {\n    var l = tests.length,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (tests[i](el)) return true;\n    }\n  };\n};\n/**\n * Selection\n */\n\n\nvar find = function find(sel, node) {\n  var results = [],\n      test = compile(sel),\n      scope = node.getElementsByTagName(test.qname),\n      i = 0,\n      el;\n  /*jshint -W084 */\n\n  while (el = scope[i++]) {\n    if (test(el)) results.push(el);\n  }\n\n  if (test.sel) {\n    while (test.sel) {\n      test = compile(test.sel);\n      scope = node.getElementsByTagName(test.qname);\n      i = 0;\n      /*jshint -W084 */\n\n      while (el = scope[i++]) {\n        if (test(el) && indexOf.call(results, el) === -1) {\n          results.push(el);\n        }\n      }\n    }\n\n    results.sort(order);\n  }\n\n  return results;\n};\n/**\n * Expose\n */\n\n\nmodule.exports = exports = function exports(sel, context) {\n  /* when context isn't a DocumentFragment and the selector is simple: */\n  var id, r;\n\n  if (context.nodeType !== 11 && sel.indexOf(' ') === -1) {\n    if (sel[0] === '#' && context.rooted && /^#[A-Z_][-A-Z0-9_]*$/i.test(sel)) {\n      if (context.doc._hasMultipleElementsWithId) {\n        id = sel.substring(1);\n\n        if (!context.doc._hasMultipleElementsWithId(id)) {\n          r = context.doc.getElementById(id);\n          return r ? [r] : [];\n        }\n      }\n    }\n\n    if (sel[0] === '.' && /^\\.\\w+$/.test(sel)) {\n      return context.getElementsByClassName(sel.substring(1));\n    }\n\n    if (/^\\w+$/.test(sel)) {\n      return context.getElementsByTagName(sel);\n    }\n  }\n  /* do things the hard/slow way */\n\n\n  return find(sel, context);\n};\n\nexports.selectors = selectors;\nexports.operators = operators;\nexports.combinators = combinators;\n\nexports.matches = function (el, sel) {\n  var test = {\n    sel: sel\n  };\n\n  do {\n    test = compile(test.sel);\n\n    if (test(el)) {\n      return true;\n    }\n  } while (test.sel);\n\n  return false;\n};","map":null,"metadata":{},"sourceType":"script"}