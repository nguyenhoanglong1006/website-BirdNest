{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Document;\n\nvar Node = require('./Node');\n\nvar NodeList = require('./NodeList');\n\nvar ContainerNode = require('./ContainerNode');\n\nvar Element = require('./Element');\n\nvar Text = require('./Text');\n\nvar Comment = require('./Comment');\n\nvar Event = require('./Event');\n\nvar DocumentFragment = require('./DocumentFragment');\n\nvar ProcessingInstruction = require('./ProcessingInstruction');\n\nvar DOMImplementation = require('./DOMImplementation');\n\nvar TreeWalker = require('./TreeWalker');\n\nvar NodeIterator = require('./NodeIterator');\n\nvar NodeFilter = require('./NodeFilter');\n\nvar URL = require('./URL');\n\nvar select = require('./select');\n\nvar events = require('./events');\n\nvar xml = require('./xmlnames');\n\nvar html = require('./htmlelts');\n\nvar svg = require('./svg');\n\nvar utils = require('./utils');\n\nvar MUTATE = require('./MutationConstants');\n\nvar NAMESPACE = utils.NAMESPACE;\n\nvar isApiWritable = require(\"./config\").isApiWritable;\n\nfunction Document(isHTML, address) {\n  ContainerNode.call(this);\n  this.nodeType = Node.DOCUMENT_NODE;\n  this.isHTML = isHTML;\n  this._address = address || 'about:blank';\n  this.readyState = 'loading';\n  this.implementation = new DOMImplementation(this); // DOMCore says that documents are always associated with themselves\n\n  this.ownerDocument = null; // ... but W3C tests expect null\n\n  this._contentType = isHTML ? 'text/html' : 'application/xml'; // These will be initialized by our custom versions of\n  // appendChild and insertBefore that override the inherited\n  // Node methods.\n  // XXX: override those methods!\n\n  this.doctype = null;\n  this.documentElement = null; // \"Associated inert template document\"\n\n  this._templateDocCache = null; // List of active NodeIterators, see NodeIterator#_preremove()\n\n  this._nodeIterators = null; // Documents are always rooted, by definition\n\n  this._nid = 1;\n  this._nextnid = 2; // For numbering children of the document\n\n  this._nodes = [null, this]; // nid to node map\n  // This maintains the mapping from element ids to element nodes.\n  // We may need to update this mapping every time a node is rooted\n  // or uprooted, and any time an attribute is added, removed or changed\n  // on a rooted element.\n\n  this.byId = Object.create(null); // This property holds a monotonically increasing value akin to\n  // a timestamp used to record the last modification time of nodes\n  // and their subtrees. See the lastModTime attribute and modify()\n  // method of the Node class. And see FilteredElementList for an example\n  // of the use of lastModTime\n\n  this.modclock = 0;\n} // Map from lowercase event category names (used as arguments to\n// createEvent()) to the property name in the impl object of the\n// event constructor.\n\n\nvar supportedEvents = {\n  event: 'Event',\n  customevent: 'CustomEvent',\n  uievent: 'UIEvent',\n  mouseevent: 'MouseEvent'\n}; // Certain arguments to document.createEvent() must be treated specially\n\nvar replacementEvent = {\n  events: 'event',\n  htmlevents: 'event',\n  mouseevents: 'mouseevent',\n  mutationevents: 'mutationevent',\n  uievents: 'uievent'\n};\n\nvar mirrorAttr = function mirrorAttr(f, name, defaultValue) {\n  return {\n    get: function get() {\n      var o = f.call(this);\n\n      if (o) {\n        return o[name];\n      }\n\n      return defaultValue;\n    },\n    set: function set(value) {\n      var o = f.call(this);\n\n      if (o) {\n        o[name] = value;\n      }\n    }\n  };\n};\n/** @spec https://dom.spec.whatwg.org/#validate-and-extract */\n\n\nfunction validateAndExtract(namespace, qualifiedName) {\n  var prefix, localName, pos;\n\n  if (namespace === '') {\n    namespace = null;\n  } // See https://github.com/whatwg/dom/issues/671\n  // and https://github.com/whatwg/dom/issues/319\n\n\n  if (!xml.isValidQName(qualifiedName)) {\n    utils.InvalidCharacterError();\n  }\n\n  prefix = null;\n  localName = qualifiedName;\n  pos = qualifiedName.indexOf(':');\n\n  if (pos >= 0) {\n    prefix = qualifiedName.substring(0, pos);\n    localName = qualifiedName.substring(pos + 1);\n  }\n\n  if (prefix !== null && namespace === null) {\n    utils.NamespaceError();\n  }\n\n  if (prefix === 'xml' && namespace !== NAMESPACE.XML) {\n    utils.NamespaceError();\n  }\n\n  if ((prefix === 'xmlns' || qualifiedName === 'xmlns') && namespace !== NAMESPACE.XMLNS) {\n    utils.NamespaceError();\n  }\n\n  if (namespace === NAMESPACE.XMLNS && !(prefix === 'xmlns' || qualifiedName === 'xmlns')) {\n    utils.NamespaceError();\n  }\n\n  return {\n    namespace: namespace,\n    prefix: prefix,\n    localName: localName\n  };\n}\n\nDocument.prototype = Object.create(ContainerNode.prototype, {\n  // This method allows dom.js to communicate with a renderer\n  // that displays the document in some way\n  // XXX: I should probably move this to the window object\n  _setMutationHandler: {\n    value: function value(handler) {\n      this.mutationHandler = handler;\n    }\n  },\n  // This method allows dom.js to receive event notifications\n  // from the renderer.\n  // XXX: I should probably move this to the window object\n  _dispatchRendererEvent: {\n    value: function value(targetNid, type, details) {\n      var target = this._nodes[targetNid];\n      if (!target) return;\n\n      target._dispatchEvent(new Event(type, details), true);\n    }\n  },\n  nodeName: {\n    value: '#document'\n  },\n  nodeValue: {\n    get: function get() {\n      return null;\n    },\n    set: function set() {}\n  },\n  // XXX: DOMCore may remove documentURI, so it is NYI for now\n  documentURI: {\n    get: function get() {\n      return this._address;\n    },\n    set: utils.nyi\n  },\n  compatMode: {\n    get: function get() {\n      // The _quirks property is set by the HTML parser\n      return this._quirks ? 'BackCompat' : 'CSS1Compat';\n    }\n  },\n  createTextNode: {\n    value: function value(data) {\n      return new Text(this, String(data));\n    }\n  },\n  createComment: {\n    value: function value(data) {\n      return new Comment(this, data);\n    }\n  },\n  createDocumentFragment: {\n    value: function value() {\n      return new DocumentFragment(this);\n    }\n  },\n  createProcessingInstruction: {\n    value: function value(target, data) {\n      if (!xml.isValidName(target) || data.indexOf('?>') !== -1) utils.InvalidCharacterError();\n      return new ProcessingInstruction(this, target, data);\n    }\n  },\n  createAttribute: {\n    value: function value(localName) {\n      localName = String(localName);\n      if (!xml.isValidName(localName)) utils.InvalidCharacterError();\n\n      if (this.isHTML) {\n        localName = utils.toASCIILowerCase(localName);\n      }\n\n      return new Element._Attr(null, localName, null, null, '');\n    }\n  },\n  createAttributeNS: {\n    value: function value(namespace, qualifiedName) {\n      // Convert parameter types according to WebIDL\n      namespace = namespace === null || namespace === undefined || namespace === '' ? null : String(namespace);\n      qualifiedName = String(qualifiedName);\n      var ve = validateAndExtract(namespace, qualifiedName);\n      return new Element._Attr(null, ve.localName, ve.prefix, ve.namespace, '');\n    }\n  },\n  createElement: {\n    value: function value(localName) {\n      localName = String(localName);\n      if (!xml.isValidName(localName)) utils.InvalidCharacterError(); // Per spec, namespace should be HTML namespace if \"context object is\n      // an HTML document or context object's content type is\n      // \"application/xhtml+xml\", and null otherwise.\n\n      if (this.isHTML) {\n        if (/[A-Z]/.test(localName)) localName = utils.toASCIILowerCase(localName);\n        return html.createElement(this, localName, null);\n      } else if (this.contentType === 'application/xhtml+xml') {\n        return html.createElement(this, localName, null);\n      } else {\n        return new Element(this, localName, null, null);\n      }\n    },\n    writable: isApiWritable\n  },\n  createElementNS: {\n    value: function value(namespace, qualifiedName) {\n      // Convert parameter types according to WebIDL\n      namespace = namespace === null || namespace === undefined || namespace === '' ? null : String(namespace);\n      qualifiedName = String(qualifiedName);\n      var ve = validateAndExtract(namespace, qualifiedName);\n      return this._createElementNS(ve.localName, ve.namespace, ve.prefix);\n    },\n    writable: isApiWritable\n  },\n  // This is used directly by HTML parser, which allows it to create\n  // elements with localNames containing ':' and non-default namespaces\n  _createElementNS: {\n    value: function value(localName, namespace, prefix) {\n      if (namespace === NAMESPACE.HTML) {\n        return html.createElement(this, localName, prefix);\n      } else if (namespace === NAMESPACE.SVG) {\n        return svg.createElement(this, localName, prefix);\n      }\n\n      return new Element(this, localName, namespace, prefix);\n    }\n  },\n  createEvent: {\n    value: function createEvent(interfaceName) {\n      interfaceName = interfaceName.toLowerCase();\n      var name = replacementEvent[interfaceName] || interfaceName;\n      var constructor = events[supportedEvents[name]];\n\n      if (constructor) {\n        var e = new constructor();\n        e._initialized = false;\n        return e;\n      } else {\n        utils.NotSupportedError();\n      }\n    }\n  },\n  // See: http://www.w3.org/TR/dom/#dom-document-createtreewalker\n  createTreeWalker: {\n    value: function value(root, whatToShow, filter) {\n      if (!root) {\n        throw new TypeError(\"root argument is required\");\n      }\n\n      if (!(root instanceof Node)) {\n        throw new TypeError(\"root not a node\");\n      }\n\n      whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : +whatToShow;\n      filter = filter === undefined ? null : filter;\n      return new TreeWalker(root, whatToShow, filter);\n    }\n  },\n  // See: http://www.w3.org/TR/dom/#dom-document-createnodeiterator\n  createNodeIterator: {\n    value: function value(root, whatToShow, filter) {\n      if (!root) {\n        throw new TypeError(\"root argument is required\");\n      }\n\n      if (!(root instanceof Node)) {\n        throw new TypeError(\"root not a node\");\n      }\n\n      whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : +whatToShow;\n      filter = filter === undefined ? null : filter;\n      return new NodeIterator(root, whatToShow, filter);\n    }\n  },\n  _attachNodeIterator: {\n    value: function value(ni) {\n      // XXX ideally this should be a weak reference from Document to NodeIterator\n      if (!this._nodeIterators) {\n        this._nodeIterators = [];\n      }\n\n      this._nodeIterators.push(ni);\n    }\n  },\n  _detachNodeIterator: {\n    value: function value(ni) {\n      // ni should always be in list of node iterators\n      var idx = this._nodeIterators.indexOf(ni);\n\n      this._nodeIterators.splice(idx, 1);\n    }\n  },\n  _preremoveNodeIterators: {\n    value: function value(toBeRemoved) {\n      if (this._nodeIterators) {\n        this._nodeIterators.forEach(function (ni) {\n          ni._preremove(toBeRemoved);\n        });\n      }\n    }\n  },\n  // Maintain the documentElement and\n  // doctype properties of the document.  Each of the following\n  // methods chains to the Node implementation of the method\n  // to do the actual inserting, removal or replacement.\n  _updateDocTypeElement: {\n    value: function _updateDocTypeElement() {\n      this.doctype = this.documentElement = null;\n\n      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n        if (kid.nodeType === Node.DOCUMENT_TYPE_NODE) this.doctype = kid;else if (kid.nodeType === Node.ELEMENT_NODE) this.documentElement = kid;\n      }\n    }\n  },\n  insertBefore: {\n    value: function insertBefore(child, refChild) {\n      Node.prototype.insertBefore.call(this, child, refChild);\n\n      this._updateDocTypeElement();\n\n      return child;\n    }\n  },\n  replaceChild: {\n    value: function replaceChild(node, child) {\n      Node.prototype.replaceChild.call(this, node, child);\n\n      this._updateDocTypeElement();\n\n      return child;\n    }\n  },\n  removeChild: {\n    value: function removeChild(child) {\n      Node.prototype.removeChild.call(this, child);\n\n      this._updateDocTypeElement();\n\n      return child;\n    }\n  },\n  getElementById: {\n    value: function value(id) {\n      var n = this.byId[id];\n      if (!n) return null;\n\n      if (n instanceof MultiId) {\n        // there was more than one element with this id\n        return n.getFirst();\n      }\n\n      return n;\n    }\n  },\n  _hasMultipleElementsWithId: {\n    value: function value(id) {\n      // Used internally by querySelectorAll optimization\n      return this.byId[id] instanceof MultiId;\n    }\n  },\n  // Just copy this method from the Element prototype\n  getElementsByName: {\n    value: Element.prototype.getElementsByName\n  },\n  getElementsByTagName: {\n    value: Element.prototype.getElementsByTagName\n  },\n  getElementsByTagNameNS: {\n    value: Element.prototype.getElementsByTagNameNS\n  },\n  getElementsByClassName: {\n    value: Element.prototype.getElementsByClassName\n  },\n  adoptNode: {\n    value: function adoptNode(node) {\n      if (node.nodeType === Node.DOCUMENT_NODE) utils.NotSupportedError();\n\n      if (node.nodeType === Node.ATTRIBUTE_NODE) {\n        return node;\n      }\n\n      if (node.parentNode) node.parentNode.removeChild(node);\n      if (node.ownerDocument !== this) recursivelySetOwner(node, this);\n      return node;\n    }\n  },\n  importNode: {\n    value: function importNode(node, deep) {\n      return this.adoptNode(node.cloneNode(deep));\n    },\n    writable: isApiWritable\n  },\n  // The following attributes and methods are from the HTML spec\n  origin: {\n    get: function origin() {\n      return null;\n    }\n  },\n  characterSet: {\n    get: function characterSet() {\n      return \"UTF-8\";\n    }\n  },\n  contentType: {\n    get: function contentType() {\n      return this._contentType;\n    }\n  },\n  URL: {\n    get: function URL() {\n      return this._address;\n    }\n  },\n  domain: {\n    get: utils.nyi,\n    set: utils.nyi\n  },\n  referrer: {\n    get: utils.nyi\n  },\n  cookie: {\n    get: utils.nyi,\n    set: utils.nyi\n  },\n  lastModified: {\n    get: utils.nyi\n  },\n  location: {\n    get: function get() {\n      return this.defaultView ? this.defaultView.location : null; // gh #75\n    },\n    set: utils.nyi\n  },\n  _titleElement: {\n    get: function get() {\n      // The title element of a document is the first title element in the\n      // document in tree order, if there is one, or null otherwise.\n      return this.getElementsByTagName('title').item(0) || null;\n    }\n  },\n  title: {\n    get: function get() {\n      var elt = this._titleElement; // The child text content of the title element, or '' if null.\n\n      var value = elt ? elt.textContent : ''; // Strip and collapse whitespace in value\n\n      return value.replace(/[ \\t\\n\\r\\f]+/g, ' ').replace(/(^ )|( $)/g, '');\n    },\n    set: function set(value) {\n      var elt = this._titleElement;\n      var head = this.head;\n\n      if (!elt && !head) {\n        return;\n        /* according to spec */\n      }\n\n      if (!elt) {\n        elt = this.createElement('title');\n        head.appendChild(elt);\n      }\n\n      elt.textContent = value;\n    }\n  },\n  dir: mirrorAttr(function () {\n    var htmlElement = this.documentElement;\n\n    if (htmlElement && htmlElement.tagName === 'HTML') {\n      return htmlElement;\n    }\n  }, 'dir', ''),\n  fgColor: mirrorAttr(function () {\n    return this.body;\n  }, 'text', ''),\n  linkColor: mirrorAttr(function () {\n    return this.body;\n  }, 'link', ''),\n  vlinkColor: mirrorAttr(function () {\n    return this.body;\n  }, 'vLink', ''),\n  alinkColor: mirrorAttr(function () {\n    return this.body;\n  }, 'aLink', ''),\n  bgColor: mirrorAttr(function () {\n    return this.body;\n  }, 'bgColor', ''),\n  // Historical aliases of Document#characterSet\n  charset: {\n    get: function get() {\n      return this.characterSet;\n    }\n  },\n  inputEncoding: {\n    get: function get() {\n      return this.characterSet;\n    }\n  },\n  scrollingElement: {\n    get: function get() {\n      return this._quirks ? this.body : this.documentElement;\n    }\n  },\n  // Return the first <body> child of the document element.\n  // XXX For now, setting this attribute is not implemented.\n  body: {\n    get: function get() {\n      return namedHTMLChild(this.documentElement, 'body');\n    },\n    set: utils.nyi\n  },\n  // Return the first <head> child of the document element.\n  head: {\n    get: function get() {\n      return namedHTMLChild(this.documentElement, 'head');\n    }\n  },\n  images: {\n    get: utils.nyi\n  },\n  embeds: {\n    get: utils.nyi\n  },\n  plugins: {\n    get: utils.nyi\n  },\n  links: {\n    get: utils.nyi\n  },\n  forms: {\n    get: utils.nyi\n  },\n  scripts: {\n    get: utils.nyi\n  },\n  applets: {\n    get: function get() {\n      return [];\n    }\n  },\n  activeElement: {\n    get: function get() {\n      return null;\n    }\n  },\n  innerHTML: {\n    get: function get() {\n      return this.serialize();\n    },\n    set: utils.nyi\n  },\n  outerHTML: {\n    get: function get() {\n      return this.serialize();\n    },\n    set: utils.nyi\n  },\n  write: {\n    value: function value(args) {\n      if (!this.isHTML) utils.InvalidStateError(); // XXX: still have to implement the ignore part\n\n      if (!this._parser\n      /* && this._ignore_destructive_writes > 0 */\n      ) return;\n\n      if (!this._parser) {// XXX call document.open, etc.\n      }\n\n      var s = arguments.join(''); // If the Document object's reload override flag is set, then\n      // append the string consisting of the concatenation of all the\n      // arguments to the method to the Document's reload override\n      // buffer.\n      // XXX: don't know what this is about.  Still have to do it\n      // If there is no pending parsing-blocking script, have the\n      // tokenizer process the characters that were inserted, one at a\n      // time, processing resulting tokens as they are emitted, and\n      // stopping when the tokenizer reaches the insertion point or when\n      // the processing of the tokenizer is aborted by the tree\n      // construction stage (this can happen if a script end tag token is\n      // emitted by the tokenizer).\n      // XXX: still have to do the above. Sounds as if we don't\n      // always call parse() here.  If we're blocked, then we just\n      // insert the text into the stream but don't parse it reentrantly...\n      // Invoke the parser reentrantly\n\n      this._parser.parse(s);\n    }\n  },\n  writeln: {\n    value: function writeln(args) {\n      this.write(Array.prototype.join.call(arguments, '') + '\\n');\n    }\n  },\n  open: {\n    value: function value() {\n      this.documentElement = null;\n    }\n  },\n  close: {\n    value: function value() {\n      this.readyState = 'interactive';\n\n      this._dispatchEvent(new Event('readystatechange'), true);\n\n      this._dispatchEvent(new Event('DOMContentLoaded'), true);\n\n      this.readyState = 'complete';\n\n      this._dispatchEvent(new Event('readystatechange'), true);\n\n      if (this.defaultView) {\n        this.defaultView._dispatchEvent(new Event('load'), true);\n      }\n    }\n  },\n  // Utility methods\n  clone: {\n    value: function clone() {\n      var d = new Document(this.isHTML, this._address);\n      d._quirks = this._quirks;\n      d._contentType = this._contentType;\n      return d;\n    }\n  },\n  // We need to adopt the nodes if we do a deep clone\n  cloneNode: {\n    value: function cloneNode(deep) {\n      var clone = Node.prototype.cloneNode.call(this, false);\n\n      if (deep) {\n        for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n          clone._appendChild(clone.importNode(kid, true));\n        }\n      }\n\n      clone._updateDocTypeElement();\n\n      return clone;\n    }\n  },\n  isEqual: {\n    value: function isEqual(n) {\n      // Any two documents are shallowly equal.\n      // Node.isEqualNode will also test the children\n      return true;\n    }\n  },\n  // Implementation-specific function.  Called when a text, comment,\n  // or pi value changes.\n  mutateValue: {\n    value: function value(node) {\n      if (this.mutationHandler) {\n        this.mutationHandler({\n          type: MUTATE.VALUE,\n          target: node,\n          data: node.data\n        });\n      }\n    }\n  },\n  // Invoked when an attribute's value changes. Attr holds the new\n  // value.  oldval is the old value.  Attribute mutations can also\n  // involve changes to the prefix (and therefore the qualified name)\n  mutateAttr: {\n    value: function value(attr, oldval) {\n      // Manage id->element mapping for getElementsById()\n      // XXX: this special case id handling should not go here,\n      // but in the attribute declaration for the id attribute\n\n      /*\n      if (attr.localName === 'id' && attr.namespaceURI === null) {\n        if (oldval) delId(oldval, attr.ownerElement);\n        addId(attr.value, attr.ownerElement);\n      }\n      */\n      if (this.mutationHandler) {\n        this.mutationHandler({\n          type: MUTATE.ATTR,\n          target: attr.ownerElement,\n          attr: attr\n        });\n      }\n    }\n  },\n  // Used by removeAttribute and removeAttributeNS for attributes.\n  mutateRemoveAttr: {\n    value: function value(attr) {\n      /*\n      * This is now handled in Attributes.js\n          // Manage id to element mapping\n          if (attr.localName === 'id' && attr.namespaceURI === null) {\n            this.delId(attr.value, attr.ownerElement);\n          }\n      */\n      if (this.mutationHandler) {\n        this.mutationHandler({\n          type: MUTATE.REMOVE_ATTR,\n          target: attr.ownerElement,\n          attr: attr\n        });\n      }\n    }\n  },\n  // Called by Node.removeChild, etc. to remove a rooted element from\n  // the tree. Only needs to generate a single mutation event when a\n  // node is removed, but must recursively mark all descendants as not\n  // rooted.\n  mutateRemove: {\n    value: function value(node) {\n      // Send a single mutation event\n      if (this.mutationHandler) {\n        this.mutationHandler({\n          type: MUTATE.REMOVE,\n          target: node.parentNode,\n          node: node\n        });\n      } // Mark this and all descendants as not rooted\n\n\n      recursivelyUproot(node);\n    }\n  },\n  // Called when a new element becomes rooted.  It must recursively\n  // generate mutation events for each of the children, and mark them all\n  // as rooted.\n  mutateInsert: {\n    value: function value(node) {\n      // Mark node and its descendants as rooted\n      recursivelyRoot(node); // Send a single mutation event\n\n      if (this.mutationHandler) {\n        this.mutationHandler({\n          type: MUTATE.INSERT,\n          target: node.parentNode,\n          node: node\n        });\n      }\n    }\n  },\n  // Called when a rooted element is moved within the document\n  mutateMove: {\n    value: function value(node) {\n      if (this.mutationHandler) {\n        this.mutationHandler({\n          type: MUTATE.MOVE,\n          target: node\n        });\n      }\n    }\n  },\n  // Add a mapping from  id to n for n.ownerDocument\n  addId: {\n    value: function addId(id, n) {\n      var val = this.byId[id];\n\n      if (!val) {\n        this.byId[id] = n;\n      } else {\n        // TODO: Add a way to opt-out console warnings\n        //console.warn('Duplicate element id ' + id);\n        if (!(val instanceof MultiId)) {\n          val = new MultiId(val);\n          this.byId[id] = val;\n        }\n\n        val.add(n);\n      }\n    }\n  },\n  // Delete the mapping from id to n for n.ownerDocument\n  delId: {\n    value: function delId(id, n) {\n      var val = this.byId[id];\n      utils.assert(val);\n\n      if (val instanceof MultiId) {\n        val.del(n);\n\n        if (val.length === 1) {\n          // convert back to a single node\n          this.byId[id] = val.downgrade();\n        }\n      } else {\n        this.byId[id] = undefined;\n      }\n    }\n  },\n  _resolve: {\n    value: function value(href) {\n      //XXX: Cache the URL\n      return new URL(this._documentBaseURL).resolve(href);\n    }\n  },\n  _documentBaseURL: {\n    get: function get() {\n      // XXX: This is not implemented correctly yet\n      var url = this._address;\n      if (url === 'about:blank') url = '/';\n      var base = this.querySelector('base[href]');\n\n      if (base) {\n        return new URL(url).resolve(base.getAttribute('href'));\n      }\n\n      return url; // The document base URL of a Document object is the\n      // absolute URL obtained by running these substeps:\n      //     Let fallback base url be the document's address.\n      //     If fallback base url is about:blank, and the\n      //     Document's browsing context has a creator browsing\n      //     context, then let fallback base url be the document\n      //     base URL of the creator Document instead.\n      //     If the Document is an iframe srcdoc document, then\n      //     let fallback base url be the document base URL of\n      //     the Document's browsing context's browsing context\n      //     container's Document instead.\n      //     If there is no base element that has an href\n      //     attribute, then the document base URL is fallback\n      //     base url; abort these steps. Otherwise, let url be\n      //     the value of the href attribute of the first such\n      //     element.\n      //     Resolve url relative to fallback base url (thus,\n      //     the base href attribute isn't affected by xml:base\n      //     attributes).\n      //     The document base URL is the result of the previous\n      //     step if it was successful; otherwise it is fallback\n      //     base url.\n    }\n  },\n  _templateDoc: {\n    get: function get() {\n      if (!this._templateDocCache) {\n        // \"associated inert template document\"\n        var newDoc = new Document(this.isHTML, this._address);\n        this._templateDocCache = newDoc._templateDocCache = newDoc;\n      }\n\n      return this._templateDocCache;\n    }\n  },\n  querySelector: {\n    value: function value(selector) {\n      return select(selector, this)[0];\n    }\n  },\n  querySelectorAll: {\n    value: function value(selector) {\n      var nodes = select(selector, this);\n      return nodes.item ? nodes : new NodeList(nodes);\n    }\n  }\n});\nvar eventHandlerTypes = ['abort', 'canplay', 'canplaythrough', 'change', 'click', 'contextmenu', 'cuechange', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragleave', 'dragover', 'dragstart', 'drop', 'durationchange', 'emptied', 'ended', 'input', 'invalid', 'keydown', 'keypress', 'keyup', 'loadeddata', 'loadedmetadata', 'loadstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'mousewheel', 'pause', 'play', 'playing', 'progress', 'ratechange', 'readystatechange', 'reset', 'seeked', 'seeking', 'select', 'show', 'stalled', 'submit', 'suspend', 'timeupdate', 'volumechange', 'waiting', 'blur', 'error', 'focus', 'load', 'scroll']; // Add event handler idl attribute getters and setters to Document\n\neventHandlerTypes.forEach(function (type) {\n  // Define the event handler registration IDL attribute for this type\n  Object.defineProperty(Document.prototype, 'on' + type, {\n    get: function get() {\n      return this._getEventHandler(type);\n    },\n    set: function set(v) {\n      this._setEventHandler(type, v);\n    }\n  });\n});\n\nfunction namedHTMLChild(parent, name) {\n  if (parent && parent.isHTML) {\n    for (var kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {\n      if (kid.nodeType === Node.ELEMENT_NODE && kid.localName === name && kid.namespaceURI === NAMESPACE.HTML) {\n        return kid;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction root(n) {\n  n._nid = n.ownerDocument._nextnid++;\n  n.ownerDocument._nodes[n._nid] = n; // Manage id to element mapping\n\n  if (n.nodeType === Node.ELEMENT_NODE) {\n    var id = n.getAttribute('id');\n    if (id) n.ownerDocument.addId(id, n); // Script elements need to know when they're inserted\n    // into the document\n\n    if (n._roothook) n._roothook();\n  }\n}\n\nfunction uproot(n) {\n  // Manage id to element mapping\n  if (n.nodeType === Node.ELEMENT_NODE) {\n    var id = n.getAttribute('id');\n    if (id) n.ownerDocument.delId(id, n);\n  }\n\n  n.ownerDocument._nodes[n._nid] = undefined;\n  n._nid = undefined;\n}\n\nfunction recursivelyRoot(node) {\n  root(node); // XXX:\n  // accessing childNodes on a leaf node creates a new array the\n  // first time, so be careful to write this loop so that it\n  // doesn't do that. node is polymorphic, so maybe this is hard to\n  // optimize?  Try switching on nodeType?\n\n  /*\n    if (node.hasChildNodes()) {\n      var kids = node.childNodes;\n      for(var i = 0, n = kids.length;  i < n; i++)\n        recursivelyRoot(kids[i]);\n    }\n  */\n\n  if (node.nodeType === Node.ELEMENT_NODE) {\n    for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling) recursivelyRoot(kid);\n  }\n}\n\nfunction recursivelyUproot(node) {\n  uproot(node);\n\n  for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling) recursivelyUproot(kid);\n}\n\nfunction recursivelySetOwner(node, owner) {\n  node.ownerDocument = owner;\n  node._lastModTime = undefined; // mod times are document-based\n\n  if (Object.prototype.hasOwnProperty.call(node, '_tagName')) {\n    node._tagName = undefined; // Element subclasses might need to change case\n  }\n\n  for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling) recursivelySetOwner(kid, owner);\n} // A class for storing multiple nodes with the same ID\n\n\nfunction MultiId(node) {\n  this.nodes = Object.create(null);\n  this.nodes[node._nid] = node;\n  this.length = 1;\n  this.firstNode = undefined;\n} // Add a node to the list, with O(1) time\n\n\nMultiId.prototype.add = function (node) {\n  if (!this.nodes[node._nid]) {\n    this.nodes[node._nid] = node;\n    this.length++;\n    this.firstNode = undefined;\n  }\n}; // Remove a node from the list, with O(1) time\n\n\nMultiId.prototype.del = function (node) {\n  if (this.nodes[node._nid]) {\n    delete this.nodes[node._nid];\n    this.length--;\n    this.firstNode = undefined;\n  }\n}; // Get the first node from the list, in the document order\n// Takes O(N) time in the size of the list, with a cache that is invalidated\n// when the list is modified.\n\n\nMultiId.prototype.getFirst = function () {\n  /* jshint bitwise: false */\n  if (!this.firstNode) {\n    var nid;\n\n    for (nid in this.nodes) {\n      if (this.firstNode === undefined || this.firstNode.compareDocumentPosition(this.nodes[nid]) & Node.DOCUMENT_POSITION_PRECEDING) {\n        this.firstNode = this.nodes[nid];\n      }\n    }\n  }\n\n  return this.firstNode;\n}; // If there is only one node left, return it. Otherwise return \"this\".\n\n\nMultiId.prototype.downgrade = function () {\n  if (this.length === 1) {\n    var nid;\n\n    for (nid in this.nodes) {\n      return this.nodes[nid];\n    }\n  }\n\n  return this;\n};","map":null,"metadata":{},"sourceType":"script"}