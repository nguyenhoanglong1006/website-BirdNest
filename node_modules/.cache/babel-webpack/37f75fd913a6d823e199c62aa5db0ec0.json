{"ast":null,"code":"\"use strict\";\n\nvar Event = require('./Event');\n\nvar MouseEvent = require('./MouseEvent');\n\nvar utils = require('./utils');\n\nmodule.exports = EventTarget;\n\nfunction EventTarget() {}\n\nEventTarget.prototype = {\n  // XXX\n  // See WebIDL ยง4.8 for details on object event handlers\n  // and how they should behave.  We actually have to accept\n  // any object to addEventListener... Can't type check it.\n  // on registration.\n  // XXX:\n  // Capturing event listeners are sort of rare.  I think I can optimize\n  // them so that dispatchEvent can skip the capturing phase (or much of\n  // it).  Each time a capturing listener is added, increment a flag on\n  // the target node and each of its ancestors.  Decrement when removed.\n  // And update the counter when nodes are added and removed from the\n  // tree as well.  Then, in dispatch event, the capturing phase can\n  // abort if it sees any node with a zero count.\n  addEventListener: function addEventListener(type, listener, capture) {\n    if (!listener) return;\n    if (capture === undefined) capture = false;\n    if (!this._listeners) this._listeners = Object.create(null);\n    if (!this._listeners[type]) this._listeners[type] = [];\n    var list = this._listeners[type]; // If this listener has already been registered, just return\n\n    for (var i = 0, n = list.length; i < n; i++) {\n      var l = list[i];\n      if (l.listener === listener && l.capture === capture) return;\n    } // Add an object to the list of listeners\n\n\n    var obj = {\n      listener: listener,\n      capture: capture\n    };\n    if (typeof listener === 'function') obj.f = listener;\n    list.push(obj);\n  },\n  removeEventListener: function removeEventListener(type, listener, capture) {\n    if (capture === undefined) capture = false;\n\n    if (this._listeners) {\n      var list = this._listeners[type];\n\n      if (list) {\n        // Find the listener in the list and remove it\n        for (var i = 0, n = list.length; i < n; i++) {\n          var l = list[i];\n\n          if (l.listener === listener && l.capture === capture) {\n            if (list.length === 1) {\n              this._listeners[type] = undefined;\n            } else {\n              list.splice(i, 1);\n            }\n\n            return;\n          }\n        }\n      }\n    }\n  },\n  // This is the public API for dispatching untrusted public events.\n  // See _dispatchEvent for the implementation\n  dispatchEvent: function dispatchEvent(event) {\n    // Dispatch an untrusted event\n    return this._dispatchEvent(event, false);\n  },\n  //\n  // See DOMCore ยง4.4\n  // XXX: I'll probably need another version of this method for\n  // internal use, one that does not set isTrusted to false.\n  // XXX: see Document._dispatchEvent: perhaps that and this could\n  // call a common internal function with different settings of\n  // a trusted boolean argument\n  //\n  // XXX:\n  // The spec has changed in how to deal with handlers registered\n  // on idl or content attributes rather than with addEventListener.\n  // Used to say that they always ran first.  That's how webkit does it\n  // Spec now says that they run in a position determined by\n  // when they were first set.  FF does it that way.  See:\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#event-handlers\n  //\n  _dispatchEvent: function _dispatchEvent(event, trusted) {\n    if (typeof trusted !== 'boolean') trusted = false;\n\n    function invoke(target, event) {\n      var type = event.type,\n          phase = event.eventPhase;\n      event.currentTarget = target; // If there was an individual handler defined, invoke it first\n      // XXX: see comment above: this shouldn't always be first.\n\n      if (phase !== Event.CAPTURING_PHASE && target._handlers && target._handlers[type]) {\n        var handler = target._handlers[type];\n        var rv;\n\n        if (typeof handler === 'function') {\n          rv = handler.call(event.currentTarget, event);\n        } else {\n          var f = handler.handleEvent;\n          if (typeof f !== 'function') throw new TypeError('handleEvent property of ' + 'event handler object is' + 'not a function.');\n          rv = f.call(handler, event);\n        }\n\n        switch (event.type) {\n          case 'mouseover':\n            if (rv === true) // Historical baggage\n              event.preventDefault();\n            break;\n\n          case 'beforeunload': // XXX: eventually we need a special case here\n\n          /* falls through */\n\n          default:\n            if (rv === false) event.preventDefault();\n            break;\n        }\n      } // Now invoke list list of listeners for this target and type\n\n\n      var list = target._listeners && target._listeners[type];\n      if (!list) return;\n      list = list.slice();\n\n      for (var i = 0, n = list.length; i < n; i++) {\n        if (event._immediatePropagationStopped) return;\n        var l = list[i];\n        if (phase === Event.CAPTURING_PHASE && !l.capture || phase === Event.BUBBLING_PHASE && l.capture) continue;\n\n        if (l.f) {\n          l.f.call(event.currentTarget, event);\n        } else {\n          var fn = l.listener.handleEvent;\n          if (typeof fn !== 'function') throw new TypeError('handleEvent property of event listener object is not a function.');\n          fn.call(l.listener, event);\n        }\n      }\n    }\n\n    if (!event._initialized || event._dispatching) utils.InvalidStateError();\n    event.isTrusted = trusted; // Begin dispatching the event now\n\n    event._dispatching = true;\n    event.target = this; // Build the list of targets for the capturing and bubbling phases\n    // XXX: we'll eventually have to add Window to this list.\n\n    var ancestors = [];\n\n    for (var n = this.parentNode; n; n = n.parentNode) ancestors.push(n); // Capturing phase\n\n\n    event.eventPhase = Event.CAPTURING_PHASE;\n\n    for (var i = ancestors.length - 1; i >= 0; i--) {\n      invoke(ancestors[i], event);\n      if (event._propagationStopped) break;\n    } // At target phase\n\n\n    if (!event._propagationStopped) {\n      event.eventPhase = Event.AT_TARGET;\n      invoke(this, event);\n    } // Bubbling phase\n\n\n    if (event.bubbles && !event._propagationStopped) {\n      event.eventPhase = Event.BUBBLING_PHASE;\n\n      for (var ii = 0, nn = ancestors.length; ii < nn; ii++) {\n        invoke(ancestors[ii], event);\n        if (event._propagationStopped) break;\n      }\n    }\n\n    event._dispatching = false;\n    event.eventPhase = Event.AT_TARGET;\n    event.currentTarget = null; // Deal with mouse events and figure out when\n    // a click has happened\n\n    if (trusted && !event.defaultPrevented && event instanceof MouseEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          this._armed = {\n            x: event.clientX,\n            y: event.clientY,\n            t: event.timeStamp\n          };\n          break;\n\n        case 'mouseout':\n        case 'mouseover':\n          this._armed = null;\n          break;\n\n        case 'mouseup':\n          if (this._isClick(event)) this._doClick(event);\n          this._armed = null;\n          break;\n      }\n    }\n\n    return !event.defaultPrevented;\n  },\n  // Determine whether a click occurred\n  // XXX We don't support double clicks for now\n  _isClick: function _isClick(event) {\n    return this._armed !== null && event.type === 'mouseup' && event.isTrusted && event.button === 0 && event.timeStamp - this._armed.t < 1000 && Math.abs(event.clientX - this._armed.x) < 10 && Math.abs(event.clientY - this._armed.Y) < 10;\n  },\n  // Clicks are handled like this:\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#interactive-content-0\n  //\n  // Note that this method is similar to the HTMLElement.click() method\n  // The event argument must be the trusted mouseup event\n  _doClick: function _doClick(event) {\n    if (this._click_in_progress) return;\n    this._click_in_progress = true; // Find the nearest enclosing element that is activatable\n    // An element is activatable if it has a\n    // _post_click_activation_steps hook\n\n    var activated = this;\n\n    while (activated && !activated._post_click_activation_steps) activated = activated.parentNode;\n\n    if (activated && activated._pre_click_activation_steps) {\n      activated._pre_click_activation_steps();\n    }\n\n    var click = this.ownerDocument.createEvent('MouseEvent');\n    click.initMouseEvent('click', true, true, this.ownerDocument.defaultView, 1, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, null);\n\n    var result = this._dispatchEvent(click, true);\n\n    if (activated) {\n      if (result) {\n        // This is where hyperlinks get followed, for example.\n        if (activated._post_click_activation_steps) activated._post_click_activation_steps(click);\n      } else {\n        if (activated._cancelled_activation_steps) activated._cancelled_activation_steps();\n      }\n    }\n  },\n  //\n  // An event handler is like an event listener, but it registered\n  // by setting an IDL or content attribute like onload or onclick.\n  // There can only be one of these at a time for any event type.\n  // This is an internal method for the attribute accessors and\n  // content attribute handlers that need to register events handlers.\n  // The type argument is the same as in addEventListener().\n  // The handler argument is the same as listeners in addEventListener:\n  // it can be a function or an object. Pass null to remove any existing\n  // handler.  Handlers are always invoked before any listeners of\n  // the same type.  They are not invoked during the capturing phase\n  // of event dispatch.\n  //\n  _setEventHandler: function _setEventHandler(type, handler) {\n    if (!this._handlers) this._handlers = Object.create(null);\n    this._handlers[type] = handler;\n  },\n  _getEventHandler: function _getEventHandler(type) {\n    return this._handlers && this._handlers[type] || null;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}