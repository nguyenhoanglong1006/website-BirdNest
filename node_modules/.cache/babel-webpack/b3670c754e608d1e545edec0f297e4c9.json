{"ast":null,"code":"\"use strict\"; // DOMTokenList implementation based on https://github.com/Raynos/DOM-shim\n\nvar utils = require('./utils');\n\nmodule.exports = DOMTokenList;\n\nfunction DOMTokenList(getter, setter) {\n  this._getString = getter;\n  this._setString = setter;\n  this._length = 0;\n  this._lastStringValue = '';\n\n  this._update();\n}\n\nObject.defineProperties(DOMTokenList.prototype, {\n  length: {\n    get: function get() {\n      return this._length;\n    }\n  },\n  item: {\n    value: function value(index) {\n      var list = getList(this);\n\n      if (index < 0 || index >= list.length) {\n        return null;\n      }\n\n      return list[index];\n    }\n  },\n  contains: {\n    value: function value(token) {\n      token = String(token); // no error checking for contains()\n\n      var list = getList(this);\n      return list.indexOf(token) > -1;\n    }\n  },\n  add: {\n    value: function value() {\n      var list = getList(this);\n\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var token = handleErrors(arguments[i]);\n\n        if (list.indexOf(token) < 0) {\n          list.push(token);\n        }\n      } // Note: as per spec, if handleErrors() throws any errors, we never\n      // make it here and none of the changes take effect.\n      // Also per spec: we run the \"update steps\" even if no change was\n      // made (ie, if the token already existed)\n\n\n      this._update(list);\n    }\n  },\n  remove: {\n    value: function value() {\n      var list = getList(this);\n\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var token = handleErrors(arguments[i]);\n        var index = list.indexOf(token);\n\n        if (index > -1) {\n          list.splice(index, 1);\n        }\n      } // Note: as per spec, if handleErrors() throws any errors, we never\n      // make it here and none of the changes take effect.\n      // Also per spec: we run the \"update steps\" even if no change was\n      // made (ie, if the token wasn't previously present)\n\n\n      this._update(list);\n    }\n  },\n  toggle: {\n    value: function toggle(token, force) {\n      token = handleErrors(token);\n\n      if (this.contains(token)) {\n        if (force === undefined || force === false) {\n          this.remove(token);\n          return false;\n        }\n\n        return true;\n      } else {\n        if (force === undefined || force === true) {\n          this.add(token);\n          return true;\n        }\n\n        return false;\n      }\n    }\n  },\n  replace: {\n    value: function replace(token, newToken) {\n      // weird corner case of spec: if `token` contains whitespace, but\n      // `newToken` is the empty string, we must throw SyntaxError not\n      // InvalidCharacterError (sigh)\n      if (String(newToken) === '') {\n        utils.SyntaxError();\n      }\n\n      token = handleErrors(token);\n      newToken = handleErrors(newToken);\n      var list = getList(this);\n      var idx = list.indexOf(token);\n\n      if (idx < 0) {\n        // Note that, per spec, we do not run the update steps on this path.\n        return false;\n      }\n\n      var idx2 = list.indexOf(newToken);\n\n      if (idx2 < 0) {\n        list[idx] = newToken;\n      } else {\n        // \"replace the first instance of either `token` or `newToken` with\n        // `newToken` and remove all other instances\"\n        if (idx < idx2) {\n          list[idx] = newToken;\n          list.splice(idx2, 1);\n        } else {\n          // idx2 is already `newToken`\n          list.splice(idx, 1);\n        }\n      }\n\n      this._update(list);\n\n      return true;\n    }\n  },\n  toString: {\n    value: function value() {\n      return this._getString();\n    }\n  },\n  value: {\n    get: function get() {\n      return this._getString();\n    },\n    set: function set(v) {\n      this._setString(v);\n\n      this._update();\n    }\n  },\n  // Called when the setter is called from outside this interface.\n  _update: {\n    value: function value(list) {\n      if (list) {\n        fixIndex(this, list);\n\n        this._setString(list.join(\" \").trim());\n      } else {\n        fixIndex(this, getList(this));\n      }\n\n      this._lastStringValue = this._getString();\n    }\n  }\n});\n\nfunction fixIndex(clist, list) {\n  var oldLength = clist._length;\n  var i;\n  clist._length = list.length;\n\n  for (i = 0; i < list.length; i++) {\n    clist[i] = list[i];\n  } // Clear/free old entries.\n\n\n  for (; i < oldLength; i++) {\n    clist[i] = undefined;\n  }\n}\n\nfunction handleErrors(token) {\n  token = String(token);\n\n  if (token === \"\") {\n    utils.SyntaxError();\n  }\n\n  if (/[ \\t\\r\\n\\f]/.test(token)) {\n    utils.InvalidCharacterError();\n  }\n\n  return token;\n}\n\nfunction toArray(clist) {\n  var length = clist._length;\n  var arr = Array(length);\n\n  for (var i = 0; i < length; i++) {\n    arr[i] = clist[i];\n  }\n\n  return arr;\n}\n\nfunction getList(clist) {\n  var strProp = clist._getString();\n\n  if (strProp === clist._lastStringValue) {\n    return toArray(clist);\n  }\n\n  var str = strProp.replace(/(^[ \\t\\r\\n\\f]+)|([ \\t\\r\\n\\f]+$)/g, '');\n\n  if (str === \"\") {\n    return [];\n  } else {\n    var seen = Object.create(null);\n    return str.split(/[ \\t\\r\\n\\f]+/g).filter(function (n) {\n      var key = '$' + n;\n\n      if (seen[key]) {\n        return false;\n      }\n\n      seen[key] = true;\n      return true;\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}